<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: chips/p9/procedures/xml/attribute_info/nest_attributes.xml $  -->
<!--                                                                        -->
<!-- IBM CONFIDENTIAL                                                       -->
<!--                                                                        -->
<!-- EKB Project                                                            -->
<!--                                                                        -->
<!-- COPYRIGHT 2015,2016                                                    -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- The source code for this program is not published or otherwise         -->
<!-- divested of its trade secrets, irrespective of what has been           -->
<!-- deposited with the U.S. Copyright Office.                              -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<!--nest_attributes.xml-->
<attributes>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_PB_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's nest mesh clock, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_A_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's A link clocks, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_X_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's X link clocks, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The lowest frequency that a core can be set to in MHz.
    This is the same for all cores in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The nominal core frequency in MHz.
    This is the same for all cores in the system.
    Provided by the #V bucket of module VPD.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Provided by the #V bucket of module VPD.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PM_SAFE_FREQUENCY_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Frequency (in MHz) to move to if the Power Management function fails.
    This is the same for all cores in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_PCIE_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's PCI-e bus in MHz.
    This is the same for all PCI-e busses in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
 </attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_ASYNC_SAFE_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Set to force all fabric asynchronous boundary crossings into safe mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    PERFORMANCE_MODE = 0x0,
    SAFE_MODE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_BUS_WIDTH</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP A bus width.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    2_BYTE = 0x01,
    4_BYTE = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_BUS_WIDTH</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP X bus width.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    2_BYTE = 0x01,
    4_BYTE = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CORE_FLOOR_RATIO</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP core floor/nest frequency ratio
  </description>
  <valueType>uint8</valueType>
  <enum>
    RATIO_8_8 = 0x0,
    RATIO_7_8 = 0x1,
    RATIO_6_8 = 0x2,
    RATIO_5_8 = 0x3,
    RATIO_4_8 = 0x4,
    RATIO_2_8 = 0x5
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CORE_CEILING_RATIO</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP core celing/nest frequency ratio
  </description>
  <valueType>uint8</valueType>
  <enum>
    RATIO_8_8 = 0x0,
    RATIO_7_8 = 0x1,
    RATIO_6_8 = 0x2,
    RATIO_5_8 = 0x3,
    RATIO_4_8 = 0x4,
    RATIO_2_8 = 0x5
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP Fabric broadcast scope configuration.
    CHIP_IS_NODE = MODE1 = default
    CHIP_IS_GROUP = MODE2
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    CHIP_IS_NODE = 0x01,
    CHIP_IS_GROUP = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CCSM_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP topology configuration.
    0 = default = 1 or 2 hop topology (PHYP image spans system)
    1 = 3 hop topology (PHYP image spans group).
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_OPTICS_CONFIG_MODE</id>
  <targetType>TARGET_TYPE_OBUS</targetType>
  <description>
    Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    SMP = 0x0,
    CAPI = 0x1,
    NV = 0x2
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SMP_OPTICS_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP optics mode.
    0 = default = Optics_is_X_bus
    1 = Optics_is_A_bus
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OPTICS_IS_X_BUS = 0x0,
    OPTICS_IS_A_BUS = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_OPTICS_CONFIG_MODE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
  </description>
  <valueType>uint8</valueType>
  <enum>
    SMP = 0x0,
    CAPI = 0x1,
    NV = 0x2
  </enum>
  <array>4</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CAPI_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor CAPI attachement protocol mode.
    0 = default = no: SMPA CAPI attachement
    1 = yes: SMPA CAPI attachement
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_ADDR_BAR_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor memory map configuration.
    0 = default = large system address map
    1 = small system address map
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    LARGE_SYSTEM = 0x0,
    SMALL_SYSTEM = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SYSTEM_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric system ID associated with this chip.Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_GROUP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric group ID associated with this chip.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
  <!-- TODO: Story 155081
       Not supposed to be writeable, PPE needs to resolve this issue in
       p9_sbe_attr_setup.C -->
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric chip ID associated with this chip.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
  <!-- TODO: Story 155081
       Not supposed to be writeable, PPE needs to resolve this issue in
       p9_sbe_attr_setup.C -->
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if the given chip should serve as the fabric system master.
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_GROUP_MASTER_CHIP</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if the given chip should serve as the fabric group master.
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies the fabric ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies the link ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies the fabric ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies the link ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_AGGREGATE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if X links on this chip should be configured in aggregate mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ADDR_DIS</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_LINK_DELAY</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint32</valueType>
  <array>7</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_AGGREGATE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if A links on this chip should be configured in aggregate mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ADDR_DIS</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_LINK_DELAY</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint32</valueType>
  <array>4</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_GB_PERCENTAGE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Guardband percentage to apply to baseline epsilon calculations
    Set by p9_fbc_eff_config.
  </description>
  <valueType>int8</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_TABLE_TYPE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor epsilon table type.
    Used to calculate the processor nest epsilon register values.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    EPS_TYPE_LE = 0x01,
    EPS_TYPE_HE = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T0</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier0 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T1</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier1 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T2</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier2 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_WRITE_CYCLES_T1</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated write tier1 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_WRITE_CYCLES_T2</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated write tier2 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_DMI_REFCLOCK_SWIZZLE</id>
  <targetType>TARGET_TYPE_MCS</targetType>
  <description>Define DMI Ref clock/Swizzle for Centaur.
   Provided by the MRW</description>
  <valueType>uint8</valueType>
  <persistRuntime/>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_SYSTEM_IPL_PHASE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>Define context for current phase of system IPL.
  </description>
  <valueType>uint8</valueType>
  <enum>HB_IPL = 0x1,HB_RUNTIME = 0x2,CACHE_CONTAINED = 0x4, CHIP_CONTAINED = 0x8</enum>
  <persistRuntime/>
  <platInit/>
  <!-- TODO: Story 155081
       Not supposed to be writeable, PPE needs to resolve this issue in
       p9_sbe_attr_setup.C -->
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_IS_MPIPL</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Indicates if current IPL is memory-preserving
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <platInit/>
  <!-- TODO: Story 155081
       Not supposed to be writeable, PPE needs to resolve this issue in
       sberegaccess.C -->
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_ADU_XSCOM_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>Defines XSCOM base address on each processor level.
        address provided by the MRW </description>
  <valueType>uint64</valueType>
  <persistRuntime/>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>Define placement policy/scheme for non-mirrored/mirrored memory
               layout
               NORMAL = non-mirrored start: 0, mirrored start: 1024TB
               FLIPPED = mirrored start: 0, non-mirrored start: 512TB
               Set by platform.
               Used by mss_eff_grouping.
  </description>
  <valueType>uint8</valueType>
  <enum>
    NORMAL    = 0x0,
    FLIPPED   = 0x1
  </enum>
  <platInit/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_BASE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The location where the stacking of non-mirrored memory groups
                of the chip starts.  This address is determined in a fixed
                manner from the chip's position in the fabric topology (i.e.
                each chip will consume a fixed portion of the system address
                map).
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_BASES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The address where each memory group starts in the non-mirrored
                memory groups stack.  This address is determined by the memory
                grouping process based on the sizes of the memory groups formed
                in each processor.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The memory size of each non-mirrored memory group in the
                non-mirrored memory groups stack.  This size is determined by
                the memory grouping process based on the amount of memory
                behind the ports that are grouped together.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_BASE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The location where the stacking of mirrored memory groups
                of the chip starts.  This address is determined in a fixed
                manner from the chip's position in the fabric topology (i.e.
                each chip will consume a fixed portion of the system address
                map).
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MIRROR_BASES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The address where each memory group starts in the mirrored
                memory groups stack.  This address is determined by
                the memory grouping process based on the sizes of the memory
                groups formed in each processor.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>4</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MIRROR_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The memory size of each memory group in the mirrored memory
                groups stack.  This size is determined by the memory grouping
                process based on the amount of memory behind the ports that are
                grouped together.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>4</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
      Used in the setting of groups.  It is a bit vector.  If the value
      BITWISE_AND  0x01 = 0x01 then groups of 1 are enabled,
      if the value BITWISE_AND  0x02 = 0x02, then groups of 2 are possible,
      if the value BITWISE_AND  0x04 = 0x04, then group of 3 are possible,
      if the value BITWISE_AND  0x08 = 0x08, then groups of 4 are possible,
      if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible,
      if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible.
      If no groups can formed according to this input, then an error will
      be thrown.
      Provided by the MRW
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <odmVisable/>
    <odmChangeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MEM_MC_IN_GROUP</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
      An 8 bit vector that would be a designation of which MC (Nimbus MCS or
      Cumulus MI) are involved in the group.
      So the bits would represent
                  Nimbus   Cumulus
        Bit 0     MCS0     MI0
        Bit 1     MCS1     MI1
        .....
        Bit 7     MCS7     MI7
      Set by p9_mss_eff_grouping
    </description>
    <valueType>uint8</valueType>
    <writeable/>
    <odmVisable/>
    <odmChangeable/>
    <array>8</array>
    <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MCS_GROUP_32</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
       creator:- mss_eff_grouping
       consumer:- mss_setup_bars
       Data Structure from eff grouping to setup bars to help determine
       different groups
       Non-Mirroring array[0-7]  [0.17]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of non-mirroring;
                                          3-- Base address; 4-11-- PortID number in group;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);

                                         13-- Alternate Group Size; 14-- Alternate Base address
       Mirroring     array[8-15] [0:17]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of mirroring;
                                          3-- Base address; 4-11-- PortID number;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);
       Measured in GB
     </description>
    <valueType>uint32</valueType>
    <array>16,18</array>
    <writeable/>
    <odmVisable/>
    <odmChangeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MEM_IPL_COMPLETE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
       Creator:- mss_setup_bars
       A numerical number indicating if the memory procedures are complete.
       written by mss_setup_bars when the bars are now functional in the
       processor.
    </description>
    <valueType>uint8</valueType>
    <writeable/>
    <odmVisable/>
    <odmChangeable/>
    <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MRW_ENHANCED_GROUPING_NO_MIRRORING</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
       If this attribute sets to TRUE, supports MCS grouping  with out mirroring.
       If this attribute to FALSE, IBM Power system Mirroring support enabled.
       This instructs the grouping code to group contiguous memory controllers
       of the same size together. Provided by the MRW.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>FALSE = 0, TRUE = 1</enum>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_NHTM_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base address where the NHTM traces start.  They are
                calculated based on the NHTM trace size requested by user.
                This address in memory will be the location where NHTM0/1
                traces are output.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars and p9_htm_setup.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_NHTM_BAR_SIZE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store NHTM traces.
                This amount will be used to store both NHTM0 and NHTM1 traces.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <initToZero/>
  <writeable/>
  <persistRuntime/>
</attribute>

<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_CHTM_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base addresses where the CHTM traces start.  They are
                calculated based on the CHTM trace sizes requested by users.
                There are 24 different CHTM regions, thus 24 different sizes.
                Each region is to store HTM trace for a core.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>24</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_CHTM_BAR_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store CHTM traces.
                There are 24 cores, thus 24 different sizes.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <array>24</array>
  <initToZero/>
  <writeable/>
  <persistRuntime/>
</attribute>

<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_OCC_SANDBOX_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base address where the OCC sandbox starts.  It is
                calculated based on the OCC sandbox size requested by users.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_OCC_SANDBOX_SIZE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store OCC sandbox
                functions.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <initToZero/>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_BASES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual non-mirrored base addresses of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming and would be acknowleged on the fabric.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_SIZES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual non-mirrored memory sizes of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_BASES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual mirrored base addresses of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming and would be acknowleged on the fabric.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>4</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_SIZES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual mirrored memory sizes of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>4</array>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************* -->

</attributes>
