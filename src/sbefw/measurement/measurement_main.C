/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/sbefw/measurement/measurement_main.C $                    */
/*                                                                        */
/* OpenPOWER sbe Project                                                  */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2019,2021                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include "sbemtrace.H"
#include "sbeglobals.H"
#include "sbe_link.H"
#include "sbemthreadroutine.H"
#include "sbeexeintf.H"
#include "sbeutil.H"
#include "sbeRoleIdentifier.H"

extern "C" {
#include "pk_api.h"
}
////////////////////////////////////////////////////////////////
//// @brief Stacks for Non-critical Interrupts ( timebase, timers )
////////////////////////////////////////////////////////////////
#define INITIAL_PK_TIMEBASE                            0
#define MEASUREMENT_NONCRITICAL_STACK_SIZE             512
//Keep stack size greater than SPI_READ_SIZE_BYTES.
#define MEASUREMENT_THREAD_SECURE_BOOT_STACK_SIZE      12288

#define SPI_CLOCK_DELAY_SHIFT                          44
#define SPI_CLOCK_DIVIDER_SHIFT                        52
#define SPI_CLOCK_DIVIDER_DELAY_MASK                   0x00000FFFFFFFFFFF
#define DEFAULT_SPI_CLOCK_DELAY                        0x80
#define BIT15_SHIFT                                    0x30
#define BIT5_SHIFT                                     0x3A
#define BIT0_MASK                                      1
#define ECC_SPIMM_ADDR_CORRECTION_DIS                  1
#define SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT            33
#define ECC_CONTROL_TRANSPARENT_READ                   1
#define SPI_ECC_CONTROL_SHIFT                          35
#define DD1                                            1
#define DD2                                            2
#define EC_MAJOR_VERSION_BIT_SHIFT                     36

uint8_t measurment_Kernel_NC_Int_stack[MEASUREMENT_NONCRITICAL_STACK_SIZE];
uint8_t measurmentSecureBoot_stack[MEASUREMENT_THREAD_SECURE_BOOT_STACK_SIZE];

///////////////////////////////////////////////////////////////////
//// @brief PkThread structure for SBE Measurement thread .
////////////////////////////////////////////////////////////////////
PkThread sbem_thread;

// SBE Frequency to be used to initialise PK
uint32_t g_sbemfreqency = SBE_REF_BASE_FREQ_HZ;
sbe_local_LFR lfrReg;
uint32_t g_sbeRole = 0xff;

extern "C"
{

// These variables are declared in linker script to keep track of
// global constructor pointer functions and sbss section.
extern void (*ctor_start_address)() __attribute__ ((section (".rodata")));
extern void (*ctor_end_address)() __attribute__ ((section (".rodata")));
extern uint64_t _sbss_start __attribute__ ((section (".sbss")));
extern uint64_t _sbss_end __attribute__ ((section (".sbss")));
// This function will be used to do any C++ handling required before doing
// any main job. Call to this function should get generated by
// compiler.
// TODO via RTC 152070
// We are also initialising sbss section to zero this function.
// Though it does not do any harm as of now, it is better  if we use loader
// or linker script to zero init sbss section. This way we will be future
// garded if pk  boot uses some static/global data  initialised to
// false in future.

////////////////////////////////////////////////////////////////
// @brief  createAndResumeThreadHelper
//            - Create and resume the given thread
//
// @param[in/out] io_thread  A pointer to an PkThread structure to initialize
// @param[in]     i_thread_routine The subroutine that implements the thread
// @param[in/out] io_arg     Private data to be passed as the argument to the
//                              thread routine when it begins execution
// @param[in]     i_stack    The stack space of the thread
// @param[in]     i_stack_size The size of the stack in bytes
// @param[in]     i_priority The initial priority of the thread
//
// @return        PK_OK Successfully created and resumed the thread
//
// @return        PK_INVALID_THREAD_AT_CREATE io_thread is null
// @return        PK_INVALID_ARGUMENT_THREAD1 i_thread_routine is null
// @return        PK_INVALID_ARGUMENT_THREAD2 i_priority is invalid
// @return        PK_INVALID_ARGUMENT_THREAD3 the stack area wraps around
//                                      the end of memory.
// @return        PK_STACK_OVERFLOW           The stack area at thread creation
//                                      is smaller than the min safe size
// @return        PK_INVALID_THREAD_AT_RESUME1 io_thread is null (unlikely)
// @return        PK_INVALID_THREAD_AT_RESUME2 The thread is not active,
//                                      i.e. has completed or been deleted,
// @return        PK_PRIORITY_IN_USE_AT_RESUME Another thread is already
//                                      mapped at the priority of the thread
////////////////////////////////////////////////////////////////
uint32_t createAndResumeThreadHelper(PkThread    *io_pThread,
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
    int l_rc = PK_OK;

    // Thread creation
    l_rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
    if(l_rc == PK_OK)
    {
        // resume the thread once created
        l_rc = pk_thread_resume(io_pThread);
    }

    // Check for errors creating or resuming the thread
    if(l_rc != PK_OK)
    {
        SBE_ERROR ("Failure creating/resuming thread, rc=[%d]", l_rc);
    }

    return l_rc;
}

void __eabi()
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
        while ( startAddr != &_sbss_end )
        {
            *startAddr = 0;
            startAddr++;
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
        {
            (*ctors)();
            ctors++;
        }
    } while (false);
}
} // end extern "C"

// Setup the SPI Clock Divider per the new clock and update LFR
void setupSpiClockDividerAndLFRPerPAUDPLL()
{
    sbe_local_LFR lfrReg;
    uint64_t loadData = 0;
    uint32_t spiAddr = 0;

    PPE_LVD(0xc0002040, lfrReg);
    //////////////////# SPI Clock Setting per the new Frequency Start /////////////////
    //  # Calculate the Clock divider from PAU Freq which is 0x7B0 (1968MHz),
    //  # default frequency set in the sbe boot seeprom, we don't need to
    //  # change this basis any boot seeprom update. This will remain hard-coded
    //  # in the measurement seeprom.
    //  # (7B0/40 - 1) = 48 = 0x30 -> SPI Seeprom Clock Divider
    //  # (7B0/192) - 1) = 10 -> SPI TPM Clock Divider
    //  # Pick up the clock delay from LFR
    uint32_t spiSeepromClockDivider = 48;
    uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
    {
        PPE_LVD(spiAddr, loadData);
        loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                ((uint64_t)spiSeepromClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
        PPE_STVD(spiAddr, loadData);
    }
    // Update TPM SPI Clock Divider
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)spiTpmClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
    PPE_STVD(spiAddr, loadData);

    // Update the LFR Clock divider and Hard-coded PAU Freq
    lfrReg.spi_clock_divider = spiSeepromClockDivider;
    lfrReg.pau_freq_in_mhz = 0x7B0;
    PPE_STVD(0xc0002040, lfrReg); // New Divider and system freq updated into LFR
    //////////////////# SPI Clock Setting per the new Frequency - End /////////////////
}
///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD2 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD2PauDpllTimeRing()
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
    //# insert header
    //# SCOMIN 0103F040 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0004 8001
    loadData = 0x0000000000048001ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 4310 1554 0000 1248
    loadData = 0x4310155400001248ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0020 0000 0000
    loadData = 0x8000000200000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 9000 2862 02AA
    loadData = 0x00009000286202AAULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0249 1000 0000
    loadData = 0x8000024910000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 16bits
    //# SCOMIN 0103F010 4000 0000 0000 0000
    loadData = 0x4000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
    if(fetchData != loadData)
    {
        // asm("li %r0, PAU_DPLL_SCAN_HDR_COMPARE_FAIL\n"); -> wanting to use this,
        // but because of compile failure hard-coding the values from sbe_link.H
        // PAU_DPLL_SCAN_HDR_COMPARE_FAIL 0x04
        asm("li %r1, 4\n");
        pk_halt();
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
}

///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD1 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD1PauDpllTimeRing()
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
    //# insert header
    //# SCOMIN 0103F040 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0048 0014
    loadData = 0x0000000000480014ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 3101 5540 0001 2488
    loadData = 0x3101554000012488;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0020 0000 0000
    loadData = 0x0000002000000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0009 0002 8620 2AA8
    loadData = 0x0009000286202AA8ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 2491 0000 0004
    loadData = 0x0000249100000004ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 16bits
    //# SCOMIN 0103F010 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
    if(fetchData != loadData)
    {
        pk_halt();
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
}

// This function is to lock on the PAU DPLL from Ref clock
void lockPauDpll(void)
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    uint32_t opcg_done = 0;
    uint32_t pau_lock = 0;
    /////////////////////////# Putring Start for perv_dpll_time/////////////////////////
    /////////////////SCOM in the SCAN Inits for the PERV_DPLL_TIME Ring/////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    // Check if you are DD1/DD2, CBS Environment Status Register bit 24-27, should be
    // 0001 -> DD1, 0002 -> DD2
    PPE_LVD(0x50004, fetchData);
    if((fetchData >> EC_MAJOR_VERSION_BIT_SHIFT) & DD1)
    {
        SBE_INFO("Scanning PAU DPLL on DD1");
        scanInitDD1PauDpllTimeRing();
    }
    else // DD2
    {
        SBE_INFO("Scanning PAU DPLL on DD2");
        scanInitDD2PauDpllTimeRing();
    }
    //////////////////////////# Putring End for perv_dpll_time/////////////////////////

    // SPI Clock Setting per the new Frequency Start
    setupSpiClockDividerAndLFRPerPAUDPLL();

    ///////////////////////////////////////////////////////////////////////////////////
    //# PAU DPLL: Initialize to mode1
    //# SCOMIN 01060052 A000000000000000
    loadData = 0xA000000000000000ULL;
    PPE_STVD(0x01060052, loadData);
    //# PAU DPLL: Write frequency settings
    //# frquency_calculated = ((7B0 + 1) * 2)/25 = 0x9D
    // SCOMIN 01060051 09D009D009D00000
    loadData = 0x09D009D009D00000ULL;
    PPE_STVD(0x01060051, loadData);
    //# PAU DPLL: Switch to internal clocks (Bit 27)
    //# SCOMIN 00050133 0000001000000000
    loadData = 0x0000001000000000ULL;
    PPE_STVD(0x00050133, loadData);
    //# PAU DPLL : Release reset (Bit 24)
    //# SCOMIN 00050133 0000008000000000
    loadData = 0x0000008000000000;
    PPE_STVD(0x00050133, loadData);
    ///////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////START CLOCKS/////////////////////////////////////
    //# Startclocks for PAU DPLL regions
    //# Exit flush (set flushmode inhibit) (set bit 2)
    //# SCOMIN 01000010 2000000000000000
    loadData = 0x2000000000000000ULL;
    PPE_STVD(0x01000010, loadData);
    //# Clear Scan region type register
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
    //# Setup all Clock Domains and Clock Types
    //# SCOMIN  01030006 400800000000E000
    loadData = 0x400800000000E000ULL;
    PPE_STVD(0x01030006, loadData);
    //# Poll OPCG done bit to check for completeness
    //# SCOMOUT 01000100 00C0000000000000, see if bit8 is set
    for(uint32_t cnt=0; cnt<0x100; cnt++)
    {
        PPE_LVD(0x01000100, fetchData);
        if(fetchData & 0x0080000000000000ULL)
        {
            opcg_done = 1;
            break;
        }
    }
    if(opcg_done == 0)
    {
        //asm("li %r0, PAU_DPLL_START_CLOCK_OPCG_FAIL\n");
        //PAU_DPLL_START_CLOCK_OPCG_FAIL 0x5
        asm("li %r1, 5\n");
        pk_halt();
    }
    //# status of region 8 - dpllpau, bit 12
    //# CLOCK RUNNING STATUS
    //# OPGC Done, check clock status SL, NSL, ARY

    //# Check for clocks running SL
    //# SCOMOUT  01030008 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030008, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running NSL
    //# SCOMOUT  01030009 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030009, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running ARY
    //# SCOMOUT  0103000A F9F7FFFFFFFFFFFF
    PPE_LVD(0x0103000A, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Clear clock region
    //# SCOMIN   01030006 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030006, loadData);
    //# Enter flush (clear flushmode inhibit)
    //# SCOMIN   01000024 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000024, loadData);

    //# Drop clock region fences for PAU DPLL
    //# SCOMIN   01000021 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000021, loadData);
    //////////////////////////////////START CLOCKS/////////////////////////////////////

    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
    //# Check for PAU DPLL lock, check if bit 63 is set
    //# SCOMOUT  01060055 09D0000000000009
    for(uint32_t cnt=0; cnt<0x2750; cnt++)
    {
        PPE_LVD(0x01060055, fetchData);
        if(fetchData & 0x1)
        {
            pau_lock = 1;
            break;
        }
    }
    if(pau_lock == 0)
    {
        //asm("li %r0, PAU_DPLL_LOCK_FAIL\n");
        //PAU_DPLL_LOCK_FAIL 0x07
        asm("li %r1, 7\n");
        pk_halt();
    }

    //# PAU DPLL: Release test_enable and bypass
    //# SCOMIN 00050133 0000006000000000
    loadData = 0x0000006000000000ULL;
    PPE_STVD(0x00050133, loadData);
    //# Raise clock region fences for PAU DPLL
    //# SCOMIN 01000011 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000011, loadData);

    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
}

////////////////////////////////////////////////////////////////
// @brief - main : Measurement Application main
////////////////////////////////////////////////////////////////
int  main(int argc, char **argv)
{
    #define SBEM_FUNC "Measurement main"
    SBEM_ENTER(SBEM_FUNC);

    int rc = 0;
    uint64_t loadData = 0;
    uint64_t scratchMsgReg = 0;
    sbe_local_LFR lfrReg;
    uint64_t scratchReg6 = 0;
    uint64_t scratchReg8 = 0;
    uint64_t spiClockReg = 0;

    do
    {
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PIBMEM_START_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);

        //Fetch the default clock divider from LFR
        PPE_LVD(0xc0002040, lfrReg);

        ///////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////// Lock PAU DPLL /////////////////////////////////////
        // Lock PAU DPLL for faster SBE clock if Scratch Reg6 bit15
        // is clear then try PAU lock Also if not in MPIPL Path
        //
        // Reset the TPM SPI Engine, c0002010 bit 12 OR_Register/ c0002018 bit 12 And_Register
        // This is an externel reset, it will clear the spi lock and any status/config register
        // to default.
        loadData = 0x0008000000000000ULL;
        PPE_STVD(0xc0002010, loadData);
        PPE_STVD(0xc0002018, loadData);
        // In this path, we make sure we have updated all SPI Clock Registers and updated LFR
        // all fields, nothing is missing, so that subsequent flow can depend on LFR
        if(!(lfrReg.mpipl)) // IPL Path
        {
            // Fetch scratch register6, check if bit15 is unset along with scratch reg8 bit5
            PPE_LVD(0x5003F, scratchReg8);
            PPE_LVD(0x5003D, scratchReg6);
            if((!((scratchReg6 >> BIT15_SHIFT) & BIT0_MASK)) && ((scratchReg8 >> BIT5_SHIFT) & BIT0_MASK)) //PAU Path
            {
                // Update the Code Flow status in messaging register 50009
                uint64_t scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PAU_DPLL_LOCK_MSG)<<32;
                PPE_STVD(0x50009, scratchMsgReg);

                if(!SBE::isSimicsRunning())
                {
                    lockPauDpll();
                    // The above function is going to return success, if not then pk_halt
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                }
                else
                {
                    //In Simics Path, Simply set the SPI Clock and LFR with new clock dividers
                    // SPI Clock Setting per the new Frequency Start
                    setupSpiClockDividerAndLFRPerPAUDPLL();
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                }
            }
            else // Ref clock Path
            {
                // We can assume all other SPIs are configured here in Otprom with
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                PPE_LVD(0xc0083, spiClockReg);
                spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                                ((uint64_t)lfrReg.spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
                                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
                                ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                                ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
                PPE_STVD(0xc0083, spiClockReg);
                g_sbemfreqency = SBE_REF_BASE_FREQ_HZ; // this is required for pk init
                // Let's update the Ref clock frequency into LFR, this is the first time we got
                // a chance to do that since otprom change is not allowed.
                lfrReg.pau_freq_in_mhz = 133; // 133MHz Ref clock
                PPE_STVD(0xc0002040, lfrReg);
            }
        }
        //In this path, no update LFR. it's already updated from last IPL run.
        else // MPIPL Path
        {
            // In Mpipl path, Otprom has set the right clock divider settings from LFR for
            // Seeprom SPIs. We need not touch that again, but we need to set up the TPM SPIs
            // in case they are modified. We have the PAU system frequency in LFR, fetch that and
            // calculate TPM SPI Clock divider.
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
        }
        //////////////////////////////////// Lock PAU DPLL ////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////
#if 0
        //Check root control register3 bit25 if the PAU DPLL in bypass or not.
        //If not bypass then we can use the 1968MHz chip frequency, if bypass then
        //use 133MHz chip frequency
        PPE_LVD(0x50013, rootCtrlReg3);
        if(!(rootCtrlReg3 & MASK_BIT25))
        {
            g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ;
            lfrReg.spi_clock_divider = 48; // Hard-coded basis (1968/40 - 1)
            // Update LFR to match up to the new divider
            PPE_STVD(0xc0002040, lfrReg);

        }
        else
        {
            // g_sbemfrequency and lfr.spi_clock_divider are already updated with
            // 133Mhz and 4 respectively. Just update the TPM Spi clock at this
            // point so that TPM can be accessible.

            //SPI4
            spiClockReg = 0;
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_MASK) |
                    ((uint64_t)lfrReg.spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
        }
#endif
        //Check SBE Role
        g_sbeRole = checkSbeRole();
        SBEM_INFO("SBE Role is %x", g_sbeRole);

        rc = pk_initialize((PkAddress)measurment_Kernel_NC_Int_stack,
                MEASUREMENT_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbemfreqency );
        if (rc)
        {
            SBEM_ERROR(SBEM_FUNC "pk_initialize failed with rc 0x%08X", rc);
            break;
        }

        SBEM_INFO("Completed PK init for Measurement with Freq [0x%08X]", g_sbemfreqency);

        //Initialize secure boot thread
        rc = createAndResumeThreadHelper(&sbem_thread,
                sbemthreadroutine,
                (void *)0,
                (PkAddress)measurmentSecureBoot_stack,
                MEASUREMENT_THREAD_SECURE_BOOT_STACK_SIZE,
                THREAD_PRIORITY_5);
        if (rc)
        {
            SBEM_ERROR(SBEM_FUNC "Initialize secure boot thread failed with rc 0x%08X", rc);
            break;
        }

        SBEM_INFO("sbemSecureBoot_thread thread initilised");

        pk_start_threads();

    }while(false);

    SBEM_EXIT(SBEM_FUNC);
    return rc;
}
