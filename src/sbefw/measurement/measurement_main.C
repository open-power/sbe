/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/sbefw/measurement/measurement_main.C $                    */
/*                                                                        */
/* OpenPOWER sbe Project                                                  */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2019,2021                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include "sbemtrace.H"
#include "sbemsecuritysetting.H"
#include "sbeglobals.H"
#include "sbeDecompression.h"
#include "sbesecuritycommon.H"
#include "sbeTPMCommand.H"
#include "sbeRoleIdentifier.H"
#include "sbemPcrStates.H"
#include "sbeOtpromMeasurementReg.H"
#include "sbe_link.H"

extern "C" {
#include "pk_api.h"
}
////////////////////////////////////////////////////////////////
//// @brief Stacks for Non-critical Interrupts ( timebase, timers )
////////////////////////////////////////////////////////////////
#define INITIAL_PK_TIMEBASE   0
//Keep stack size greater than SPI_READ_SIZE_BYTES.
#define MEASUREMENT_NONCRITICAL_STACK_SIZE      12288
#define SPI_CLOCK_DELAY_SHIFT                   44
#define SPI_CLOCK_DIVIDER_SHIFT                 52
#define SPI_CLOCK_DIVIDER_DELAY_MASK            0x00000FFFFFFFFFFF
#define DEFAULT_SPI_CLOCK_DELAY                 0x80
#define BIT15_SHIFT                             0x30
#define BIT5_SHIFT                              0x3A
#define BIT0_MASK                               1
#define ECC_SPIMM_ADDR_CORRECTION_DIS           1
#define SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT     33
#define ECC_CONTROL_TRANSPARENT_READ            1
#define SPI_ECC_CONTROL_SHIFT                   35
#define DD1                                     1
#define DD2                                     2
#define EC_MAJOR_VERSION_BIT_SHIFT              36
#define TPM_DECONFIG_BIT_SHIFT                  51

// TODO - Need to define a Header file for this and remove extern
extern uint32_t performTPMSequences();

uint8_t measurment_Kernel_NC_Int_stack[MEASUREMENT_NONCRITICAL_STACK_SIZE];
// SBE Frequency to be used to initialise PK
uint32_t g_sbemfreqency = SBE_REF_BASE_FREQ_HZ;
uint32_t g_sbeRole;

extern "C"
{

// These variables are declared in linker script to keep track of
// global constructor pointer functions and sbss section.
extern void (*ctor_start_address)() __attribute__ ((section (".rodata")));
extern void (*ctor_end_address)() __attribute__ ((section (".rodata")));
extern uint64_t _sbss_start __attribute__ ((section (".sbss")));
extern uint64_t _sbss_end __attribute__ ((section (".sbss")));
// This function will be used to do any C++ handling required before doing
// any main job. Call to this function should get generated by
// compiler.
// TODO via RTC 152070
// We are also initialising sbss section to zero this function.
// Though it does not do any harm as of now, it is better  if we use loader
// or linker script to zero init sbss section. This way we will be future
// garded if pk  boot uses some static/global data  initialised to
// false in future.

void __eabi()
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
        while ( startAddr != &_sbss_end )
        {
            *startAddr = 0;
            startAddr++;
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
        {
            (*ctors)();
            ctors++;
        }
    } while (false);
}

/*
 ** API to jump to verification code.
 */
void jump2verificationImage(uint32_t i_destAddr)
{
    asm volatile (
                     "mr %0, %1" : : "i" (6), "r" (i_destAddr) : "memory"
                 );
    asm(
            "mtctr %r6\n"
            "bctr\n"
       );
}

/*
 *  ** API to jump to the boot seeprom.
 *   */
void jump2bootImage()
{
    asm(
            "lis %r4, 0xFF80\n"
            "lvd %d0, 0(%r4)\n"
            "lis %r2 , 0x5849\n"
            "ori %r2 , %r2 , 0x5020\n"
            "lis %r3 , 0x5345\n"
            "ori %r3 , %r3, 0x504d\n"
            "cmplwbc 0, 2, %r0, %r2, magic_failed\n"
            "cmplwbc 0, 2, %r1, %r3, magic_failed\n"
            "ori %r4, %r4, 8\n"
            "lvd %d0 , 0(%r4)\n"
            "mtctr %r1\n"
            "bctr\n"
"magic_failed:\n"
            "trap\n"
       );
}
} // end extern "C"

// Load section to destination address.
int32_t loadSectionForVerification( uint64_t *i_srcAddr, uint64_t *i_destAddr )
{
    uint32_t rc = 0;
    do {
         uint8_t rc = decompress((uint8_t *)i_srcAddr, (uint8_t *)i_destAddr);
         if (rc != 0 )
           break;
       } while(0);

    return rc;
}

// Setup the SPI Clock Divider per the new clock and update LFR
void setupSpiClockDividerAndLFRPerPAUDPLL()
{
    sbe_local_LFR lfrReg;
    uint64_t loadData = 0;
    uint32_t spiAddr = 0;

    PPE_LVD(0xc0002040, lfrReg);
    //////////////////# SPI Clock Setting per the new Frequency Start /////////////////
    //  # Calculate the Clock divider from PAU Freq which is 0x7B0 (1968MHz),
    //  # default frequency set in the sbe boot seeprom, we don't need to
    //  # change this basis any boot seeprom update. This will remain hard-coded
    //  # in the measurement seeprom.
    //  # (7B0/40 - 1) = 48 = 0x30 -> SPI Seeprom Clock Divider
    //  # (7B0/192) - 1) = 10 -> SPI TPM Clock Divider
    //  # Pick up the clock delay from LFR
    uint32_t spiSeepromClockDivider = 48;
    uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
    {
        PPE_LVD(spiAddr, loadData);
        loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                ((uint64_t)spiSeepromClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
        PPE_STVD(spiAddr, loadData);
    }
    // Update TPM SPI Clock Divider
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)spiTpmClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
    PPE_STVD(spiAddr, loadData);

    // Update the LFR Clock divider and Hard-coded PAU Freq
    lfrReg.spi_clock_divider = spiSeepromClockDivider;
    lfrReg.pau_freq_in_mhz = 0x7B0;
    PPE_STVD(0xc0002040, lfrReg); // New Divider and system freq updated into LFR
    //////////////////# SPI Clock Setting per the new Frequency - End /////////////////
}
///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD2 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD2PauDpllTimeRing()
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
    //# insert header
    //# SCOMIN 0103F040 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0004 8001
    loadData = 0x0000000000048001ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 4310 1554 0000 1248
    loadData = 0x4310155400001248ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0020 0000 0000
    loadData = 0x8000000200000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 9000 2862 02AA
    loadData = 0x00009000286202AAULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0249 1000 0000
    loadData = 0x8000024910000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 16bits
    //# SCOMIN 0103F010 4000 0000 0000 0000
    loadData = 0x4000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
    if(fetchData != loadData)
    {
        // asm("li %r0, PAU_DPLL_SCAN_HDR_COMPARE_FAIL\n"); -> wanting to use this,
        // but because of compile failure hard-coding the values from sbe_link.H
        // PAU_DPLL_SCAN_HDR_COMPARE_FAIL 0x04
        asm("li %r1, 4\n");
        pk_halt();
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
}

///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD1 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD1PauDpllTimeRing()
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
    //# insert header
    //# SCOMIN 0103F040 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0048 0014
    loadData = 0x0000000000480014ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 3101 5540 0001 2488
    loadData = 0x3101554000012488;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0020 0000 0000
    loadData = 0x0000002000000000ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0009 0002 8620 2AA8
    loadData = 0x0009000286202AA8ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 2491 0000 0004
    loadData = 0x0000249100000004ULL;
    PPE_STVD(0x0103F040, loadData);
    //# insert scan data 16bits
    //# SCOMIN 0103F010 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
    if(fetchData != loadData)
    {
        pk_halt();
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
}

// This function is to lock on the PAU DPLL from Ref clock
void lockPauDpll(void)
{
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    uint32_t opcg_done = 0;
    uint32_t pau_lock = 0;
    /////////////////////////# Putring Start for perv_dpll_time/////////////////////////
    /////////////////SCOM in the SCAN Inits for the PERV_DPLL_TIME Ring/////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    // Check if you are DD1/DD2, CBS Environment Status Register bit 24-27, should be
    // 0001 -> DD1, 0002 -> DD2
    PPE_LVD(0x50004, fetchData);
    if((fetchData >> EC_MAJOR_VERSION_BIT_SHIFT) & DD1)
    {
        SBE_INFO("Scanning PAU DPLL on DD1");
        scanInitDD1PauDpllTimeRing();
    }
    else // DD2
    {
        SBE_INFO("Scanning PAU DPLL on DD2");
        scanInitDD2PauDpllTimeRing();
    }
    //////////////////////////# Putring End for perv_dpll_time/////////////////////////

    // SPI Clock Setting per the new Frequency Start
    setupSpiClockDividerAndLFRPerPAUDPLL();

    ///////////////////////////////////////////////////////////////////////////////////
    //# PAU DPLL: Initialize to mode1
    //# SCOMIN 01060052 A000000000000000
    loadData = 0xA000000000000000ULL;
    PPE_STVD(0x01060052, loadData);
    //# PAU DPLL: Write frequency settings
    //# frquency_calculated = ((7B0 + 1) * 2)/25 = 0x9D
    // SCOMIN 01060051 09D009D009D00000
    loadData = 0x09D009D009D00000ULL;
    PPE_STVD(0x01060051, loadData);
    //# PAU DPLL: Switch to internal clocks (Bit 27)
    //# SCOMIN 00050133 0000001000000000
    loadData = 0x0000001000000000ULL;
    PPE_STVD(0x00050133, loadData);
    //# PAU DPLL : Release reset (Bit 24)
    //# SCOMIN 00050133 0000008000000000
    loadData = 0x0000008000000000;
    PPE_STVD(0x00050133, loadData);
    ///////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////START CLOCKS/////////////////////////////////////
    //# Startclocks for PAU DPLL regions
    //# Exit flush (set flushmode inhibit) (set bit 2)
    //# SCOMIN 01000010 2000000000000000
    loadData = 0x2000000000000000ULL;
    PPE_STVD(0x01000010, loadData);
    //# Clear Scan region type register
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
    //# Setup all Clock Domains and Clock Types
    //# SCOMIN  01030006 400800000000E000
    loadData = 0x400800000000E000ULL;
    PPE_STVD(0x01030006, loadData);
    //# Poll OPCG done bit to check for completeness
    //# SCOMOUT 01000100 00C0000000000000, see if bit8 is set
    for(uint32_t cnt=0; cnt<0x100; cnt++)
    {
        PPE_LVD(0x01000100, fetchData);
        if(fetchData & 0x0080000000000000ULL)
        {
            opcg_done = 1;
            break;
        }
    }
    if(opcg_done == 0)
    {
        //asm("li %r0, PAU_DPLL_START_CLOCK_OPCG_FAIL\n");
        //PAU_DPLL_START_CLOCK_OPCG_FAIL 0x5
        asm("li %r1, 5\n");
        pk_halt();
    }
    //# status of region 8 - dpllpau, bit 12
    //# CLOCK RUNNING STATUS
    //# OPGC Done, check clock status SL, NSL, ARY

    //# Check for clocks running SL
    //# SCOMOUT  01030008 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030008, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running NSL
    //# SCOMOUT  01030009 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030009, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running ARY
    //# SCOMOUT  0103000A F9F7FFFFFFFFFFFF
    PPE_LVD(0x0103000A, fetchData);
    if(((fetchData >> 32) & 0x00800000) == 0)
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Clear clock region
    //# SCOMIN   01030006 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030006, loadData);
    //# Enter flush (clear flushmode inhibit)
    //# SCOMIN   01000024 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000024, loadData);

    //# Drop clock region fences for PAU DPLL
    //# SCOMIN   01000021 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000021, loadData);
    //////////////////////////////////START CLOCKS/////////////////////////////////////

    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
    //# Check for PAU DPLL lock, check if bit 63 is set
    //# SCOMOUT  01060055 09D0000000000009
    for(uint32_t cnt=0; cnt<0x2750; cnt++)
    {
        PPE_LVD(0x01060055, fetchData);
        if(fetchData & 0x1)
        {
            pau_lock = 1;
            break;
        }
    }
    if(pau_lock == 0)
    {
        //asm("li %r0, PAU_DPLL_LOCK_FAIL\n");
        //PAU_DPLL_LOCK_FAIL 0x07
        asm("li %r1, 7\n");
        pk_halt();
    }

    //# PAU DPLL: Release test_enable and bypass
    //# SCOMIN 00050133 0000006000000000
    loadData = 0x0000006000000000ULL;
    PPE_STVD(0x00050133, loadData);
    //# Raise clock region fences for PAU DPLL
    //# SCOMIN 01000011 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000011, loadData);

    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
}

void writeTruncatedVerificationImageHash(SHA512truncated_t truncatedResult)
{
    uint64_t hashData = 0x00;
    memcpy(&hashData, &truncatedResult[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG4), hashData);
    memcpy(&hashData, &truncatedResult[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG5), hashData);
    memcpy(&hashData, &truncatedResult[sizeof(uint64_t) * 2], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG6), hashData);
    memcpy(&hashData, &truncatedResult[sizeof(uint64_t) * 3], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG7), hashData);
}

////////////////////////////////////////////////////////////////
// @brief - main : Measurement Application main
////////////////////////////////////////////////////////////////
int  main(int argc, char **argv)
{
    #define SBEM_FUNC "Measurement main"
    SBEM_ENTER(SBEM_FUNC);
    int rc = 0;
    uint64_t loadData = 0;
    uint64_t scratchMsgReg = 0;
    sbe_local_LFR lfrReg;
    uint64_t scratchReg6 = 0;
    uint64_t scratchReg8 = 0;
    uint64_t spiClockReg = 0;
    uint64_t data = 0;
    uint64_t securityReg = 0;
    SHA512_t result;
    SHA512truncated_t truncatedResult;
    securityState_PCR6_t securityStatePCR6;
    securityState_PCR1_t securityStatePCR1;

    do
    {
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PIBMEM_START_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);

        //Fetch the default clock divider from LFR
        PPE_LVD(0xc0002040, lfrReg);

        ///////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////// Lock PAU DPLL /////////////////////////////////////
        // Lock PAU DPLL for faster SBE clock if Scratch Reg6 bit15
        // is clear then try PAU lock Also if not in MPIPL Path
        //
        // Reset the TPM SPI Engine, c0002010 bit 12 OR_Register/ c0002018 bit 12 And_Register
        // This is an externel reset, it will clear the spi lock and any status/config register
        // to default.
        loadData = 0x0008000000000000ULL;
        PPE_STVD(0xc0002010, loadData);
        PPE_STVD(0xc0002018, loadData);
        // In this path, we make sure we have updated all SPI Clock Registers and updated LFR
        // all fields, nothing is missing, so that subsequent flow can depend on LFR
        if(!(lfrReg.mpipl)) // IPL Path
        {
            // Fetch scratch register6, check if bit15 is unset along with scratch reg8 bit5
            PPE_LVD(0x5003F, scratchReg8);
            PPE_LVD(0x5003D, scratchReg6);
            if((!((scratchReg6 >> BIT15_SHIFT) & BIT0_MASK)) && ((scratchReg8 >> BIT5_SHIFT) & BIT0_MASK)) //PAU Path
            {
                // Update the Code Flow status in messaging register 50009
                uint64_t scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PAU_DPLL_LOCK_MSG)<<32;
                PPE_STVD(0x50009, scratchMsgReg);

                if(!SBE::isSimicsRunning())
                {
                    lockPauDpll();
                    // The above function is going to return success, if not then pk_halt
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                }
                else
                {
                    //In Simics Path, Simply set the SPI Clock and LFR with new clock dividers
                    // SPI Clock Setting per the new Frequency Start
                    setupSpiClockDividerAndLFRPerPAUDPLL();
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                }
            }
            else // Ref clock Path
            {
                // We can assume all other SPIs are configured here in Otprom with
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                PPE_LVD(0xc0083, spiClockReg);
                spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                                ((uint64_t)lfrReg.spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
                                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
                                ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                                ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
                PPE_STVD(0xc0083, spiClockReg);
                g_sbemfreqency = SBE_REF_BASE_FREQ_HZ; // this is required for pk init
                // Let's update the Ref clock frequency into LFR, this is the first time we got
                // a chance to do that since otprom change is not allowed.
                lfrReg.pau_freq_in_mhz = 133; // 133MHz Ref clock
                PPE_STVD(0xc0002040, lfrReg);
            }
        }
        //In this path, no update LFR. it's already updated from last IPL run.
        else // MPIPL Path
        {
            // In Mpipl path, Otprom has set the right clock divider settings from LFR for
            // Seeprom SPIs. We need not touch that again, but we need to set up the TPM SPIs
            // in case they are modified. We have the PAU system frequency in LFR, fetch that and
            // calculate TPM SPI Clock divider.
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - 3)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
        }
        //////////////////////////////////// Lock PAU DPLL ////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////
#if 0
        //Check root control register3 bit25 if the PAU DPLL in bypass or not.
        //If not bypass then we can use the 1968MHz chip frequency, if bypass then
        //use 133MHz chip frequency
        PPE_LVD(0x50013, rootCtrlReg3);
        if(!(rootCtrlReg3 & MASK_BIT25))
        {
            g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ;
            lfrReg.spi_clock_divider = 48; // Hard-coded basis (1968/40 - 1)
            // Update LFR to match up to the new divider
            PPE_STVD(0xc0002040, lfrReg);

        }
        else
        {
            // g_sbemfrequency and lfr.spi_clock_divider are already updated with
            // 133Mhz and 4 respectively. Just update the TPM Spi clock at this
            // point so that TPM can be accessible.

            //SPI4
            spiClockReg = 0;
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_MASK) |
                    ((uint64_t)lfrReg.spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
        }
#endif
        rc = pk_initialize((PkAddress)measurment_Kernel_NC_Int_stack,
                MEASUREMENT_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbemfreqency );
        if (rc)
        {
            SBEM_ERROR(SBEM_FUNC "pk_initialize failed with rc 0x%08X", rc);
            break;
        }
        SBEM_INFO("Completed PK init for Measurement with Freq [0x%08X]", g_sbemfreqency);

        sbemSetSecureAccessBit();

        // Check SBE Role
        g_sbeRole = checkSbeRole();

        // Update the Code Flow status in messaging register 50009
        uint64_t scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_TPM_INIT_SEQUENCE_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);

        // Startup TPM Sequence for Master Chip, Poison for Alt-master and Deconfig Bit for Secondary chips
        rc = performTPMSequences();
        if (rc)
        {
            SBEM_ERROR(SBEM_FUNC "verifySPIandTPM failed with rc 0x%08X", rc);
        }

        //Write extendSecurityStatePCR6 into measurement register x10010
        securityStatePCR6.update(g_sbeRole);
        memcpy(&data, (uint8_t *)&securityStatePCR6, sizeof(securityState_PCR6_t));
        putscom_abs(OTPROM_MEASUREMENT_REG0, data);

        //Write extendSecurityStatePCR1 into measurement register x10012
        securityStatePCR1.update(g_sbeRole);
        memcpy(&data, (uint8_t *)&securityStatePCR1, sizeof(securityState_PCR1_t));
        putscom_abs(OTPROM_MEASUREMENT_REG2, data);

        PPE_LVD(0x10005, securityReg);
        //Skip if error/rc in TPM sequence.
        if((g_sbeRole == SBE_ROLE_MASTER) && (!(securityReg >> TPM_DECONFIG_BIT_SHIFT)) )
        {
            //Extend HW key hash to PCR6 and PCR1 if SBE role is master.
            if(getXipSize(P9_XIP_SECTION_SBE_SB_SETTINGS) != 0x00)
            {
                memcpy(truncatedResult, (uint8_t *)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + sizeof(SHA512truncated_t)), sizeof(SHA512truncated_t));
            }
            else
            {
                SBEM_ERROR(".sb_settings XIP section not found. HW key hash not found");
                SBEM_ERROR("Extending 0x00 into TPM_PCR6 and TPM_PCR1");
            }
            // TODO - Please handle the return RC and update scratch and deconfig TPM
            tpmExtendPCR(TPM_PCR6, truncatedResult, sizeof(SHA512truncated_t));
            // TODO - Please handle the return RC and update scratch and deconfig TPM
            tpmExtendPCR(TPM_PCR1, truncatedResult, sizeof(SHA512truncated_t));

            //Extend Security state to PCR6.i.e Jumper State and MSV.
            memset(truncatedResult, 0x00, sizeof(SHA512truncated_t));
            memcpy(truncatedResult, &securityStatePCR6, sizeof(securityStatePCR6));
            // TODO - Please handle the return RC and update scratch and deconfig TPM
            tpmExtendPCR(TPM_PCR6, truncatedResult, sizeof(SHA512truncated_t));

            //Extend Security state to PCR1.
            memset(truncatedResult, 0x00, sizeof(SHA512truncated_t));
            memcpy(truncatedResult, &securityStatePCR1, sizeof(securityStatePCR1));
            // TODO - Please handle the return RC and update scratch and deconfig TPM
            tpmExtendPCR(TPM_PCR1, truncatedResult, sizeof(SHA512truncated_t));
        }

        //Measure/Calculate SHA512 of .sb_verification XIP Section
        memset(truncatedResult, 0x00, sizeof(SHA512truncated_t));
        if(getXipSize(P9_XIP_SECTION_SBE_SB_VERIFICATION) != 0x00)
        {
            SBEM_INFO("Measure/Calculate SHA512 of .sb_verification XIP Section");
            // TODO - Fix Sha512, Presently it is going to append zeros.
            //SHA512_XIP_section(P9_XIP_SECTION_SBE_SB_VERIFICATION, &result);
            memcpy(truncatedResult, &result[sizeof(SHA512truncated_t)], sizeof(SHA512truncated_t));

            //Write truncated hash of SBE verification code to measurement register
            //4-7 (x10014-x10017).
            writeTruncatedVerificationImageHash(truncatedResult);

            //Skip if error/rc in TPM sequence.
            if((g_sbeRole == SBE_ROLE_MASTER) && (!(securityReg >> TPM_DECONFIG_BIT_SHIFT)) )
            {
                //Extend MSB 32 Bytes of result into TPM PCR0 and PCR6 if SBE
                //role is master.
                //TODO:Handle TPM fail cases.
                // TODO - Please handle the return RC and update scratch and deconfig TPM
                tpmExtendPCR(TPM_PCR0, truncatedResult, sizeof(SHA512truncated_t));
                // TODO - Please handle the return RC and update scratch and deconfig TPM
                tpmExtendPCR(TPM_PCR6, truncatedResult, sizeof(SHA512truncated_t));
            }
        }
        else
        {
            SBEM_ERROR(".sb_verification XIP section not found. Verification code not found.");
            SBEM_ERROR("SHA512 not calculated for .sb_verification XIP section.");
        }
    }while(0);

    SBEM_INFO("LFR = [0x%04X 0x%02X] SBE Freq = 0x%08X", lfrReg.spi_clock_divider, lfrReg.round_trip_delay, g_sbemfreqency);

    SBEM_INFO("Measurment Main is Completed.Loading L1 Loader of Boot Seeprom");

#if 0
    // Load .sb_verification section into PIBMEM.
    P9XipHeader *hdr = getXipHdr();
    P9XipSection* pSection = &hdr->iv_section[P9_XIP_SECTION_SBE_SB_VERIFICATION];
    uint32_t dsize = pSection->iv_size;
    if(dsize)
    {
        uint32_t verificationOffset = pSection->iv_offset;;
        uint32_t verificationAddress = (g_headerAddr + verificationOffset);
        P9XipHeader *vhdr = (P9XipHeader *)(verificationAddress);
        P9XipSection* pVBase = &vhdr->iv_section[P9_XIP_SECTION_SBE_BASE];
        uint64_t *srcAddr = (uint64_t *)(pVBase->iv_offset + (uint32_t)vhdr);
        SBEM_INFO("Source addr is 0x%08X", srcAddr);
        loadSectionForVerification(srcAddr, (uint64_t *)(vhdr->iv_L1LoaderAddr));
        SBEM_INFO("Completed Loading of .sb_verification into PIBMEM. Verify the image.");
        jump2verificationImage((uint32_t )vhdr->iv_kernelAddr);
    }
    else
#endif
    {
        SBEM_INFO("No verification image, jump to boot");
        jump2bootImage();
    }

    SBEM_EXIT(SBEM_FUNC);
    return rc;
}
