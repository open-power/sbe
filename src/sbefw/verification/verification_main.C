/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/sbefw/verification/verification_main.C $                  */
/*                                                                        */
/* OpenPOWER sbe Project                                                  */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2019,2021                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include "sbevtrace.H"
#include "sbevthreadroutine.H"
#include "ppe42_scom.h"
#include "sbeglobals.H"
#include "sbeexeintf.H"
#include "sbe_link.H"
#include "sbeRoleIdentifier.H"

extern "C" {
#include "pk_api.h"
}

////////////////////////////////////////////////////////////////
//// @brief Stacks for Non-critical Interrupts ( timebase, timers )
////////////////////////////////////////////////////////////////
#define INITIAL_PK_TIMEBASE   0
#define VERIFICATION_NONCRITICAL_STACK_SIZE 512
//Keep stack size greater than SPI_READ_SIZE_BYTES.
#define VERIFICATION_THREAD_SECURE_BOOT_STACK_SIZE 12288

// SBE Frequency to be used to initialise PK
uint32_t g_sbevfreqency = SBE_REF_BASE_FREQ_HZ;

uint8_t verification_Kernel_NC_Int_stack[VERIFICATION_NONCRITICAL_STACK_SIZE];
uint8_t verificationSecureBoot_stack[VERIFICATION_THREAD_SECURE_BOOT_STACK_SIZE];

///////////////////////////////////////////////////////////////////
//// @brief PkThread structure for SBE Verification thread .
////////////////////////////////////////////////////////////////////
PkThread sbev_thread;

uint32_t g_sbevRole;

extern "C"
{
// These variables are declared in linker script to keep track of
// global constructor pointer functions and sbss section.
extern void (*ctor_start_address)() __attribute__ ((section (".rodata")));
extern void (*ctor_end_address)() __attribute__ ((section (".rodata")));
extern uint64_t _sbss_start __attribute__ ((section (".sbss")));
extern uint64_t _sbss_end __attribute__ ((section (".sbss")));
// This function will be used to do any C++ handling required before doing
// any main job. Call to this function should get generated by
// compiler.
// TODO via RTC 152070
// We are also initialising sbss section to zero this function.
// Though it does not do any harm as of now, it is better  if we use loader
// or linker script to zero init sbss section. This way we will be future
// garded if pk  boot uses some static/global data  initialised to
// false in future.

void __eabi()
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
        while ( startAddr != &_sbss_end )
        {
            *startAddr = 0;
            startAddr++;
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
        {
            (*ctors)();
            ctors++;
        }
    } while (false);
}

} // end extern "C"

////////////////////////////////////////////////////////////////
// @brief  createAndResumeThreadHelper
//            - Create and resume the given thread
//
// @param[in/out] io_thread  A pointer to an PkThread structure to initialize
// @param[in]     i_thread_routine The subroutine that implements the thread
// @param[in/out] io_arg     Private data to be passed as the argument to the
//                              thread routine when it begins execution
// @param[in]     i_stack    The stack space of the thread
// @param[in]     i_stack_size The size of the stack in bytes
// @param[in]     i_priority The initial priority of the thread
//
// @return        PK_OK Successfully created and resumed the thread
//
// @return        PK_INVALID_THREAD_AT_CREATE io_thread is null
// @return        PK_INVALID_ARGUMENT_THREAD1 i_thread_routine is null
// @return        PK_INVALID_ARGUMENT_THREAD2 i_priority is invalid
// @return        PK_INVALID_ARGUMENT_THREAD3 the stack area wraps around
//                                      the end of memory.
// @return        PK_STACK_OVERFLOW           The stack area at thread creation
//                                      is smaller than the min safe size
// @return        PK_INVALID_THREAD_AT_RESUME1 io_thread is null (unlikely)
// @return        PK_INVALID_THREAD_AT_RESUME2 The thread is not active,
//                                      i.e. has completed or been deleted,
// @return        PK_PRIORITY_IN_USE_AT_RESUME Another thread is already
//                                      mapped at the priority of the thread
////////////////////////////////////////////////////////////////
uint32_t createAndResumeThreadHelper(PkThread    *io_pThread,
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
    int rc = PK_OK;

    // Thread creation
    rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
    if(rc == PK_OK)
    {
        // resume the thread once created
        rc = pk_thread_resume(io_pThread);
    }

    // Check for errors creating or resuming the thread
    if(rc != PK_OK)
    {
        SBEV_ERROR ("Failure creating/resuming thread, rc=[%d]", rc);
    }

    return rc;
}

////////////////////////////////////////////////////////////////
// @brief - main : Verification Application main
////////////////////////////////////////////////////////////////
int  main(int argc, char **argv)
{
    #define SBEV_FUNC "Verification_main "
    SBEV_ENTER(SBEV_FUNC);
    int rc = 0;
    uint64_t rootCtrlReg3 = 0;
    sbe_local_LFR lfrReg;

    do
    {
        uint64_t loadValue = (uint64_t)(SBE_CODE_VERIFICATION_PIBMEM_MAIN_MSG)<<32;
        PPE_STVD(0x50009, loadValue);

        // Load the LFR, to fetch the Pib clock frequency
        PPE_LVD(0xc0002040, lfrReg);

        //Check SBE Role
        g_sbevRole = checkSbeRole();
        SBEV_INFO(SBEV_FUNC "SBE Role is %x", g_sbevRole);

        // Check root control register3 bit25 if the PAU DPLL in bypass or not.
        // If not bypass then we use LFR frequency, if bypass then
        // use 133MHz chip frequency
        PPE_LVD(0x50013, rootCtrlReg3);
        if(!(rootCtrlReg3 & MASK_BIT25))
        {
            g_sbevfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to PAU Clock freq [0x%04X]", (uint16_t)lfrReg.pau_freq_in_mhz);
        }
        else
        {
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to Ref Clock");
            // g_sbevfrequency is already default initialised to ref clock frequency
        }

        rc = pk_initialize((PkAddress)verification_Kernel_NC_Int_stack,
                VERIFICATION_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbevfreqency );
        if (rc)
        {
            SBEV_ERROR(SBEV_FUNC "PK Initialization failed in Verification Image");
            break;
        }
        SBEV_INFO(SBEV_FUNC "Completed PK initialization for Verification Image");

        //Initialize secure boot thread
        rc = createAndResumeThreadHelper(&sbev_thread,
                sbevthreadroutine,
                (void *)0,
                (PkAddress)verificationSecureBoot_stack,
                VERIFICATION_THREAD_SECURE_BOOT_STACK_SIZE,
                THREAD_PRIORITY_5);
        if (rc)
        {
            SBEV_ERROR(SBEV_FUNC "Initialize verification secure boot thread failed with rc 0x%08X", rc);
            break;
        }

        SBEV_INFO(SBEV_FUNC "sbevSecureBoot_thread thread initilised");

        pk_start_threads();

    }while(false);

    SBEV_EXIT(SBEV_FUNC);
    return 0;
}
