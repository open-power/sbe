
/tmp/power-jenkins.swg-devops/jenkins-agent/workspace/PSE-JET/EKB/Auto-Release-HW-Image/checkNewCommit-buildRelease__2/REPO_DEST_PROJ/PPE/label/rhel7/ppe/images/sbe_verification.out:     file format elf32-powerpc


Disassembly of section .pkVectors:

fffa0000 <__vectors>:
fffa0000:	48 00 00 20 	b       fffa0020 <__machine_check>
	...

fffa0010 <__set_msr>:
fffa0010:	7c 60 01 24 	mtmsr   r3
fffa0014:	4e 80 00 20 	blr
	...

fffa0020 <__machine_check>:
fffa0020:	48 00 0b 70 	b       fffa0b90 <__sbe_machine_check_handler>
	...

fffa0040 <__system_reset>:
fffa0040:	48 00 07 38 	b       fffa0778 <__pk_boot>
	...

fffa0060 <__data_storage>:
fffa0060:	48 00 0b 29 	bl      fffa0b88 <__sbe_register_saveoff>
fffa0064:	7f e0 10 08 	twu     r0,r2
	...

fffa0080 <__instruction_storage>:
fffa0080:	48 00 0b 09 	bl      fffa0b88 <__sbe_register_saveoff>
fffa0084:	7f e0 18 08 	twu     r0,r3
	...

fffa00a0 <__external_interrupt_vector>:
fffa00a0:	f8 21 ff af 	stcxu   r1,-88(r1)
fffa00a4:	3c 60 ff fa 	lis     r3,-6
fffa00a8:	60 63 02 d0 	ori     r3,r3,720
fffa00ac:	7c 68 03 a6 	mtlr    r3
fffa00b0:	7c 90 42 a6 	mfsprg  r4,0
fffa00b4:	48 00 01 ac 	b       fffa0260 <ctx_check_discard>
	...

fffa00c0 <__alignment_exception>:
fffa00c0:	48 00 0a c9 	bl      fffa0b88 <__sbe_register_saveoff>
fffa00c4:	7f e0 20 08 	twu     r0,r4
	...

fffa00e0 <__program_exception>:
fffa00e0:	48 00 0a a9 	bl      fffa0b88 <__sbe_register_saveoff>
fffa00e4:	7f e0 e0 08 	twu     r0,r28
	...

fffa0100 <__dec_interrupt>:
fffa0100:	f8 21 ff af 	stcxu   r1,-88(r1)
fffa0104:	3c 60 ff fa 	lis     r3,-6
fffa0108:	60 63 01 b0 	ori     r3,r3,432
fffa010c:	7c 68 03 a6 	mtlr    r3
fffa0110:	7c 90 42 a6 	mfsprg  r4,0
fffa0114:	48 00 01 4c 	b       fffa0260 <ctx_check_discard>
	...

fffa0120 <__fit_interrupt>:
fffa0120:	f8 21 ff af 	stcxu   r1,-88(r1)
fffa0124:	3c 60 ff fa 	lis     r3,-6
fffa0128:	60 63 01 f4 	ori     r3,r3,500
fffa012c:	7c 68 03 a6 	mtlr    r3
fffa0130:	7c 90 42 a6 	mfsprg  r4,0
fffa0134:	48 00 01 2c 	b       fffa0260 <ctx_check_discard>
	...

fffa0140 <__watchdog_interrupt>:
fffa0140:	f8 21 ff af 	stcxu   r1,-88(r1)
fffa0144:	3c 60 ff fa 	lis     r3,-6
fffa0148:	60 63 02 20 	ori     r3,r3,544
fffa014c:	7c 68 03 a6 	mtlr    r3
fffa0150:	7c 90 42 a6 	mfsprg  r4,0
fffa0154:	48 00 01 0c 	b       fffa0260 <ctx_check_discard>
	...

fffa0160 <__virtual_exception>:
fffa0160:	7f e0 e8 08 	twu     r0,r29

Disassembly of section .base:

fffa0164 <__pk_idle_thread-0x1c>:
	...

fffa0180 <__pk_idle_thread>:
fffa0180:	7c 70 42 a6 	mfsprg  r3,0
fffa0184:	54 63 84 3e 	rlwinm  r3,r3,16,16,31
fffa0188:	64 63 a0 80 	oris    r3,r3,41088
fffa018c:	7c 70 43 a6 	mtsprg  0,r3
fffa0190:	80 2d 03 24 	lwz     r1,804(r13)

fffa0194 <__pk_idle_thread_from_bootloader>:
fffa0194:	80 6d 03 08 	lwz     r3,776(r13)
fffa0198:	64 63 00 04 	oris    r3,r3,4
fffa019c:	4b ff fe 75 	bl      fffa0010 <__set_msr>
fffa01a0:	48 00 00 00 	b       fffa01a0 <__pk_idle_thread_from_bootloader+0xc>

fffa01a4 <pk_halt>:
fffa01a4:	3f e0 30 00 	lis     r31,12288
fffa01a8:	7f f4 4b a6 	mtspr   308,r31
fffa01ac:	00 00 00 00 	.long 0x0

fffa01b0 <dec_handler>:
fffa01b0:	38 80 00 58 	li      r4,88
fffa01b4:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fffa01b8:	64 63 40 00 	oris    r3,r3,16384
fffa01bc:	7c 70 43 a6 	mtsprg  0,r3
fffa01c0:	3c 60 08 00 	lis     r3,2048
fffa01c4:	7c 70 53 a6 	mtspr   336,r3
fffa01c8:	48 00 04 41 	bl      fffa0608 <__pk_timer_handler>
fffa01cc:	48 00 01 5c 	b       fffa0328 <check_for_ext_interrupt>

fffa01d0 <__pk_next_thread_resume>:
fffa01d0:	80 6d 03 10 	lwz     r3,784(r13)
fffa01d4:	90 6d 03 14 	stw     r3,788(r13)
fffa01d8:	06 c3 07 d4 	bwz     r3,fffa0180 <__pk_idle_thread>
fffa01dc:	80 23 00 00 	lwz     r1,0(r3)

fffa01e0 <restore_and_update_sprg0>:
fffa01e0:	8b ed 03 0c 	lbz     r31,780(r13)
fffa01e4:	80 61 00 0c 	lwz     r3,12(r1)
fffa01e8:	53 e3 c0 8e 	rlwimi  r3,r31,24,2,7
fffa01ec:	7c 70 43 a6 	mtsprg  0,r3
fffa01f0:	48 00 01 ac 	b       fffa039c <ctx_pop>

fffa01f4 <fit_handler>:
fffa01f4:	38 80 00 59 	li      r4,89
fffa01f8:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fffa01fc:	64 63 40 00 	oris    r3,r3,16384
fffa0200:	7c 70 43 a6 	mtsprg  0,r3
fffa0204:	80 6d 46 c0 	lwz     r3,18112(r13)
fffa0208:	3c c0 04 00 	lis     r6,1024
fffa020c:	7c d0 53 a6 	mtspr   336,r6
fffa0210:	80 cd 46 cc 	lwz     r6,18124(r13)
fffa0214:	7c c8 03 a6 	mtlr    r6
fffa0218:	4e 80 00 21 	blrl
fffa021c:	48 00 01 0c 	b       fffa0328 <check_for_ext_interrupt>

fffa0220 <watchdog_handler>:
fffa0220:	38 80 00 5a 	li      r4,90
fffa0224:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fffa0228:	64 63 40 00 	oris    r3,r3,16384
fffa022c:	7c 70 43 a6 	mtsprg  0,r3
fffa0230:	3c c0 40 00 	lis     r6,16384
fffa0234:	7c d0 53 a6 	mtspr   336,r6
fffa0238:	80 cd 46 c8 	lwz     r6,18120(r13)
fffa023c:	7c c8 03 a6 	mtlr    r6
fffa0240:	4e 80 00 21 	blrl
fffa0244:	48 00 00 e4 	b       fffa0328 <check_for_ext_interrupt>
fffa0248:	48 00 00 18 	b       fffa0260 <ctx_check_discard>
fffa024c:	60 00 00 00 	nop
fffa0250:	60 00 00 00 	nop
fffa0254:	60 00 00 00 	nop
fffa0258:	60 00 00 00 	nop
fffa025c:	60 00 00 00 	nop

fffa0260 <ctx_check_discard>:
fffa0260:	07 84 40 1a 	bb0wi   r4,8,fffa0294 <ctx_interrupt_check>
fffa0264:	38 21 00 58 	addi    r1,r1,88
fffa0268:	4e 80 00 20 	blr

fffa026c <__ctx_switch>:
fffa026c:	7c 68 02 a6 	mflr    r3
fffa0270:	7c 80 00 a6 	mfmsr   r4
fffa0274:	7c 00 01 46 	wrteei  0
fffa0278:	7c 7a 03 a6 	mtsrr0  r3
fffa027c:	7c 9b 03 a6 	mtsrr1  r4
fffa0280:	7c 00 04 ac 	sync    
fffa0284:	f8 21 ff af 	stcxu   r1,-88(r1)
fffa0288:	3c a0 ff fa 	lis     r5,-6
fffa028c:	60 a5 01 d0 	ori     r5,r5,464
fffa0290:	7c a8 03 a6 	mtlr    r5

fffa0294 <ctx_interrupt_check>:
fffa0294:	7c 70 42 a6 	mfsprg  r3,0
fffa0298:	07 03 08 14 	bb1wi   r3,1,fffa02c0 <kernel_stack_check>
fffa029c:	80 8d 03 14 	lwz     r4,788(r13)
fffa02a0:	06 c4 00 0a 	bwz     r4,fffa02b4 <stack_good>
fffa02a4:	90 24 00 00 	stw     r1,0(r4)
fffa02a8:	80 e4 00 04 	lwz     r7,4(r4)
fffa02ac:	05 87 08 04 	cmplwblt r7,r1,fffa02b4 <stack_good>
fffa02b0:	7f e3 28 08 	twu     r3,r5

fffa02b4 <stack_good>:
fffa02b4:	90 2d 03 28 	stw     r1,808(r13)
fffa02b8:	80 2d 03 24 	lwz     r1,804(r13)
fffa02bc:	4e 80 00 20 	blr

fffa02c0 <kernel_stack_check>:
fffa02c0:	80 ed 03 20 	lwz     r7,800(r13)
fffa02c4:	05 87 08 04 	cmplwblt r7,r1,fffa02cc <ctx_push_complete>
fffa02c8:	7f e3 28 08 	twu     r3,r5

fffa02cc <ctx_push_complete>:
fffa02cc:	4e 80 00 20 	blr

fffa02d0 <__get_ext_irq>:
fffa02d0:	7c 70 42 a6 	mfsprg  r3,0
fffa02d4:	3c a0 00 82 	lis     r5,130
fffa02d8:	60 a5 18 00 	ori     r5,r5,6144
fffa02dc:	7c a0 01 24 	mtmsr   r5
fffa02e0:	7c 00 04 ac 	sync    
fffa02e4:	3c a0 c0 00 	lis     r5,-16384
fffa02e8:	14 a5 00 80 	lvd     d5,128(r5)
fffa02ec:	7c a4 00 34 	cntlzw  r4,r5
fffa02f0:	06 24 f8 06 	cmpwible r4,31,fffa02fc <call_external_irq_handler>
fffa02f4:	7c c4 00 34 	cntlzw  r4,r6
fffa02f8:	38 84 00 20 	addi    r4,r4,32

fffa02fc <call_external_irq_handler>:
fffa02fc:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fffa0300:	64 63 40 00 	oris    r3,r3,16384
fffa0304:	7c 70 43 a6 	mtsprg  0,r3
fffa0308:	54 83 18 38 	rlwinm  r3,r4,3,0,28
fffa030c:	3c c0 ff fa 	lis     r6,-6
fffa0310:	60 c6 76 78 	ori     r6,r6,30328
fffa0314:	7c a6 18 2e 	lwzx    r5,r6,r3
fffa0318:	38 63 00 04 	addi    r3,r3,4
fffa031c:	7c 66 18 2e 	lwzx    r3,r6,r3
fffa0320:	7c a8 03 a6 	mtlr    r5
fffa0324:	4e 80 00 21 	blrl

fffa0328 <check_for_ext_interrupt>:
fffa0328:	7f f0 42 a6 	mfsprg  r31,0
fffa032c:	67 ff 00 80 	oris    r31,r31,128
fffa0330:	7f f0 43 a6 	mtsprg  0,r31
fffa0334:	7c 00 81 46 	wrteei  1
fffa0338:	7c 00 01 46 	wrteei  0

fffa033c <check_interrupted_bh>:
fffa033c:	57 e4 46 be 	rlwinm  r4,r31,8,26,31
fffa0340:	2c 04 00 21 	cmpwi   r4,33
fffa0344:	41 82 00 50 	beq     fffa0394 <ctx_pop_with_sprg0>

fffa0348 <check_for_bh>:
fffa0348:	80 8d 02 60 	lwz     r4,608(r13)
fffa034c:	80 a4 00 00 	lwz     r5,0(r4)
fffa0350:	05 c4 28 10 	cmplwbeq r4,r5,fffa0370 <restore_interrupted_sp>

fffa0354 <process_bottom_halves>:
fffa0354:	57 e3 02 42 	rlwinm  r3,r31,0,9,1
fffa0358:	64 63 21 00 	oris    r3,r3,8448
fffa035c:	7c 70 43 a6 	mtsprg  0,r3
fffa0360:	7c 00 81 46 	wrteei  1
fffa0364:	48 00 00 51 	bl      fffa03b4 <_pk_process_bh>
fffa0368:	7c 00 01 46 	wrteei  0
fffa036c:	7f f0 43 a6 	mtsprg  0,r31

fffa0370 <restore_interrupted_sp>:
fffa0370:	80 2d 03 28 	lwz     r1,808(r13)

fffa0374 <check_thread_mode>:
fffa0374:	07 9f 00 10 	bb0wi   r31,0,fffa0394 <ctx_pop_with_sprg0>

fffa0378 <check_for_ctx_switch>:
fffa0378:	80 6d 03 18 	lwz     r3,792(r13)
fffa037c:	06 c3 00 08 	bwz     r3,fffa038c <check_for_idle_thread>
fffa0380:	38 60 00 00 	li      r3,0
fffa0384:	90 6d 03 18 	stw     r3,792(r13)
fffa0388:	4b ff fe 48 	b       fffa01d0 <__pk_next_thread_resume>

fffa038c <check_for_idle_thread>:
fffa038c:	80 6d 03 14 	lwz     r3,788(r13)
fffa0390:	06 c3 06 f8 	bwz     r3,fffa0180 <__pk_idle_thread>

fffa0394 <ctx_pop_with_sprg0>:
fffa0394:	80 01 00 0c 	lwz     r0,12(r1)
fffa0398:	7c 10 43 a6 	mtsprg  0,r0

fffa039c <ctx_pop>:
fffa039c:	e8 21 00 5f 	lcxu    r1,88(r1)
fffa03a0:	4c 00 00 64 	rfi

fffa03a4 <__ppe42_default_irq_handler>:
/// by the application.  These interrupts should never fire.

void
__ppe42_default_irq_handler(void* arg, PkIrqId irq)
{
    PK_PANIC(PK_DEFAULT_IRQ_HANDLER);
fffa03a4:	7f e0 30 08 	twu     r0,r6
fffa03a8:	4e 80 00 20 	blr

fffa03ac <__ppe42_phantom_irq_handler>:
/// 'glitch' occurred on the external interrupt input
/// to the PPE42 core.

void __ppe42_phantom_irq_handler(void* arg, PkIrqId irq)
{
    PK_PANIC(PPE42_PHANTOM_INTERRUPT);
fffa03ac:	7f e0 40 08 	twu     r0,r8
fffa03b0:	4e 80 00 20 	blr

fffa03b4 <_pk_process_bh>:

/// Statically initialize the bottom half queue
PK_DEQUE_SENTINEL_STATIC_CREATE(_pk_bh_queue);

void _pk_process_bh(void)
{
fffa03b4:	94 21 ff f0 	stwu    r1,-16(r1)
fffa03b8:	7c 08 02 a6 	mflr    r0
fffa03bc:	1b c1 00 08 	stvd    d30,8(r1)
fffa03c0:	90 01 00 14 	stw     r0,20(r1)
/// \retval 1 The PkDeque is empty

static inline int
pk_deque_is_empty(PkDeque* deque)
{
    return (deque == deque->next);
fffa03c4:	3b ed 02 60 	addi    r31,r13,608
fffa03c8:	81 2d 02 60 	lwz     r9,608(r13)
static inline PkDeque*
pk_deque_pop_front(PkDeque* deque)
{
    PkDeque* head;

    if (pk_deque_is_empty(deque))
fffa03cc:	04 c9 f8 16 	cmpwbeq r9,r31,fffa03f8 <_pk_process_bh+0x44>
        return 0;
    }
    else
    {
        head = (PkDeque*)(deque->next);
        deque->next = head->next;
fffa03d0:	81 49 00 00 	lwz     r10,0(r9)
    PkBottomHalf* bh;

    while((bh = (PkBottomHalf*)pk_deque_pop_front(&_pk_bh_queue)) != 0)
    {
        bh->bh_handler(bh->arg);
fffa03d4:	80 69 00 0c 	lwz     r3,12(r9)
        deque->next->previous = deque;
fffa03d8:	93 ea 00 04 	stw     r31,4(r10)
        return 0;
    }
    else
    {
        head = (PkDeque*)(deque->next);
        deque->next = head->next;
fffa03dc:	91 4d 02 60 	stw     r10,608(r13)
        deque->next->previous = deque;
        head->next = 0;
fffa03e0:	39 40 00 00 	li      r10,0
fffa03e4:	91 49 00 00 	stw     r10,0(r9)
fffa03e8:	81 49 00 08 	lwz     r10,8(r9)
fffa03ec:	7d 49 03 a6 	mtctr   r10
fffa03f0:	4e 80 04 21 	bctrl
fffa03f4:	4b ff ff d4 	b       fffa03c8 <_pk_process_bh+0x14>
    }

    return;
}
fffa03f8:	80 01 00 14 	lwz     r0,20(r1)
fffa03fc:	17 c1 00 08 	lvd     d30,8(r1)
fffa0400:	7c 08 03 a6 	mtlr    r0
fffa0404:	38 21 00 10 	addi    r1,r1,16
fffa0408:	4e 80 00 20 	blr

fffa040c <pk_deque_sentinel_create>:
int
pk_deque_sentinel_create(PkDeque* deque)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(deque == 0, PK_INVALID_DEQUE_SENTINEL);
fffa040c:	06 c3 00 0a 	bwz     r3,fffa0420 <pk_deque_sentinel_create+0x14>
    }

    deque->next = deque->previous = deque;
fffa0410:	90 63 00 04 	stw     r3,4(r3)
fffa0414:	90 63 00 00 	stw     r3,0(r3)
    return 0;
fffa0418:	38 60 00 00 	li      r3,0
fffa041c:	4e 80 00 20 	blr
int
pk_deque_sentinel_create(PkDeque* deque)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(deque == 0, PK_INVALID_DEQUE_SENTINEL);
fffa0420:	38 60 fc e1 	li      r3,-799
    }

    deque->next = deque->previous = deque;
    return 0;
}
fffa0424:	4e 80 00 20 	blr

fffa0428 <pk_deque_element_create>:
int
pk_deque_element_create(PkDeque* element)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(element == 0, PK_INVALID_DEQUE_ELEMENT);
fffa0428:	06 c3 00 0a 	bwz     r3,fffa043c <pk_deque_element_create+0x14>
    }

    element->next = 0;
fffa042c:	39 20 00 00 	li      r9,0
fffa0430:	91 23 00 00 	stw     r9,0(r3)
    return 0;
fffa0434:	38 60 00 00 	li      r3,0
fffa0438:	4e 80 00 20 	blr
int
pk_deque_element_create(PkDeque* element)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(element == 0, PK_INVALID_DEQUE_ELEMENT);
fffa043c:	38 60 fc 00 	li      r3,-1024
    }

    element->next = 0;
    return 0;
}
fffa0440:	4e 80 00 20 	blr

fffa0444 <__pk_timer_bh_handler>:
// The main loop iterates on the PkDeque form of the time queue, casting each
// element back up to the PkTimer as it is processed.

static void
__pk_timer_bh_handler(void* arg)
{
fffa0444:	94 21 ff e0 	stwu    r1,-32(r1)
fffa0448:	7c 08 02 a6 	mflr    r0
fffa044c:	1b c1 00 18 	stvd    d30,24(r1)
fffa0450:	90 01 00 24 	stw     r0,36(r1)
    tq = &__pk_time_queue;

    // Check if we entered the function while it was running in another context.
    if (PK_ERROR_CHECK_KERNEL)
    {
        if (tq->cursor != 0)
fffa0454:	3b ed 02 68 	addi    r31,r13,616
fffa0458:	81 3f 00 10 	lwz     r9,16(r31)
// The main loop iterates on the PkDeque form of the time queue, casting each
// element back up to the PkTimer as it is processed.

static void
__pk_timer_bh_handler(void* arg)
{
fffa045c:	1b 81 00 10 	stvd    d28,16(r1)
    tq = &__pk_time_queue;

    // Check if we entered the function while it was running in another context.
    if (PK_ERROR_CHECK_KERNEL)
    {
        if (tq->cursor != 0)
fffa0460:	06 c9 00 04 	bwz     r9,fffa0468 <__pk_timer_bh_handler+0x24>
        {
            PK_PANIC(PK_TIMER_HANDLER_INVARIANT);
fffa0464:	7f e4 30 08 	twu     r4,r6

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa0468:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fffa046c:	7c 00 01 46 	wrteei  0

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
    {
        tq->next_timeout = PK_TIMEBASE_MAX;
fffa0470:	3b 80 ff ff 	li      r28,-1
fffa0474:	3b a0 ff ff 	li      r29,-1
        }
    }

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
fffa0478:	48 00 04 a9 	bl      fffa0920 <pk_timebase_get>
fffa047c:	81 2d 02 70 	lwz     r9,624(r13)
fffa0480:	7c 68 1b 78 	mr      r8,r3
fffa0484:	05 a9 40 62 	cmplwbgt r9,r8,fffa0548 <__pk_timer_bh_handler+0x104>
fffa0488:	04 c9 40 5a 	cmpwbeq r9,r8,fffa053c <__pk_timer_bh_handler+0xf8>
    {
        tq->next_timeout = PK_TIMEBASE_MAX;
fffa048c:	1b 8d 02 70 	stvd    d28,624(r13)
        timer_deque = ((PkDeque*)tq)->next;
fffa0490:	81 2d 02 68 	lwz     r9,616(r13)

        // Iterate through the entire timer list, calling the callback of
        // timed-out elements and finding the timer that will timeout next,
        // which is stored in tq->next_timeout.
        while (timer_deque != (PkDeque*)tq)
fffa0494:	04 c9 ff f2 	cmpwbeq r9,r31,fffa0478 <__pk_timer_bh_handler+0x34>

            timer = (PkTimer*)timer_deque;

            // Setting this to a non-zero value indicates we are in the middle
            // of processing the time queue.
            tq->cursor = timer_deque->next;
fffa0498:	80 e9 00 00 	lwz     r7,0(r9)
fffa049c:	39 4d 02 68 	addi    r10,r13,616
fffa04a0:	90 ea 00 10 	stw     r7,16(r10)

            if (timer->timeout <= now)
fffa04a4:	81 49 00 08 	lwz     r10,8(r9)
fffa04a8:	80 c9 00 0c 	lwz     r6,12(r9)
fffa04ac:	80 e9 00 00 	lwz     r7,0(r9)
fffa04b0:	05 aa 40 28 	cmplwbgt r10,r8,fffa0500 <__pk_timer_bh_handler+0xbc>
fffa04b4:	04 4a 40 04 	cmpwbne r10,r8,fffa04bc <__pk_timer_bh_handler+0x78>
fffa04b8:	05 a6 20 24 	cmplwbgt r6,r4,fffa0500 <__pk_timer_bh_handler+0xbc>
/// enqueued, but the API does not check for this error.

static inline void
pk_deque_delete(PkDeque* element)
{
    element->previous->next = element->next;
fffa04bc:	81 49 00 04 	lwz     r10,4(r9)
fffa04c0:	90 ea 00 00 	stw     r7,0(r10)
    element->next->previous = element->previous;
fffa04c4:	80 e9 00 00 	lwz     r7,0(r9)
fffa04c8:	91 47 00 04 	stw     r10,4(r7)
    element->next = 0;
fffa04cc:	39 40 00 00 	li      r10,0
fffa04d0:	91 49 00 00 	stw     r10,0(r9)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa04d4:	7f c0 01 24 	mtmsr   r30

                pk_deque_delete(timer_deque);

                pk_critical_section_exit(&ctx);

                callback = timer->callback;
fffa04d8:	81 49 00 10 	lwz     r10,16(r9)

                if (callback)
fffa04dc:	06 ca 00 28 	bwz     r10,fffa052c <__pk_timer_bh_handler+0xe8>
                {
                    callback(timer->arg);
fffa04e0:	80 69 00 14 	lwz     r3,20(r9)
fffa04e4:	7d 49 03 a6 	mtctr   r10
fffa04e8:	90 81 00 0c 	stw     r4,12(r1)
fffa04ec:	91 01 00 08 	stw     r8,8(r1)
fffa04f0:	4e 80 04 21 	bctrl
fffa04f4:	80 81 00 0c 	lwz     r4,12(r1)
fffa04f8:	81 01 00 08 	lwz     r8,8(r1)
fffa04fc:	48 00 00 30 	b       fffa052c <__pk_timer_bh_handler+0xe8>
            else
            {

                // This timer has not timed out.  Its timeout will simply
                // participate in the computation of the next timeout.
                tq->next_timeout = MIN(timer->timeout, tq->next_timeout);
fffa0500:	81 2d 02 70 	lwz     r9,624(r13)
fffa0504:	80 ff 00 0c 	lwz     r7,12(r31)
fffa0508:	05 a9 50 06 	cmplwbgt r9,r10,fffa0514 <__pk_timer_bh_handler+0xd0>
fffa050c:	04 49 50 08 	cmpwbne r9,r10,fffa051c <__pk_timer_bh_handler+0xd8>
fffa0510:	05 27 30 06 	cmplwble r7,r6,fffa051c <__pk_timer_bh_handler+0xd8>
fffa0514:	7d 49 53 78 	mr      r9,r10
fffa0518:	7c c7 33 78 	mr      r7,r6
fffa051c:	91 2d 02 70 	stw     r9,624(r13)
fffa0520:	39 2d 02 68 	addi    r9,r13,616
fffa0524:	90 e9 00 0c 	stw     r7,12(r9)
fffa0528:	7f c0 01 24 	mtmsr   r30
                pk_critical_section_exit(&ctx);
            }

            timer_deque = tq->cursor;
fffa052c:	81 3f 00 10 	lwz     r9,16(r31)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa0530:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fffa0534:	7c 00 01 46 	wrteei  0
fffa0538:	4b ff ff 5c 	b       fffa0494 <__pk_timer_bh_handler+0x50>
        }
    }

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
fffa053c:	39 2d 02 68 	addi    r9,r13,616
fffa0540:	81 29 00 0c 	lwz     r9,12(r9)
fffa0544:	05 29 27 a4 	cmplwble r9,r4,fffa048c <__pk_timer_bh_handler+0x48>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa0548:	7f c0 01 24 	mtmsr   r30
    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fffa054c:	80 01 00 24 	lwz     r0,36(r1)
    }

    pk_critical_section_exit(&ctx);

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;
fffa0550:	39 20 00 00 	li      r9,0

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fffa0554:	7c 08 03 a6 	mtlr    r0
    }

    pk_critical_section_exit(&ctx);

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;
fffa0558:	91 3f 00 10 	stw     r9,16(r31)

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fffa055c:	17 81 00 10 	lvd     d28,16(r1)
fffa0560:	17 c1 00 18 	lvd     d30,24(r1)

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
fffa0564:	14 6d 02 70 	lvd     d3,624(r13)
}
fffa0568:	38 21 00 20 	addi    r1,r1,32

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
fffa056c:	48 00 02 74 	b       fffa07e0 <__pk_schedule_hardware_timeout>

fffa0570 <__pk_timer_cancel>:
//  Note that cancelling a timer does not cause a re-evaluation of the next
//  timeout.  This will happen naturally when the current timeout expires.

int
__pk_timer_cancel(PkTimer* timer)
{
fffa0570:	81 23 00 00 	lwz     r9,0(r3)
    int rc;
    PkDeque* timer_deque = (PkDeque*)timer;
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fffa0574:	06 c9 00 1a 	bwz     r9,fffa05a8 <__pk_timer_cancel+0x38>

    }
    else
    {

        if (timer_deque == tq->cursor)
fffa0578:	39 4d 02 68 	addi    r10,r13,616
fffa057c:	81 0a 00 10 	lwz     r8,16(r10)
fffa0580:	04 43 40 04 	cmpwbne r3,r8,fffa0588 <__pk_timer_cancel+0x18>
        {
            tq->cursor = tq->cursor->next;
fffa0584:	91 2a 00 10 	stw     r9,16(r10)
/// enqueued, but the API does not check for this error.

static inline void
pk_deque_delete(PkDeque* element)
{
    element->previous->next = element->next;
fffa0588:	81 43 00 04 	lwz     r10,4(r3)
fffa058c:	91 2a 00 00 	stw     r9,0(r10)
    element->next->previous = element->previous;
fffa0590:	81 23 00 00 	lwz     r9,0(r3)
fffa0594:	91 49 00 04 	stw     r10,4(r9)
    element->next = 0;
fffa0598:	39 20 00 00 	li      r9,0
fffa059c:	91 23 00 00 	stw     r9,0(r3)
        }

        pk_deque_delete(timer_deque);
        rc = 0;
fffa05a0:	38 60 00 00 	li      r3,0
fffa05a4:	4e 80 00 20 	blr
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
    {

        rc = -PK_TIMER_NOT_ACTIVE;
fffa05a8:	38 60 fc f9 	li      r3,-775
        pk_deque_delete(timer_deque);
        rc = 0;
    }

    return rc;
}
fffa05ac:	4e 80 00 20 	blr

fffa05b0 <__pk_timer_schedule>:
void
__pk_timer_schedule(PkTimer* timer)
{
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fffa05b0:	81 03 00 00 	lwz     r8,0(r3)
// we are in the midst of processing the time queue, and the end of time queue
// processing will schedule the next hardware timemout.

void
__pk_timer_schedule(PkTimer* timer)
{
fffa05b4:	7c 69 1b 78 	mr      r9,r3
fffa05b8:	39 4d 02 68 	addi    r10,r13,616
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fffa05bc:	06 48 00 0c 	bwnz    r8,fffa05d4 <__pk_timer_schedule+0x24>
/// but the API does not check for this error.

static inline void
pk_deque_push_back(PkDeque* deque, PkDeque* element)
{
    deque->previous->next = element;
fffa05c0:	81 0d 02 6c 	lwz     r8,620(r13)
fffa05c4:	90 68 00 00 	stw     r3,0(r8)
    element->previous = deque->previous;
fffa05c8:	91 03 00 04 	stw     r8,4(r3)
    element->next = deque;
fffa05cc:	91 43 00 00 	stw     r10,0(r3)
    deque->previous = element;
fffa05d0:	90 6d 02 6c 	stw     r3,620(r13)
    {
        pk_deque_push_back((PkDeque*)tq, (PkDeque*)timer);
    }

    if (timer->timeout < tq->next_timeout)
fffa05d4:	14 69 00 08 	lvd     d3,8(r9)
fffa05d8:	81 2d 02 70 	lwz     r9,624(r13)
fffa05dc:	05 a9 18 0a 	cmplwbgt r9,r3,fffa05f0 <__pk_timer_schedule+0x40>
fffa05e0:	04 49 18 12 	cmpwbne r9,r3,fffa0604 <__pk_timer_schedule+0x54>
fffa05e4:	39 2d 02 68 	addi    r9,r13,616
fffa05e8:	81 29 00 0c 	lwz     r9,12(r9)
fffa05ec:	05 29 20 0c 	cmplwble r9,r4,fffa0604 <__pk_timer_schedule+0x54>
    {
        tq->next_timeout = timer->timeout;

        if (tq->cursor == 0)
fffa05f0:	81 2a 00 10 	lwz     r9,16(r10)
        pk_deque_push_back((PkDeque*)tq, (PkDeque*)timer);
    }

    if (timer->timeout < tq->next_timeout)
    {
        tq->next_timeout = timer->timeout;
fffa05f4:	90 6d 02 70 	stw     r3,624(r13)
fffa05f8:	90 8a 00 0c 	stw     r4,12(r10)

        if (tq->cursor == 0)
fffa05fc:	06 49 00 04 	bwnz    r9,fffa0604 <__pk_timer_schedule+0x54>
        {
            __pk_schedule_hardware_timeout(tq->next_timeout);
fffa0600:	48 00 01 e0 	b       fffa07e0 <__pk_schedule_hardware_timeout>
fffa0604:	4e 80 00 20 	blr

fffa0608 <__pk_timer_handler>:
extern PkDeque _pk_bh_queue SECTION(".sdata.pk");

static inline void
pk_bh_schedule(PkBottomHalf* bottom_half)
{
    if(!pk_deque_is_queued((PkDeque*)bottom_half))
fffa0608:	81 4d 03 2c 	lwz     r10,812(r13)
fffa060c:	39 2d 03 2c 	addi    r9,r13,812
fffa0610:	06 4a 00 0e 	bwnz    r10,fffa062c <__pk_timer_handler+0x24>
/// but the API does not check for this error.

static inline void
pk_deque_push_back(PkDeque* deque, PkDeque* element)
{
    deque->previous->next = element;
fffa0614:	81 4d 02 64 	lwz     r10,612(r13)
fffa0618:	91 2a 00 00 	stw     r9,0(r10)
    element->previous = deque->previous;
fffa061c:	91 4d 03 30 	stw     r10,816(r13)
    element->next = deque;
fffa0620:	39 4d 02 60 	addi    r10,r13,608
fffa0624:	91 4d 03 2c 	stw     r10,812(r13)
    deque->previous = element;
fffa0628:	91 2d 02 64 	stw     r9,612(r13)
fffa062c:	4e 80 00 20 	blr

fffa0630 <pk_timer_schedule>:
///

int
pk_timer_schedule(PkTimer*    timer,
                  PkInterval interval)
{
fffa0630:	94 21 ff e8 	stwu    r1,-24(r1)
fffa0634:	7c 08 02 a6 	mflr    r0
fffa0638:	1b c1 00 10 	stvd    d30,16(r1)
fffa063c:	1b 81 00 08 	stvd    d28,8(r1)
fffa0640:	7c df 33 78 	mr      r31,r6
fffa0644:	7c be 2b 78 	mr      r30,r5
fffa0648:	90 01 00 1c 	stw     r0,28(r1)
fffa064c:	7c 7d 1b 78 	mr      r29,r3
    PkMachineContext ctx;
    PkTimebase  timeout = pk_timebase_get() + PK_INTERVAL_SCALE(interval);
fffa0650:	48 00 02 d1 	bl      fffa0920 <pk_timebase_get>
fffa0654:	3d 20 ff fa 	lis     r9,-6
fffa0658:	89 09 76 20 	lbz     r8,30240(r9)
fffa065c:	7f c8 44 76 	srvd    d8,d30,r8
fffa0660:	7f ff 48 14 	addc    r31,r31,r9
fffa0664:	7f de 41 14 	adde    r30,r30,r8
fffa0668:	7f ff 20 14 	addc    r31,r31,r4
fffa066c:	7f de 19 14 	adde    r30,r30,r3

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa0670:	7f 80 00 a6 	mfmsr   r28

wrteei(0);
fffa0674:	7c 00 01 46 	wrteei  0

    pk_critical_section_enter(&ctx);

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(timer == 0, PK_INVALID_TIMER_AT_SCHEDULE);
fffa0678:	38 60 fd fd 	li      r3,-515
fffa067c:	06 dd 00 0c 	bwz     r29,fffa0694 <pk_timer_schedule+0x64>
    }

    timer->timeout = timeout;
fffa0680:	1b dd 00 08 	stvd    d30,8(r29)
    __pk_timer_schedule(timer);
fffa0684:	7f a3 eb 78 	mr      r3,r29
fffa0688:	4b ff ff 29 	bl      fffa05b0 <__pk_timer_schedule>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa068c:	7f 80 01 24 	mtmsr   r28

    pk_critical_section_exit(&ctx);

    return PK_OK;
fffa0690:	38 60 00 00 	li      r3,0
}
fffa0694:	80 01 00 1c 	lwz     r0,28(r1)
fffa0698:	17 81 00 08 	lvd     d28,8(r1)
fffa069c:	7c 08 03 a6 	mtlr    r0
fffa06a0:	17 c1 00 10 	lvd     d30,16(r1)
fffa06a4:	38 21 00 18 	addi    r1,r1,24
fffa06a8:	4e 80 00 20 	blr

fffa06ac <pk_trace_timer_callback>:
#if PK_TRACE_TIMER_OUTPUT
    // guarantee at least one trace before the lower 32bit timebase flips
    PK_TRACE("PERIODIC TIMESTAMPING TRACE");
#endif
    // restart the timer
    pk_timer_schedule(&g_pk_trace_timer,
fffa06ac:	3c c0 fc 46 	lis     r6,-954
fffa06b0:	38 6d 13 78 	addi    r3,r13,4984
fffa06b4:	38 a0 00 00 	li      r5,0
fffa06b8:	60 c6 53 5f 	ori     r6,r6,21343
fffa06bc:	4b ff ff 74 	b       fffa0630 <pk_timer_schedule>

fffa06c0 <pk_trace_tiny>:
// Creates an 8 byte entry in the trace buffer that includes a timestamp,
// a format string hash value and a 16 bit parameter.
//
// i_parm has the hash value combined with the 16 bit parameter
void pk_trace_tiny(uint32_t i_parm)
{
fffa06c0:	94 21 ff f0 	stwu    r1,-16(r1)
fffa06c4:	7c 08 02 a6 	mflr    r0
fffa06c8:	1b c1 00 08 	stvd    d30,8(r1)
fffa06cc:	90 01 00 14 	stw     r0,20(r1)
fffa06d0:	7c 7f 1b 78 	mr      r31,r3
    uint64_t            tb64;
    PkMachineContext    ctx;

    //fill in the footer data
    footer.parms.word32 = i_parm;
    tb64 = pk_timebase_get();
fffa06d4:	48 00 02 4d 	bl      fffa0920 <pk_timebase_get>
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;

    footer.time_format.format = PK_TRACE_FORMAT_TINY;
fffa06d8:	39 20 00 01 	li      r9,1
fffa06dc:	51 24 07 be 	rlwimi  r4,r9,0,30,31

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa06e0:	7d 00 00 a6 	mfmsr   r8

wrteei(0);
fffa06e4:	7c 00 01 46 	wrteei  0
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fffa06e8:	39 4d 03 40 	addi    r10,r13,832
fffa06ec:	81 2a 00 34 	lwz     r9,52(r10)
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fffa06f0:	90 6a 00 30 	stw     r3,48(r10)
    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];

    //calculate the offset for the next entry in the cb
    state.offset = g_pk_trace_buf.state.offset + sizeof(PkTraceTiny);
fffa06f4:	38 e9 00 08 	addi    r7,r9,8
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fffa06f8:	55 29 05 3e 	clrlwi  r9,r9,20
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fffa06fc:	90 ea 00 34 	stw     r7,52(r10)
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fffa0700:	39 29 00 30 	addi    r9,r9,48
    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;

    //write the data to the circular buffer including the
    //timesamp, string hash, and 16bit parameter
    *ptr64 = footer.word64;
fffa0704:	39 4a 00 08 	addi    r10,r10,8
fffa0708:	7c ea 4a 14 	add     r7,r10,r9
fffa070c:	7f ea 49 2e 	stwx    r31,r10,r9
fffa0710:	90 87 00 04 	stw     r4,4(r7)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa0714:	7d 00 01 24 	mtmsr   r8

    //exit the critical section
    pk_critical_section_exit(&ctx);
}
fffa0718:	80 01 00 14 	lwz     r0,20(r1)
fffa071c:	17 c1 00 08 	lvd     d30,8(r1)
fffa0720:	7c 08 03 a6 	mtlr    r0
fffa0724:	38 21 00 10 	addi    r1,r1,16
fffa0728:	4e 80 00 20 	blr

fffa072c <pk_trace_set_timebase>:
// as the current timebase for tracing purposes.  It can also be used
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
fffa072c:	94 21 ff f0 	stwu    r1,-16(r1)
fffa0730:	7c 08 02 a6 	mflr    r0
fffa0734:	1b c1 00 08 	stvd    d30,8(r1)
fffa0738:	90 01 00 14 	stw     r0,20(r1)
fffa073c:	7c 9f 23 78 	mr      r31,r4
fffa0740:	7c 7e 1b 78 	mr      r30,r3
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fffa0744:	48 00 01 dd 	bl      fffa0920 <pk_timebase_get>
}
fffa0748:	80 01 00 14 	lwz     r0,20(r1)
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fffa074c:	7f e4 f8 10 	subfc   r31,r4,r31
fffa0750:	7f c3 f1 10 	subfe   r30,r3,r30
}
fffa0754:	7c 08 03 a6 	mtlr    r0
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fffa0758:	39 2d 03 40 	addi    r9,r13,832
fffa075c:	1b c9 00 28 	stvd    d30,40(r9)
}
fffa0760:	17 c1 00 08 	lvd     d30,8(r1)
fffa0764:	38 21 00 10 	addi    r1,r1,16
fffa0768:	4e 80 00 20 	blr

fffa076c <pk_trace_set_freq>:

void pk_trace_set_freq(uint32_t i_frequency)
{
    g_pk_trace_buf.hz = i_frequency;
fffa076c:	39 2d 03 40 	addi    r9,r13,832
fffa0770:	90 69 00 20 	stw     r3,32(r9)
fffa0774:	4e 80 00 20 	blr

fffa0778 <__pk_boot>:
fffa0778:	38 60 00 00 	li      r3,0
fffa077c:	7c 74 53 a6 	mtspr   340,r3
fffa0780:	3c 40 ff fa 	lis     r2,-6
fffa0784:	60 42 71 20 	ori     r2,r2,28960
fffa0788:	3d a0 ff fa 	lis     r13,-6
fffa078c:	61 ad 76 20 	ori     r13,r13,30240
fffa0790:	3c 20 ff fa 	lis     r1,-6
fffa0794:	60 21 c1 17 	ori     r1,r1,49431
fffa0798:	54 21 00 38 	rlwinm  r1,r1,0,0,28
fffa079c:	94 61 ff f8 	stwu    r3,-8(r1)
fffa07a0:	7c 70 43 a6 	mtsprg  0,r3
fffa07a4:	3c 60 01 80 	lis     r3,384
fffa07a8:	60 63 00 04 	ori     r3,r3,4
fffa07ac:	7c 74 4b a6 	mtspr   308,r3
fffa07b0:	38 60 00 00 	li      r3,0
fffa07b4:	7c 7c 4b a6 	mtspr   316,r3
fffa07b8:	3c 60 00 82 	lis     r3,130
fffa07bc:	60 63 18 00 	ori     r3,r3,6144
fffa07c0:	7c 60 01 24 	mtmsr   r3
fffa07c4:	7c 00 04 ac 	sync    
fffa07c8:	48 00 00 c1 	bl      fffa0888 <__ppe42_system_setup>
fffa07cc:	38 60 00 00 	li      r3,0
fffa07d0:	3c 80 00 00 	lis     r4,0
fffa07d4:	60 84 00 00 	ori     r4,r4,0
fffa07d8:	48 00 03 41 	bl      fffa0b18 <__pk_main>
fffa07dc:	4b ff f9 b8 	b       fffa0194 <__pk_idle_thread_from_bootloader>

fffa07e0 <__pk_schedule_hardware_timeout>:
{
    PkTimebase       now;
    uint32_t         new_dec;
    uint32_t         dec;

    if (timeout != PK_TIMEBASE_MAX)
fffa07e0:	2c 03 ff ff 	cmpwi   r3,-1
// in the future in accordance with the PK specification.

#ifndef APPCFG_USE_EXT_TIMEBASE
void
__pk_schedule_hardware_timeout(PkTimebase timeout)
{
fffa07e4:	94 21 ff f0 	stwu    r1,-16(r1)
fffa07e8:	7c 08 02 a6 	mflr    r0
fffa07ec:	1b c1 00 08 	stvd    d30,8(r1)
fffa07f0:	90 01 00 14 	stw     r0,20(r1)
fffa07f4:	7c 9f 23 78 	mr      r31,r4
fffa07f8:	7c 7e 1b 78 	mr      r30,r3
    PkTimebase       now;
    uint32_t         new_dec;
    uint32_t         dec;

    if (timeout != PK_TIMEBASE_MAX)
fffa07fc:	40 a2 00 0c 	bne     fffa0808 <__pk_schedule_hardware_timeout+0x28>
fffa0800:	2c 04 ff ff 	cmpwi   r4,-1
fffa0804:	41 82 00 70 	beq     fffa0874 <__pk_schedule_hardware_timeout+0x94>
    {

        now = pk_timebase_get();
fffa0808:	48 00 01 19 	bl      fffa0920 <pk_timebase_get>

        if (timeout <= now)
fffa080c:	05 be 18 06 	cmplwbgt r30,r3,fffa0818 <__pk_schedule_hardware_timeout+0x38>
fffa0810:	04 5e 18 12 	cmpwbne r30,r3,fffa0834 <__pk_schedule_hardware_timeout+0x54>
fffa0814:	05 3f 20 10 	cmplwble r31,r4,fffa0834 <__pk_schedule_hardware_timeout+0x54>
        {
            new_dec = 1;
        }
        else if ((timeout - now) > 0xffff0000)
fffa0818:	7d 24 f8 10 	subfc   r9,r4,r31
fffa081c:	7d 03 f1 10 	subfe   r8,r3,r30
fffa0820:	06 48 00 0e 	bwnz    r8,fffa083c <__pk_schedule_hardware_timeout+0x5c>
fffa0824:	3d 40 ff ff 	lis     r10,-1
fffa0828:	05 8a 48 0a 	cmplwblt r10,r9,fffa083c <__pk_schedule_hardware_timeout+0x5c>
        {
            new_dec = 0xffff0000;
        }
        else
        {
            new_dec = timeout - now;
fffa082c:	7d 44 f8 50 	subf    r10,r4,r31
fffa0830:	48 00 00 10 	b       fffa0840 <__pk_schedule_hardware_timeout+0x60>

        now = pk_timebase_get();

        if (timeout <= now)
        {
            new_dec = 1;
fffa0834:	39 40 00 01 	li      r10,1
fffa0838:	48 00 00 08 	b       fffa0840 <__pk_schedule_hardware_timeout+0x60>
        }
        else if ((timeout - now) > 0xffff0000)
        {
            new_dec = 0xffff0000;
fffa083c:	3d 40 ff ff 	lis     r10,-1
            new_dec = timeout - now;
        }

        //read and write the DEC back-to-back so that we lose as little time
        //as possible
        dec = mfspr(SPRN_DEC);
fffa0840:	7c f6 02 a6 	mfdec   r7
        mtspr(SPRN_DEC, new_dec);
fffa0844:	7d 56 03 a6 	mtdec   r10

        //update our 64bit accumulator with how much time has advanced since
        //we last changed it.
        ppe42_64bit_timebase += ppe42_tb_data.dec_start - dec;
fffa0848:	80 cd 46 d0 	lwz     r6,18128(r13)
fffa084c:	39 00 00 00 	li      r8,0
fffa0850:	7d 27 30 50 	subf    r9,r7,r6
fffa0854:	14 cd 46 d8 	lvd     d6,18136(r13)

        //update our start time so we know how much time has advanced since
        //this update of the accumulator
        ppe42_tb_data.dec_start = new_dec;
fffa0858:	91 4d 46 d0 	stw     r10,18128(r13)
        dec = mfspr(SPRN_DEC);
        mtspr(SPRN_DEC, new_dec);

        //update our 64bit accumulator with how much time has advanced since
        //we last changed it.
        ppe42_64bit_timebase += ppe42_tb_data.dec_start - dec;
fffa085c:	7d 29 38 14 	addc    r9,r9,r7
fffa0860:	7d 08 31 14 	adde    r8,r8,r6
fffa0864:	19 0d 46 d8 	stvd    d8,18136(r13)

        //update our start time so we know how much time has advanced since
        //this update of the accumulator
        ppe42_tb_data.dec_start = new_dec;
        ppe42_tb_data.dec_change_tag++;
fffa0868:	81 2d 46 d4 	lwz     r9,18132(r13)
fffa086c:	39 29 00 01 	addi    r9,r9,1
fffa0870:	91 2d 46 d4 	stw     r9,18132(r13)
    }
}
fffa0874:	80 01 00 14 	lwz     r0,20(r1)
fffa0878:	17 c1 00 08 	lvd     d30,8(r1)
fffa087c:	7c 08 03 a6 	mtlr    r0
fffa0880:	38 21 00 10 	addi    r1,r1,16
fffa0884:	4e 80 00 20 	blr

fffa0888 <__ppe42_system_setup>:
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
fffa0888:	39 00 00 40 	li      r8,64
fffa088c:	7d 09 03 a6 	mtctr   r8
fffa0890:	3d 20 ff fa 	lis     r9,-6
void __hwmacro_setup(void);


void
__ppe42_system_setup()
{
fffa0894:	39 40 00 00 	li      r10,0
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
fffa0898:	39 29 03 a4 	addi    r9,r9,932
fffa089c:	39 0d 00 58 	addi    r8,r13,88
fffa08a0:	7d 28 51 2e 	stwx    r9,r8,r10
fffa08a4:	39 4a 00 08 	addi    r10,r10,8
    //Only do this if the application hasn't provided a static table definition
#ifndef STATIC_IRQ_TABLE
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
fffa08a8:	42 00 ff f4 	bdnz    fffa089c <__ppe42_system_setup+0x14>
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
    }

    //NOTE: EXTERNAL_IRQS is the phantom interrupt assigned irq
    __ppe42_irq_handlers[irq].handler = __ppe42_phantom_irq_handler;
fffa08ac:	3d 40 ff fa 	lis     r10,-6
fffa08b0:	39 4a 03 ac 	addi    r10,r10,940
fffa08b4:	91 48 02 00 	stw     r10,512(r8)

#endif /*STATIC_IRQ_TABLE*/
    // Initialize special interrupt handlers

    __ppe42_fit_routine = __ppe42_default_irq_handler;
    __ppe42_fit_arg = 0;
fffa08b8:	39 40 00 00 	li      r10,0
    __ppe42_irq_handlers[irq].handler = __ppe42_phantom_irq_handler;

#endif /*STATIC_IRQ_TABLE*/
    // Initialize special interrupt handlers

    __ppe42_fit_routine = __ppe42_default_irq_handler;
fffa08bc:	91 2d 46 cc 	stw     r9,18124(r13)
    __ppe42_fit_arg = 0;
fffa08c0:	91 4d 46 c0 	stw     r10,18112(r13)

    __ppe42_watchdog_routine = __ppe42_default_irq_handler;
fffa08c4:	91 2d 46 c8 	stw     r9,18120(r13)
    __ppe42_watchdog_arg = 0;
fffa08c8:	91 4d 46 c4 	stw     r10,18116(r13)

    //Clear all status bits in the TSR
    mtspr(SPRN_TSR, TSR_ENW | TSR_WIS | TSR_DIS | TSR_FIS);
fffa08cc:	3d 20 cc 00 	lis     r9,-13312
fffa08d0:	7d 30 53 a6 	mtspr   336,r9
#ifdef APPCFG_USE_EXT_TIMEBASE
    //Enable the DEC interrupt and configure it to use the external dec_timer signal
    mtspr(SPRN_TCR, TCR_DIE | TCR_DS);
#else
    //Enable the DEC interrupt and configure it to use the internal clock signal
    mtspr(SPRN_TCR, TCR_DIE);
fffa08d4:	3d 20 04 00 	lis     r9,1024
fffa08d8:	7d 34 53 a6 	mtspr   340,r9

#if PK_TIMER_SUPPORT
#if PK_TRACE_SUPPORT
    extern PkTraceBuffer g_pk_trace_buf;
    //set the ppe instance id
    g_pk_trace_buf.instance_id = (uint16_t)(mfspr(SPRN_PIR) & PIR_PPE_INSTANCE_MASK);
fffa08dc:	7d 3e 42 a6 	mfspr   r9,286
fffa08e0:	39 4d 03 40 	addi    r10,r13,832
fffa08e4:	55 29 06 fe 	clrlwi  r9,r9,27
fffa08e8:	b1 2a 00 14 	sth     r9,20(r10)
#endif  /* PK_TRACE_SUPPORT */
#endif  /* PK_TIMER_SUPPORT */

    //call macro-specific setup
    __hwmacro_setup();
fffa08ec:	48 00 00 58 	b       fffa0944 <__hwmacro_setup>
	...

fffa0900 <pk_timebase32_get>:
fffa0900:	14 8d 46 d0 	lvd     d4,18128(r13)
fffa0904:	80 6d 46 dc 	lwz     r3,18140(r13)
fffa0908:	7c 16 02 a6 	mfdec   r0
fffa090c:	80 cd 46 d4 	lwz     r6,18132(r13)
fffa0910:	05 45 37 f8 	cmplwbne r5,r6,fffa0900 <pk_timebase32_get>
fffa0914:	7c a0 20 50 	subf    r5,r0,r4
fffa0918:	7c 65 1a 14 	add     r3,r5,r3
fffa091c:	4e 80 00 20 	blr

fffa0920 <pk_timebase_get>:
fffa0920:	14 ad 46 d0 	lvd     d5,18128(r13)
fffa0924:	14 6d 46 d8 	lvd     d3,18136(r13)
fffa0928:	7c 16 02 a6 	mfdec   r0
fffa092c:	80 ed 46 d4 	lwz     r7,18132(r13)
fffa0930:	05 46 3f f8 	cmplwbne r6,r7,fffa0920 <pk_timebase_get>
fffa0934:	7c c0 28 50 	subf    r6,r0,r5
fffa0938:	7c 86 20 14 	addc    r4,r6,r4
fffa093c:	7c 63 01 94 	addze   r3,r3
fffa0940:	4e 80 00 20 	blr

fffa0944 <__hwmacro_setup>:

void
__hwmacro_setup(void)
{
    //mask all interrupts to prevent spurious pulse to PPE
    out64(STD_LCL_EIMR, 0xffffffffffffffffull);
fffa0944:	3d 40 c0 00 	lis     r10,-16384
fffa0948:	39 00 ff ff 	li      r8,-1
fffa094c:	39 20 ff ff 	li      r9,-1
fffa0950:	61 4a 00 20 	ori     r10,r10,32
fffa0954:	19 0a 00 00 	stvd    d8,0(r10)

    //set up the configured polarity
    out64(STD_LCL_EIPR, g_ext_irqs_polarity);
fffa0958:	15 0d 00 40 	lvd     d8,64(r13)
fffa095c:	39 4a 00 20 	addi    r10,r10,32
fffa0960:	19 0a 00 00 	stvd    d8,0(r10)

    //set up the configured type
    out64(STD_LCL_EITR, g_ext_irqs_type);
fffa0964:	15 0d 00 48 	lvd     d8,72(r13)
fffa0968:	39 4a 00 20 	addi    r10,r10,32
fffa096c:	19 0a 00 00 	stvd    d8,0(r10)

    //clear the status of all edge interrupts
    out64(STD_LCL_EISR_CLR, g_ext_irqs_type);
fffa0970:	15 0d 00 48 	lvd     d8,72(r13)
fffa0974:	39 4a ff b8 	addi    r10,r10,-72
fffa0978:	19 0a 00 00 	stvd    d8,0(r10)

    //unmask the interrupts that are to be enabled by default
    out64(STD_LCL_EIMR_CLR, g_ext_irqs_enable);
fffa097c:	15 0d 00 50 	lvd     d8,80(r13)
fffa0980:	19 0a 00 20 	stvd    d8,32(r10)

    //wait for the last operation to complete
    sync();
fffa0984:	7c 00 04 ac 	sync    
fffa0988:	4e 80 00 20 	blr

fffa098c <pk_set_timebase_rshift>:
uint8_t  __pk_timebase_rshift = 32;

void pk_set_timebase_rshift(uint32_t timebase_freq_hz)
{
    //Use 1.0 scale if less than or equal to 1.0625 * base frequency
    if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 4)))
fffa098c:	3d 40 19 54 	lis     r10,6484
fffa0990:	61 4a fc 40 	ori     r10,r10,64576
fffa0994:	3d 20 ff fa 	lis     r9,-6
fffa0998:	05 a3 50 06 	cmplwbgt r3,r10,fffa09a4 <pk_set_timebase_rshift+0x18>
    {
        __pk_timebase_rshift = 32;
fffa099c:	39 40 00 20 	li      r10,32
fffa09a0:	48 00 00 44 	b       fffa09e4 <pk_set_timebase_rshift+0x58>
    }

    //use 1.125 scale if between 1.0625 and 1.1875 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 4) + (PK_BASE_FREQ_HZ >> 3)))
fffa09a4:	3d 40 1c 4f 	lis     r10,7247
fffa09a8:	61 4a ec c0 	ori     r10,r10,60608
fffa09ac:	05 a3 50 06 	cmplwbgt r3,r10,fffa09b8 <pk_set_timebase_rshift+0x2c>
    {
        __pk_timebase_rshift = 3;
fffa09b0:	39 40 00 03 	li      r10,3
fffa09b4:	48 00 00 30 	b       fffa09e4 <pk_set_timebase_rshift+0x58>
    }

    //use 1.25 scale if between 1,1875 and 1.375 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 3) + (PK_BASE_FREQ_HZ >> 2)))
fffa09b8:	3d 40 20 c8 	lis     r10,8392
fffa09bc:	61 4a 55 80 	ori     r10,r10,21888
fffa09c0:	05 a3 50 06 	cmplwbgt r3,r10,fffa09cc <pk_set_timebase_rshift+0x40>
    {
        __pk_timebase_rshift = 2;
fffa09c4:	39 40 00 02 	li      r10,2
fffa09c8:	48 00 00 1c 	b       fffa09e4 <pk_set_timebase_rshift+0x58>
    }
    //use 1.5 scale if between 1.375 and 1.75 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 2) + (PK_BASE_FREQ_HZ >> 1)))
fffa09cc:	3d 40 29 b9 	lis     r10,10681
fffa09d0:	61 4a 27 00 	ori     r10,r10,9984
fffa09d4:	05 a3 50 06 	cmplwbgt r3,r10,fffa09e0 <pk_set_timebase_rshift+0x54>
    {
        __pk_timebase_rshift = 1;
fffa09d8:	39 40 00 01 	li      r10,1
fffa09dc:	48 00 00 08 	b       fffa09e4 <pk_set_timebase_rshift+0x58>
    }
    //use 2.0 scale if greater than 1.75 * base frequency
    else
    {
        __pk_timebase_rshift = 0;
fffa09e0:	39 40 00 00 	li      r10,0
fffa09e4:	99 49 76 20 	stb     r10,30240(r9)
fffa09e8:	4e 80 00 20 	blr

fffa09ec <pk_initialize>:
int
pk_initialize(PkAddress     kernel_stack,
              size_t       kernel_stack_size,
              PkTimebase   initial_timebase,
              uint32_t     timebase_frequency_hz)
{
fffa09ec:	94 21 ff d8 	stwu    r1,-40(r1)
fffa09f0:	7c 08 02 a6 	mflr    r0
fffa09f4:	1b 81 00 18 	stvd    d28,24(r1)
fffa09f8:	90 01 00 2c 	stw     r0,44(r1)
fffa09fc:	1b c1 00 20 	stvd    d30,32(r1)
fffa0a00:	18 61 00 08 	stvd    d3,8(r1)
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((kernel_stack == 0) ||
fffa0a04:	06 c3 00 7c 	bwz     r3,fffa0afc <pk_initialize+0x110>
fffa0a08:	38 60 fd e2 	li      r3,-542
fffa0a0c:	06 c4 00 7a 	bwz     r4,fffa0b00 <pk_initialize+0x114>
                    (kernel_stack_size == 0),
                    PK_INVALID_ARGUMENT_INIT);
    }

    __pk_timebase_frequency_hz = timebase_frequency_hz;
fffa0a10:	3d 20 ff fa 	lis     r9,-6
fffa0a14:	90 e9 76 24 	stw     r7,30244(r9)

    __pk_thread_machine_context_default = PK_THREAD_MACHINE_CONTEXT_DEFAULT;
fffa0a18:	3d 20 00 82 	lis     r9,130
fffa0a1c:	61 29 98 00 	ori     r9,r9,38912

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);
fffa0a20:	7c e3 3b 78 	mr      r3,r7
fffa0a24:	7c ff 3b 78 	mr      r31,r7
fffa0a28:	7c de 33 78 	mr      r30,r6
fffa0a2c:	7c bd 2b 78 	mr      r29,r5
                    PK_INVALID_ARGUMENT_INIT);
    }

    __pk_timebase_frequency_hz = timebase_frequency_hz;

    __pk_thread_machine_context_default = PK_THREAD_MACHINE_CONTEXT_DEFAULT;
fffa0a30:	91 2d 03 08 	stw     r9,776(r13)

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);
fffa0a34:	4b ff ff 59 	bl      fffa098c <pk_set_timebase_rshift>

    __pk_kernel_stack_limit = kernel_stack;
fffa0a38:	81 21 00 08 	lwz     r9,8(r1)

    rc = __pk_stack_init(&kernel_stack, &kernel_stack_size);
fffa0a3c:	38 61 00 08 	addi    r3,r1,8
fffa0a40:	38 81 00 0c 	addi    r4,r1,12

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);

    __pk_kernel_stack_limit = kernel_stack;
fffa0a44:	91 2d 03 20 	stw     r9,800(r13)

    rc = __pk_stack_init(&kernel_stack, &kernel_stack_size);
fffa0a48:	48 00 00 d5 	bl      fffa0b1c <__pk_stack_init>
fffa0a4c:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fffa0a50:	06 5c 00 58 	bwnz    r28,fffa0b00 <pk_initialize+0x114>
    {
        return rc;
    }

    __pk_kernel_stack = kernel_stack;
fffa0a54:	81 21 00 08 	lwz     r9,8(r1)
fffa0a58:	91 2d 03 24 	stw     r9,804(r13)
    __pk_kernel_stack_size = kernel_stack_size;
fffa0a5c:	81 21 00 0c 	lwz     r9,12(r1)
fffa0a60:	91 2d 03 04 	stw     r9,772(r13)
#if PK_TIMER_SUPPORT

    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
fffa0a64:	39 2d 02 68 	addi    r9,r13,616
fffa0a68:	7d 23 4b 78 	mr      r3,r9
fffa0a6c:	91 21 00 10 	stw     r9,16(r1)
fffa0a70:	4b ff f9 9d 	bl      fffa040c <pk_deque_sentinel_create>
    __pk_time_queue.cursor = 0;
fffa0a74:	81 21 00 10 	lwz     r9,16(r1)
    __pk_time_queue.next_timeout = PK_TIMEBASE_MAX;
fffa0a78:	39 00 ff ff 	li      r8,-1

    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
    __pk_time_queue.cursor = 0;
fffa0a7c:	93 89 00 10 	stw     r28,16(r9)

#endif  /* PK_TIMER_SUPPORT (timed callback)*/

#if PK_TRACE_SUPPORT
    //set the trace timebase HZ
    pk_trace_set_freq(timebase_frequency_hz);
fffa0a80:	7f e3 fb 78 	mr      r3,r31
    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
    __pk_time_queue.cursor = 0;
    __pk_time_queue.next_timeout = PK_TIMEBASE_MAX;
fffa0a84:	39 20 ff ff 	li      r9,-1
fffa0a88:	19 0d 02 70 	stvd    d8,624(r13)

#endif  /* PK_TIMER_SUPPORT (timed callback)*/

#if PK_TRACE_SUPPORT
    //set the trace timebase HZ
    pk_trace_set_freq(timebase_frequency_hz);
fffa0a8c:	4b ff fc e1 	bl      fffa076c <pk_trace_set_freq>

    if(initial_timebase != PK_TIMEBASE_CONTINUES)
fffa0a90:	2c 1d ff ff 	cmpwi   r29,-1
fffa0a94:	40 82 00 0c 	bne     fffa0aa0 <pk_initialize+0xb4>
fffa0a98:	2c 1e ff ff 	cmpwi   r30,-1
fffa0a9c:	41 82 00 10 	beq     fffa0aac <pk_initialize+0xc0>
    {
        //set the timebase ajdustment for trace synchronization
        pk_trace_set_timebase(initial_timebase);
fffa0aa0:	7f a3 eb 78 	mr      r3,r29
fffa0aa4:	7f c4 f3 78 	mr      r4,r30
fffa0aa8:	4b ff fc 85 	bl      fffa072c <pk_trace_set_timebase>
    }

    // Schedule the timer that puts a 64bit timestamp in the trace buffer
    // periodically.  This allows us to use 32bit timestamps.
    pk_timer_schedule(&g_pk_trace_timer,
fffa0aac:	3c c0 fc 46 	lis     r6,-954
fffa0ab0:	38 6d 13 78 	addi    r3,r13,4984
fffa0ab4:	38 a0 00 00 	li      r5,0
fffa0ab8:	60 c6 53 5f 	ori     r6,r6,21343
fffa0abc:	4b ff fb 75 	bl      fffa0630 <pk_timer_schedule>

    int i;

    for (i = 0; i <= PK_THREADS; i++)
    {
        __pk_priority_map[i] = 0;
fffa0ac0:	39 20 00 21 	li      r9,33
fffa0ac4:	7d 29 03 a6 	mtctr   r9
        pk_trace_set_timebase(initial_timebase);
    }

    // Schedule the timer that puts a 64bit timestamp in the trace buffer
    // periodically.  This allows us to use 32bit timestamps.
    pk_timer_schedule(&g_pk_trace_timer,
fffa0ac8:	39 40 00 00 	li      r10,0

    int i;

    for (i = 0; i <= PK_THREADS; i++)
    {
        __pk_priority_map[i] = 0;
fffa0acc:	38 e0 00 00 	li      r7,0
fffa0ad0:	39 0d 02 80 	addi    r8,r13,640
fffa0ad4:	7c e8 51 2e 	stwx    r7,r8,r10
fffa0ad8:	39 20 00 00 	li      r9,0
fffa0adc:	39 4a 00 04 	addi    r10,r10,4
    // Clear the priority map. The final entry [PK_THREADS] is for the idle
    // thread.

    int i;

    for (i = 0; i <= PK_THREADS; i++)
fffa0ae0:	42 00 ff f0 	bdnz    fffa0ad0 <pk_initialize+0xe4>
// cntlzw().

static inline void
__pk_thread_queue_clear(volatile PkThreadQueue* queue)
{
*queue = 0;
fffa0ae4:	91 2d 03 1c 	stw     r9,796(r13)
    }

    // Initialize the thread scheduler

    __pk_thread_queue_clear(&__pk_run_queue);
    __pk_current_thread = 0;
fffa0ae8:	91 2d 03 14 	stw     r9,788(r13)
    __pk_next_thread    = 0;
fffa0aec:	91 2d 03 10 	stw     r9,784(r13)
    __pk_delayed_switch = 0;
fffa0af0:	91 2d 03 18 	stw     r9,792(r13)

#endif  /* PK_THREAD_SUPPORT */

    return PK_OK;
fffa0af4:	38 60 00 00 	li      r3,0
fffa0af8:	48 00 00 08 	b       fffa0b00 <pk_initialize+0x114>
{
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((kernel_stack == 0) ||
fffa0afc:	38 60 fd e2 	li      r3,-542
    __pk_delayed_switch = 0;

#endif  /* PK_THREAD_SUPPORT */

    return PK_OK;
}
fffa0b00:	80 01 00 2c 	lwz     r0,44(r1)
fffa0b04:	17 81 00 18 	lvd     d28,24(r1)
fffa0b08:	7c 08 03 a6 	mtlr    r0
fffa0b0c:	17 c1 00 20 	lvd     d30,32(r1)
fffa0b10:	38 21 00 28 	addi    r1,r1,40
fffa0b14:	4e 80 00 20 	blr

fffa0b18 <__pk_main>:
__pk_main(int argc, char** argv)
{
    PK_MAIN_HOOK;

    int main(int argc, char** argv);
    main(argc, argv);
fffa0b18:	48 00 01 54 	b       fffa0c6c <main>

fffa0b1c <__pk_stack_init>:
        // stacks, otherwise the initial address is first brought into range
        // before alignment.  The stack is aligned downward, then the size is
        // adjusted to a multiple of the stack type.  Stacks are optionally
        // prepatterned. Alignment is assumed to be a power of 2.

        *stack += *size;
fffa0b1c:	81 24 00 00 	lwz     r9,0(r4)
fffa0b20:	81 43 00 00 	lwz     r10,0(r3)

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fffa0b24:	3c e0 03 ab 	lis     r7,939
        // stacks, otherwise the initial address is first brought into range
        // before alignment.  The stack is aligned downward, then the size is
        // adjusted to a multiple of the stack type.  Stacks are optionally
        // prepatterned. Alignment is assumed to be a power of 2.

        *stack += *size;
fffa0b28:	7d 49 52 14 	add     r10,r9,r10
            *stack -= sizeof(PK_STACK_TYPE);
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
fffa0b2c:	55 48 07 7e 	clrlwi  r8,r10,29
        *stack -= excess;
        *size -= excess;
fffa0b30:	7d 28 48 50 	subf    r9,r8,r9
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
        *stack -= excess;
fffa0b34:	7d 48 50 50 	subf    r10,r8,r10
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);
fffa0b38:	55 29 00 3a 	rlwinm  r9,r9,0,0,29
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
        *stack -= excess;
fffa0b3c:	91 43 00 00 	stw     r10,0(r3)
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);
fffa0b40:	91 24 00 00 	stw     r9,0(r4)

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fffa0b44:	55 29 f0 be 	rlwinm  r9,r9,30,2,31
fffa0b48:	39 29 00 01 	addi    r9,r9,1
fffa0b4c:	7d 29 03 a6 	mtctr   r9
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);

        if (PK_STACK_CHECK)
        {
            p = (PK_STACK_TYPE*)(*stack);
fffa0b50:	7d 48 53 78 	mr      r8,r10

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fffa0b54:	60 e7 cd ef 	ori     r7,r7,52719
        if (PK_STACK_CHECK)
        {
            p = (PK_STACK_TYPE*)(*stack);
            count = *size / sizeof(PK_STACK_TYPE);

            for (i = 0; i < count; i++)
fffa0b58:	42 40 00 0c 	bdz     fffa0b64 <__pk_stack_init+0x48>
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fffa0b5c:	94 e8 ff fc 	stwu    r7,-4(r8)
fffa0b60:	4b ff ff f8 	b       fffa0b58 <__pk_stack_init+0x3c>
/// behind the SP are for the initial subroutine's LR.

static inline void
__pk_stack_create_initial_frame(PkAddress* stack, size_t* size)
{
*stack -= 8;
fffa0b64:	39 2a ff f8 	addi    r9,r10,-8
fffa0b68:	91 23 00 00 	stw     r9,0(r3)
* size -= 8;
fffa0b6c:	81 24 00 00 	lwz     r9,0(r4)

        PK_PANIC(PK_UNIMPLEMENTED);
    }

    return PK_OK;
}
fffa0b70:	38 60 00 00 	li      r3,0
fffa0b74:	39 29 ff f8 	addi    r9,r9,-8
fffa0b78:	91 24 00 00 	stw     r9,0(r4)
* ((PK_STACK_TYPE*)(*stack)) = 0;
fffa0b7c:	39 20 00 00 	li      r9,0
fffa0b80:	91 2a ff f8 	stw     r9,-8(r10)
fffa0b84:	4e 80 00 20 	blr

fffa0b88 <__sbe_register_saveoff>:

#include "sbeirq.H"

extern "C" void __sbe_register_saveoff()
{
    asm("b pk_halt\n");
fffa0b88:	4b ff f6 1c 	b       fffa01a4 <pk_halt>
fffa0b8c:	4e 80 00 20 	blr

fffa0b90 <__sbe_machine_check_handler>:
}

extern "C" void __sbe_machine_check_handler()
{
    asm("b pk_halt\n");
fffa0b90:	4b ff f6 14 	b       fffa01a4 <pk_halt>
fffa0b94:	4e 80 00 20 	blr

fffa0b98 <__eabi>:
void __eabi()
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
fffa0b98:	39 2d 13 98 	addi    r9,r13,5016
        while ( startAddr != &_sbss_end )
fffa0b9c:	39 4d 46 f8 	addi    r10,r13,18168
        {
            *startAddr = 0;
fffa0ba0:	38 c0 00 00 	li      r6,0
fffa0ba4:	38 e0 00 00 	li      r7,0
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
        while ( startAddr != &_sbss_end )
fffa0ba8:	04 c9 50 08 	cmpwbeq r9,r10,fffa0bb8 <__eabi+0x20>
        {
            *startAddr = 0;
fffa0bac:	18 c9 00 00 	stvd    d6,0(r9)
            startAddr++;
fffa0bb0:	39 29 00 08 	addi    r9,r9,8
fffa0bb4:	4b ff ff f4 	b       fffa0ba8 <__eabi+0x10>
// or linker script to zero init sbss section. This way we will be future
// garded if pk  boot uses some static/global data  initialised to
// false in future.

void __eabi()
{
fffa0bb8:	94 21 ff f0 	stwu    r1,-16(r1)
fffa0bbc:	7c 08 02 a6 	mflr    r0
fffa0bc0:	1b c1 00 08 	stvd    d30,8(r1)
fffa0bc4:	90 01 00 14 	stw     r0,20(r1)
fffa0bc8:	3f e0 ff fa 	lis     r31,-6
            *startAddr = 0;
            startAddr++;
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
fffa0bcc:	3f c0 ff fa 	lis     r30,-6
fffa0bd0:	3b ff 71 20 	addi    r31,r31,28960
fffa0bd4:	3b de 71 24 	addi    r30,r30,28964
fffa0bd8:	04 df f0 0c 	cmpwbeq r31,r30,fffa0bf0 <__eabi+0x58>
        {
            (*ctors)();
fffa0bdc:	81 3f 00 00 	lwz     r9,0(r31)
            ctors++;
fffa0be0:	3b ff 00 04 	addi    r31,r31,4
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
        {
            (*ctors)();
fffa0be4:	7d 29 03 a6 	mtctr   r9
fffa0be8:	4e 80 04 21 	bctrl
fffa0bec:	4b ff ff ec 	b       fffa0bd8 <__eabi+0x40>
            ctors++;
        }
    } while (false);
}
fffa0bf0:	80 01 00 14 	lwz     r0,20(r1)
fffa0bf4:	17 c1 00 08 	lvd     d30,8(r1)
fffa0bf8:	7c 08 03 a6 	mtlr    r0
fffa0bfc:	38 21 00 10 	addi    r1,r1,16
fffa0c00:	4e 80 00 20 	blr

fffa0c04 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities>:
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
fffa0c04:	94 21 ff f0 	stwu    r1,-16(r1)
fffa0c08:	7c 08 02 a6 	mflr    r0
    rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
fffa0c0c:	55 08 06 3e 	clrlwi  r8,r8,24
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
fffa0c10:	1b c1 00 08 	stvd    d30,8(r1)
fffa0c14:	90 01 00 14 	stw     r0,20(r1)
fffa0c18:	7c 7e 1b 78 	mr      r30,r3
    rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
fffa0c1c:	48 00 2e 0d 	bl      fffa3a28 <pk_thread_create>
fffa0c20:	7c 7f 1b 78 	mr      r31,r3
    if(rc == PK_OK)
fffa0c24:	06 43 00 0a 	bwnz    r3,fffa0c38 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities+0x34>
    {
        // resume the thread once created
        rc = pk_thread_resume(io_pThread);
fffa0c28:	7f c3 f3 78 	mr      r3,r30
fffa0c2c:	48 00 2d 31 	bl      fffa395c <pk_thread_resume>
fffa0c30:	7c 7f 1b 78 	mr      r31,r3
    }

    // Check for errors creating or resuming the thread
    if(rc != PK_OK)
fffa0c34:	06 c3 00 10 	bwz     r3,fffa0c54 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities+0x50>
    {
        SBEV_ERROR ("Failure creating/resuming thread, rc=[%d]", rc);
fffa0c38:	3c 60 bf 45 	lis     r3,-16571
fffa0c3c:	60 63 00 01 	ori     r3,r3,1
fffa0c40:	7f e5 fb 78 	mr      r5,r31
fffa0c44:	38 c0 00 00 	li      r6,0
fffa0c48:	38 e0 00 00 	li      r7,0
fffa0c4c:	39 00 00 00 	li      r8,0
fffa0c50:	48 00 2f 01 	bl      fffa3b50 <pk_trace_big>
    }

    return rc;
}
fffa0c54:	80 01 00 14 	lwz     r0,20(r1)
fffa0c58:	7f e3 fb 78 	mr      r3,r31
fffa0c5c:	7c 08 03 a6 	mtlr    r0
fffa0c60:	17 c1 00 08 	lvd     d30,8(r1)
fffa0c64:	38 21 00 10 	addi    r1,r1,16
fffa0c68:	4e 80 00 20 	blr

fffa0c6c <main>:

////////////////////////////////////////////////////////////////
// @brief - main : Verification Application main
////////////////////////////////////////////////////////////////
int  main(int argc, char **argv)
{
fffa0c6c:	94 21 ff f0 	stwu    r1,-16(r1)
fffa0c70:	7c 08 02 a6 	mflr    r0
fffa0c74:	1b c1 00 08 	stvd    d30,8(r1)
fffa0c78:	90 01 00 14 	stw     r0,20(r1)
fffa0c7c:	4b ff ff 1d 	bl      fffa0b98 <__eabi>

    do
    {
        //Update IVPR
        uint64_t data = (uint64_t)i_ivprAddr << 32;
        PPE_STVD(0xc0000160, data);
fffa0c80:	3d 40 c0 00 	lis     r10,-16384
fffa0c84:	3d 00 ff fa 	lis     r8,-6
fffa0c88:	39 20 00 00 	li      r9,0
fffa0c8c:	61 4a 01 60 	ori     r10,r10,352
fffa0c90:	19 0a 00 00 	stvd    d8,0(r10)

        uint64_t loadValue = (uint64_t)(SBE_CODE_VERIFICATION_PIBMEM_MAIN_MSG)<<32;
        PPE_STVD(0x50009, loadValue);
fffa0c94:	3d 40 00 05 	lis     r10,5
fffa0c98:	39 00 00 0a 	li      r8,10
fffa0c9c:	39 20 00 00 	li      r9,0
fffa0ca0:	61 4a 00 09 	ori     r10,r10,9
fffa0ca4:	19 0a 00 00 	stvd    d8,0(r10)

        // Load the LFR, to fetch the Pib clock frequency
        PPE_LVD(0xc0002040, lfrReg);
fffa0ca8:	3d 00 c0 00 	lis     r8,-16384
fffa0cac:	61 08 20 40 	ori     r8,r8,8256
fffa0cb0:	15 08 00 00 	lvd     d8,0(r8)
fffa0cb4:	55 3f 04 3e 	clrlwi  r31,r9,16

        //Check SBE Role
        g_sbevRole = checkSbeRole();
fffa0cb8:	48 00 30 15 	bl      fffa3ccc <_Z12checkSbeRolev>
fffa0cbc:	7c 65 1b 78 	mr      r5,r3
fffa0cc0:	90 6d 46 e0 	stw     r3,18144(r13)
        SBEV_INFO(SBEV_FUNC "SBE Role is %x", g_sbevRole);
fffa0cc4:	3c 60 bd 4f 	lis     r3,-17073
fffa0cc8:	60 63 00 01 	ori     r3,r3,1
fffa0ccc:	38 c0 00 00 	li      r6,0
fffa0cd0:	38 e0 00 00 	li      r7,0
fffa0cd4:	39 00 00 00 	li      r8,0
fffa0cd8:	48 00 2e 79 	bl      fffa3b50 <pk_trace_big>

        // Check root control register3 bit25 if the PAU DPLL in bypass or not.
        // If not bypass then we use LFR frequency, if bypass then
        // use 133MHz chip frequency
        PPE_LVD(0x50013, rootCtrlReg3);
fffa0cdc:	3d 00 00 05 	lis     r8,5
fffa0ce0:	61 08 00 13 	ori     r8,r8,19
fffa0ce4:	15 08 00 00 	lvd     d8,0(r8)
            g_sbevfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to PAU Clock freq [0x%04X]", (uint16_t)lfrReg.pau_freq_in_mhz);
        }
        else
        {
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to Ref Clock");
fffa0ce8:	3c 60 4f fe 	lis     r3,20478

        // Check root control register3 bit25 if the PAU DPLL in bypass or not.
        // If not bypass then we use LFR frequency, if bypass then
        // use 133MHz chip frequency
        PPE_LVD(0x50013, rootCtrlReg3);
        if(!(rootCtrlReg3 & MASK_BIT25))
fffa0cec:	07 08 c8 0c 	bb1wi   r8,25,fffa0d04 <main+0x98>
        {
            g_sbevfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
fffa0cf0:	3d 20 00 03 	lis     r9,3
fffa0cf4:	61 29 d0 90 	ori     r9,r9,53392
fffa0cf8:	7d 3f 49 d6 	mullw   r9,r31,r9
fffa0cfc:	91 2d 13 90 	stw     r9,5008(r13)
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to PAU Clock freq [0x%04X]", (uint16_t)lfrReg.pau_freq_in_mhz);
fffa0d00:	67 e3 96 22 	oris    r3,r31,38434
        }
        else
        {
            SBEV_INFO(SBEV_FUNC "PK Frequency Initialised to Ref Clock");
fffa0d04:	4b ff f9 bd 	bl      fffa06c0 <pk_trace_tiny>
        }

        rc = pk_initialize((PkAddress)verification_Kernel_NC_Int_stack,
                VERIFICATION_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbevfreqency );
fffa0d08:	3c 60 ff fb 	lis     r3,-5
fffa0d0c:	80 ed 13 90 	lwz     r7,5008(r13)
fffa0d10:	38 63 89 b8 	addi    r3,r3,-30280
fffa0d14:	38 80 02 00 	li      r4,512
fffa0d18:	38 a0 00 00 	li      r5,0
fffa0d1c:	38 c0 00 00 	li      r6,0
fffa0d20:	4b ff fc cd 	bl      fffa09ec <pk_initialize>
        if (rc)
fffa0d24:	06 c3 00 08 	bwz     r3,fffa0d34 <main+0xc8>
        {
            SBEV_ERROR(SBEV_FUNC "PK Initialization failed in Verification Image");
fffa0d28:	3c 60 5b d6 	lis     r3,23510
fffa0d2c:	4b ff f9 95 	bl      fffa06c0 <pk_trace_tiny>
            break;
fffa0d30:	48 00 00 64 	b       fffa0d94 <main+0x128>
        }
        SBEV_INFO(SBEV_FUNC "Completed PK initialization for Verification Image");
fffa0d34:	3c 60 3e 91 	lis     r3,16017
fffa0d38:	4b ff f9 89 	bl      fffa06c0 <pk_trace_tiny>
        rc = createAndResumeThreadHelper(&sbev_thread,
                sbevthreadroutine,
                (void *)0,
                (PkAddress)verificationSecureBoot_stack,
                VERIFICATION_THREAD_SECURE_BOOT_STACK_SIZE,
                THREAD_PRIORITY_5);
fffa0d3c:	3c 60 ff fb 	lis     r3,-5
fffa0d40:	3c 80 ff fa 	lis     r4,-6
fffa0d44:	3c c0 ff fb 	lis     r6,-5
fffa0d48:	38 a0 00 00 	li      r5,0
fffa0d4c:	38 63 8b b8 	addi    r3,r3,-29768
fffa0d50:	38 84 0d ac 	addi    r4,r4,3500
fffa0d54:	38 c6 8b e8 	addi    r6,r6,-29720
fffa0d58:	38 e0 30 00 	li      r7,12288
fffa0d5c:	39 00 00 05 	li      r8,5
fffa0d60:	4b ff fe a5 	bl      fffa0c04 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities>
fffa0d64:	7c 65 1b 78 	mr      r5,r3
        if (rc)
fffa0d68:	06 c3 00 10 	bwz     r3,fffa0d88 <main+0x11c>
        {
            SBEV_ERROR(SBEV_FUNC "Initialize verification secure boot thread failed with rc 0x%08X", rc);
fffa0d6c:	3c 60 46 71 	lis     r3,18033
fffa0d70:	60 63 00 01 	ori     r3,r3,1
fffa0d74:	38 c0 00 00 	li      r6,0
fffa0d78:	38 e0 00 00 	li      r7,0
fffa0d7c:	39 00 00 00 	li      r8,0
fffa0d80:	48 00 2d d1 	bl      fffa3b50 <pk_trace_big>
            break;
fffa0d84:	48 00 00 10 	b       fffa0d94 <main+0x128>
        }

        SBEV_INFO(SBEV_FUNC "sbevSecureBoot_thread thread initilised");
fffa0d88:	3c 60 50 75 	lis     r3,20597
fffa0d8c:	4b ff f9 35 	bl      fffa06c0 <pk_trace_tiny>

        pk_start_threads();
fffa0d90:	48 00 2b 95 	bl      fffa3924 <pk_start_threads>

    }while(false);

    SBEV_EXIT(SBEV_FUNC);
    return 0;
}
fffa0d94:	80 01 00 14 	lwz     r0,20(r1)
fffa0d98:	17 c1 00 08 	lvd     d30,8(r1)
fffa0d9c:	7c 08 03 a6 	mtlr    r0
fffa0da0:	38 60 00 00 	li      r3,0
fffa0da4:	38 21 00 10 	addi    r1,r1,16
fffa0da8:	4e 80 00 20 	blr

fffa0dac <_Z17sbevthreadroutinePv>:
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG15), hashData);
}

void sbevthreadroutine(void *i_pArg)
{
fffa0dac:	94 21 ff 60 	stwu    r1,-160(r1)
fffa0db0:	7c 08 02 a6 	mflr    r0
    #define SBEV_FUNC " sbevthreadroutine "
    SBEV_ENTER(SBEV_FUNC);

    SBEV_INFO("Inside verification thread");
fffa0db4:	3c 60 a2 e2 	lis     r3,-23838
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG15), hashData);
}

void sbevthreadroutine(void *i_pArg)
{
fffa0db8:	90 01 00 a4 	stw     r0,164(r1)
fffa0dbc:	1b c1 00 98 	stvd    d30,152(r1)
    #define SBEV_FUNC " sbevthreadroutine "
    SBEV_ENTER(SBEV_FUNC);

    SBEV_INFO("Inside verification thread");
fffa0dc0:	4b ff f9 01 	bl      fffa06c0 <pk_trace_tiny>
    uint32_t securitySwitch;

    //Constructor
    securitySwitchReg_PCR1()
    {
        securitySwitch = 0;
fffa0dc4:	39 20 00 00 	li      r9,0
    }status;

    //Constructor
    secureBootStatus()
    {
        statusReg = 0x00;
fffa0dc8:	39 00 00 00 	li      r8,0
fffa0dcc:	91 21 00 90 	stw     r9,144(r1)
    uint32_t isSecureHdrPassed = 0;
    uint32_t tpmRespCode = SBEM_TPM_OPERATION_SUCCESSFUL;
    int rc = 0;

    do{
        SBEV_INFO(SBEV_FUNC "Verify Secure containers");
fffa0dd0:	3c 60 b5 d7 	lis     r3,-18985
fffa0dd4:	39 20 00 00 	li      r9,0
fffa0dd8:	19 01 00 88 	stvd    d8,136(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa0ddc:	19 01 00 80 	stvd    d8,128(r1)
    SHA512truncated_t sha512Truncated;
    secureBootStatus_t secureBootStatus;
    ROM_response sbeFwSecureHdrRsp;
    ROM_response sbeHbblSecureHdrRsp;
    fapi2::buffer<uint64_t> securityReg;
    uint64_t data = 0;
fffa0de0:	19 01 00 78 	stvd    d8,120(r1)
    uint32_t isSecureHdrPassed = 0;
    uint32_t tpmRespCode = SBEM_TPM_OPERATION_SUCCESSFUL;
    int rc = 0;

    do{
        SBEV_INFO(SBEV_FUNC "Verify Secure containers");
fffa0de4:	4b ff f8 dd 	bl      fffa06c0 <pk_trace_tiny>

        SBEV_INFO(SBEV_FUNC "Verify SBE-FW secure header.");
fffa0de8:	3c 60 dd 09 	lis     r3,-8951
fffa0dec:	4b ff f8 d5 	bl      fffa06c0 <pk_trace_tiny>
        sbeFwSecureHdrRsp = verifySecureHdr(P9_XIP_SECTION_SBE_SBH_FIRMWARE, VERIFY_HW_SIG_C_SBE_FW, &sbeFwSecureHdrResponse);
fffa0df0:	38 80 00 02 	li      r4,2
fffa0df4:	38 a1 00 08 	addi    r5,r1,8
fffa0df8:	38 60 00 13 	li      r3,19
fffa0dfc:	48 00 10 39 	bl      fffa1e34 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse>
fffa0e00:	7c 7f 1b 78 	mr      r31,r3
        SBEV_INFO(SBEV_FUNC "Completed SBE-FW secure header verification. Response: [0x%08x] Status: [0x%02x]",
            sbeFwSecureHdrRsp, sbeFwSecureHdrResponse.statusCode);
fffa0e04:	88 c1 00 2c 	lbz     r6,44(r1)
fffa0e08:	3c 60 77 80 	lis     r3,30592
fffa0e0c:	60 63 00 02 	ori     r3,r3,2
fffa0e10:	7f e5 fb 78 	mr      r5,r31
fffa0e14:	38 e0 00 00 	li      r7,0
fffa0e18:	39 00 00 00 	li      r8,0
fffa0e1c:	48 00 2d 35 	bl      fffa3b50 <pk_trace_big>

        uint64_t loadValue = (uint64_t)(SBE_CODE_VERIFICATION_SBEFW_SECURE_HDR_DONE)<<32;
        PPE_STVD(0x50009, loadValue);
fffa0e20:	3d 40 00 05 	lis     r10,5
fffa0e24:	39 00 00 0b 	li      r8,11
fffa0e28:	39 20 00 00 	li      r9,0
fffa0e2c:	61 4a 00 09 	ori     r10,r10,9
fffa0e30:	19 0a 00 00 	stvd    d8,0(r10)

        if( sbeFwSecureHdrRsp == ROM_DONE )
fffa0e34:	06 5f 00 22 	bwnz    r31,fffa0e78 <_Z17sbevthreadroutinePv+0xcc>
        {
            isSecureHdrPassed = 1;
            SBEV_INFO(SBEV_FUNC "Prefix header flag in SBE_FW secure container [0x%08x]", sbeFwSecureHdrResponse.flag);
fffa0e38:	80 a1 00 28 	lwz     r5,40(r1)
fffa0e3c:	3c 60 a5 e9 	lis     r3,-23063
fffa0e40:	60 63 00 01 	ori     r3,r3,1
fffa0e44:	38 c0 00 00 	li      r6,0
fffa0e48:	38 e0 00 00 	li      r7,0
fffa0e4c:	39 00 00 00 	li      r8,0
fffa0e50:	48 00 2d 01 	bl      fffa3b50 <pk_trace_big>
            SBEV_INFO(SBEV_FUNC "Completed SBE_FW secure header verification. Response:[0x%08x] Status:[0x%02x]",
                sbeFwSecureHdrRsp, sbeFwSecureHdrResponse.statusCode);
fffa0e54:	3c 60 37 73 	lis     r3,14195
fffa0e58:	88 c1 00 2c 	lbz     r6,44(r1)
fffa0e5c:	60 63 00 02 	ori     r3,r3,2
fffa0e60:	38 a0 00 00 	li      r5,0
fffa0e64:	38 e0 00 00 	li      r7,0
fffa0e68:	39 00 00 00 	li      r8,0
fffa0e6c:	48 00 2c e5 	bl      fffa3b50 <pk_trace_big>
        uint64_t loadValue = (uint64_t)(SBE_CODE_VERIFICATION_SBEFW_SECURE_HDR_DONE)<<32;
        PPE_STVD(0x50009, loadValue);

        if( sbeFwSecureHdrRsp == ROM_DONE )
        {
            isSecureHdrPassed = 1;
fffa0e70:	38 60 00 01 	li      r3,1
fffa0e74:	48 00 00 14 	b       fffa0e88 <_Z17sbevthreadroutinePv+0xdc>
                sbeFwSecureHdrRsp, sbeFwSecureHdrResponse.statusCode);
        }
        else
        {
            isSecureHdrPassed = 0;
            SBEV_ERROR(SBEV_FUNC "SBE_FW Secure Header Verification Failed. Response:[0x%08x] Status:[0x%02x]"
fffa0e78:	88 61 00 2c 	lbz     r3,44(r1)
fffa0e7c:	64 63 65 e6 	oris    r3,r3,26086
fffa0e80:	4b ff f8 41 	bl      fffa06c0 <pk_trace_tiny>
            SBEV_INFO(SBEV_FUNC "Completed SBE_FW secure header verification. Response:[0x%08x] Status:[0x%02x]",
                sbeFwSecureHdrRsp, sbeFwSecureHdrResponse.statusCode);
        }
        else
        {
            isSecureHdrPassed = 0;
fffa0e84:	38 60 00 00 	li      r3,0
            SBEV_ERROR(SBEV_FUNC "SBE_FW Secure Header Verification Failed. Response:[0x%08x] Status:[0x%02x]"
                sbeFwSecureHdrRsp, sbeFwSecureHdrResponse.statusCode);
        }
        sbevSetSecureAccessBit(isSecureHdrPassed, sbeFwSecureHdrResponse.flag);
fffa0e88:	80 81 00 28 	lwz     r4,40(r1)
fffa0e8c:	48 00 11 d1 	bl      fffa205c <_Z22sbevSetSecureAccessBitmm>

        SBEV_INFO(SBEV_FUNC "Verify HBBL secure header.");
fffa0e90:	3c 60 9d 41 	lis     r3,-25279
fffa0e94:	4b ff f8 2d 	bl      fffa06c0 <pk_trace_tiny>
        sbeHbblSecureHdrRsp = verifySecureHdr(P9_XIP_SECTION_SBE_SBH_HBBL, VERIFY_HW_SIG_A_HBBL, &hbblSecureHdrResponse);
fffa0e98:	38 a1 00 30 	addi    r5,r1,48
fffa0e9c:	38 60 00 14 	li      r3,20
fffa0ea0:	38 80 00 00 	li      r4,0
fffa0ea4:	48 00 0f 91 	bl      fffa1e34 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse>
fffa0ea8:	7c 65 1b 78 	mr      r5,r3
fffa0eac:	88 c1 00 54 	lbz     r6,84(r1)
        if( sbeHbblSecureHdrRsp == ROM_FAILED )
fffa0eb0:	06 43 08 0a 	cmpwibne r3,1,fffa0ec4 <_Z17sbevthreadroutinePv+0x118>
        {
            SBEV_ERROR(SBEV_FUNC "HBBL Secure Header Verification Failed. Response:[0x%08x] Status:[0x%02x]"
fffa0eb4:	54 c3 06 3e 	clrlwi  r3,r6,24
fffa0eb8:	64 63 48 82 	oris    r3,r3,18562
fffa0ebc:	4b ff f8 05 	bl      fffa06c0 <pk_trace_tiny>
fffa0ec0:	48 00 00 1c 	b       fffa0edc <_Z17sbevthreadroutinePv+0x130>
                sbeHbblSecureHdrRsp, hbblSecureHdrResponse.statusCode);
        }
        else
        {
            SBEV_INFO(SBEV_FUNC "Completed HBBL secure header verification. Response:[0x%08x] Status:[0x%02x]",
                sbeHbblSecureHdrRsp, hbblSecureHdrResponse.statusCode);
fffa0ec4:	3c 60 e5 42 	lis     r3,-6846
fffa0ec8:	60 63 00 02 	ori     r3,r3,2
fffa0ecc:	54 c6 06 3e 	clrlwi  r6,r6,24
fffa0ed0:	38 e0 00 00 	li      r7,0
fffa0ed4:	39 00 00 00 	li      r8,0
fffa0ed8:	48 00 2c 79 	bl      fffa3b50 <pk_trace_big>
        }

        loadValue = (uint64_t)(SBE_CODE_VERIFICATION_HBBL_SECURE_HDR_DONE)<<32;
        PPE_STVD(0x50009, loadValue);
fffa0edc:	3d 40 00 05 	lis     r10,5
fffa0ee0:	39 00 00 0c 	li      r8,12
fffa0ee4:	39 20 00 00 	li      r9,0
fffa0ee8:	61 4a 00 09 	ori     r10,r10,9
fffa0eec:	19 0a 00 00 	stvd    d8,0(r10)

        //Update SBE-FW and HBBL secure header status into Mailbox scratch 11.
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
fffa0ef0:	3c 60 00 05 	lis     r3,5
fffa0ef4:	38 81 00 88 	addi    r4,r1,136
fffa0ef8:	60 63 01 82 	ori     r3,r3,386
fffa0efc:	48 00 27 99 	bl      fffa3694 <getscom_abs>
        secureBootStatus.status.sbeFWSecureHdrStatus = sbeFwSecureHdrResponse.statusCode;
fffa0f00:	89 21 00 2c 	lbz     r9,44(r1)
        secureBootStatus.status.hbblSecureHdrStatus = hbblSecureHdrResponse.statusCode;
        putscom_abs(MAILBOX_SCRATCH_REG_11, secureBootStatus.statusReg);
fffa0f04:	3c 60 00 05 	lis     r3,5
        loadValue = (uint64_t)(SBE_CODE_VERIFICATION_HBBL_SECURE_HDR_DONE)<<32;
        PPE_STVD(0x50009, loadValue);

        //Update SBE-FW and HBBL secure header status into Mailbox scratch 11.
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
        secureBootStatus.status.sbeFWSecureHdrStatus = sbeFwSecureHdrResponse.statusCode;
fffa0f08:	99 21 00 8b 	stb     r9,139(r1)
        secureBootStatus.status.hbblSecureHdrStatus = hbblSecureHdrResponse.statusCode;
fffa0f0c:	89 21 00 54 	lbz     r9,84(r1)
        putscom_abs(MAILBOX_SCRATCH_REG_11, secureBootStatus.statusReg);
fffa0f10:	60 63 01 82 	ori     r3,r3,386
        PPE_STVD(0x50009, loadValue);

        //Update SBE-FW and HBBL secure header status into Mailbox scratch 11.
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
        secureBootStatus.status.sbeFWSecureHdrStatus = sbeFwSecureHdrResponse.statusCode;
        secureBootStatus.status.hbblSecureHdrStatus = hbblSecureHdrResponse.statusCode;
fffa0f14:	99 21 00 8a 	stb     r9,138(r1)
extern uint32_t g_sbevRole;
extern SHA512truncated_t SHA256separator;

static void writeTruncatedSbeFwPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
fffa0f18:	3b c0 00 00 	li      r30,0

        //Update SBE-FW and HBBL secure header status into Mailbox scratch 11.
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
        secureBootStatus.status.sbeFWSecureHdrStatus = sbeFwSecureHdrResponse.statusCode;
        secureBootStatus.status.hbblSecureHdrStatus = hbblSecureHdrResponse.statusCode;
        putscom_abs(MAILBOX_SCRATCH_REG_11, secureBootStatus.statusReg);
fffa0f1c:	14 a1 00 88 	lvd     d5,136(r1)
extern uint32_t g_sbevRole;
extern SHA512truncated_t SHA256separator;

static void writeTruncatedSbeFwPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
fffa0f20:	3b e0 00 00 	li      r31,0

        //Update SBE-FW and HBBL secure header status into Mailbox scratch 11.
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
        secureBootStatus.status.sbeFWSecureHdrStatus = sbeFwSecureHdrResponse.statusCode;
        secureBootStatus.status.hbblSecureHdrStatus = hbblSecureHdrResponse.statusCode;
        putscom_abs(MAILBOX_SCRATCH_REG_11, secureBootStatus.statusReg);
fffa0f24:	48 00 27 61 	bl      fffa3684 <putscom_abs>
        SBEV_INFO("Updated SBE-FW and HBBL secure header status into Mailbox scratch 11 [0x%08x 0x%08x]",
                SBE::higher32BWord(secureBootStatus.statusReg), SBE::lower32BWord(secureBootStatus.statusReg));
fffa0f28:	14 a1 00 88 	lvd     d5,136(r1)
fffa0f2c:	3c 60 32 81 	lis     r3,12929
fffa0f30:	38 e0 00 00 	li      r7,0
fffa0f34:	39 00 00 00 	li      r8,0
fffa0f38:	60 63 00 02 	ori     r3,r3,2
fffa0f3c:	48 00 2c 15 	bl      fffa3b50 <pk_trace_big>

        //Write SBE_FW truncated payload hash into otprom register 8-11 (x10018-x1001B)
        SBEV_INFO("Writing truncated SBE_FW payload hash into otprom register 8-11 (x10018-x1001B)");
fffa0f40:	3c 60 fd 2a 	lis     r3,-726
fffa0f44:	4b ff f7 7d 	bl      fffa06c0 <pk_trace_tiny>
extern SHA512truncated_t SHA256separator;

static void writeTruncatedSbeFwPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
fffa0f48:	38 81 00 08 	addi    r4,r1,8
fffa0f4c:	38 a0 00 08 	li      r5,8
fffa0f50:	38 61 00 58 	addi    r3,r1,88
extern uint32_t g_sbevRole;
extern SHA512truncated_t SHA256separator;

static void writeTruncatedSbeFwPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
fffa0f54:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
fffa0f58:	48 00 4b 1d 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG8), hashData);
fffa0f5c:	14 a1 00 58 	lvd     d5,88(r1)
fffa0f60:	3c 60 00 01 	lis     r3,1
fffa0f64:	60 63 00 18 	ori     r3,r3,24
fffa0f68:	48 00 27 1d 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
fffa0f6c:	38 81 00 10 	addi    r4,r1,16
fffa0f70:	38 a0 00 08 	li      r5,8
fffa0f74:	38 61 00 58 	addi    r3,r1,88
static void writeTruncatedSbeFwPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG8), hashData);
    hashData = 0x00;
fffa0f78:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
fffa0f7c:	48 00 4a f9 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG9), hashData);
fffa0f80:	14 a1 00 58 	lvd     d5,88(r1)
fffa0f84:	3c 60 00 01 	lis     r3,1
fffa0f88:	60 63 00 19 	ori     r3,r3,25
fffa0f8c:	48 00 26 f9 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
fffa0f90:	38 81 00 18 	addi    r4,r1,24
fffa0f94:	38 a0 00 08 	li      r5,8
fffa0f98:	38 61 00 58 	addi    r3,r1,88
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG8), hashData);
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG9), hashData);
    hashData = 0x00;
fffa0f9c:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
fffa0fa0:	48 00 4a d5 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG10), hashData);
fffa0fa4:	14 a1 00 58 	lvd     d5,88(r1)
fffa0fa8:	3c 60 00 01 	lis     r3,1
fffa0fac:	60 63 00 1a 	ori     r3,r3,26
fffa0fb0:	48 00 26 d5 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
fffa0fb4:	38 81 00 20 	addi    r4,r1,32
fffa0fb8:	38 a0 00 08 	li      r5,8
fffa0fbc:	38 61 00 58 	addi    r3,r1,88
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG9), hashData);
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG10), hashData);
    hashData = 0x00;
fffa0fc0:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
fffa0fc4:	48 00 4a b1 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG11), hashData);
fffa0fc8:	14 a1 00 58 	lvd     d5,88(r1)
fffa0fcc:	3c 60 00 01 	lis     r3,1
fffa0fd0:	60 63 00 1b 	ori     r3,r3,27
fffa0fd4:	48 00 26 b1 	bl      fffa3684 <putscom_abs>
        //Write SBE_FW truncated payload hash into otprom register 8-11 (x10018-x1001B)
        SBEV_INFO("Writing truncated SBE_FW payload hash into otprom register 8-11 (x10018-x1001B)");
        writeTruncatedSbeFwPayloadHash(sbeFwSecureHdrResponse.sha512Truncated);

        //Write HBBL truncated payload hash into otprom register 12-15 (x1001C-x1001F)
        SBEV_INFO("Writing truncated HBBL payload hash into otprom register 12-15 (x1001C-x1001F)");
fffa0fd8:	3c 60 9d e1 	lis     r3,-25119
fffa0fdc:	4b ff f6 e5 	bl      fffa06c0 <pk_trace_tiny>
}

static void writeTruncatedHbblPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
fffa0fe0:	38 81 00 30 	addi    r4,r1,48
fffa0fe4:	38 a0 00 08 	li      r5,8
fffa0fe8:	38 61 00 58 	addi    r3,r1,88
    putscom_abs((OTPROM_MEASUREMENT_REG11), hashData);
}

static void writeTruncatedHbblPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
fffa0fec:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
fffa0ff0:	48 00 4a 85 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG12), hashData);
fffa0ff4:	14 a1 00 58 	lvd     d5,88(r1)
fffa0ff8:	3c 60 00 01 	lis     r3,1
fffa0ffc:	60 63 00 1c 	ori     r3,r3,28
fffa1000:	48 00 26 85 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
fffa1004:	38 81 00 38 	addi    r4,r1,56
fffa1008:	38 a0 00 08 	li      r5,8
fffa100c:	38 61 00 58 	addi    r3,r1,88
static void writeTruncatedHbblPayloadHash(SHA512truncated_t i_sha512Truncated)
{
    uint64_t hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG12), hashData);
    hashData = 0x00;
fffa1010:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
fffa1014:	48 00 4a 61 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG13), hashData);
fffa1018:	14 a1 00 58 	lvd     d5,88(r1)
fffa101c:	3c 60 00 01 	lis     r3,1
fffa1020:	60 63 00 1d 	ori     r3,r3,29
fffa1024:	48 00 26 61 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
fffa1028:	38 81 00 40 	addi    r4,r1,64
fffa102c:	38 a0 00 08 	li      r5,8
fffa1030:	38 61 00 58 	addi    r3,r1,88
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG12), hashData);
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG13), hashData);
    hashData = 0x00;
fffa1034:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
fffa1038:	48 00 4a 3d 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG14), hashData);
fffa103c:	14 a1 00 58 	lvd     d5,88(r1)
fffa1040:	3c 60 00 01 	lis     r3,1
fffa1044:	60 63 00 1e 	ori     r3,r3,30
fffa1048:	48 00 26 3d 	bl      fffa3684 <putscom_abs>
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
fffa104c:	38 81 00 48 	addi    r4,r1,72
fffa1050:	38 a0 00 08 	li      r5,8
fffa1054:	38 61 00 58 	addi    r3,r1,88
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG13), hashData);
    hashData = 0x00;
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 2], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG14), hashData);
    hashData = 0x00;
fffa1058:	1b c1 00 58 	stvd    d30,88(r1)
    memcpy(&hashData, &i_sha512Truncated[sizeof(uint64_t) * 3], sizeof(uint64_t));
fffa105c:	48 00 4a 19 	bl      fffa5a74 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG15), hashData);
fffa1060:	14 a1 00 58 	lvd     d5,88(r1)
fffa1064:	3c 60 00 01 	lis     r3,1
fffa1068:	60 63 00 1f 	ori     r3,r3,31
fffa106c:	48 00 26 19 	bl      fffa3684 <putscom_abs>
        SBEV_INFO("Writing truncated HBBL payload hash into otprom register 12-15 (x1001C-x1001F)");
        writeTruncatedHbblPayloadHash(hbblSecureHdrResponse.sha512Truncated);

        //Check if TPM Deconfig bit is set.(Write the updated value into otprom
        //regs and TPM)
        getscom_abs(0x10005, &securityReg());
fffa1070:	3c 60 00 01 	lis     r3,1
fffa1074:	38 81 00 80 	addi    r4,r1,128
fffa1078:	60 63 00 05 	ori     r3,r3,5
fffa107c:	48 00 26 19 	bl      fffa3694 <getscom_abs>

        //Write extendSecurityStatePCR1 into measurement register x10013
        securitySwitchReg_PCR1.update(securityReg());
fffa1080:	14 a1 00 80 	lvd     d5,128(r1)
fffa1084:	38 61 00 90 	addi    r3,r1,144
fffa1088:	48 00 0f bd 	bl      fffa2044 <_ZN22securitySwitchReg_PCR16updateEy>
        data = 0;
        memcpy(&data, (uint8_t *)&securitySwitchReg_PCR1, sizeof(securitySwitchReg_PCR1_t));
fffa108c:	38 81 00 90 	addi    r4,r1,144
fffa1090:	38 a0 00 04 	li      r5,4
fffa1094:	38 61 00 78 	addi    r3,r1,120
        //regs and TPM)
        getscom_abs(0x10005, &securityReg());

        //Write extendSecurityStatePCR1 into measurement register x10013
        securitySwitchReg_PCR1.update(securityReg());
        data = 0;
fffa1098:	1b c1 00 78 	stvd    d30,120(r1)
        memcpy(&data, (uint8_t *)&securitySwitchReg_PCR1, sizeof(securitySwitchReg_PCR1_t));
fffa109c:	48 00 49 d9 	bl      fffa5a74 <memcpy>
        SBEV_INFO("Writing securitySwitchReg_PCR1 details [0x%08X 0x%08X] into Register [0x%08X]",
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG3);
fffa10a0:	14 a1 00 78 	lvd     d5,120(r1)
fffa10a4:	3c 60 41 37 	lis     r3,16695
fffa10a8:	3c e0 00 01 	lis     r7,1
fffa10ac:	60 63 00 03 	ori     r3,r3,3
fffa10b0:	60 e7 00 13 	ori     r7,r7,19
fffa10b4:	39 00 00 00 	li      r8,0
fffa10b8:	48 00 2a 99 	bl      fffa3b50 <pk_trace_big>
        putscom_abs(OTPROM_MEASUREMENT_REG3, data);
fffa10bc:	3c 60 00 01 	lis     r3,1
fffa10c0:	14 a1 00 78 	lvd     d5,120(r1)
fffa10c4:	60 63 00 13 	ori     r3,r3,19
fffa10c8:	48 00 25 bd 	bl      fffa3684 <putscom_abs>

        //Skip if error/rc/deconfig bit set in TPM sequence.
        if( (g_sbevRole == SBE_ROLE_MASTER) && (!(securityReg.getBit<TPM_DECONFIG_BIT>())) )
fffa10cc:	81 2d 46 e0 	lwz     r9,18144(r13)
fffa10d0:	06 c9 00 06 	bwz     r9,fffa10dc <_Z17sbevthreadroutinePv+0x330>
    ROM_response sbeFwSecureHdrRsp;
    ROM_response sbeHbblSecureHdrRsp;
    fapi2::buffer<uint64_t> securityReg;
    uint64_t data = 0;
    uint32_t isSecureHdrPassed = 0;
    uint32_t tpmRespCode = SBEM_TPM_OPERATION_SUCCESSFUL;
fffa10d4:	3b e0 00 00 	li      r31,0
fffa10d8:	48 00 00 34 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
        SBEV_INFO("Writing securitySwitchReg_PCR1 details [0x%08X 0x%08X] into Register [0x%08X]",
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG3);
        putscom_abs(OTPROM_MEASUREMENT_REG3, data);

        //Skip if error/rc/deconfig bit set in TPM sequence.
        if( (g_sbevRole == SBE_ROLE_MASTER) && (!(securityReg.getBit<TPM_DECONFIG_BIT>())) )
fffa10dc:	81 21 00 80 	lwz     r9,128(r1)
fffa10e0:	07 09 67 fa 	bb1wi   r9,12,fffa10d4 <_Z17sbevthreadroutinePv+0x328>
        {
            //Extend calculated truncated hash of SBE_FW secure Hdr into PCR0
            SBEV_INFO("Extending calculated truncated hash of SBE_FW secure Hdr into PCR0");
fffa10e4:	3c 60 8d 21 	lis     r3,-29407
fffa10e8:	4b ff f5 d9 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR0, sbeFwSecureHdrResponse.sha512Truncated, sizeof(SHA512truncated_t));
fffa10ec:	38 60 00 00 	li      r3,0
fffa10f0:	38 81 00 08 	addi    r4,r1,8
fffa10f4:	38 a0 00 20 	li      r5,32
fffa10f8:	48 00 2e 5d 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa10fc:	06 c3 00 5a 	bwz     r3,fffa11b0 <_Z17sbevthreadroutinePv+0x404>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending truncated hash of SBE_FW secure Hdr into PCR0");
fffa1100:	3c 60 68 0a 	lis     r3,26634
fffa1104:	4b ff f5 bd 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SBE_FW_PAYLOAD_IMAGE_HASH_PCR0_FAILURE;
fffa1108:	3b e0 00 0d 	li      r31,13
        }

    }while(false);

    if( (g_sbevRole == SBE_ROLE_MASTER) &&
        (tpmRespCode != SBEM_TPM_OPERATION_SUCCESSFUL) &&
fffa110c:	81 2d 46 e0 	lwz     r9,18144(r13)
fffa1110:	06 49 00 40 	bwnz    r9,fffa1190 <_Z17sbevthreadroutinePv+0x3e4>
            /*************************************************TPM_EXTEND_SEPERATOR_END***************************************************/
        }

    }while(false);

    if( (g_sbevRole == SBE_ROLE_MASTER) &&
fffa1114:	06 df 00 3e 	bwz     r31,fffa1190 <_Z17sbevthreadroutinePv+0x3e4>
        (tpmRespCode != SBEM_TPM_OPERATION_SUCCESSFUL) &&
fffa1118:	81 21 00 80 	lwz     r9,128(r1)
fffa111c:	07 09 60 3a 	bb1wi   r9,12,fffa1190 <_Z17sbevthreadroutinePv+0x3e4>
        (!(securityReg.getBit<TPM_DECONFIG_BIT>())) )
    {
        SBEV_INFO(SBEV_FUNC "Setting the TPM deconfig bit");
fffa1120:	3c 60 d8 51 	lis     r3,-10159
fffa1124:	4b ff f5 9d 	bl      fffa06c0 <pk_trace_tiny>
        rc = setTPMDeconfigBit();
fffa1128:	48 00 30 79 	bl      fffa41a0 <_Z17setTPMDeconfigBitv>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa112c:	06 c3 00 10 	bwz     r3,fffa114c <_Z17sbevthreadroutinePv+0x3a0>
        {
            SBEV_ERROR(SBEV_FUNC "Failed to set the deconfig bit with rc 0x%08X", rc);
fffa1130:	3c 60 ce 9d 	lis     r3,-12643
fffa1134:	60 63 00 01 	ori     r3,r3,1
fffa1138:	38 a0 00 01 	li      r5,1
fffa113c:	38 c0 00 00 	li      r6,0
fffa1140:	38 e0 00 00 	li      r7,0
fffa1144:	39 00 00 00 	li      r8,0
fffa1148:	48 00 2a 09 	bl      fffa3b50 <pk_trace_big>
        }

        SBEV_INFO(SBEV_FUNC "Setting the TPM response code into Scratch Reg 11");
fffa114c:	3c 60 0a e7 	lis     r3,2791
fffa1150:	4b ff f5 71 	bl      fffa06c0 <pk_trace_tiny>
        getscom_abs(MAILBOX_SCRATCH_REG_11, &secureBootStatus.statusReg);
fffa1154:	3c 60 00 05 	lis     r3,5
fffa1158:	38 81 00 88 	addi    r4,r1,136
fffa115c:	60 63 01 82 	ori     r3,r3,386
fffa1160:	48 00 25 35 	bl      fffa3694 <getscom_abs>
        secureBootStatus.status.tpmStatus = (uint8_t)tpmRespCode;
fffa1164:	9b e1 00 89 	stb     r31,137(r1)
        putscom_abs(MAILBOX_SCRATCH_REG_11, secureBootStatus.statusReg);
fffa1168:	3c 60 00 05 	lis     r3,5
fffa116c:	14 a1 00 88 	lvd     d5,136(r1)
fffa1170:	60 63 01 82 	ori     r3,r3,386
fffa1174:	48 00 25 11 	bl      fffa3684 <putscom_abs>
        SBEV_INFO("Updated SBE-FW and HBBL secure header status into Mailbox scratch 11 [0x%08x 0x%08x]",
                SBE::higher32BWord(secureBootStatus.statusReg), SBE::lower32BWord(secureBootStatus.statusReg));
fffa1178:	3c 60 32 81 	lis     r3,12929
fffa117c:	14 a1 00 88 	lvd     d5,136(r1)
fffa1180:	60 63 00 02 	ori     r3,r3,2
fffa1184:	38 e0 00 00 	li      r7,0
fffa1188:	39 00 00 00 	li      r8,0
fffa118c:	48 00 29 c5 	bl      fffa3b50 <pk_trace_big>
    }
    SBEV_INFO("Jump to Boot from Verification.");
fffa1190:	3c 60 3a d9 	lis     r3,15065
fffa1194:	4b ff f5 2d 	bl      fffa06c0 <pk_trace_tiny>
    jump2boot();
fffa1198:	48 00 01 f9 	bl      fffa1390 <jump2boot>

    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}
fffa119c:	80 01 00 a4 	lwz     r0,164(r1)
fffa11a0:	17 c1 00 98 	lvd     d30,152(r1)
fffa11a4:	7c 08 03 a6 	mtlr    r0
fffa11a8:	38 21 00 a0 	addi    r1,r1,160
fffa11ac:	4e 80 00 20 	blr
                tpmRespCode = SBEV_TPM_EXTEND_SBE_FW_PAYLOAD_IMAGE_HASH_PCR0_FAILURE;
                break;
            }

            //Extend calculated truncated hash of HBBL secure Hdr into PCR0
            SBEV_INFO("Extending calculated truncated hash of HBBL secure Hdr into PCR0");
fffa11b0:	3c 60 79 a8 	lis     r3,31144
fffa11b4:	4b ff f5 0d 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR0, hbblSecureHdrResponse.sha512Truncated, sizeof(SHA512truncated_t));
fffa11b8:	38 60 00 00 	li      r3,0
fffa11bc:	38 81 00 30 	addi    r4,r1,48
fffa11c0:	38 a0 00 20 	li      r5,32
fffa11c4:	48 00 2d 91 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa11c8:	06 c3 00 0a 	bwz     r3,fffa11dc <_Z17sbevthreadroutinePv+0x430>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending truncated hash of HBBL secure Hdr into PCR0");
fffa11cc:	3c 60 59 3b 	lis     r3,22843
fffa11d0:	4b ff f4 f1 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_HBBL_PAYLOAD_IMAGE_HASH_PCR0_FAILURE;
fffa11d4:	3b e0 00 0e 	li      r31,14
                break;
fffa11d8:	4b ff ff 34 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }

            //Extend Security state to PCR1.i.e Security Switch Register
            memset(sha512Truncated, 0x00, sizeof(SHA512truncated_t));
fffa11dc:	38 80 00 00 	li      r4,0
fffa11e0:	38 a0 00 20 	li      r5,32
fffa11e4:	38 61 00 58 	addi    r3,r1,88
fffa11e8:	48 00 47 b9 	bl      fffa59a0 <memset>
            memcpy(sha512Truncated, &securitySwitchReg_PCR1, sizeof(securitySwitchReg_PCR1_t));
fffa11ec:	38 81 00 90 	addi    r4,r1,144
fffa11f0:	38 a0 00 04 	li      r5,4
fffa11f4:	38 61 00 58 	addi    r3,r1,88
fffa11f8:	48 00 48 7d 	bl      fffa5a74 <memcpy>
            SBEV_INFO("Extending securitySwitchReg_PCR1 details into TPM_PCR1");
fffa11fc:	3c 60 52 3f 	lis     r3,21055
fffa1200:	4b ff f4 c1 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR1, sha512Truncated, sizeof(SHA512truncated_t));
fffa1204:	38 60 00 01 	li      r3,1
fffa1208:	38 81 00 58 	addi    r4,r1,88
fffa120c:	38 a0 00 20 	li      r5,32
fffa1210:	48 00 2d 45 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa1214:	06 c3 00 0a 	bwz     r3,fffa1228 <_Z17sbevthreadroutinePv+0x47c>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending securitySwitchReg_PCR1 details into TPM_PCR1");
fffa1218:	3c 60 13 37 	lis     r3,4919
fffa121c:	4b ff f4 a5 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SECURITY_SWITCH_REG_PCR1_FAILURE ;
fffa1220:	3b e0 00 0f 	li      r31,15
                break;
fffa1224:	4b ff fe e8 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            /*************************************************TPM_EXTEND_SEPERATOR*******************************************************/

            //Extend separator to denote change of control from measurement
            //SEEProm to Boots SEEProm PCR0 to PCR7
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR0");
            rc = tpmExtendPCR(TPM_PCR0, SHA256separator, sizeof(SHA512truncated_t));
fffa1228:	3f e0 ff fa 	lis     r31,-6

            /*************************************************TPM_EXTEND_SEPERATOR*******************************************************/

            //Extend separator to denote change of control from measurement
            //SEEProm to Boots SEEProm PCR0 to PCR7
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR0");
fffa122c:	3c 60 36 e4 	lis     r3,14052
            rc = tpmExtendPCR(TPM_PCR0, SHA256separator, sizeof(SHA512truncated_t));
fffa1230:	3b ff 76 28 	addi    r31,r31,30248

            /*************************************************TPM_EXTEND_SEPERATOR*******************************************************/

            //Extend separator to denote change of control from measurement
            //SEEProm to Boots SEEProm PCR0 to PCR7
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR0");
fffa1234:	4b ff f4 8d 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR0, SHA256separator, sizeof(SHA512truncated_t));
fffa1238:	38 60 00 00 	li      r3,0
fffa123c:	7f e4 fb 78 	mr      r4,r31
fffa1240:	38 a0 00 20 	li      r5,32
fffa1244:	48 00 2d 11 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa1248:	06 c3 00 0a 	bwz     r3,fffa125c <_Z17sbevthreadroutinePv+0x4b0>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR0");
fffa124c:	3c 60 30 3c 	lis     r3,12348
fffa1250:	4b ff f4 71 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR0_FAILURE;
fffa1254:	3b e0 00 10 	li      r31,16
                break;
fffa1258:	4b ff fe b4 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR1");
fffa125c:	3c 60 8a 8b 	lis     r3,-30069
fffa1260:	4b ff f4 61 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR1, SHA256separator, sizeof(SHA512truncated_t));
fffa1264:	38 60 00 01 	li      r3,1
fffa1268:	7f e4 fb 78 	mr      r4,r31
fffa126c:	38 a0 00 20 	li      r5,32
fffa1270:	48 00 2c e5 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa1274:	06 c3 00 0a 	bwz     r3,fffa1288 <_Z17sbevthreadroutinePv+0x4dc>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR1");
fffa1278:	3c 60 0b fd 	lis     r3,3069
fffa127c:	4b ff f4 45 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR1_FAILURE;
fffa1280:	3b e0 00 11 	li      r31,17
                break;
fffa1284:	4b ff fe 88 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR2");
fffa1288:	3c 60 38 77 	lis     r3,14455
fffa128c:	4b ff f4 35 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR2, SHA256separator, sizeof(SHA512truncated_t));
fffa1290:	38 60 00 02 	li      r3,2
fffa1294:	7f e4 fb 78 	mr      r4,r31
fffa1298:	38 a0 00 20 	li      r5,32
fffa129c:	48 00 2c b9 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa12a0:	06 c3 00 0a 	bwz     r3,fffa12b4 <_Z17sbevthreadroutinePv+0x508>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR2");
fffa12a4:	3c 60 1d 97 	lis     r3,7575
fffa12a8:	4b ff f4 19 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR2_FAILURE;
fffa12ac:	3b e0 00 12 	li      r31,18
                break;
fffa12b0:	4b ff fe 5c 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR3");
fffa12b4:	3c 60 00 7f 	lis     r3,127
fffa12b8:	4b ff f4 09 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR3, SHA256separator, sizeof(SHA512truncated_t));
fffa12bc:	38 60 00 03 	li      r3,3
fffa12c0:	7f e4 fb 78 	mr      r4,r31
fffa12c4:	38 a0 00 20 	li      r5,32
fffa12c8:	48 00 2c 8d 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa12cc:	06 c3 00 0a 	bwz     r3,fffa12e0 <_Z17sbevthreadroutinePv+0x534>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR3");
fffa12d0:	3c 60 3b 9b 	lis     r3,15259
fffa12d4:	4b ff f3 ed 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR3_FAILURE;
fffa12d8:	3b e0 00 13 	li      r31,19
                break;
fffa12dc:	4b ff fe 30 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR4");
fffa12e0:	3c 60 17 8d 	lis     r3,6029
fffa12e4:	4b ff f3 dd 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR4, SHA256separator, sizeof(SHA512truncated_t));
fffa12e8:	38 60 00 04 	li      r3,4
fffa12ec:	7f e4 fb 78 	mr      r4,r31
fffa12f0:	38 a0 00 20 	li      r5,32
fffa12f4:	48 00 2c 61 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa12f8:	06 c3 00 0a 	bwz     r3,fffa130c <_Z17sbevthreadroutinePv+0x560>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR4");
fffa12fc:	3c 60 0c be 	lis     r3,3262
fffa1300:	4b ff f3 c1 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR4_FAILURE;
fffa1304:	3b e0 00 14 	li      r31,20
                break;
fffa1308:	4b ff fe 04 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR5");
fffa130c:	3c 60 b4 e5 	lis     r3,-19227
fffa1310:	4b ff f3 b1 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR5, SHA256separator, sizeof(SHA512truncated_t));
fffa1314:	38 60 00 05 	li      r3,5
fffa1318:	7f e4 fb 78 	mr      r4,r31
fffa131c:	38 a0 00 20 	li      r5,32
fffa1320:	48 00 2c 35 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa1324:	06 c3 00 0a 	bwz     r3,fffa1338 <_Z17sbevthreadroutinePv+0x58c>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR5");
fffa1328:	3c 60 a5 37 	lis     r3,-23241
fffa132c:	4b ff f3 95 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR5_FAILURE;
fffa1330:	3b e0 00 15 	li      r31,21
                break;
fffa1334:	4b ff fd d8 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR6");
fffa1338:	3c 60 cb df 	lis     r3,-13345
fffa133c:	4b ff f3 85 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR6, SHA256separator, sizeof(SHA512truncated_t));
fffa1340:	38 60 00 06 	li      r3,6
fffa1344:	7f e4 fb 78 	mr      r4,r31
fffa1348:	38 a0 00 20 	li      r5,32
fffa134c:	48 00 2c 09 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa1350:	06 c3 00 0a 	bwz     r3,fffa1364 <_Z17sbevthreadroutinePv+0x5b8>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR6");
fffa1354:	3c 60 09 f5 	lis     r3,2549
fffa1358:	4b ff f3 69 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR6_FAILURE;
fffa135c:	3b e0 00 16 	li      r31,22
                break;
fffa1360:	4b ff fd ac 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>
            }
            SBEV_INFO("Extending seperator to denote change of control from measurement to boots seeprom into TPM_PCR7");
fffa1364:	3c 60 5a 41 	lis     r3,23105
fffa1368:	4b ff f3 59 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR7, SHA256separator, sizeof(SHA512truncated_t));
fffa136c:	38 60 00 07 	li      r3,7
fffa1370:	7f e4 fb 78 	mr      r4,r31
fffa1374:	38 a0 00 20 	li      r5,32
fffa1378:	48 00 2b dd 	bl      fffa3f54 <_Z12tpmExtendPCRmPhm>
            if(rc)
fffa137c:	06 c3 06 ac 	bwz     r3,fffa10d4 <_Z17sbevthreadroutinePv+0x328>
            {
                SBEV_ERROR(SBEV_FUNC "tpmExtendPCR failed while extending seperator into PCR7");
fffa1380:	3c 60 eb 3b 	lis     r3,-5317
fffa1384:	4b ff f3 3d 	bl      fffa06c0 <pk_trace_tiny>
                tpmRespCode = SBEV_TPM_EXTEND_SEPERATOR_PCR7_FAILURE;
fffa1388:	3b e0 00 17 	li      r31,23
                break;
fffa138c:	4b ff fd 80 	b       fffa110c <_Z17sbevthreadroutinePv+0x360>

fffa1390 <jump2boot>:
            "lvd %d0 , 0(%r4)\n"
            "mtctr %r1\n"
            "bctr\n"
"magic_failed:\n"
            "trap\n"
       );
fffa1390:	3c 80 ff 80 	lis     r4,-128
fffa1394:	14 04 00 00 	lvd     d0,0(r4)
fffa1398:	3c 40 58 49 	lis     r2,22601
fffa139c:	60 42 50 20 	ori     r2,r2,20512
fffa13a0:	3c 60 53 45 	lis     r3,21317
fffa13a4:	60 63 50 4d 	ori     r3,r3,20557
fffa13a8:	05 40 10 0c 	cmplwbne r0,r2,fffa13c0 <magic_failed>
fffa13ac:	05 41 18 0a 	cmplwbne r1,r3,fffa13c0 <magic_failed>
fffa13b0:	60 84 00 08 	ori     r4,r4,8
fffa13b4:	14 04 00 00 	lvd     d0,0(r4)
fffa13b8:	7c 29 03 a6 	mtctr   r1
fffa13bc:	4e 80 04 20 	bctr

fffa13c0 <magic_failed>:
fffa13c0:	7f e0 00 08 	trap
fffa13c4:	4e 80 00 20 	blr

fffa13c8 <_ZL11memcpy_bytePvPKvj>:
{

    // Loop, copying 1 byte
    uint8_t* cdest = (uint8_t *)vdest;
    const uint8_t* csrc = (const uint8_t *)vsrc;
    size_t i = 0;
fffa13c8:	38 a5 00 01 	addi    r5,r5,1
fffa13cc:	7c a9 03 a6 	mtctr   r5
fffa13d0:	39 20 00 00 	li      r9,0

    for (; i < len; ++i)
fffa13d4:	42 40 00 14 	bdz     fffa13e8 <_ZL11memcpy_bytePvPKvj+0x20>
    {
        cdest[i] = csrc[i];
fffa13d8:	7d 44 48 ae 	lbzx    r10,r4,r9
fffa13dc:	7d 43 49 ae 	stbx    r10,r3,r9
    // Loop, copying 1 byte
    uint8_t* cdest = (uint8_t *)vdest;
    const uint8_t* csrc = (const uint8_t *)vsrc;
    size_t i = 0;

    for (; i < len; ++i)
fffa13e0:	39 29 00 01 	addi    r9,r9,1
fffa13e4:	4b ff ff f0 	b       fffa13d4 <_ZL11memcpy_bytePvPKvj+0xc>
    {
        cdest[i] = csrc[i];
    }
}
fffa13e8:	4e 80 00 20 	blr

fffa13ec <_ZL16multi_key_verifyPhiS_S_i>:
    #undef SBEV_FUNC
}

static int multi_key_verify(uint8_t* digest, int key_count, uint8_t* keys,
        uint8_t* sigs, int sig_to_verify)
{
fffa13ec:	94 21 ff d0 	stwu    r1,-48(r1)
fffa13f0:	7c 08 02 a6 	mflr    r0
fffa13f4:	90 81 00 08 	stw     r4,8(r1)
fffa13f8:	90 01 00 34 	stw     r0,52(r1)
fffa13fc:	90 a1 00 0c 	stw     r5,12(r1)
fffa1400:	90 c1 00 10 	stw     r6,16(r1)
fffa1404:	1b 81 00 20 	stvd    d28,32(r1)
fffa1408:	1b c1 00 28 	stvd    d30,40(r1)
    #define SBEV_FUNC " multi_key_verify "
    SBEV_ENTER(SBEV_FUNC);

    int no_of_keys = key_count;
    bool found_key = false;
    for (;key_count;key_count--,keys+=sizeof(ecc_key_t),
fffa140c:	3b 80 00 00 	li      r28,0
    #undef SBEV_FUNC
}

static int multi_key_verify(uint8_t* digest, int key_count, uint8_t* keys,
        uint8_t* sigs, int sig_to_verify)
{
fffa1410:	7c 7e 1b 78 	mr      r30,r3
fffa1414:	7c ff 3b 78 	mr      r31,r7
    #define SBEV_FUNC " multi_key_verify "
    SBEV_ENTER(SBEV_FUNC);

    int no_of_keys = key_count;
    bool found_key = false;
    for (;key_count;key_count--,keys+=sizeof(ecc_key_t),
fffa1418:	3b a0 00 00 	li      r29,0
{
    #define SBEV_FUNC " multi_key_verify "
    SBEV_ENTER(SBEV_FUNC);

    int no_of_keys = key_count;
    bool found_key = false;
fffa141c:	39 40 00 00 	li      r10,0
fffa1420:	81 01 00 10 	lwz     r8,16(r1)
fffa1424:	1d 3d 00 84 	mulli   r9,r29,132
fffa1428:	7c 08 4a 14 	add     r0,r8,r9
fffa142c:	81 01 00 0c 	lwz     r8,12(r1)
fffa1430:	7d 28 4a 14 	add     r9,r8,r9
    for (;key_count;key_count--,keys+=sizeof(ecc_key_t),
fffa1434:	06 dc 00 52 	bwz     r28,fffa14d8 <_ZL16multi_key_verifyPhiS_S_i+0xec>
            sigs+=sizeof(ecc_signature_t))
    {
        if((no_of_keys - key_count) == sig_to_verify)
fffa1438:	04 5f e8 38 	cmpwbne r31,r29,fffa14a8 <_ZL16multi_key_verifyPhiS_S_i+0xbc>
        {
            found_key = true;
            SBEV_INFO("Verifying signature: %d",(no_of_keys-key_count));
fffa143c:	3c 60 34 b6 	lis     r3,13494
fffa1440:	60 63 00 01 	ori     r3,r3,1
fffa1444:	7f e5 fb 78 	mr      r5,r31
fffa1448:	38 c0 00 00 	li      r6,0
fffa144c:	38 e0 00 00 	li      r7,0
fffa1450:	39 00 00 00 	li      r8,0
fffa1454:	90 01 00 18 	stw     r0,24(r1)
fffa1458:	91 21 00 14 	stw     r9,20(r1)
fffa145c:	48 00 26 f5 	bl      fffa3b50 <pk_trace_big>
            if(!SBE::isSimicsRunning())
fffa1460:	48 00 0b a1 	bl      fffa2000 <_ZN3SBE15isSimicsRunningEv>
fffa1464:	80 01 00 18 	lwz     r0,24(r1)
fffa1468:	81 21 00 14 	lwz     r9,20(r1)
fffa146c:	06 43 00 16 	bwnz    r3,fffa1498 <_ZL16multi_key_verifyPhiS_S_i+0xac>
            {
                if (ec_verify (keys, digest, sigs)<1)
fffa1470:	7d 23 4b 78 	mr      r3,r9
fffa1474:	7f c4 f3 78 	mr      r4,r30
fffa1478:	7c 05 03 78 	mr      r5,r0
fffa147c:	48 00 1e 9d 	bl      fffa3318 <_Z9ec_verifyPKhS0_S0_>
fffa1480:	06 a3 00 08 	bwgtz   r3,fffa1490 <_ZL16multi_key_verifyPhiS_S_i+0xa4>
                {
                    SBEV_INFO(SBEV_FUNC "Entering EC Verify Failed");
fffa1484:	3c 60 fc fb 	lis     r3,-773
fffa1488:	4b ff f2 39 	bl      fffa06c0 <pk_trace_tiny>
fffa148c:	48 00 00 78 	b       fffa1504 <_ZL16multi_key_verifyPhiS_S_i+0x118>
                    return 0;
                }
                SBEV_INFO(SBEV_FUNC "EC Verify Passed");
fffa1490:	3c 60 5b 6b 	lis     r3,23403
fffa1494:	48 00 00 08 	b       fffa149c <_ZL16multi_key_verifyPhiS_S_i+0xb0>
            }
            else
            {
                SBEV_INFO("Skipping ECDSA - Simics running");
fffa1498:	3c 60 d0 1a 	lis     r3,-12262
fffa149c:	4b ff f2 25 	bl      fffa06c0 <pk_trace_tiny>
    for (;key_count;key_count--,keys+=sizeof(ecc_key_t),
            sigs+=sizeof(ecc_signature_t))
    {
        if((no_of_keys - key_count) == sig_to_verify)
        {
            found_key = true;
fffa14a0:	39 40 00 01 	li      r10,1
fffa14a4:	48 00 00 28 	b       fffa14cc <_ZL16multi_key_verifyPhiS_S_i+0xe0>
                SBEV_INFO("Skipping ECDSA - Simics running");
            }
        }
        else
        {
            SBEV_INFO("Skiping verification of signature: %d",(no_of_keys-key_count));
fffa14a8:	3c 60 19 7b 	lis     r3,6523
fffa14ac:	60 63 00 01 	ori     r3,r3,1
fffa14b0:	7f a5 eb 78 	mr      r5,r29
fffa14b4:	38 c0 00 00 	li      r6,0
fffa14b8:	38 e0 00 00 	li      r7,0
fffa14bc:	39 00 00 00 	li      r8,0
fffa14c0:	91 41 00 14 	stw     r10,20(r1)
fffa14c4:	48 00 26 8d 	bl      fffa3b50 <pk_trace_big>
fffa14c8:	81 41 00 14 	lwz     r10,20(r1)
fffa14cc:	33 bd 00 01 	addic   r29,r29,1
fffa14d0:	7f 9c 01 94 	addze   r28,r28
fffa14d4:	4b ff ff 4c 	b       fffa1420 <_ZL16multi_key_verifyPhiS_S_i+0x34>
    #define SBEV_FUNC " multi_key_verify "
    SBEV_ENTER(SBEV_FUNC);

    int no_of_keys = key_count;
    bool found_key = false;
    for (;key_count;key_count--,keys+=sizeof(ecc_key_t),
fffa14d8:	81 01 00 08 	lwz     r8,8(r1)
fffa14dc:	04 48 ef ae 	cmpwbne r8,r29,fffa1438 <_ZL16multi_key_verifyPhiS_S_i+0x4c>
    {
        SBEV_INFO("We didn't find a key to verify, this isn't good: %d",sig_to_verify);
        return 0;
    }
    SBEV_EXIT(SBEV_FUNC);
    return 1; // This is return success
fffa14e0:	38 60 00 01 	li      r3,1
        {
            SBEV_INFO("Skiping verification of signature: %d",(no_of_keys-key_count));
        }
    }

    if (!found_key)
fffa14e4:	06 4a 00 12 	bwnz    r10,fffa1508 <_ZL16multi_key_verifyPhiS_S_i+0x11c>
    {
        SBEV_INFO("We didn't find a key to verify, this isn't good: %d",sig_to_verify);
fffa14e8:	3c 60 36 c6 	lis     r3,14022
fffa14ec:	60 63 00 01 	ori     r3,r3,1
fffa14f0:	7f e5 fb 78 	mr      r5,r31
fffa14f4:	38 c0 00 00 	li      r6,0
fffa14f8:	38 e0 00 00 	li      r7,0
fffa14fc:	39 00 00 00 	li      r8,0
fffa1500:	48 00 26 51 	bl      fffa3b50 <pk_trace_big>
        return 0;
fffa1504:	38 60 00 00 	li      r3,0
    }
    SBEV_EXIT(SBEV_FUNC);
    return 1; // This is return success
    #undef SBEV_FUNC
}
fffa1508:	80 01 00 34 	lwz     r0,52(r1)
fffa150c:	17 81 00 20 	lvd     d28,32(r1)
fffa1510:	7c 08 03 a6 	mtlr    r0
fffa1514:	17 c1 00 28 	lvd     d30,40(r1)
fffa1518:	38 21 00 30 	addi    r1,r1,48
fffa151c:	4e 80 00 20 	blr

fffa1520 <_ZL24SHA512_HBBL_Payload_HashPA64_hPy>:
    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}

static void SHA512_HBBL_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa1520:	94 21 ff 20 	stwu    r1,-224(r1)
fffa1524:	7c 08 02 a6 	mflr    r0
    #define SBEV_FUNC " SHA512_HBBL_Payload_Hash "
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;
fffa1528:	39 00 00 00 	li      r8,0
fffa152c:	39 20 00 00 	li      r9,0
    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}

static void SHA512_HBBL_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa1530:	90 01 00 e4 	stw     r0,228(r1)
fffa1534:	1b c1 00 d8 	stvd    d30,216(r1)
    #define SBEV_FUNC " SHA512_HBBL_Payload_Hash "
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;
fffa1538:	19 04 00 00 	stvd    d8,0(r4)
    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}

static void SHA512_HBBL_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa153c:	7c 9f 23 78 	mr      r31,r4
fffa1540:	7c 7e 1b 78 	mr      r30,r3
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;

    SHA512_Init(&context);
fffa1544:	38 61 00 08 	addi    r3,r1,8
fffa1548:	48 00 33 75 	bl      fffa48bc <SHA512_Init>
    SHA512UpdateXipSection(P9_XIP_SECTION_SBE_HBBL, &context, sectionSize);
fffa154c:	38 81 00 08 	addi    r4,r1,8
fffa1550:	7f e5 fb 78 	mr      r5,r31
fffa1554:	38 60 00 0d 	li      r3,13
fffa1558:	48 00 28 71 	bl      fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>
    SHA512_Final(&context, result);
fffa155c:	38 61 00 08 	addi    r3,r1,8
fffa1560:	7f c4 f3 78 	mr      r4,r30
fffa1564:	48 00 34 f9 	bl      fffa4a5c <SHA512_Final>

    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}
fffa1568:	80 01 00 e4 	lwz     r0,228(r1)
fffa156c:	17 c1 00 d8 	lvd     d30,216(r1)
fffa1570:	7c 08 03 a6 	mtlr    r0
fffa1574:	38 21 00 e0 	addi    r1,r1,224
fffa1578:	4e 80 00 20 	blr

fffa157c <_ZL22SHA512_FW_Payload_HashPA64_hPy>:
    return 1; // This is return success
    #undef SBEV_FUNC
}

static void SHA512_FW_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa157c:	94 21 ff 20 	stwu    r1,-224(r1)
fffa1580:	7c 08 02 a6 	mflr    r0
    #define SBEV_FUNC " SHA512_FW_Payload_Hash "
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;
fffa1584:	39 00 00 00 	li      r8,0
fffa1588:	39 20 00 00 	li      r9,0
    return 1; // This is return success
    #undef SBEV_FUNC
}

static void SHA512_FW_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa158c:	90 01 00 e4 	stw     r0,228(r1)
fffa1590:	1b c1 00 d8 	stvd    d30,216(r1)
    #define SBEV_FUNC " SHA512_FW_Payload_Hash "
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;
fffa1594:	19 04 00 00 	stvd    d8,0(r4)
    return 1; // This is return success
    #undef SBEV_FUNC
}

static void SHA512_FW_Payload_Hash(SHA512_t *result, uint64_t* sectionSize)
{
fffa1598:	7c 9f 23 78 	mr      r31,r4
fffa159c:	7c 7e 1b 78 	mr      r30,r3
    SBEV_ENTER(SBEV_FUNC);

    SHA512_CTX context;
    *sectionSize = 0;

    SHA512_Init(&context);
fffa15a0:	38 61 00 08 	addi    r3,r1,8
fffa15a4:	48 00 33 19 	bl      fffa48bc <SHA512_Init>

    SHA512UpdateXipSection(P9_XIP_SECTION_SBE_LOADERTEXT, &context, sectionSize);
fffa15a8:	38 81 00 08 	addi    r4,r1,8
fffa15ac:	7f e5 fb 78 	mr      r5,r31
fffa15b0:	38 60 00 05 	li      r3,5
fffa15b4:	48 00 28 15 	bl      fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>
    SHA512UpdateXipSection(P9_XIP_SECTION_SBE_TEXT, &context, sectionSize);
fffa15b8:	38 81 00 08 	addi    r4,r1,8
fffa15bc:	7f e5 fb 78 	mr      r5,r31
fffa15c0:	38 60 00 07 	li      r3,7
fffa15c4:	48 00 28 05 	bl      fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>
    SHA512UpdateXipSection(P9_XIP_SECTION_SBE_BASELOADER, &context, sectionSize);
fffa15c8:	38 81 00 08 	addi    r4,r1,8
fffa15cc:	7f e5 fb 78 	mr      r5,r31
fffa15d0:	38 60 00 0a 	li      r3,10
fffa15d4:	48 00 27 f5 	bl      fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>
    SHA512UpdateXipSection(P9_XIP_SECTION_SBE_BASE, &context, sectionSize);
fffa15d8:	38 81 00 08 	addi    r4,r1,8
fffa15dc:	7f e5 fb 78 	mr      r5,r31
fffa15e0:	38 60 00 09 	li      r3,9
fffa15e4:	48 00 27 e5 	bl      fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>

    SHA512_Final(&context, result);
fffa15e8:	38 61 00 08 	addi    r3,r1,8
fffa15ec:	7f c4 f3 78 	mr      r4,r30
fffa15f0:	48 00 34 6d 	bl      fffa4a5c <SHA512_Final>

    SBEV_EXIT(SBEV_FUNC);
    #undef SBEV_FUNC
}
fffa15f4:	80 01 00 e4 	lwz     r0,228(r1)
fffa15f8:	17 c1 00 d8 	lvd     d30,216(r1)
fffa15fc:	7c 08 03 a6 	mtlr    r0
fffa1600:	38 21 00 e0 	addi    r1,r1,224
fffa1604:	4e 80 00 20 	blr

fffa1608 <_Z5get64Pv>:
        cdest[i] = csrc[i];
    }
}

inline uint64_t get64(void* src)
{
fffa1608:	94 21 ff e8 	stwu    r1,-24(r1)
fffa160c:	7c 08 02 a6 	mflr    r0
fffa1610:	7c 64 1b 78 	mr      r4,r3
    uint64_t dest;
    memcpy_byte(&dest, src,sizeof(uint64_t));
fffa1614:	38 a0 00 08 	li      r5,8
fffa1618:	38 61 00 08 	addi    r3,r1,8
        cdest[i] = csrc[i];
    }
}

inline uint64_t get64(void* src)
{
fffa161c:	90 01 00 1c 	stw     r0,28(r1)
    uint64_t dest;
    memcpy_byte(&dest, src,sizeof(uint64_t));
fffa1620:	4b ff fd a9 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    return dest;
}
fffa1624:	80 01 00 1c 	lwz     r0,28(r1)
fffa1628:	14 61 00 08 	lvd     d3,8(r1)
fffa162c:	7c 08 03 a6 	mtlr    r0
fffa1630:	38 21 00 18 	addi    r1,r1,24
fffa1634:	4e 80 00 20 	blr

fffa1638 <_Z5get32Pv>:

inline uint32_t get32(void* src)
{
fffa1638:	94 21 ff e8 	stwu    r1,-24(r1)
fffa163c:	7c 08 02 a6 	mflr    r0
fffa1640:	7c 64 1b 78 	mr      r4,r3
    uint32_t dest;
    memcpy_byte(&dest, src,sizeof(uint32_t));
fffa1644:	38 a0 00 04 	li      r5,4
fffa1648:	38 61 00 08 	addi    r3,r1,8
    memcpy_byte(&dest, src,sizeof(uint64_t));
    return dest;
}

inline uint32_t get32(void* src)
{
fffa164c:	90 01 00 1c 	stw     r0,28(r1)
    uint32_t dest;
    memcpy_byte(&dest, src,sizeof(uint32_t));
fffa1650:	4b ff fd 79 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    return dest;
}
fffa1654:	80 01 00 1c 	lwz     r0,28(r1)
fffa1658:	80 61 00 08 	lwz     r3,8(r1)
fffa165c:	7c 08 03 a6 	mtlr    r0
fffa1660:	38 21 00 18 	addi    r1,r1,24
fffa1664:	4e 80 00 20 	blr

fffa1668 <_Z5get16Pv>:

inline uint16_t get16(void* src)
{
fffa1668:	94 21 ff e8 	stwu    r1,-24(r1)
fffa166c:	7c 08 02 a6 	mflr    r0
fffa1670:	7c 64 1b 78 	mr      r4,r3
    uint16_t dest;
    memcpy_byte(&dest, src,sizeof(uint16_t));
fffa1674:	38 a0 00 02 	li      r5,2
fffa1678:	38 61 00 08 	addi    r3,r1,8
    memcpy_byte(&dest, src,sizeof(uint32_t));
    return dest;
}

inline uint16_t get16(void* src)
{
fffa167c:	90 01 00 1c 	stw     r0,28(r1)
    uint16_t dest;
    memcpy_byte(&dest, src,sizeof(uint16_t));
fffa1680:	4b ff fd 49 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    return dest;
}
fffa1684:	80 01 00 1c 	lwz     r0,28(r1)
fffa1688:	a0 61 00 08 	lhz     r3,8(r1)
fffa168c:	7c 08 03 a6 	mtlr    r0
fffa1690:	38 21 00 18 	addi    r1,r1,24
fffa1694:	4e 80 00 20 	blr

fffa1698 <_Z4get8Pv>:

inline uint8_t get8(void* src)
{
fffa1698:	94 21 ff e8 	stwu    r1,-24(r1)
fffa169c:	7c 08 02 a6 	mflr    r0
fffa16a0:	7c 64 1b 78 	mr      r4,r3
    uint8_t dest;
    memcpy_byte(&dest, src,sizeof(uint8_t));
fffa16a4:	38 a0 00 01 	li      r5,1
fffa16a8:	38 61 00 08 	addi    r3,r1,8
    memcpy_byte(&dest, src,sizeof(uint16_t));
    return dest;
}

inline uint8_t get8(void* src)
{
fffa16ac:	90 01 00 1c 	stw     r0,28(r1)
    uint8_t dest;
    memcpy_byte(&dest, src,sizeof(uint8_t));
fffa16b0:	4b ff fd 19 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    return dest;
}
fffa16b4:	80 01 00 1c 	lwz     r0,28(r1)
fffa16b8:	88 61 00 08 	lbz     r3,8(r1)
fffa16bc:	7c 08 03 a6 	mtlr    r0
fffa16c0:	38 21 00 18 	addi    r1,r1,24
fffa16c4:	4e 80 00 20 	blr

fffa16c8 <_ZL13valid_ver_algP15ROM_version_rawh>:

static int valid_ver_alg(ROM_version_raw* ver_alg, uint8_t sig_alg)
{
fffa16c8:	94 21 ff e8 	stwu    r1,-24(r1)
fffa16cc:	7c 08 02 a6 	mflr    r0
fffa16d0:	1b c1 00 10 	stvd    d30,16(r1)
fffa16d4:	90 01 00 1c 	stw     r0,28(r1)
fffa16d8:	1b 81 00 08 	stvd    d28,8(r1)
fffa16dc:	7c 7f 1b 78 	mr      r31,r3
fffa16e0:	7c 9e 23 78 	mr      r30,r4
    #define SBEV_FUNC " valid_ver_alg "
    SBEV_ENTER(SBEV_FUNC);

    //Validate header version
    SBEV_INFO("Hdr: Version : %d", get16(&ver_alg->version));
fffa16e4:	4b ff ff 85 	bl      fffa1668 <_Z5get16Pv>
fffa16e8:	64 63 35 5d 	oris    r3,r3,13661
fffa16ec:	4b ff ef d5 	bl      fffa06c0 <pk_trace_tiny>
    if(get16(&ver_alg->version) != HEADER_VERSION)
fffa16f0:	7f e3 fb 78 	mr      r3,r31
fffa16f4:	4b ff ff 75 	bl      fffa1668 <_Z5get16Pv>
fffa16f8:	06 c3 08 06 	cmpwibeq r3,1,fffa1704 <_ZL13valid_ver_algP15ROM_version_rawh+0x3c>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED: bad header version");
fffa16fc:	3c 60 b8 9d 	lis     r3,-18275
fffa1700:	48 00 00 28 	b       fffa1728 <_ZL13valid_ver_algP15ROM_version_rawh+0x60>
        return 0;
    }

    //Validate header hash algo version
    SBEV_INFO("Hdr: hash algo : %d", get8(&ver_alg->hash_alg));
fffa1704:	3b bf 00 02 	addi    r29,r31,2
fffa1708:	7f a3 eb 78 	mr      r3,r29
fffa170c:	4b ff ff 8d 	bl      fffa1698 <_Z4get8Pv>
fffa1710:	64 63 e0 35 	oris    r3,r3,57397
fffa1714:	4b ff ef ad 	bl      fffa06c0 <pk_trace_tiny>
    if(get8(&ver_alg->hash_alg) != HASH_ALG_SHA512)
fffa1718:	7f a3 eb 78 	mr      r3,r29
fffa171c:	4b ff ff 7d 	bl      fffa1698 <_Z4get8Pv>
fffa1720:	06 c3 08 0a 	cmpwibeq r3,1,fffa1734 <_ZL13valid_ver_algP15ROM_version_rawh+0x6c>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED: bad algorithm version");
fffa1724:	3c 60 45 a5 	lis     r3,17829
fffa1728:	4b ff ef 99 	bl      fffa06c0 <pk_trace_tiny>
        return 0;
fffa172c:	38 60 00 00 	li      r3,0
fffa1730:	48 00 00 34 	b       fffa1764 <_ZL13valid_ver_algP15ROM_version_rawh+0x9c>
    }

    if (!sig_alg)
fffa1734:	06 5e 00 06 	bwnz    r30,fffa1740 <_ZL13valid_ver_algP15ROM_version_rawh+0x78>
    {
        return 1;
fffa1738:	38 60 00 01 	li      r3,1
fffa173c:	48 00 00 28 	b       fffa1764 <_ZL13valid_ver_algP15ROM_version_rawh+0x9c>
    }

    //Validate header sign algo version
    SBEV_INFO("Hdr: Sign Algo : %d", get8(&ver_alg->sig_alg));
fffa1740:	3b ff 00 03 	addi    r31,r31,3
fffa1744:	7f e3 fb 78 	mr      r3,r31
fffa1748:	4b ff ff 51 	bl      fffa1698 <_Z4get8Pv>
fffa174c:	64 63 e0 ff 	oris    r3,r3,57599
fffa1750:	4b ff ef 71 	bl      fffa06c0 <pk_trace_tiny>
    if(get8(&ver_alg->sig_alg) != sig_alg)
fffa1754:	7f e3 fb 78 	mr      r3,r31
fffa1758:	4b ff ff 41 	bl      fffa1698 <_Z4get8Pv>
fffa175c:	04 43 f7 e4 	cmpwbne r3,r30,fffa1724 <_ZL13valid_ver_algP15ROM_version_rawh+0x5c>
fffa1760:	4b ff ff d8 	b       fffa1738 <_ZL13valid_ver_algP15ROM_version_rawh+0x70>
    }

    SBEV_EXIT(SBEV_FUNC);
    return 1;
    #undef SBEV_FUNC
}
fffa1764:	80 01 00 1c 	lwz     r0,28(r1)
fffa1768:	17 81 00 08 	lvd     d28,8(r1)
fffa176c:	7c 08 03 a6 	mtlr    r0
fffa1770:	17 c1 00 10 	lvd     d30,16(r1)
fffa1774:	38 21 00 18 	addi    r1,r1,24
fffa1778:	4e 80 00 20 	blr

fffa177c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm>:
ROM_response ROM_verify( ROM_container_raw* container,
                         ROM_hw_params* params,
                         int hw_sig_to_verify,
                         SHA512_t *SHA512Result,
                         uint32_t *flag)
{
fffa177c:	94 21 fd e8 	stwu    r1,-536(r1)
fffa1780:	7c 08 02 a6 	mflr    r0
fffa1784:	1b c1 02 10 	stvd    d30,528(r1)
fffa1788:	90 a1 01 f0 	stw     r5,496(r1)
fffa178c:	7c 7e 1b 78 	mr      r30,r3
fffa1790:	7c 9f 23 78 	mr      r31,r4
    ROM_sw_sig_raw* sw_sig;
    SHA512_t digest;
    //NOTE: Keep the array size 8 byte aligned to overcome sram allignment issues.
    //396 bytes is MAX hash we calculate and hence buffer size is 400 bytes.
    const uint32_t hashDataBuffSize = sizeof(uint64_t) * 50;
    uint8_t hashDataBuff[hashDataBuffSize]  __attribute__ ((aligned(8))) = {0x00};
fffa1794:	38 a0 01 90 	li      r5,400
fffa1798:	38 80 00 00 	li      r4,0
fffa179c:	38 61 00 08 	addi    r3,r1,8
ROM_response ROM_verify( ROM_container_raw* container,
                         ROM_hw_params* params,
                         int hw_sig_to_verify,
                         SHA512_t *SHA512Result,
                         uint32_t *flag)
{
fffa17a0:	90 01 02 1c 	stw     r0,540(r1)
fffa17a4:	90 c1 01 f4 	stw     r6,500(r1)
fffa17a8:	90 e1 01 f8 	stw     r7,504(r1)
fffa17ac:	1b 81 02 08 	stvd    d28,520(r1)
    ROM_sw_sig_raw* sw_sig;
    SHA512_t digest;
    //NOTE: Keep the array size 8 byte aligned to overcome sram allignment issues.
    //396 bytes is MAX hash we calculate and hence buffer size is 400 bytes.
    const uint32_t hashDataBuffSize = sizeof(uint64_t) * 50;
    uint8_t hashDataBuff[hashDataBuffSize]  __attribute__ ((aligned(8))) = {0x00};
fffa17b0:	48 00 41 f1 	bl      fffa59a0 <memset>
    uint64_t size;
    uint8_t swKeyCount;
    uint64_t sectionSize = 0;
fffa17b4:	39 00 00 00 	li      r8,0
fffa17b8:	39 20 00 00 	li      r9,0
fffa17bc:	19 01 01 d8 	stvd    d8,472(r1)

    // params.log is used to pass in a FW Secure Version to
    // compare against the container's sw header's fw_secure_version field
    uint8_t i_fw_secure_version = static_cast<uint8_t>(params->log);
fffa17c0:	81 3f 00 5c 	lwz     r9,92(r31)

    params->log = CONTEXT|BEGIN;
fffa17c4:	39 00 00 00 	li      r8,0
    uint8_t swKeyCount;
    uint64_t sectionSize = 0;

    // params.log is used to pass in a FW Secure Version to
    // compare against the container's sw header's fw_secure_version field
    uint8_t i_fw_secure_version = static_cast<uint8_t>(params->log);
fffa17c8:	91 21 01 fc 	stw     r9,508(r1)

    params->log = CONTEXT|BEGIN;
fffa17cc:	39 20 00 01 	li      r9,1
fffa17d0:	19 1f 00 58 	stvd    d8,88(r31)

    //Validate Magic Number
    SBEV_INFO("Magic number: 0x%X", get32(&container->magic_number));
fffa17d4:	7f c3 f3 78 	mr      r3,r30
fffa17d8:	4b ff fe 61 	bl      fffa1638 <_Z5get32Pv>
fffa17dc:	7c 65 1b 78 	mr      r5,r3
fffa17e0:	3c 60 61 2a 	lis     r3,24874
fffa17e4:	60 63 00 01 	ori     r3,r3,1
fffa17e8:	38 c0 00 00 	li      r6,0
fffa17ec:	38 e0 00 00 	li      r7,0
fffa17f0:	39 00 00 00 	li      r8,0
fffa17f4:	48 00 23 5d 	bl      fffa3b50 <pk_trace_big>
    if(!(get32(&container->magic_number) == ROM_MAGIC_NUMBER))
fffa17f8:	7f c3 f3 78 	mr      r3,r30
fffa17fc:	4b ff fe 3d 	bl      fffa1638 <_Z5get32Pv>
fffa1800:	3d 20 17 08 	lis     r9,5896
fffa1804:	61 29 20 11 	ori     r9,r9,8209
fffa1808:	04 c3 48 0c 	cmpwbeq r3,r9,fffa1820 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0xa4>
    {
        SBEV_ERROR (SBEV_FUNC "FAILED : bad container magic number");
fffa180c:	3c 60 52 b5 	lis     r3,21173
fffa1810:	4b ff ee b1 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(MAGIC_NUMBER_TEST);
fffa1814:	39 00 ff ff 	li      r8,-1
fffa1818:	39 20 80 20 	li      r9,-32736
fffa181c:	48 00 03 cc 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    //Validate Container Version
    SBEV_INFO("Container Version: 0x%X", get16(&container->version));
fffa1820:	3b be 00 04 	addi    r29,r30,4
fffa1824:	7f a3 eb 78 	mr      r3,r29
fffa1828:	4b ff fe 41 	bl      fffa1668 <_Z5get16Pv>
fffa182c:	64 63 84 c2 	oris    r3,r3,33986
fffa1830:	4b ff ee 91 	bl      fffa06c0 <pk_trace_tiny>
    if(!(get16(&container->version) == CONTAINER_VERSION))
fffa1834:	7f a3 eb 78 	mr      r3,r29
fffa1838:	4b ff fe 31 	bl      fffa1668 <_Z5get16Pv>
fffa183c:	06 c3 08 0c 	cmpwibeq r3,1,fffa1854 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0xd8>
    {
        SBEV_ERROR (SBEV_FUNC "FAILED : bad container version");
fffa1840:	3c 60 b4 68 	lis     r3,-19352
fffa1844:	4b ff ee 7d 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(CONTAINER_VERSION_TEST);
fffa1848:	39 00 ff ff 	li      r8,-1
fffa184c:	39 20 80 21 	li      r9,-32735
fffa1850:	48 00 03 98 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    //Process HW Keys and verify HW keys Hash
    memcpy_byte(hashDataBuff, &container->hw_pkey_a, HW_KEY_COUNT*sizeof(ecc_key_t));
fffa1854:	39 5e 00 1e 	addi    r10,r30,30
fffa1858:	7d 44 53 78 	mr      r4,r10
fffa185c:	38 61 00 08 	addi    r3,r1,8
fffa1860:	38 a0 01 8c 	li      r5,396
fffa1864:	91 41 01 e8 	stw     r10,488(r1)
fffa1868:	4b ff fb 61 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    SHA512_Hash(hashDataBuff, HW_KEY_COUNT*sizeof(ecc_key_t), &digest);
fffa186c:	38 61 00 08 	addi    r3,r1,8
fffa1870:	38 80 01 8c 	li      r4,396
fffa1874:	38 a1 01 98 	addi    r5,r1,408
fffa1878:	48 00 32 e5 	bl      fffa4b5c <SHA512_Hash>
    if(memcmp(params->hw_key_hash, digest, sizeof(SHA512_t)))
fffa187c:	7f e3 fb 78 	mr      r3,r31
fffa1880:	38 81 01 98 	addi    r4,r1,408
fffa1884:	38 a0 00 40 	li      r5,64
fffa1888:	48 00 42 7d 	bl      fffa5b04 <memcmp>
fffa188c:	06 c3 00 0c 	bwz     r3,fffa18a4 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x128>
    {
        SBEV_ERROR (SBEV_FUNC "FAILED : invalid hw keys");
fffa1890:	3c 60 33 c0 	lis     r3,13248
fffa1894:	4b ff ee 2d 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(HW_KEY_HASH_TEST);
fffa1898:	39 00 ff ff 	li      r8,-1
fffa189c:	39 20 80 60 	li      r9,-32672
fffa18a0:	48 00 03 48 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // process prefix header
    prefix = (ROM_prefix_header_raw*)&container->prefix;
fffa18a4:	3b 9e 01 aa 	addi    r28,r30,426
    // test for valid header version, hash & signature algorithms (sanity check)
    if(!valid_ver_alg(&prefix->ver_alg, SIG_ALG_ECDSA521))
fffa18a8:	7f 83 e3 78 	mr      r3,r28
fffa18ac:	38 80 00 01 	li      r4,1
fffa18b0:	4b ff fe 19 	bl      fffa16c8 <_ZL13valid_ver_algP15ROM_version_rawh>
fffa18b4:	06 43 00 0c 	bwnz    r3,fffa18cc <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x150>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : bad prefix header version,alg's");
fffa18b8:	3c 60 0f bc 	lis     r3,4028
fffa18bc:	4b ff ee 05 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(PREFIX_VER_ALG_TEST);
fffa18c0:	39 00 ff ff 	li      r8,-1
fffa18c4:	39 20 80 22 	li      r9,-32734
fffa18c8:	48 00 03 20 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for valid prefix header signatures (all)
    hw_data = (ROM_prefix_data_raw*)(prefix->ecid + get8(&prefix->ecid_count)*ECID_SIZE);
fffa18cc:	3b be 02 0b 	addi    r29,r30,523
fffa18d0:	7f a3 eb 78 	mr      r3,r29
fffa18d4:	4b ff fd c5 	bl      fffa1698 <_Z4get8Pv>
fffa18d8:	7c 6a 1b 78 	mr      r10,r3

    // Validate the PREFIX_HEADER_SIZE fits in our hashDataBuff
    if (hashDataBuffSize < PREFIX_HEADER_SIZE(prefix))
fffa18dc:	7f a3 eb 78 	mr      r3,r29
fffa18e0:	91 41 02 00 	stw     r10,512(r1)
fffa18e4:	4b ff fd b5 	bl      fffa1698 <_Z4get8Pv>
fffa18e8:	54 63 20 36 	rlwinm  r3,r3,4,0,27
fffa18ec:	39 23 00 62 	addi    r9,r3,98
fffa18f0:	28 09 01 90 	cmplwi  r9,400
fffa18f4:	81 41 02 00 	lwz     r10,512(r1)
fffa18f8:	40 81 00 10 	ble     fffa1908 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x18c>
    {
        VERIFY_FAILED(PREFIX_HEADER_SZ_TEST);
fffa18fc:	39 00 ff ff 	li      r8,-1
fffa1900:	39 20 80 66 	li      r9,-32666
fffa1904:	48 00 02 e4 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
        SBEV_ERROR(SBEV_FUNC "FAILED : bad prefix header version,alg's");
        VERIFY_FAILED(PREFIX_VER_ALG_TEST);
    }

    // test for valid prefix header signatures (all)
    hw_data = (ROM_prefix_data_raw*)(prefix->ecid + get8(&prefix->ecid_count)*ECID_SIZE);
fffa1908:	39 3e 02 0c 	addi    r9,r30,524
fffa190c:	55 4a 20 36 	rlwinm  r10,r10,4,0,27
fffa1910:	7d 49 52 14 	add     r10,r9,r10
    {
        VERIFY_FAILED(PREFIX_HEADER_SZ_TEST);
    }

    //Calculate Hash of prefix header
    memcpy_byte(hashDataBuff, prefix, PREFIX_HEADER_SIZE(prefix));
fffa1914:	7f a3 eb 78 	mr      r3,r29
        SBEV_ERROR(SBEV_FUNC "FAILED : bad prefix header version,alg's");
        VERIFY_FAILED(PREFIX_VER_ALG_TEST);
    }

    // test for valid prefix header signatures (all)
    hw_data = (ROM_prefix_data_raw*)(prefix->ecid + get8(&prefix->ecid_count)*ECID_SIZE);
fffa1918:	91 41 01 ec 	stw     r10,492(r1)
    {
        VERIFY_FAILED(PREFIX_HEADER_SZ_TEST);
    }

    //Calculate Hash of prefix header
    memcpy_byte(hashDataBuff, prefix, PREFIX_HEADER_SIZE(prefix));
fffa191c:	4b ff fd 7d 	bl      fffa1698 <_Z4get8Pv>
fffa1920:	54 65 20 36 	rlwinm  r5,r3,4,0,27
fffa1924:	7f 84 e3 78 	mr      r4,r28
fffa1928:	38 a5 00 62 	addi    r5,r5,98
fffa192c:	38 61 00 08 	addi    r3,r1,8
fffa1930:	4b ff fa 99 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    SHA512_Hash(hashDataBuff, PREFIX_HEADER_SIZE(prefix), &digest);
fffa1934:	7f a3 eb 78 	mr      r3,r29
fffa1938:	4b ff fd 61 	bl      fffa1698 <_Z4get8Pv>
fffa193c:	54 64 20 36 	rlwinm  r4,r3,4,0,27
fffa1940:	38 84 00 62 	addi    r4,r4,98
fffa1944:	38 61 00 08 	addi    r3,r1,8
fffa1948:	38 a1 01 98 	addi    r5,r1,408
fffa194c:	48 00 32 11 	bl      fffa4b5c <SHA512_Hash>

    //Verify HW signatures a if HBBL secure hdr and HW signature c if SBE-FW secure hdr
    if(!multi_key_verify(digest, HW_KEY_COUNT, container->hw_pkey_a,
                                  hw_data->hw_sig_a,hw_sig_to_verify))
fffa1950:	14 a1 01 e8 	lvd     d5,488(r1)
fffa1954:	80 e1 01 f0 	lwz     r7,496(r1)
fffa1958:	38 61 01 98 	addi    r3,r1,408
fffa195c:	38 80 00 03 	li      r4,3
fffa1960:	4b ff fa 8d 	bl      fffa13ec <_ZL16multi_key_verifyPhiS_S_i>
    //Calculate Hash of prefix header
    memcpy_byte(hashDataBuff, prefix, PREFIX_HEADER_SIZE(prefix));
    SHA512_Hash(hashDataBuff, PREFIX_HEADER_SIZE(prefix), &digest);

    //Verify HW signatures a if HBBL secure hdr and HW signature c if SBE-FW secure hdr
    if(!multi_key_verify(digest, HW_KEY_COUNT, container->hw_pkey_a,
fffa1964:	06 43 00 0c 	bwnz    r3,fffa197c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x200>
                                  hw_data->hw_sig_a,hw_sig_to_verify))
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid hw signature");
fffa1968:	3c 60 84 15 	lis     r3,-31723
fffa196c:	4b ff ed 55 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(HW_SIGNATURE_TEST);
fffa1970:	39 00 ff ff 	li      r8,-1
fffa1974:	39 20 80 61 	li      r9,-32671
fffa1978:	48 00 02 70 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    SBEV_INFO("Prefix Hdr: code start offset : %d", get64(&prefix->code_start_offset));
fffa197c:	38 7e 01 ae 	addi    r3,r30,430
fffa1980:	4b ff fc 89 	bl      fffa1608 <_Z5get64Pv>
fffa1984:	3c 60 e3 be 	lis     r3,-7234
fffa1988:	7c 85 23 78 	mr      r5,r4
fffa198c:	38 c0 00 00 	li      r6,0
fffa1990:	38 e0 00 00 	li      r7,0
fffa1994:	39 00 00 00 	li      r8,0
fffa1998:	60 63 00 01 	ori     r3,r3,1
fffa199c:	48 00 21 b5 	bl      fffa3b50 <pk_trace_big>
    SBEV_INFO("Prefix Hdr: Reserved : %d", get64(&prefix->reserved));
fffa19a0:	38 7e 01 b6 	addi    r3,r30,438
fffa19a4:	4b ff fc 65 	bl      fffa1608 <_Z5get64Pv>
fffa19a8:	3c 60 8a d3 	lis     r3,-29997
fffa19ac:	7c 85 23 78 	mr      r5,r4
fffa19b0:	38 c0 00 00 	li      r6,0
fffa19b4:	38 e0 00 00 	li      r7,0
fffa19b8:	39 00 00 00 	li      r8,0
fffa19bc:	60 63 00 01 	ori     r3,r3,1
    SBEV_INFO("Prefix Hdr: flags : %X", get32(&prefix->flags));
fffa19c0:	3b 9e 01 be 	addi    r28,r30,446
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid hw signature");
        VERIFY_FAILED(HW_SIGNATURE_TEST);
    }

    SBEV_INFO("Prefix Hdr: code start offset : %d", get64(&prefix->code_start_offset));
    SBEV_INFO("Prefix Hdr: Reserved : %d", get64(&prefix->reserved));
fffa19c4:	48 00 21 8d 	bl      fffa3b50 <pk_trace_big>
    SBEV_INFO("Prefix Hdr: flags : %X", get32(&prefix->flags));
fffa19c8:	7f 83 e3 78 	mr      r3,r28
fffa19cc:	4b ff fc 6d 	bl      fffa1638 <_Z5get32Pv>
fffa19d0:	7c 65 1b 78 	mr      r5,r3
fffa19d4:	3c 60 42 ef 	lis     r3,17135
fffa19d8:	38 c0 00 00 	li      r6,0
fffa19dc:	38 e0 00 00 	li      r7,0
fffa19e0:	39 00 00 00 	li      r8,0
fffa19e4:	60 63 00 01 	ori     r3,r3,1
fffa19e8:	48 00 21 69 	bl      fffa3b50 <pk_trace_big>
    //Return the Prefix Hdr flag
    *flag = get32(&prefix->flags);
fffa19ec:	7f 83 e3 78 	mr      r3,r28
fffa19f0:	4b ff fc 49 	bl      fffa1638 <_Z5get32Pv>
fffa19f4:	81 21 01 f8 	lwz     r9,504(r1)
fffa19f8:	90 69 00 00 	stw     r3,0(r9)

    // test for machine specific matching ecid
    SBEV_INFO("Prefix Hdr: ECID Count: %d",get8(&prefix->ecid_count));
fffa19fc:	7f a3 eb 78 	mr      r3,r29
fffa1a00:	4b ff fc 99 	bl      fffa1698 <_Z4get8Pv>
fffa1a04:	64 63 83 d9 	oris    r3,r3,33753
fffa1a08:	4b ff ec b9 	bl      fffa06c0 <pk_trace_tiny>
    //Need not copy  prefix->ecid to SRAM as it is not de-referenced.
    if(!valid_ecid(get8(&prefix->ecid_count), prefix->ecid, params->my_ecid))
fffa1a0c:	7f a3 eb 78 	mr      r3,r29
fffa1a10:	4b ff fc 89 	bl      fffa1698 <_Z4get8Pv>
static int valid_ecid(int ecid_count, uint8_t* ecids, uint8_t* hw_ecid)
{
    #define SBEV_FUNC " valid_ecid "
    SBEV_ENTER(SBEV_FUNC);

    if (ecid_count == 0)
fffa1a14:	06 c3 00 0c 	bwz     r3,fffa1a2c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x2b0>
    // test for machine specific matching ecid
    SBEV_INFO("Prefix Hdr: ECID Count: %d",get8(&prefix->ecid_count));
    //Need not copy  prefix->ecid to SRAM as it is not de-referenced.
    if(!valid_ecid(get8(&prefix->ecid_count), prefix->ecid, params->my_ecid))
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : unauthorized prefix ecid");
fffa1a18:	3c 60 e2 a8 	lis     r3,-7512
fffa1a1c:	4b ff ec a5 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(PREFIX_ECID_TEST);
fffa1a20:	39 00 ff ff 	li      r8,-1
fffa1a24:	39 20 80 62 	li      r9,-32670
fffa1a28:	48 00 01 c0 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for valid prefix payload hash
    SBEV_INFO("Prefix Hdr: Payload Size: %d", get64(&prefix->payload_size));
fffa1a2c:	3b be 01 c3 	addi    r29,r30,451
fffa1a30:	7f a3 eb 78 	mr      r3,r29
fffa1a34:	4b ff fb d5 	bl      fffa1608 <_Z5get64Pv>
fffa1a38:	3c 60 da 3e 	lis     r3,-9666
fffa1a3c:	60 63 00 01 	ori     r3,r3,1
fffa1a40:	7c 85 23 78 	mr      r5,r4
fffa1a44:	38 c0 00 00 	li      r6,0
fffa1a48:	38 e0 00 00 	li      r7,0
fffa1a4c:	39 00 00 00 	li      r8,0
fffa1a50:	48 00 21 01 	bl      fffa3b50 <pk_trace_big>
    size = get64(&prefix->payload_size);
fffa1a54:	7f a3 eb 78 	mr      r3,r29
fffa1a58:	4b ff fb b1 	bl      fffa1608 <_Z5get64Pv>
fffa1a5c:	7c 9d 23 78 	mr      r29,r4

    // Validate the prefix payload fits in our hashDataBuff
    if (hashDataBuffSize < size)
fffa1a60:	06 c3 00 08 	bwz     r3,fffa1a70 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x2f4>
    {
        VERIFY_FAILED(PREFIX_PAYLD_SZ_TEST);
fffa1a64:	39 00 ff ff 	li      r8,-1
fffa1a68:	39 20 80 67 	li      r9,-32665
fffa1a6c:	48 00 01 7c 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    // test for valid prefix payload hash
    SBEV_INFO("Prefix Hdr: Payload Size: %d", get64(&prefix->payload_size));
    size = get64(&prefix->payload_size);

    // Validate the prefix payload fits in our hashDataBuff
    if (hashDataBuffSize < size)
fffa1a70:	28 04 01 90 	cmplwi  r4,400
fffa1a74:	41 81 ff f0 	bgt     fffa1a64 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x2e8>
    {
        VERIFY_FAILED(PREFIX_PAYLD_SZ_TEST);
    }
    memcpy_byte(hashDataBuff, &hw_data->sw_pkey_p, size);
fffa1a78:	81 41 01 ec 	lwz     r10,492(r1)
fffa1a7c:	38 61 00 08 	addi    r3,r1,8
fffa1a80:	39 4a 01 8c 	addi    r10,r10,396
fffa1a84:	7d 44 53 78 	mr      r4,r10
fffa1a88:	7f a5 eb 78 	mr      r5,r29
fffa1a8c:	91 41 01 e8 	stw     r10,488(r1)
fffa1a90:	4b ff f9 39 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    SHA512_Hash(hashDataBuff, size, &digest);
fffa1a94:	38 61 00 08 	addi    r3,r1,8
fffa1a98:	7f a4 eb 78 	mr      r4,r29
fffa1a9c:	38 a1 01 98 	addi    r5,r1,408
fffa1aa0:	48 00 30 bd 	bl      fffa4b5c <SHA512_Hash>
    memcpy_byte(hashDataBuff, &prefix->payload_hash, SHA512_DIGEST_LENGTH);
fffa1aa4:	38 61 00 08 	addi    r3,r1,8
fffa1aa8:	38 9e 01 cb 	addi    r4,r30,459
fffa1aac:	38 a0 00 40 	li      r5,64
fffa1ab0:	4b ff f9 19 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    if(memcmp(&hashDataBuff, digest, sizeof(SHA512_t)))
fffa1ab4:	38 61 00 08 	addi    r3,r1,8
fffa1ab8:	38 81 01 98 	addi    r4,r1,408
fffa1abc:	38 a0 00 40 	li      r5,64
fffa1ac0:	48 00 40 45 	bl      fffa5b04 <memcmp>
fffa1ac4:	06 c3 00 0c 	bwz     r3,fffa1adc <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x360>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid prefix payload hash");
fffa1ac8:	3c 60 b7 d2 	lis     r3,-18478
fffa1acc:	4b ff eb f5 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(PREFIX_HASH_TEST);
fffa1ad0:	39 00 ff ff 	li      r8,-1
fffa1ad4:	39 20 80 63 	li      r9,-32669
fffa1ad8:	48 00 01 10 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for valid sw key count
    SBEV_INFO("Prefix Hdr: SW Key Count: %d", get8(&prefix->sw_key_count));
fffa1adc:	3b de 01 c2 	addi    r30,r30,450
fffa1ae0:	7f c3 f3 78 	mr      r3,r30
fffa1ae4:	4b ff fb b5 	bl      fffa1698 <_Z4get8Pv>
fffa1ae8:	64 63 fe 43 	oris    r3,r3,65091
fffa1aec:	4b ff eb d5 	bl      fffa06c0 <pk_trace_tiny>
    if (get8(&prefix->sw_key_count) < SW_KEY_COUNT_MIN ||
fffa1af0:	7f c3 f3 78 	mr      r3,r30
fffa1af4:	4b ff fb a5 	bl      fffa1698 <_Z4get8Pv>
fffa1af8:	06 c3 00 0a 	bwz     r3,fffa1b0c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x390>
            get8(&prefix->sw_key_count) > SW_KEY_COUNT_MAX)
fffa1afc:	7f c3 f3 78 	mr      r3,r30
fffa1b00:	4b ff fb 99 	bl      fffa1698 <_Z4get8Pv>
        VERIFY_FAILED(PREFIX_HASH_TEST);
    }

    // test for valid sw key count
    SBEV_INFO("Prefix Hdr: SW Key Count: %d", get8(&prefix->sw_key_count));
    if (get8(&prefix->sw_key_count) < SW_KEY_COUNT_MIN ||
fffa1b04:	28 03 00 03 	cmplwi  r3,3
fffa1b08:	40 81 00 18 	ble     fffa1b20 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x3a4>
            get8(&prefix->sw_key_count) > SW_KEY_COUNT_MAX)
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : sw key count not between 1-3");
fffa1b0c:	3c 60 2f a0 	lis     r3,12192
fffa1b10:	4b ff eb b1 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(SW_KEY_INVALID_COUNT);
fffa1b14:	39 00 ff ff 	li      r8,-1
fffa1b18:	39 20 80 65 	li      r9,-32667
fffa1b1c:	48 00 00 cc 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // finish procesing prefix header
    // test for protection of all sw key material (sanity check)
    if(size != (get8(&prefix->sw_key_count) * sizeof(ecc_key_t)))
fffa1b20:	7f c3 f3 78 	mr      r3,r30
fffa1b24:	4b ff fb 75 	bl      fffa1698 <_Z4get8Pv>
fffa1b28:	1c 63 00 84 	mulli   r3,r3,132
fffa1b2c:	04 dd 18 0c 	cmpwbeq r29,r3,fffa1b44 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x3c8>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : incomplete sw key protection in prefix header");
fffa1b30:	3c 60 9d 3a 	lis     r3,-25286
fffa1b34:	4b ff eb 8d 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(SW_KEY_PROTECTION_TEST);
fffa1b38:	39 00 ff ff 	li      r8,-1
fffa1b3c:	39 20 80 64 	li      r9,-32668
fffa1b40:	48 00 00 a8 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // start processing sw header
    header = (ROM_sw_header_raw*)(hw_data->sw_pkey_p + get8(&prefix->sw_key_count)*sizeof(ecc_key_t));
fffa1b44:	7f c3 f3 78 	mr      r3,r30
fffa1b48:	4b ff fb 51 	bl      fffa1698 <_Z4get8Pv>
fffa1b4c:	81 21 01 e8 	lwz     r9,488(r1)
fffa1b50:	1c 63 00 84 	mulli   r3,r3,132
fffa1b54:	7f a9 1a 14 	add     r29,r9,r3

    // test for fw secure version - compare what was passed in via
    // params.log to what the container's sw header has
    SBEV_INFO("SW Hdr: Secure Version: %d", get8(&header->fw_secure_version));
fffa1b58:	3b 9d 00 18 	addi    r28,r29,24
fffa1b5c:	7f 83 e3 78 	mr      r3,r28
fffa1b60:	4b ff fb 39 	bl      fffa1698 <_Z4get8Pv>
fffa1b64:	64 63 d7 b5 	oris    r3,r3,55221
fffa1b68:	4b ff eb 59 	bl      fffa06c0 <pk_trace_tiny>
    if(get8(&header->fw_secure_version) < i_fw_secure_version)
fffa1b6c:	7f 83 e3 78 	mr      r3,r28
fffa1b70:	4b ff fb 29 	bl      fffa1698 <_Z4get8Pv>
fffa1b74:	81 41 01 fc 	lwz     r10,508(r1)
fffa1b78:	55 49 06 3e 	clrlwi  r9,r10,24
fffa1b7c:	05 03 48 0c 	cmplwbge r3,r9,fffa1b94 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x418>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : bad container fw secure version");
fffa1b80:	3c 60 01 7e 	lis     r3,382
fffa1b84:	4b ff eb 3d 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(SECURE_VERSION_TEST);
fffa1b88:	39 00 ff ff 	li      r8,-1
fffa1b8c:	39 20 80 90 	li      r9,-32624
fffa1b90:	48 00 00 58 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for valid header version, hash & signature algorithms (sanity check)
    if(!valid_ver_alg(&header->ver_alg, 0))
fffa1b94:	7f a3 eb 78 	mr      r3,r29
fffa1b98:	38 80 00 00 	li      r4,0
fffa1b9c:	4b ff fb 2d 	bl      fffa16c8 <_ZL13valid_ver_algP15ROM_version_rawh>
fffa1ba0:	06 43 00 0c 	bwnz    r3,fffa1bb8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x43c>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : bad sw header version,alg's");
fffa1ba4:	3c 60 01 20 	lis     r3,288
fffa1ba8:	4b ff eb 19 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(HEADER_VER_ALG_TEST);
fffa1bac:	39 00 ff ff 	li      r8,-1
fffa1bb0:	39 20 80 23 	li      r9,-32733
fffa1bb4:	48 00 00 34 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for machine specific matching ecid
    SBEV_INFO("SW Hdr: ECID Count: %d",get8(&header->ecid_count));
fffa1bb8:	3b 9d 00 61 	addi    r28,r29,97
fffa1bbc:	7f 83 e3 78 	mr      r3,r28
fffa1bc0:	4b ff fa d9 	bl      fffa1698 <_Z4get8Pv>
fffa1bc4:	64 63 b7 51 	oris    r3,r3,46929
fffa1bc8:	4b ff ea f9 	bl      fffa06c0 <pk_trace_tiny>
    //Need not copy  header->ecid to SRAM as it is not de-referenced.
    if(!valid_ecid(get8(&header->ecid_count), header->ecid, params->my_ecid))
fffa1bcc:	7f 83 e3 78 	mr      r3,r28
fffa1bd0:	4b ff fa c9 	bl      fffa1698 <_Z4get8Pv>
static int valid_ecid(int ecid_count, uint8_t* ecids, uint8_t* hw_ecid)
{
    #define SBEV_FUNC " valid_ecid "
    SBEV_ENTER(SBEV_FUNC);

    if (ecid_count == 0)
fffa1bd4:	06 c3 00 10 	bwz     r3,fffa1bf4 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x478>
    // test for machine specific matching ecid
    SBEV_INFO("SW Hdr: ECID Count: %d",get8(&header->ecid_count));
    //Need not copy  header->ecid to SRAM as it is not de-referenced.
    if(!valid_ecid(get8(&header->ecid_count), header->ecid, params->my_ecid))
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : unauthorized SW ecid");
fffa1bd8:	3c 60 dd 0c 	lis     r3,-8948
fffa1bdc:	4b ff ea e5 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(HEADER_ECID_TEST);
fffa1be0:	39 00 ff ff 	li      r8,-1
fffa1be4:	39 20 80 71 	li      r9,-32655
fffa1be8:	19 1f 00 58 	stvd    d8,88(r31)
fffa1bec:	38 60 00 01 	li      r3,1
fffa1bf0:	48 00 02 2c 	b       fffa1e1c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x6a0>
    }

    sw_sig = (ROM_sw_sig_raw*) (header->ecid + get8(&header->ecid_count)*ECID_SIZE);
fffa1bf4:	7f 83 e3 78 	mr      r3,r28
fffa1bf8:	4b ff fa a1 	bl      fffa1698 <_Z4get8Pv>
fffa1bfc:	54 63 20 36 	rlwinm  r3,r3,4,0,27
fffa1c00:	38 dd 00 62 	addi    r6,r29,98
fffa1c04:	7c c6 1a 14 	add     r6,r6,r3

    swKeyCount = get8(&prefix->sw_key_count);
fffa1c08:	7f c3 f3 78 	mr      r3,r30
fffa1c0c:	90 c1 02 00 	stw     r6,512(r1)
fffa1c10:	4b ff fa 89 	bl      fffa1698 <_Z4get8Pv>
fffa1c14:	7c 7e 1b 78 	mr      r30,r3
    //Calculate Hash of SW/FW header
    memcpy_byte(hashDataBuff, header, SW_HEADER_SIZE(header));
fffa1c18:	7f 83 e3 78 	mr      r3,r28
fffa1c1c:	4b ff fa 7d 	bl      fffa1698 <_Z4get8Pv>
fffa1c20:	54 65 20 36 	rlwinm  r5,r3,4,0,27
fffa1c24:	7f a4 eb 78 	mr      r4,r29
fffa1c28:	38 a5 00 62 	addi    r5,r5,98
fffa1c2c:	38 61 00 08 	addi    r3,r1,8
fffa1c30:	4b ff f7 99 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    SHA512_Hash(hashDataBuff, SW_HEADER_SIZE(header), &digest);
fffa1c34:	7f 83 e3 78 	mr      r3,r28
fffa1c38:	4b ff fa 61 	bl      fffa1698 <_Z4get8Pv>
fffa1c3c:	54 64 20 36 	rlwinm  r4,r3,4,0,27
fffa1c40:	38 84 00 62 	addi    r4,r4,98
fffa1c44:	38 61 00 08 	addi    r3,r1,8
fffa1c48:	38 a1 01 98 	addi    r5,r1,408
fffa1c4c:	48 00 2f 11 	bl      fffa4b5c <SHA512_Hash>

    // test for valid sw header signatures (all)
    if(!multi_key_verify(digest, swKeyCount, hw_data->sw_pkey_p,
                                  sw_sig->sw_sig_p,VERIFY_SW_SIG_P))
fffa1c50:	80 a1 01 e8 	lwz     r5,488(r1)
fffa1c54:	80 c1 02 00 	lwz     r6,512(r1)
fffa1c58:	38 61 01 98 	addi    r3,r1,408
fffa1c5c:	7f c4 f3 78 	mr      r4,r30
fffa1c60:	38 e0 00 00 	li      r7,0
fffa1c64:	4b ff f7 89 	bl      fffa13ec <_ZL16multi_key_verifyPhiS_S_i>
    //Calculate Hash of SW/FW header
    memcpy_byte(hashDataBuff, header, SW_HEADER_SIZE(header));
    SHA512_Hash(hashDataBuff, SW_HEADER_SIZE(header), &digest);

    // test for valid sw header signatures (all)
    if(!multi_key_verify(digest, swKeyCount, hw_data->sw_pkey_p,
fffa1c68:	06 43 00 0c 	bwnz    r3,fffa1c80 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x504>
                                  sw_sig->sw_sig_p,VERIFY_SW_SIG_P))
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid sw signature");
fffa1c6c:	3c 60 ae 57 	lis     r3,-20905
fffa1c70:	4b ff ea 51 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(SW_SIGNATURE_TEST);
fffa1c74:	39 00 ff ff 	li      r8,-1
fffa1c78:	39 20 80 70 	li      r9,-32656
fffa1c7c:	4b ff ff 6c 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for entry point within protected payload (sanity check)
    params->entry_point = get64(&header->code_start_offset);
fffa1c80:	38 7d 00 04 	addi    r3,r29,4
fffa1c84:	4b ff f9 85 	bl      fffa1608 <_Z5get64Pv>
fffa1c88:	18 7f 00 50 	stvd    d3,80(r31)
    //check if the entry is HRMOR-relative and aligned
    if(params->entry_point & ~(ENTRY_MASK))
fffa1c8c:	54 63 00 00 	rlwinm  r3,r3,0,0,0
fffa1c90:	54 84 07 be 	clrlwi  r4,r4,30
fffa1c94:	7c 64 23 78 	or      r4,r3,r4
fffa1c98:	06 c4 00 0c 	bwz     r4,fffa1cb0 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x534>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : entry is not HRMOR relative or not aligned");
fffa1c9c:	3c 60 ee 40 	lis     r3,-4544
fffa1ca0:	4b ff ea 21 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(ENTRY_VALID_TEST);
fffa1ca4:	39 00 ff ff 	li      r8,-1
fffa1ca8:	39 20 80 80 	li      r9,-32640
fffa1cac:	4b ff ff 3c 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    // test for valid sw payload hash
    SBEV_INFO("SW/FW Hdr: Payload Size: %d", get64(&header->payload_size));
fffa1cb0:	3b dd 00 19 	addi    r30,r29,25
fffa1cb4:	7f c3 f3 78 	mr      r3,r30
fffa1cb8:	4b ff f9 51 	bl      fffa1608 <_Z5get64Pv>
fffa1cbc:	3c 60 24 1d 	lis     r3,9245
fffa1cc0:	60 63 00 01 	ori     r3,r3,1
fffa1cc4:	7c 85 23 78 	mr      r5,r4
fffa1cc8:	38 c0 00 00 	li      r6,0
fffa1ccc:	38 e0 00 00 	li      r7,0
fffa1cd0:	39 00 00 00 	li      r8,0
    if(get64(&header->component_id) == HBBL_SECURE_HDR_COMPONENT_ID)
fffa1cd4:	3b 9d 00 0c 	addi    r28,r29,12
        SBEV_ERROR(SBEV_FUNC "FAILED : entry is not HRMOR relative or not aligned");
        VERIFY_FAILED(ENTRY_VALID_TEST);
    }

    // test for valid sw payload hash
    SBEV_INFO("SW/FW Hdr: Payload Size: %d", get64(&header->payload_size));
fffa1cd8:	48 00 1e 79 	bl      fffa3b50 <pk_trace_big>
    if(get64(&header->component_id) == HBBL_SECURE_HDR_COMPONENT_ID)
fffa1cdc:	7f 83 e3 78 	mr      r3,r28
fffa1ce0:	4b ff f9 29 	bl      fffa1608 <_Z5get64Pv>
fffa1ce4:	3d 20 48 42 	lis     r9,18498
fffa1ce8:	61 29 42 4c 	ori     r9,r9,16972
fffa1cec:	04 43 48 0c 	cmpwbne r3,r9,fffa1d04 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x588>
fffa1cf0:	06 44 00 0a 	bwnz    r4,fffa1d04 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x588>
    {
        SHA512_HBBL_Payload_Hash(&digest, &sectionSize);
fffa1cf4:	38 61 01 98 	addi    r3,r1,408
fffa1cf8:	38 81 01 d8 	addi    r4,r1,472
fffa1cfc:	4b ff f8 25 	bl      fffa1520 <_ZL24SHA512_HBBL_Payload_HashPA64_hPy>
fffa1d00:	48 00 00 44 	b       fffa1d44 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x5c8>
    }
    else if(get64(&header->component_id) == FW_SECURE_HDR_COMPONENT_ID)
fffa1d04:	7f 83 e3 78 	mr      r3,r28
fffa1d08:	4b ff f9 01 	bl      fffa1608 <_Z5get64Pv>
fffa1d0c:	3d 20 53 42 	lis     r9,21314
fffa1d10:	61 29 45 5f 	ori     r9,r9,17759
fffa1d14:	04 43 48 0e 	cmpwbne r3,r9,fffa1d30 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x5b4>
fffa1d18:	3d 20 46 57 	lis     r9,18007
fffa1d1c:	04 44 48 0a 	cmpwbne r4,r9,fffa1d30 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x5b4>
    {
        SHA512_FW_Payload_Hash(&digest, &sectionSize);
fffa1d20:	38 61 01 98 	addi    r3,r1,408
fffa1d24:	38 81 01 d8 	addi    r4,r1,472
fffa1d28:	4b ff f8 55 	bl      fffa157c <_ZL22SHA512_FW_Payload_HashPA64_hPy>
fffa1d2c:	48 00 00 18 	b       fffa1d44 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x5c8>
    }
    else
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid component ID . SBE Check");
fffa1d30:	3c 60 21 e0 	lis     r3,8672
fffa1d34:	4b ff e9 8d 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(COMPONENT_ID_TEST);
fffa1d38:	39 00 ff ff 	li      r8,-1
fffa1d3c:	39 20 80 74 	li      r9,-32652
fffa1d40:	4b ff fe a8 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    if(get64(&header->payload_size) != sectionSize)
fffa1d44:	7f c3 f3 78 	mr      r3,r30
fffa1d48:	4b ff f8 c1 	bl      fffa1608 <_Z5get64Pv>
fffa1d4c:	81 21 01 d8 	lwz     r9,472(r1)
fffa1d50:	04 49 18 06 	cmpwbne r9,r3,fffa1d5c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x5e0>
fffa1d54:	81 21 01 dc 	lwz     r9,476(r1)
fffa1d58:	04 c9 20 1c 	cmpwbeq r9,r4,fffa1d90 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x614>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : Invalid payload section size exp:%d, act:%d",
fffa1d5c:	7f c3 f3 78 	mr      r3,r30
fffa1d60:	4b ff f8 a9 	bl      fffa1608 <_Z5get64Pv>
                   get64(&header->payload_size),sectionSize);
fffa1d64:	80 a1 01 d8 	lwz     r5,472(r1)
fffa1d68:	3c 60 3e 68 	lis     r3,15976
fffa1d6c:	80 c1 01 dc 	lwz     r6,476(r1)
fffa1d70:	39 00 00 00 	li      r8,0
fffa1d74:	60 63 00 02 	ori     r3,r3,2
fffa1d78:	7c 85 2b 78 	or      r5,r4,r5
fffa1d7c:	38 e0 00 00 	li      r7,0
fffa1d80:	48 00 1d d1 	bl      fffa3b50 <pk_trace_big>
        VERIFY_FAILED(SW_PAYLD_SZ_TEST);
fffa1d84:	39 00 ff ff 	li      r8,-1
fffa1d88:	39 20 80 68 	li      r9,-32664
fffa1d8c:	4b ff fe 5c 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
fffa1d90:	3b c1 01 98 	addi    r30,r1,408
fffa1d94:	3b 81 01 d8 	addi    r28,r1,472
    }

    for (uint8_t i=0; i<sizeof(digest); i=i+4)
    {
        SBEV_INFO("SHA512 of payload is %x %x %x %x",
                digest[i],digest[i+1],digest[i+2],digest[i+3]);
fffa1d98:	88 be 00 00 	lbz     r5,0(r30)
fffa1d9c:	88 de 00 01 	lbz     r6,1(r30)
fffa1da0:	88 fe 00 02 	lbz     r7,2(r30)
fffa1da4:	89 1e 00 03 	lbz     r8,3(r30)
fffa1da8:	3c 60 82 e1 	lis     r3,-32031
fffa1dac:	60 63 00 04 	ori     r3,r3,4
fffa1db0:	3b de 00 04 	addi    r30,r30,4
fffa1db4:	48 00 1d 9d 	bl      fffa3b50 <pk_trace_big>
        SBEV_ERROR(SBEV_FUNC "FAILED : Invalid payload section size exp:%d, act:%d",
                   get64(&header->payload_size),sectionSize);
        VERIFY_FAILED(SW_PAYLD_SZ_TEST);
    }

    for (uint8_t i=0; i<sizeof(digest); i=i+4)
fffa1db8:	04 5c f7 f0 	cmpwbne r28,r30,fffa1d98 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x61c>
    {
        SBEV_INFO("SHA512 of payload is %x %x %x %x",
                digest[i],digest[i+1],digest[i+2],digest[i+3]);
    }
    memcpy_byte(hashDataBuff, &header->payload_hash, SHA512_DIGEST_LENGTH);
fffa1dbc:	38 61 00 08 	addi    r3,r1,8
fffa1dc0:	38 9d 00 21 	addi    r4,r29,33
fffa1dc4:	38 a0 00 40 	li      r5,64
fffa1dc8:	4b ff f6 01 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    //Return the calculated SHA512.
    memcpy(SHA512Result, digest, sizeof(SHA512_t));
fffa1dcc:	80 61 01 f4 	lwz     r3,500(r1)
fffa1dd0:	38 81 01 98 	addi    r4,r1,408
fffa1dd4:	38 a0 00 40 	li      r5,64
fffa1dd8:	48 00 3c 9d 	bl      fffa5a74 <memcpy>
    if(memcmp(&hashDataBuff, digest, sizeof(SHA512_t)))
fffa1ddc:	38 61 00 08 	addi    r3,r1,8
fffa1de0:	38 81 01 98 	addi    r4,r1,408
fffa1de4:	38 a0 00 40 	li      r5,64
fffa1de8:	48 00 3d 1d 	bl      fffa5b04 <memcmp>
fffa1dec:	06 c3 00 0c 	bwz     r3,fffa1e04 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x688>
    {
        SBEV_ERROR(SBEV_FUNC "FAILED : invalid sw payload hash");
fffa1df0:	3c 60 c9 11 	lis     r3,-14063
fffa1df4:	4b ff e8 cd 	bl      fffa06c0 <pk_trace_tiny>
        VERIFY_FAILED(HEADER_HASH_TEST);
fffa1df8:	39 00 ff ff 	li      r8,-1
fffa1dfc:	39 20 80 72 	li      r9,-32654
fffa1e00:	4b ff fd e8 	b       fffa1be8 <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm+0x46c>
    }

    SBEV_INFO("Secure HDR Verified");
fffa1e04:	3c 60 38 43 	lis     r3,14403
fffa1e08:	4b ff e8 b9 	bl      fffa06c0 <pk_trace_tiny>
    params->log=CONTEXT|COMPLETED;
fffa1e0c:	39 00 00 00 	li      r8,0
fffa1e10:	39 20 00 03 	li      r9,3
fffa1e14:	19 1f 00 58 	stvd    d8,88(r31)

    SBEV_EXIT(SBEV_FUNC);
    return ROM_DONE;
fffa1e18:	38 60 00 00 	li      r3,0
    #undef SBEV_FUNC
}
fffa1e1c:	80 01 02 1c 	lwz     r0,540(r1)
fffa1e20:	17 81 02 08 	lvd     d28,520(r1)
fffa1e24:	7c 08 03 a6 	mtlr    r0
fffa1e28:	17 c1 02 10 	lvd     d30,528(r1)
fffa1e2c:	38 21 02 18 	addi    r1,r1,536
fffa1e30:	4e 80 00 20 	blr

fffa1e34 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse>:

ROM_response verifySecureHdr(p9_xip_section_sbe_t secureHdrXipSection, int hw_sig_to_verify, secureHdrResponse_t *secureHdrResponse)
{
fffa1e34:	94 21 ff 38 	stwu    r1,-200(r1)
fffa1e38:	7c 08 02 a6 	mflr    r0
    #define SBEV_FUNC " verifySecureHdr "
    SBEV_ENTER(SBEV_FUNC);
    ROM_response status;
    SHA512_t digest;
    uint64_t sectionSize = 0;
fffa1e3c:	39 20 00 00 	li      r9,0
fffa1e40:	39 00 00 00 	li      r8,0
    return ROM_DONE;
    #undef SBEV_FUNC
}

ROM_response verifySecureHdr(p9_xip_section_sbe_t secureHdrXipSection, int hw_sig_to_verify, secureHdrResponse_t *secureHdrResponse)
{
fffa1e44:	1b 81 00 b8 	stvd    d28,184(r1)
fffa1e48:	1b c1 00 c0 	stvd    d30,192(r1)
fffa1e4c:	7c 9d 23 78 	mr      r29,r4
fffa1e50:	7c 7f 1b 78 	mr      r31,r3

    // Declare local input struct
    ROM_hw_params l_hw_parms;
    // Clear/zero-out the struct since we want 0 ('zero') values for
    // struct elements my_ecid, entry_point and log
    memset(&l_hw_parms,0x00,sizeof(ROM_hw_params));
fffa1e54:	38 80 00 00 	li      r4,0
    return ROM_DONE;
    #undef SBEV_FUNC
}

ROM_response verifySecureHdr(p9_xip_section_sbe_t secureHdrXipSection, int hw_sig_to_verify, secureHdrResponse_t *secureHdrResponse)
{
fffa1e58:	7c be 2b 78 	mr      r30,r5

    // Declare local input struct
    ROM_hw_params l_hw_parms;
    // Clear/zero-out the struct since we want 0 ('zero') values for
    // struct elements my_ecid, entry_point and log
    memset(&l_hw_parms,0x00,sizeof(ROM_hw_params));
fffa1e5c:	38 61 00 08 	addi    r3,r1,8
fffa1e60:	38 a0 00 60 	li      r5,96
    return ROM_DONE;
    #undef SBEV_FUNC
}

ROM_response verifySecureHdr(p9_xip_section_sbe_t secureHdrXipSection, int hw_sig_to_verify, secureHdrResponse_t *secureHdrResponse)
{
fffa1e64:	90 01 00 cc 	stw     r0,204(r1)
    #define SBEV_FUNC " verifySecureHdr "
    SBEV_ENTER(SBEV_FUNC);
    ROM_response status;
    SHA512_t digest;
    uint64_t sectionSize = 0;
fffa1e68:	19 01 00 a8 	stvd    d8,168(r1)

    // Declare local input struct
    ROM_hw_params l_hw_parms;
    // Clear/zero-out the struct since we want 0 ('zero') values for
    // struct elements my_ecid, entry_point and log
    memset(&l_hw_parms,0x00,sizeof(ROM_hw_params));
fffa1e6c:	48 00 3b 35 	bl      fffa59a0 <memset>
static void populateHWParams(ROM_hw_params* params)
{
    #define SBEV_FUNC " populateHWParams "
    SBEV_ENTER(SBEV_FUNC);

    SBEV_INFO("SBE Settings(HW Key Hash):Start Offset: [0x%08X] Size: [0x%08X] ", getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS), getXipSize(P9_XIP_SECTION_SBE_SB_SETTINGS));
fffa1e70:	38 60 00 15 	li      r3,21
fffa1e74:	48 00 23 a1 	bl      fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fffa1e78:	7c 7c 1b 78 	mr      r28,r3
fffa1e7c:	38 60 00 15 	li      r3,21
fffa1e80:	48 00 23 a9 	bl      fffa4228 <_Z10getXipSize20p9_xip_section_sbe_t>
fffa1e84:	7c 66 1b 78 	mr      r6,r3
fffa1e88:	3c 60 36 5f 	lis     r3,13919
fffa1e8c:	38 e0 00 00 	li      r7,0
fffa1e90:	39 00 00 00 	li      r8,0
fffa1e94:	7f 85 e3 78 	mr      r5,r28
fffa1e98:	60 63 00 02 	ori     r3,r3,2
fffa1e9c:	48 00 1c b5 	bl      fffa3b50 <pk_trace_big>

    //Populate params struct
    //Get HW key hash from .sb_settings
    memcpy_byte(params->hw_key_hash,(uint8_t *)getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS), SHA512_DIGEST_LENGTH);
fffa1ea0:	38 60 00 15 	li      r3,21
fffa1ea4:	48 00 23 71 	bl      fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fffa1ea8:	7c 64 1b 78 	mr      r4,r3
fffa1eac:	38 a0 00 40 	li      r5,64
fffa1eb0:	38 61 00 08 	addi    r3,r1,8
fffa1eb4:	4b ff f5 15 	bl      fffa13c8 <_ZL11memcpy_bytePvPKvj>
    //Get MSV from .sb_settings
    params->log = get8((uint8_t *)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH));
fffa1eb8:	38 60 00 15 	li      r3,21
fffa1ebc:	48 00 23 59 	bl      fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fffa1ec0:	38 63 00 40 	addi    r3,r3,64
fffa1ec4:	4b ff f7 d5 	bl      fffa1698 <_Z4get8Pv>
fffa1ec8:	90 61 00 64 	stw     r3,100(r1)
fffa1ecc:	39 20 00 00 	li      r9,0
    // Clear/zero-out the struct since we want 0 ('zero') values for
    // struct elements my_ecid, entry_point and log
    memset(&l_hw_parms,0x00,sizeof(ROM_hw_params));
    populateHWParams(&l_hw_parms);

    SBEV_INFO(SBEV_FUNC "Secure Header:Start Offset: [0x%08X] Size: [0x%08X] ", getXipOffsetAbs(secureHdrXipSection), getXipSize(secureHdrXipSection));
fffa1ed0:	7f e3 fb 78 	mr      r3,r31

    //Populate params struct
    //Get HW key hash from .sb_settings
    memcpy_byte(params->hw_key_hash,(uint8_t *)getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS), SHA512_DIGEST_LENGTH);
    //Get MSV from .sb_settings
    params->log = get8((uint8_t *)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH));
fffa1ed4:	91 21 00 60 	stw     r9,96(r1)
    // Clear/zero-out the struct since we want 0 ('zero') values for
    // struct elements my_ecid, entry_point and log
    memset(&l_hw_parms,0x00,sizeof(ROM_hw_params));
    populateHWParams(&l_hw_parms);

    SBEV_INFO(SBEV_FUNC "Secure Header:Start Offset: [0x%08X] Size: [0x%08X] ", getXipOffsetAbs(secureHdrXipSection), getXipSize(secureHdrXipSection));
fffa1ed8:	48 00 23 3d 	bl      fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fffa1edc:	7c 7c 1b 78 	mr      r28,r3
fffa1ee0:	7f e3 fb 78 	mr      r3,r31
fffa1ee4:	48 00 23 45 	bl      fffa4228 <_Z10getXipSize20p9_xip_section_sbe_t>
fffa1ee8:	7c 66 1b 78 	mr      r6,r3
fffa1eec:	3c 60 45 59 	lis     r3,17753
fffa1ef0:	39 00 00 00 	li      r8,0
fffa1ef4:	7f 85 e3 78 	mr      r5,r28
fffa1ef8:	38 e0 00 00 	li      r7,0
fffa1efc:	60 63 00 02 	ori     r3,r3,2
fffa1f00:	48 00 1c 51 	bl      fffa3b50 <pk_trace_big>
    ROM_container_raw* container = (ROM_container_raw *)getXipOffsetAbs(secureHdrXipSection);
fffa1f04:	7f e3 fb 78 	mr      r3,r31
fffa1f08:	48 00 23 0d 	bl      fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>

    status = ROM_verify(container, &l_hw_parms, hw_sig_to_verify, &digest, &secureHdrResponse->flag);
fffa1f0c:	7f a5 eb 78 	mr      r5,r29
fffa1f10:	38 c1 00 68 	addi    r6,r1,104
fffa1f14:	38 fe 00 20 	addi    r7,r30,32
fffa1f18:	38 81 00 08 	addi    r4,r1,8
fffa1f1c:	4b ff f8 61 	bl      fffa177c <_Z10ROM_verifyP17ROM_container_rawP13ROM_hw_paramsiPA64_hPm>
    secureHdrResponse->statusCode = (uint8_t)l_hw_parms.log;
fffa1f20:	80 c1 00 64 	lwz     r6,100(r1)
    populateHWParams(&l_hw_parms);

    SBEV_INFO(SBEV_FUNC "Secure Header:Start Offset: [0x%08X] Size: [0x%08X] ", getXipOffsetAbs(secureHdrXipSection), getXipSize(secureHdrXipSection));
    ROM_container_raw* container = (ROM_container_raw *)getXipOffsetAbs(secureHdrXipSection);

    status = ROM_verify(container, &l_hw_parms, hw_sig_to_verify, &digest, &secureHdrResponse->flag);
fffa1f24:	7c 7d 1b 78 	mr      r29,r3
    secureHdrResponse->statusCode = (uint8_t)l_hw_parms.log;
fffa1f28:	98 de 00 24 	stb     r6,36(r30)
    SBEV_INFO(SBEV_FUNC "Status code is [0x%08X%08X]", SBE::higher32BWord(l_hw_parms.log), SBE::lower32BWord(l_hw_parms.log));
fffa1f2c:	3c 60 06 1c 	lis     r3,1564
fffa1f30:	80 a1 00 60 	lwz     r5,96(r1)
fffa1f34:	60 63 00 02 	ori     r3,r3,2
fffa1f38:	38 e0 00 00 	li      r7,0
fffa1f3c:	39 00 00 00 	li      r8,0
fffa1f40:	48 00 1c 11 	bl      fffa3b50 <pk_trace_big>

    if(status == ROM_DONE && secureHdrResponse->statusCode == COMPLETED)
fffa1f44:	06 5d 00 0e 	bwnz    r29,fffa1f60 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x12c>
fffa1f48:	89 3e 00 24 	lbz     r9,36(r30)
fffa1f4c:	06 49 18 3e 	cmpwibne r9,3,fffa1fc8 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x194>
    {
        // We only want to return a non-zero status on failure
        secureHdrResponse->statusCode = 0;
fffa1f50:	9b be 00 24 	stb     r29,36(r30)
        SBEV_INFO(SBEV_FUNC "Container verification Passed");
fffa1f54:	3c 60 18 db 	lis     r3,6363
fffa1f58:	4b ff e7 69 	bl      fffa06c0 <pk_trace_tiny>
fffa1f5c:	48 00 00 6c 	b       fffa1fc8 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x194>
    }
    else if(status == ROM_FAILED)
fffa1f60:	06 5d 08 34 	cmpwibne r29,1,fffa1fc8 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x194>
fffa1f64:	3b 81 00 a8 	addi    r28,r1,168
    {
        if(secureHdrXipSection == P9_XIP_SECTION_SBE_SBH_FIRMWARE)
fffa1f68:	06 5f 98 10 	cmpwibne r31,19,fffa1f88 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x154>
        {
            SBEV_INFO(SBEV_FUNC "Container verification failed. Calculating SBE_FW Payload SHA512 Hash");
fffa1f6c:	3c 60 5a ec 	lis     r3,23276
fffa1f70:	4b ff e7 51 	bl      fffa06c0 <pk_trace_tiny>
            SHA512_FW_Payload_Hash(&digest, &sectionSize);
fffa1f74:	38 61 00 68 	addi    r3,r1,104
fffa1f78:	7f 84 e3 78 	mr      r4,r28
fffa1f7c:	4b ff f6 01 	bl      fffa157c <_ZL22SHA512_FW_Payload_HashPA64_hPy>
fffa1f80:	3b e1 00 68 	addi    r31,r1,104
fffa1f84:	48 00 00 20 	b       fffa1fa4 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x170>
        }
        else if(secureHdrXipSection == P9_XIP_SECTION_SBE_SBH_HBBL)
fffa1f88:	06 5f a7 fc 	cmpwibne r31,20,fffa1f80 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x14c>
        {
            SBEV_INFO(SBEV_FUNC "Container verification failed. Calculating HBBL Payload SHA512 Hash");
fffa1f8c:	3c 60 94 b2 	lis     r3,-27470
fffa1f90:	4b ff e7 31 	bl      fffa06c0 <pk_trace_tiny>
            SHA512_HBBL_Payload_Hash(&digest, &sectionSize);
fffa1f94:	38 61 00 68 	addi    r3,r1,104
fffa1f98:	7f 84 e3 78 	mr      r4,r28
fffa1f9c:	4b ff f5 85 	bl      fffa1520 <_ZL24SHA512_HBBL_Payload_HashPA64_hPy>
fffa1fa0:	4b ff ff e0 	b       fffa1f80 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x14c>
        }

        for (uint8_t i=0; i<sizeof(digest); i=i+4)
        {
            SBEV_INFO(SBEV_FUNC "SHA512 of payload is %x %x %x %x",
                    digest[i],digest[i+1],digest[i+2],digest[i+3]);
fffa1fa4:	88 bf 00 00 	lbz     r5,0(r31)
fffa1fa8:	88 df 00 01 	lbz     r6,1(r31)
fffa1fac:	88 ff 00 02 	lbz     r7,2(r31)
fffa1fb0:	89 1f 00 03 	lbz     r8,3(r31)
fffa1fb4:	3c 60 b4 ae 	lis     r3,-19282
fffa1fb8:	60 63 00 04 	ori     r3,r3,4
fffa1fbc:	3b ff 00 04 	addi    r31,r31,4
fffa1fc0:	48 00 1b 91 	bl      fffa3b50 <pk_trace_big>
        {
            SBEV_INFO(SBEV_FUNC "Container verification failed. Calculating HBBL Payload SHA512 Hash");
            SHA512_HBBL_Payload_Hash(&digest, &sectionSize);
        }

        for (uint8_t i=0; i<sizeof(digest); i=i+4)
fffa1fc4:	04 5c ff f0 	cmpwbne r28,r31,fffa1fa4 <_Z15verifySecureHdr20p9_xip_section_sbe_tiP17secureHdrResponse+0x170>
            SBEV_INFO(SBEV_FUNC "SHA512 of payload is %x %x %x %x",
                    digest[i],digest[i+1],digest[i+2],digest[i+3]);
        }
    }

    memcpy(&secureHdrResponse->sha512Truncated, digest, sizeof(SHA512truncated_t));
fffa1fc8:	7f c3 f3 78 	mr      r3,r30
fffa1fcc:	38 81 00 68 	addi    r4,r1,104
fffa1fd0:	38 a0 00 20 	li      r5,32
fffa1fd4:	48 00 3a a1 	bl      fffa5a74 <memcpy>

    SBEV_EXIT(SBEV_FUNC);
    return status;
    #undef SBEV_FUNC
}
fffa1fd8:	80 01 00 cc 	lwz     r0,204(r1)
fffa1fdc:	7f a3 eb 78 	mr      r3,r29
fffa1fe0:	7c 08 03 a6 	mtlr    r0
fffa1fe4:	17 81 00 b8 	lvd     d28,184(r1)
fffa1fe8:	17 c1 00 c0 	lvd     d30,192(r1)
fffa1fec:	38 21 00 c8 	addi    r1,r1,200
fffa1ff0:	4e 80 00 20 	blr

fffa1ff4 <_ZN3SBE8isSimicsEv>:
    bool isSimics() __attribute__((alias("__isSimicsRunning")));
    extern "C" void __isSimicsRunning() __attribute__ ((noinline));

    void __isSimicsRunning()
    {
        asm volatile("li 3, 0");
fffa1ff4:	38 60 00 00 	li      r3,0
{
    register int n = _n;
    asm volatile("rlwimi %0,%0,0,%1,%2"       \
        :: "i" (((n) >> 8) & 0x1f),           \
        "i" (((n) >> 4) & 0xf),               \
        "i" ((((n) >> 0) & 0xf) | 16));
fffa1ff8:	53 ff 01 20 	rlwimi  r31,r31,0,4,16
fffa1ffc:	4e 80 00 20 	blr

fffa2000 <_ZN3SBE15isSimicsRunningEv>:
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fffa2000:	89 2d 46 e8 	lbz     r9,18152(r13)
fffa2004:	7d 29 07 74 	extsb   r9,r9
fffa2008:	06 49 00 1a 	bwnz    r9,fffa203c <_ZN3SBE15isSimicsRunningEv+0x3c>
        asm volatile("li 3, 0");
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
fffa200c:	94 21 ff f8 	stwu    r1,-8(r1)
fffa2010:	7c 08 02 a6 	mflr    r0
fffa2014:	90 01 00 0c 	stw     r0,12(r1)
        static bool simics = isSimics();
fffa2018:	4b ff ff dd 	bl      fffa1ff4 <_ZN3SBE8isSimicsEv>
        return simics;
    }
fffa201c:	80 01 00 0c 	lwz     r0,12(r1)
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fffa2020:	98 6d 46 e4 	stb     r3,18148(r13)
        return simics;
    }
fffa2024:	7c 08 03 a6 	mtlr    r0
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fffa2028:	39 20 00 01 	li      r9,1
        return simics;
    }
fffa202c:	88 6d 46 e4 	lbz     r3,18148(r13)
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fffa2030:	99 2d 46 e8 	stb     r9,18152(r13)
        return simics;
    }
fffa2034:	38 21 00 08 	addi    r1,r1,8
fffa2038:	4e 80 00 20 	blr
fffa203c:	88 6d 46 e4 	lbz     r3,18148(r13)
fffa2040:	4e 80 00 20 	blr

fffa2044 <_ZN22securitySwitchReg_PCR16updateEy>:
     *
     * @return - uint32_t word
     */
    inline uint32_t higher32BWord(uint64_t i_lWord)
    {
        return (uint32_t)(SHIFT_RIGHT(MASK_ZERO_L32B_UINT64(i_lWord), 32));
fffa2044:	90 a3 00 00 	stw     r5,0(r3)
    #define SBEV_FUNC "securityState_PCR1::update"
    SBEV_ENTER(SBEV_FUNC);

    //Fetch Security Switch Register
    securitySwitch = SBE::higher32BWord(securitySwitchReg);
    SBEV_INFO("Security Switch Reg [0x%08x 0x%08x]", SBE::higher32BWord(securitySwitchReg), SBE::lower32BWord(securitySwitchReg));
fffa2048:	3c 60 16 0b 	lis     r3,5643
fffa204c:	60 63 00 02 	ori     r3,r3,2
fffa2050:	38 e0 00 00 	li      r7,0
fffa2054:	39 00 00 00 	li      r8,0
fffa2058:	48 00 1a f8 	b       fffa3b50 <pk_trace_big>

fffa205c <_Z22sbevSetSecureAccessBitmm>:
#include "sbeglobals.H"
#include "p10_sbe_scratch_regs.H"
#include "sbevtrace.H"

void sbevSetSecureAccessBit(uint32_t i_secureHdrStatus, uint32_t i_secureHdrFlags)
{
fffa205c:	94 21 ff b0 	stwu    r1,-80(r1)
fffa2060:	39 00 00 00 	li      r8,0
fffa2064:	39 20 00 00 	li      r9,0
fffa2068:	19 01 00 20 	stvd    d8,32(r1)
fffa206c:	19 01 00 18 	stvd    d8,24(r1)
fffa2070:	19 01 00 10 	stvd    d8,16(r1)
fffa2074:	19 01 00 08 	stvd    d8,8(r1)
fffa2078:	1b c1 00 48 	stvd    d30,72(r1)
    uint32_t bitsreserved : 12;           //Bit 36-47 Reserved
    uint32_t pau_freq_in_mhz : 16;        //Bit 48-63 PAU system frequency in MHz

    sbe_local_LFR()
    {
        spi_clock_divider = 0;
fffa207c:	39 20 00 00 	li      r9,0
fffa2080:	3b c0 00 00 	li      r30,0
fffa2084:	51 3e a0 16 	rlwimi  r30,r9,20,0,11
        sec_boot_seeprom = 0;
fffa2088:	51 3e 9b 18 	rlwimi  r30,r9,19,12,12
        sec_meas_seeprom = 0;
fffa208c:	51 3e 93 5a 	rlwimi  r30,r9,18,13,13
        mpipl = 0;
fffa2090:	51 3e 8b 9c 	rlwimi  r30,r9,17,14,14
        ipl_reset = 0;
fffa2094:	51 3e 83 de 	rlwimi  r30,r9,16,15,15
        runtime_reset = 0;
fffa2098:	51 3e 7c 20 	rlwimi  r30,r9,15,16,16
        hreset_done = 0;
fffa209c:	51 3e 74 62 	rlwimi  r30,r9,14,17,17
        mpipl_reset_done = 0;
fffa20a0:	51 3e 6c a4 	rlwimi  r30,r9,13,18,18
    uint32_t bitsreserved : 12;           //Bit 36-47 Reserved
    uint32_t pau_freq_in_mhz : 16;        //Bit 48-63 PAU system frequency in MHz

    sbe_local_LFR()
    {
        spi_clock_divider = 0;
fffa20a4:	3b e0 00 00 	li      r31,0
        mpipl = 0;
        ipl_reset = 0;
        runtime_reset = 0;
        hreset_done = 0;
        mpipl_reset_done = 0;
        round_trip_delay = 0;
fffa20a8:	51 3e 45 2e 	rlwimi  r30,r9,8,20,23
        secure_mode = 0;
        pau_freq_in_mhz = 0;
fffa20ac:	51 3f 04 3e 	rlwimi  r31,r9,0,16,31
fffa20b0:	7c 08 02 a6 	mflr    r0
        ipl_reset = 0;
        runtime_reset = 0;
        hreset_done = 0;
        mpipl_reset_done = 0;
        round_trip_delay = 0;
        secure_mode = 0;
fffa20b4:	51 3e 64 e6 	rlwimi  r30,r9,12,19,19
        pau_freq_in_mhz = 0;
        tpm_spi_clock_freq_Mhz = 0;
        tpm_spi_clock_delay = 0;
fffa20b8:	51 3f e0 06 	rlwimi  r31,r9,28,0,3
        hreset_done = 0;
        mpipl_reset_done = 0;
        round_trip_delay = 0;
        secure_mode = 0;
        pau_freq_in_mhz = 0;
        tpm_spi_clock_freq_Mhz = 0;
fffa20bc:	51 3e 06 3e 	rlwimi  r30,r9,0,24,31
        tpm_spi_clock_delay = 0;
        // This is required else these gets initialised with dummy data
        bitsreserved = 0;
fffa20c0:	51 3f 81 1e 	rlwimi  r31,r9,16,4,15
fffa20c4:	90 01 00 54 	stw     r0,84(r1)
fffa20c8:	1b 81 00 40 	stvd    d28,64(r1)
    fapi2::buffer<uint64_t> scratch_reg3;
    fapi2::buffer<uint64_t> scratch_reg8;
    fapi2::buffer<uint64_t> temp_lfr_reg;
    sbe_local_LFR lfr_reg;
    uint32_t security_mode = 1;
    Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
fffa20cc:	90 61 00 38 	stw     r3,56(r1)
#include "sbeglobals.H"
#include "p10_sbe_scratch_regs.H"
#include "sbevtrace.H"

void sbevSetSecureAccessBit(uint32_t i_secureHdrStatus, uint32_t i_secureHdrFlags)
{
fffa20d0:	7c 9c 23 78 	mr      r28,r4
    fapi2::buffer<uint64_t> scratch_reg3;
    fapi2::buffer<uint64_t> scratch_reg8;
    fapi2::buffer<uint64_t> temp_lfr_reg;
    sbe_local_LFR lfr_reg;
    uint32_t security_mode = 1;
    Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
fffa20d4:	7c 3d 0b 78 	mr      r29,r1
fffa20d8:	48 00 15 8d 	bl      fffa3664 <_ZN5fapi218plat_getChipTargetEv>
fffa20dc:	94 7d 00 28 	stwu    r3,40(r29)

    do
    {
        //Skip evaluating SAB in MPIPL Path only evaluate in cold Ipl path
        // Fetch LFR
        rc = getscom_abs_wrap (&target, 0xc0002040, &temp_lfr_reg());
fffa20e0:	3c 80 c0 00 	lis     r4,-16384
fffa20e4:	60 84 20 40 	ori     r4,r4,8256
fffa20e8:	38 a1 00 08 	addi    r5,r1,8
fffa20ec:	7f a3 eb 78 	mr      r3,r29
fffa20f0:	48 00 14 d1 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
        SBEV_INFO(SBEV_FUNC "LFR Reg before update [0x%08X %08X]",
             ((temp_lfr_reg >> 32) & 0xFFFFFFFF), (temp_lfr_reg & 0xFFFFFFFF));
fffa20f4:	3c 60 13 96 	lis     r3,5014
fffa20f8:	14 a1 00 08 	lvd     d5,8(r1)
fffa20fc:	60 63 00 02 	ori     r3,r3,2
fffa2100:	38 e0 00 00 	li      r7,0
fffa2104:	39 00 00 00 	li      r8,0
fffa2108:	48 00 1a 49 	bl      fffa3b50 <pk_trace_big>
        if(temp_lfr_reg.getBit<14>())
fffa210c:	81 21 00 08 	lwz     r9,8(r1)
fffa2110:	81 41 00 38 	lwz     r10,56(r1)
fffa2114:	07 89 70 08 	bb0wi   r9,14,fffa2124 <_Z22sbevSetSecureAccessBitmm+0xc8>
        {
            SBEV_INFO(SBEV_FUNC "Not evaluating SAB in MPIPL Path");
fffa2118:	3c 60 9b fb 	lis     r3,-25605
fffa211c:	4b ff e5 a5 	bl      fffa06c0 <pk_trace_tiny>
            break;
fffa2120:	48 00 01 c4 	b       fffa22e4 <_Z22sbevSetSecureAccessBitmm+0x288>
        //The above attribute will come directly from the parsing the boot seeprom
        //secure header xip section flags to determine if the SBE should allow
        //secure_mode to be disabled based on the scratch register request
        if(i_secureHdrStatus == 0)  //Secure Header verification failed, security disablement not allowed .
        {
            SBEV_INFO(SBEV_FUNC "Disabling security not allowed since SBE_FW Secure Header Failed");
fffa2124:	3c 60 e2 d9 	lis     r3,-7463

        //FAPI_ATTR_GET(fapi2::ATTR_SECURITY_MODE, FAPI_SYSTEM, security_mode));
        //The above attribute will come directly from the parsing the boot seeprom
        //secure header xip section flags to determine if the SBE should allow
        //secure_mode to be disabled based on the scratch register request
        if(i_secureHdrStatus == 0)  //Secure Header verification failed, security disablement not allowed .
fffa2128:	06 ca 00 0e 	bwz     r10,fffa2144 <_Z22sbevSetSecureAccessBitmm+0xe8>
            security_mode = 1;
        }
        else //Secure Header verification passed
        {
            // Check for SB header flag (0x00080000) that is only possible in imprint signed images
            if ((0x00080000 & i_secureHdrFlags) != 0)
fffa212c:	07 9c 60 0a 	bb0wi   r28,12,fffa2140 <_Z22sbevSetSecureAccessBitmm+0xe4>
            {
                security_mode = 0;
                SBEV_INFO(SBEV_FUNC "Secure Header valid and security disablement allowed");
fffa2130:	3c 60 51 d5 	lis     r3,20949
fffa2134:	4b ff e5 8d 	bl      fffa06c0 <pk_trace_tiny>
        else //Secure Header verification passed
        {
            // Check for SB header flag (0x00080000) that is only possible in imprint signed images
            if ((0x00080000 & i_secureHdrFlags) != 0)
            {
                security_mode = 0;
fffa2138:	3b 80 00 00 	li      r28,0
fffa213c:	48 00 00 10 	b       fffa214c <_Z22sbevSetSecureAccessBitmm+0xf0>
                SBEV_INFO(SBEV_FUNC "Secure Header valid and security disablement allowed");
            }
            else
            {
                security_mode = 1;
                SBEV_INFO(SBEV_FUNC "Secure Header valid and security disablement NOT allowed");
fffa2140:	3c 60 5e 19 	lis     r3,24089
fffa2144:	4b ff e5 7d 	bl      fffa06c0 <pk_trace_tiny>
                security_mode = 0;
                SBEV_INFO(SBEV_FUNC "Secure Header valid and security disablement allowed");
            }
            else
            {
                security_mode = 1;
fffa2148:	3b 80 00 01 	li      r28,1
            }
        }
        // 1 == Secure mode == Disabling security not allowed
        // 0 == Unsecure mode == Disabling security allowed via request in scratch register

        rc = getscom_abs_wrap (&target, scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
fffa214c:	3c 80 00 05 	lis     r4,5
fffa2150:	7f a3 eb 78 	mr      r3,r29
fffa2154:	60 84 00 01 	ori     r4,r4,1
fffa2158:	38 a1 00 20 	addi    r5,r1,32
fffa215c:	48 00 14 65 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
        if(rc)
fffa2160:	06 c3 00 06 	bwz     r3,fffa216c <_Z22sbevSetSecureAccessBitmm+0x110>
        {
            SBEV_ERROR("Failed to read CBS_Control_status register");
fffa2164:	3c 60 b7 8d 	lis     r3,-18547
fffa2168:	48 00 00 38 	b       fffa21a0 <_Z22sbevSetSecureAccessBitmm+0x144>
            pk_halt();
        }
        SBEV_INFO(SBEV_FUNC "CBS_Control_status register [0x%08X %08X]",
                ((cbs_cs_reg >> 32) & 0xFFFFFFFF), (cbs_cs_reg & 0xFFFFFFFF));
fffa216c:	14 a1 00 20 	lvd     d5,32(r1)
fffa2170:	3c 60 71 07 	lis     r3,28935
fffa2174:	60 63 00 02 	ori     r3,r3,2
fffa2178:	38 e0 00 00 	li      r7,0
fffa217c:	39 00 00 00 	li      r8,0
fffa2180:	48 00 19 d1 	bl      fffa3b50 <pk_trace_big>

        rc = getscom_abs_wrap (&target, scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_8_RW, &scratch_reg8());
fffa2184:	3c 80 00 05 	lis     r4,5
fffa2188:	7f a3 eb 78 	mr      r3,r29
fffa218c:	60 84 00 3f 	ori     r4,r4,63
fffa2190:	38 a1 00 10 	addi    r5,r1,16
fffa2194:	48 00 14 2d 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
        if(rc)
fffa2198:	06 c3 00 08 	bwz     r3,fffa21a8 <_Z22sbevSetSecureAccessBitmm+0x14c>
        {
            SBEV_ERROR("Failed to read Scratch register8");
fffa219c:	3c 60 30 60 	lis     r3,12384
fffa21a0:	4b ff e5 21 	bl      fffa06c0 <pk_trace_tiny>
            pk_halt();
fffa21a4:	4b ff e0 01 	bl      fffa01a4 <pk_halt>
        }
        SBEV_INFO(SBEV_FUNC "Scratch register8 [0x%08X %08X]",
             ((scratch_reg8 >> 32) & 0xFFFFFFFF), (scratch_reg8 & 0xFFFFFFFF));
fffa21a8:	14 a1 00 10 	lvd     d5,16(r1)
fffa21ac:	3c 60 0e 0e 	lis     r3,3598
fffa21b0:	60 63 00 02 	ori     r3,r3,2
fffa21b4:	38 e0 00 00 	li      r7,0
fffa21b8:	39 00 00 00 	li      r8,0
fffa21bc:	48 00 19 95 	bl      fffa3b50 <pk_trace_big>
        // Updating Secure mode bit into LFR Bit 19, so that Boot Seeprom can
        // fetch it from here again and interpret what needs to be set for
        // securityOverride mode and allowAttrOverrides, these needs to be
        // passed to hostboot loader
        lfr_reg.secure_mode = security_mode;
        PPE_STVD(0xc0002050, lfr_reg);
fffa21c0:	3d 20 c0 00 	lis     r9,-16384

        // Updating Secure mode bit into LFR Bit 19, so that Boot Seeprom can
        // fetch it from here again and interpret what needs to be set for
        // securityOverride mode and allowAttrOverrides, these needs to be
        // passed to hostboot loader
        lfr_reg.secure_mode = security_mode;
fffa21c4:	53 9e 64 e6 	rlwimi  r30,r28,12,19,19
        PPE_STVD(0xc0002050, lfr_reg);
fffa21c8:	61 29 20 50 	ori     r9,r9,8272
fffa21cc:	1b c9 00 00 	stvd    d30,0(r9)
        rc = getscom_abs_wrap (&target, 0xc0002040, &temp_lfr_reg());
fffa21d0:	3c 80 c0 00 	lis     r4,-16384
fffa21d4:	60 84 20 40 	ori     r4,r4,8256
fffa21d8:	38 a1 00 08 	addi    r5,r1,8
fffa21dc:	7f a3 eb 78 	mr      r3,r29
fffa21e0:	48 00 13 e1 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
        SBEV_INFO(SBEV_FUNC "LFR Reg after update [0x%08X %08X]",
              ((temp_lfr_reg >> 32) & 0xFFFFFFFF), (temp_lfr_reg & 0xFFFFFFFF));
fffa21e4:	3c 60 a2 c4 	lis     r3,-23868
fffa21e8:	14 a1 00 08 	lvd     d5,8(r1)
fffa21ec:	39 00 00 00 	li      r8,0
fffa21f0:	60 63 00 02 	ori     r3,r3,2
fffa21f4:	38 e0 00 00 	li      r7,0
fffa21f8:	48 00 19 59 	bl      fffa3b50 <pk_trace_big>
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa21fc:	15 01 00 20 	lvd     d8,32(r1)
         |0                      0                         1 (ask for disable)        Non-secure |
         |---------------------------------------------------------------------------------------|
         */

        // This will make sense only if C4 pin status on SMD bit is secure i.e. 0
        if(cbs_cs_reg.getBit<5>() == 0)
fffa2200:	07 08 28 1e 	bb1wi   r8,5,fffa223c <_Z22sbevSetSecureAccessBitmm+0x1e0>
fffa2204:	79 08 2e e0 	rldicl  d8,d8,5,59
        {
            SBEV_INFO("2801:Bit5[%d] 2801:Bit4[%d]", cbs_cs_reg.getBit<5>(), cbs_cs_reg.getBit<4>());
fffa2208:	3c 60 73 83 	lis     r3,29571
fffa220c:	60 63 00 02 	ori     r3,r3,2
fffa2210:	38 a0 00 00 	li      r5,0
fffa2214:	55 26 07 fe 	clrlwi  r6,r9,31
fffa2218:	38 e0 00 00 	li      r7,0
fffa221c:	39 00 00 00 	li      r8,0
fffa2220:	48 00 19 31 	bl      fffa3b50 <pk_trace_big>
            if( !(security_mode) && (scratch_reg8.getBit<SCRATCH3_REG_VALID_BIT>()) )
fffa2224:	06 5c 00 26 	bwnz    r28,fffa2270 <_Z22sbevSetSecureAccessBitmm+0x214>
fffa2228:	81 21 00 10 	lwz     r9,16(r1)
fffa222c:	07 09 10 2e 	bb1wi   r9,2,fffa2288 <_Z22sbevSetSecureAccessBitmm+0x22c>
fffa2230:	48 00 00 40 	b       fffa2270 <_Z22sbevSetSecureAccessBitmm+0x214>
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            // This would be a candidate for a fast_mask (see variable_buffer) but
            // we'd need tables for all the integral types which maybe we need to
            // do ...
            iv_data |= (T(~0) >> (TT::bits_per_unit() - C)) << (TT::bits_per_unit() - B -
fffa2234:	65 29 08 00 	oris    r9,r9,2048
fffa2238:	19 21 00 20 	stvd    d9,32(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa223c:	15 01 00 20 	lvd     d8,32(r1)
fffa2240:	79 08 2e e0 	rldicl  d8,d8,5,59
fffa2244:	55 23 07 fe 	clrlwi  r3,r9,31
                // Enable Secure mode
                SBEV_INFO(SBEV_FUNC "Either Security Mode or Scratch8 is not set, Setting SAB by default");
                cbs_cs_reg.setBit<scomt::perv::FSXCOMP_FSXLOG_CBS_CS_SECURE_ACCESS_BIT>();
            }
        }
        SBEV_INFO(SBEV_FUNC "Updating the SAB Bit4[%d]", cbs_cs_reg.getBit<4>());
fffa2248:	64 63 f5 33 	oris    r3,r3,62771
fffa224c:	4b ff e4 75 	bl      fffa06c0 <pk_trace_tiny>
        rc = putscom_abs_wrap (&target, scomt::perv::FSXCOMP_FSXLOG_CBS_CS, cbs_cs_reg());
fffa2250:	3c 80 00 05 	lis     r4,5
fffa2254:	14 a1 00 20 	lvd     d5,32(r1)
fffa2258:	7f a3 eb 78 	mr      r3,r29
fffa225c:	60 84 00 01 	ori     r4,r4,1
fffa2260:	48 00 13 b5 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
        if(rc)
fffa2264:	06 c3 00 40 	bwz     r3,fffa22e4 <_Z22sbevSetSecureAccessBitmm+0x288>
        {
            SBEV_ERROR("Failed to write CBS_Control_status register");
fffa2268:	3c 60 6d 88 	lis     r3,28040
fffa226c:	4b ff ff 34 	b       fffa21a0 <_Z22sbevSetSecureAccessBitmm+0x144>
                cbs_cs_reg.writeBit<scomt::perv::FSXCOMP_FSXLOG_CBS_CS_SECURE_ACCESS_BIT>(!scratch_reg3.getBit<6>());
            }
            else
            {
                // Enable Secure mode
                SBEV_INFO(SBEV_FUNC "Either Security Mode or Scratch8 is not set, Setting SAB by default");
fffa2270:	3c 60 f2 4a 	lis     r3,-3510
fffa2274:	4b ff e4 4d 	bl      fffa06c0 <pk_trace_tiny>
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            // This would be a candidate for a fast_mask (see variable_buffer) but
            // we'd need tables for all the integral types which maybe we need to
            // do ...
            iv_data |= (T(~0) >> (TT::bits_per_unit() - C)) << (TT::bits_per_unit() - B -
fffa2278:	81 21 00 20 	lwz     r9,32(r1)
fffa227c:	65 29 08 00 	oris    r9,r9,2048
fffa2280:	91 21 00 20 	stw     r9,32(r1)
fffa2284:	4b ff ff b8 	b       fffa223c <_Z22sbevSetSecureAccessBitmm+0x1e0>
        {
            SBEV_INFO("2801:Bit5[%d] 2801:Bit4[%d]", cbs_cs_reg.getBit<5>(), cbs_cs_reg.getBit<4>());
            if( !(security_mode) && (scratch_reg8.getBit<SCRATCH3_REG_VALID_BIT>()) )
            {
                SBEV_INFO(SBEV_FUNC "Reading mailbox Scratch Register3 Bit6 to "
                        "check for external security override request");
fffa2288:	3c 60 b8 81 	lis     r3,-18303
fffa228c:	4b ff e4 35 	bl      fffa06c0 <pk_trace_tiny>

                rc = getscom_abs_wrap (&target, scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_3_RW, &scratch_reg3());
fffa2290:	3c 80 00 05 	lis     r4,5
fffa2294:	7f a3 eb 78 	mr      r3,r29
fffa2298:	60 84 00 3a 	ori     r4,r4,58
fffa229c:	38 a1 00 18 	addi    r5,r1,24
fffa22a0:	48 00 13 21 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
                if(rc)
fffa22a4:	06 c3 00 06 	bwz     r3,fffa22b0 <_Z22sbevSetSecureAccessBitmm+0x254>
                {
                    SBEV_ERROR("Failed to read Scratch register3");
fffa22a8:	3c 60 0b 0f 	lis     r3,2831
fffa22ac:	4b ff fe f4 	b       fffa21a0 <_Z22sbevSetSecureAccessBitmm+0x144>
                    pk_halt();
                }
                SBEV_INFO("Scratch register3 [0x%08X %08X] Bit6[%d] Bit7[%d]",
fffa22b0:	14 a1 00 18 	lvd     d5,24(r1)
                        ((scratch_reg3 >> 32) & 0xFFFFFFFF),(scratch_reg3 & 0xFFFFFFFF),
                        scratch_reg3.getBit<6>(), scratch_reg3.getBit<7>());
fffa22b4:	3c 60 fa 70 	lis     r3,-1424
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa22b8:	78 a8 46 20 	rldicl  d8,d5,8,56
fffa22bc:	78 be 3e 60 	rldicl  d30,d5,7,57
fffa22c0:	55 28 07 fe 	clrlwi  r8,r9,31
fffa22c4:	60 63 00 04 	ori     r3,r3,4
fffa22c8:	57 e7 07 fe 	clrlwi  r7,r31,31
fffa22cc:	48 00 18 85 	bl      fffa3b50 <pk_trace_big>
        inline buffer & writeBit(const bool i_value)
        {
            static_assert((B >= 0) &&
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            (i_value == 0) ? clearBit<B, C>() : setBit<B, C>();
fffa22d0:	81 01 00 18 	lwz     r8,24(r1)
fffa22d4:	15 21 00 20 	lvd     d9,32(r1)
fffa22d8:	07 88 37 ae 	bb0wi   r8,6,fffa2234 <_Z22sbevSetSecureAccessBitmm+0x1d8>
        inline buffer & clearBit(void)
        {
            static_assert((B >= 0) &&
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            iv_data &= buffer<T>().template setBit<B, C>().invert();
fffa22dc:	55 29 01 46 	rlwinm  r9,r9,0,5,3
fffa22e0:	4b ff ff a0 	b       fffa2280 <_Z22sbevSetSecureAccessBitmm+0x224>
            SBEV_ERROR("Failed to write CBS_Control_status register");
            pk_halt();
        }
    }while(0);
    SBEV_EXIT(SBEV_FUNC);
}
fffa22e4:	80 01 00 54 	lwz     r0,84(r1)
fffa22e8:	17 81 00 40 	lvd     d28,64(r1)
fffa22ec:	7c 08 03 a6 	mtlr    r0
fffa22f0:	17 c1 00 48 	lvd     d30,72(r1)
fffa22f4:	38 21 00 50 	addi    r1,r1,80
fffa22f8:	4e 80 00 20 	blr

fffa22fc <_Z7BN_COPYPmPKm>:
#define __LITTLE_ENDIAN

#ifdef SPPE_IMAGE

void __attribute__((noinline)) BN_COPY (bn_t *dst, const bn_t *src)
{
fffa22fc:	39 40 00 11 	li      r10,17
fffa2300:	7d 49 03 a6 	mtctr   r10
fffa2304:	39 20 00 00 	li      r9,0
    size_t i;
    for(i=0;i<NWORDS;i++)
    {
        *dst++ = *src++;
fffa2308:	7d 44 48 2e 	lwzx    r10,r4,r9
fffa230c:	7d 43 49 2e 	stwx    r10,r3,r9
fffa2310:	39 29 00 04 	addi    r9,r9,4
#ifdef SPPE_IMAGE

void __attribute__((noinline)) BN_COPY (bn_t *dst, const bn_t *src)
{
    size_t i;
    for(i=0;i<NWORDS;i++)
fffa2314:	42 00 ff f4 	bdnz    fffa2308 <_Z7BN_COPYPmPKm+0xc>
    {
        *dst++ = *src++;
    }
}
fffa2318:	4e 80 00 20 	blr

fffa231c <_Z6bn_shlPmm>:
// acc contains MSW of lower half
//
bn_t bn_shl (bn_t *a, bn_t acc)
{
    bnindex_t i = NWORDS;
    bn_t cf = 0;
fffa231c:	39 40 00 12 	li      r10,18
fffa2320:	7d 49 03 a6 	mtctr   r10

    EC_ASSERT(NULL != a);
    EC_ASSERT(0 == a[0]);

    a += NWORDS;
fffa2324:	39 23 00 44 	addi    r9,r3,68
// acc contains MSW of lower half
//
bn_t bn_shl (bn_t *a, bn_t acc)
{
    bnindex_t i = NWORDS;
    bn_t cf = 0;
fffa2328:	38 60 00 00 	li      r3,0
    EC_ASSERT(NULL != a);
    EC_ASSERT(0 == a[0]);

    a += NWORDS;

    while (0<i--)
fffa232c:	42 40 00 20 	bdz     fffa234c <_Z6bn_shlPmm+0x30>
    {
        cf = *(--a);
fffa2330:	84 69 ff fc 	lwzu    r3,-4(r9)
        *a <<= BN_MSW_UNUSED_BITS;
        *a |= BN_MSW_UNUSED_MASK & (acc >> BN_PRIME_MSW_BITS);
fffa2334:	54 84 ba 7e 	rlwinm  r4,r4,23,9,31
    a += NWORDS;

    while (0<i--)
    {
        cf = *(--a);
        *a <<= BN_MSW_UNUSED_BITS;
fffa2338:	54 6a b8 10 	rlwinm  r10,r3,23,0,8
        *a |= BN_MSW_UNUSED_MASK & (acc >> BN_PRIME_MSW_BITS);
fffa233c:	7d 44 23 78 	or      r4,r10,r4
fffa2340:	90 89 00 00 	stw     r4,0(r9)
        acc = cf;
fffa2344:	7c 64 1b 78 	mr      r4,r3
fffa2348:	4b ff ff e4 	b       fffa232c <_Z6bn_shlPmm+0x10>
    }

    return cf;
}
fffa234c:	4e 80 00 20 	blr

fffa2350 <_Z7bn_dmulmm>:
    bn_t t;

    al = a;
    ah = (hbn_t) (a >> HBN_BITS);
    bl = b;
    bh = (hbn_t) (b >> HBN_BITS);
fffa2350:	54 88 84 3e 	rlwinm  r8,r4,16,16,31
#else
    hbn_t ah, al, bh, bl;
    bn_t t;

    al = a;
    ah = (hbn_t) (a >> HBN_BITS);
fffa2354:	54 6a 84 3e 	rlwinm  r10,r3,16,16,31
    bl = b;
    bh = (hbn_t) (b >> HBN_BITS);
    a = ((bn_t) ah) * bh;         // collects high word
    b = ((bn_t) al) * bl;         // collects low  word
fffa2358:	54 84 04 3e 	clrlwi  r4,r4,16

    al = a;
    ah = (hbn_t) (a >> HBN_BITS);
    bl = b;
    bh = (hbn_t) (b >> HBN_BITS);
    a = ((bn_t) ah) * bh;         // collects high word
fffa235c:	7c ea 41 d6 	mullw   r7,r10,r8
    b = ((bn_t) al) * bl;         // collects low  word
fffa2360:	54 69 04 3e 	clrlwi  r9,r3,16

    t = ((bn_t) ah) * bl;
fffa2364:	7d 4a 21 d6 	mullw   r10,r10,r4
    a += t >> HBN_BITS;
fffa2368:	55 43 84 3e 	rlwinm  r3,r10,16,16,31
    t <<= HBN_BITS;
fffa236c:	55 4a 80 1e 	rlwinm  r10,r10,16,0,15
    al = a;
    ah = (hbn_t) (a >> HBN_BITS);
    bl = b;
    bh = (hbn_t) (b >> HBN_BITS);
    a = ((bn_t) ah) * bh;         // collects high word
    b = ((bn_t) al) * bl;         // collects low  word
fffa2370:	7c 89 21 d6 	mullw   r4,r9,r4

    t = ((bn_t) ah) * bl;
    a += t >> HBN_BITS;
    t <<= HBN_BITS;
    if (b+t < t)
fffa2374:	7c 8a 22 14 	add     r4,r10,r4
    {
        ++a;
fffa2378:	7d 4a 20 10 	subfc   r10,r10,r4
fffa237c:	7d 4a 51 10 	subfe   r10,r10,r10
    }
    b += t;

    t = ((bn_t) al) * bh;
fffa2380:	7d 29 41 d6 	mullw   r9,r9,r8
    bh = (hbn_t) (b >> HBN_BITS);
    a = ((bn_t) ah) * bh;         // collects high word
    b = ((bn_t) al) * bl;         // collects low  word

    t = ((bn_t) ah) * bl;
    a += t >> HBN_BITS;
fffa2384:	7c 63 3a 14 	add     r3,r3,r7
    t <<= HBN_BITS;
    if (b+t < t)
    {
        ++a;
fffa2388:	7d 4a 00 d0 	neg     r10,r10
fffa238c:	7c 63 52 14 	add     r3,r3,r10
    }
    b += t;

    t = ((bn_t) al) * bh;
    a += t >> HBN_BITS;
fffa2390:	55 2a 84 3e 	rlwinm  r10,r9,16,16,31
    t <<= HBN_BITS;
fffa2394:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
    if (b+t < t)
fffa2398:	7c 84 4a 14 	add     r4,r4,r9
    {
        ++a;
fffa239c:	7d 29 20 10 	subfc   r9,r9,r4
fffa23a0:	7d 29 49 10 	subfe   r9,r9,r9
        ++a;
    }
    b += t;

    t = ((bn_t) al) * bh;
    a += t >> HBN_BITS;
fffa23a4:	7c 63 52 14 	add     r3,r3,r10
    t <<= HBN_BITS;
    if (b+t < t)
    {
        ++a;
fffa23a8:	7d 29 00 d0 	neg     r9,r9
fffa23ac:	7c 63 4a 14 	add     r3,r3,r9
    }
    return a;
#endif
}
fffa23b0:	4e 80 00 20 	blr

fffa23b4 <_Z6bn_mulPmPKmS1_>:
 *  delaying carry-collection simplifies multiply loop
 */
// XXX split to half-words' array; get rid of bn_dmul()
//
void bn_mul (bn_t *r, const bn_t *a, const bn_t *b)
{
fffa23b4:	94 21 ff 98 	stwu    r1,-104(r1)
fffa23b8:	7c 08 02 a6 	mflr    r0
fffa23bc:	1b 81 00 58 	stvd    d28,88(r1)
fffa23c0:	18 81 00 38 	stvd    d4,56(r1)

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_dclear(r);
fffa23c4:	38 80 00 00 	li      r4,0
fffa23c8:	38 a0 00 88 	li      r5,136
    memset(cf, 0, sizeof(cf));
fffa23cc:	3b a1 00 08 	addi    r29,r1,8
 *  delaying carry-collection simplifies multiply loop
 */
// XXX split to half-words' array; get rid of bn_dmul()
//
void bn_mul (bn_t *r, const bn_t *a, const bn_t *b)
{
fffa23d0:	90 01 00 6c 	stw     r0,108(r1)
fffa23d4:	1b c1 00 60 	stvd    d30,96(r1)
fffa23d8:	7c 7c 1b 78 	mr      r28,r3

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_dclear(r);
fffa23dc:	48 00 35 c5 	bl      fffa59a0 <memset>
    memset(cf, 0, sizeof(cf));
fffa23e0:	7f a3 eb 78 	mr      r3,r29
fffa23e4:	38 80 00 00 	li      r4,0
fffa23e8:	38 a0 00 22 	li      r5,34
fffa23ec:	48 00 35 b5 	bl      fffa59a0 <memset>
fffa23f0:	81 01 00 38 	lwz     r8,56(r1)

    for (j=0; j<NWORDS; ++j)
fffa23f4:	3b c0 00 00 	li      r30,0
fffa23f8:	39 08 00 40 	addi    r8,r8,64
fffa23fc:	91 01 00 40 	stw     r8,64(r1)
fffa2400:	81 01 00 38 	lwz     r8,56(r1)
fffa2404:	57 c5 10 3a 	rlwinm  r5,r30,2,0,29
fffa2408:	38 c8 ff fc 	addi    r6,r8,-4
fffa240c:	7d 3c 2a 14 	add     r9,r28,r5
fffa2410:	7f fd f2 14 	add     r31,r29,r30
    {
        for (i=0; i<NWORDS; ++i)
        {
            ph = bn_dmul(a[i], b[j]);
fffa2414:	81 01 00 3c 	lwz     r8,60(r1)
fffa2418:	85 46 00 04 	lwzu    r10,4(r6)
fffa241c:	7c 08 28 2e 	lwzx    r0,r8,r5
fffa2420:	7d 43 53 78 	mr      r3,r10
fffa2424:	7c 04 03 78 	mr      r4,r0
fffa2428:	90 01 00 48 	stw     r0,72(r1)
fffa242c:	90 a1 00 54 	stw     r5,84(r1)
fffa2430:	90 c1 00 4c 	stw     r6,76(r1)
fffa2434:	91 21 00 50 	stw     r9,80(r1)
fffa2438:	91 41 00 44 	stw     r10,68(r1)
fffa243c:	4b ff ff 15 	bl      fffa2350 <_Z7bn_dmulmm>
                "addze   %1,%3"
                : "=r" (r[i+j+1]), "=r" (cf[i+j+1])
                : "0" (r[i+j+1]), "1" (cf[i+j+1]), "r" (pl)
                );
#else
            r[i+j] += ph;
fffa2440:	81 21 00 50 	lwz     r9,80(r1)
    for (j=0; j<NWORDS; ++j)
    {
        for (i=0; i<NWORDS; ++i)
        {
            ph = bn_dmul(a[i], b[j]);
            pl = a[i] * b[j];
fffa2444:	80 01 00 48 	lwz     r0,72(r1)
                "addze   %1,%3"
                : "=r" (r[i+j+1]), "=r" (cf[i+j+1])
                : "0" (r[i+j+1]), "1" (cf[i+j+1]), "r" (pl)
                );
#else
            r[i+j] += ph;
fffa2448:	80 89 00 00 	lwz     r4,0(r9)
    for (j=0; j<NWORDS; ++j)
    {
        for (i=0; i<NWORDS; ++i)
        {
            ph = bn_dmul(a[i], b[j]);
            pl = a[i] * b[j];
fffa244c:	81 41 00 44 	lwz     r10,68(r1)
                "addze   %1,%3"
                : "=r" (r[i+j+1]), "=r" (cf[i+j+1])
                : "0" (r[i+j+1]), "1" (cf[i+j+1]), "r" (pl)
                );
#else
            r[i+j] += ph;
fffa2450:	7c 83 22 14 	add     r4,r3,r4
fffa2454:	90 89 00 00 	stw     r4,0(r9)
    for (j=0; j<NWORDS; ++j)
    {
        for (i=0; i<NWORDS; ++i)
        {
            ph = bn_dmul(a[i], b[j]);
            pl = a[i] * b[j];
fffa2458:	7d 40 51 d6 	mullw   r10,r0,r10
                : "=r" (r[i+j+1]), "=r" (cf[i+j+1])
                : "0" (r[i+j+1]), "1" (cf[i+j+1]), "r" (pl)
                );
#else
            r[i+j] += ph;
            if (r[i+j] < ph)
fffa245c:	80 a1 00 54 	lwz     r5,84(r1)
fffa2460:	80 c1 00 4c 	lwz     r6,76(r1)
fffa2464:	05 04 18 08 	cmplwbge r4,r3,fffa2474 <_Z6bn_mulPmPKmS1_+0xc0>
            {
                EC_ASSERT(i+j>0);    // MSW can't carry to left
                (cf[i+j-1])++;
fffa2468:	88 9f ff ff 	lbz     r4,-1(r31)
fffa246c:	38 84 00 01 	addi    r4,r4,1
fffa2470:	98 9f ff ff 	stb     r4,-1(r31)
            }

            r[i+j+1] += pl;
fffa2474:	84 89 00 04 	lwzu    r4,4(r9)
fffa2478:	7c 8a 22 14 	add     r4,r10,r4
fffa247c:	90 89 00 00 	stw     r4,0(r9)
            if (r[i+j+1] < pl)
fffa2480:	05 04 50 08 	cmplwbge r4,r10,fffa2490 <_Z6bn_mulPmPKmS1_+0xdc>
            {
                (cf[i+j])++;
fffa2484:	89 5f 00 00 	lbz     r10,0(r31)
fffa2488:	39 4a 00 01 	addi    r10,r10,1
fffa248c:	99 5f 00 00 	stb     r10,0(r31)
    bn_dclear(r);
    memset(cf, 0, sizeof(cf));

    for (j=0; j<NWORDS; ++j)
    {
        for (i=0; i<NWORDS; ++i)
fffa2490:	81 41 00 40 	lwz     r10,64(r1)
fffa2494:	3b ff 00 01 	addi    r31,r31,1
fffa2498:	04 4a 37 be 	cmpwbne r10,r6,fffa2414 <_Z6bn_mulPmPKmS1_+0x60>
    EC_ASSERT(NULL != b);

    bn_dclear(r);
    memset(cf, 0, sizeof(cf));

    for (j=0; j<NWORDS; ++j)
fffa249c:	3b de 00 01 	addi    r30,r30,1
fffa24a0:	06 5e 8f b0 	cmpwibne r30,17,fffa2400 <_Z6bn_mulPmPKmS1_+0x4c>
fffa24a4:	39 20 00 22 	li      r9,34
fffa24a8:	7d 29 03 a6 	mtctr   r9
            : "0" (r[i]), "r" (cf[i+1])
            );
#else
    for (i=NWORDS+NWORDS; 0<i; )
    {
        if (cf[--i])
fffa24ac:	39 29 ff ff 	addi    r9,r9,-1
fffa24b0:	7c dd 48 ae 	lbzx    r6,r29,r9
fffa24b4:	06 c6 00 14 	bwz     r6,fffa24dc <_Z6bn_mulPmPKmS1_+0x128>
fffa24b8:	55 25 10 3a 	rlwinm  r5,r9,2,0,29
        {
            r[i] += cf[i];
fffa24bc:	7d 5c 28 2e 	lwzx    r10,r28,r5
fffa24c0:	7d 46 52 14 	add     r10,r6,r10
fffa24c4:	7d 5c 29 2e 	stwx    r10,r28,r5
            if (r[i] < cf[i])
fffa24c8:	05 0a 30 0a 	cmplwbge r10,r6,fffa24dc <_Z6bn_mulPmPKmS1_+0x128>
fffa24cc:	7c dd 4a 14 	add     r6,r29,r9
            {
                EC_ASSERT(0 < i);
                cf[i-1]++;
fffa24d0:	89 46 ff ff 	lbz     r10,-1(r6)
fffa24d4:	39 4a 00 01 	addi    r10,r10,1
fffa24d8:	99 46 ff ff 	stb     r10,-1(r6)
fffa24dc:	42 00 ff d0 	bdnz    fffa24ac <_Z6bn_mulPmPKmS1_+0xf8>
            }
        }
#endif
    }
}
fffa24e0:	80 01 00 6c 	lwz     r0,108(r1)
fffa24e4:	17 81 00 58 	lvd     d28,88(r1)
fffa24e8:	7c 08 03 a6 	mtlr    r0
fffa24ec:	17 c1 00 60 	lvd     d30,96(r1)
fffa24f0:	38 21 00 68 	addi    r1,r1,104
fffa24f4:	4e 80 00 20 	blr

fffa24f8 <_Z6bn_cmpPKmS0_>:
}

#else /*  defined(__BIG_ENDIAN) */

int __attribute__((noinline)) bn_cmp (const bn_t *a, const bn_t *b)
{
fffa24f8:	39 40 00 11 	li      r10,17
fffa24fc:	7d 49 03 a6 	mtctr   r10
fffa2500:	39 20 00 00 	li      r9,0
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    for (i=0; i<NWORDS; ++i)
    {
        if (a[i] != b[i])
fffa2504:	7d 43 48 2e 	lwzx    r10,r3,r9
fffa2508:	7d 04 48 2e 	lwzx    r8,r4,r9
fffa250c:	7c 0a 40 40 	cmplw   r10,r8
fffa2510:	41 a2 00 10 	beq     fffa2520 <_Z6bn_cmpPKmS0_+0x28>
        {
            return 1 - ((a[i] < b[i]) <<1);
fffa2514:	41 80 00 1c 	blt     fffa2530 <_Z6bn_cmpPKmS0_+0x38>
fffa2518:	38 60 00 01 	li      r3,1
fffa251c:	4e 80 00 20 	blr
fffa2520:	39 29 00 04 	addi    r9,r9,4
    bnindex_t i;

    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    for (i=0; i<NWORDS; ++i)
fffa2524:	42 00 ff e0 	bdnz    fffa2504 <_Z6bn_cmpPKmS0_+0xc>
        {
            return 1 - ((a[i] < b[i]) <<1);
        }
    }

    return 0;
fffa2528:	38 60 00 00 	li      r3,0
fffa252c:	4e 80 00 20 	blr

    for (i=0; i<NWORDS; ++i)
    {
        if (a[i] != b[i])
        {
            return 1 - ((a[i] < b[i]) <<1);
fffa2530:	38 60 ff ff 	li      r3,-1
        }
    }

    return 0;
}
fffa2534:	4e 80 00 20 	blr

fffa2538 <_Z10bn_is_zeroPKmj>:
{
    EC_ASSERT(NULL != m);
    EC_ASSERT(mn < NWORDS);

    const unsigned char *p2 = (const unsigned char *) m;
    size_t n=sizeof(bn_t)*(NWORDS-mn);
fffa2538:	20 84 00 11 	subfic  r4,r4,17
fffa253c:	54 84 10 3a 	rlwinm  r4,r4,2,0,29

    while (n-- > 0)
fffa2540:	38 84 00 01 	addi    r4,r4,1
fffa2544:	7c 89 03 a6 	mtctr   r4
fffa2548:	39 20 00 00 	li      r9,0
fffa254c:	42 40 00 1c 	bdz     fffa2568 <_Z10bn_is_zeroPKmj+0x30>
fffa2550:	39 29 00 01 	addi    r9,r9,1
fffa2554:	7d 43 4a 14 	add     r10,r3,r9
    {
        if (0 != *p2)
fffa2558:	89 4a ff ff 	lbz     r10,-1(r10)
fffa255c:	06 ca 07 f8 	bwz     r10,fffa254c <_Z10bn_is_zeroPKmj+0x14>
        {
            return !(0 - *p2);
fffa2560:	38 60 00 00 	li      r3,0
        }
        p2 += 1;
    }

    return !0;
}
fffa2564:	4e 80 00 20 	blr
            return !(0 - *p2);
        }
        p2 += 1;
    }

    return !0;
fffa2568:	38 60 00 01 	li      r3,1
fffa256c:	4e 80 00 20 	blr

fffa2570 <_Z6bn_addPmPKm>:
        if (cf)
        {
            cf = (0 == ++aw);
        }
        aw += *b;
        cf |= (aw < *(b--));
fffa2570:	39 40 00 12 	li      r10,18
fffa2574:	7d 49 03 a6 	mtctr   r10
fffa2578:	38 84 00 44 	addi    r4,r4,68
fffa257c:	38 63 00 44 	addi    r3,r3,68
}


void __attribute__((noinline)) bn_add (bn_t *a, const bn_t *b)
{
    bn_t aw, cf = 0;           /* aw: copy of current word to allow a==b */
fffa2580:	39 20 00 00 	li      r9,0
    EC_ASSERT(NULL != b);

    a += NWORDS-1;
    b += NWORDS-1;

    while (0 < i--)
fffa2584:	42 40 00 44 	bdz     fffa25c8 <_Z6bn_addPmPKm+0x58>
    {
        aw = *a;
fffa2588:	85 43 ff fc 	lwzu    r10,-4(r3)
        if (cf)
fffa258c:	06 c9 00 0e 	bwz     r9,fffa25a8 <_Z6bn_addPmPKm+0x38>
        {
            cf = (0 == ++aw);
fffa2590:	39 4a 00 01 	addi    r10,r10,1
fffa2594:	7d 2a 00 d0 	neg     r9,r10
fffa2598:	7d 49 48 38 	and     r9,r10,r9
fffa259c:	7d 29 00 34 	cntlzw  r9,r9
fffa25a0:	21 29 00 1f 	subfic  r9,r9,31
fffa25a4:	55 29 0f fe 	rlwinm  r9,r9,1,31,31
        }
        aw += *b;
fffa25a8:	84 e4 ff fc 	lwzu    r7,-4(r4)
fffa25ac:	7d 4a 3a 14 	add     r10,r10,r7
        cf |= (aw < *(b--));
fffa25b0:	7d 07 50 10 	subfc   r8,r7,r10
fffa25b4:	7d 08 41 10 	subfe   r8,r8,r8
fffa25b8:	7d 08 00 d0 	neg     r8,r8
fffa25bc:	7d 29 43 78 	or      r9,r9,r8
        *(a--) = aw;
fffa25c0:	91 43 00 00 	stw     r10,0(r3)
fffa25c4:	4b ff ff c0 	b       fffa2584 <_Z6bn_addPmPKm+0x14>
    }
}
fffa25c8:	4e 80 00 20 	blr

fffa25cc <_Z6bn_subPmPKm>:
        if (cf)
        {
            cf = (0 == (*a)--);
        }
        bw = *b;
        cf |= (*a < *(b--));
fffa25cc:	39 20 00 12 	li      r9,18
fffa25d0:	7d 29 03 a6 	mtctr   r9
fffa25d4:	39 43 00 44 	addi    r10,r3,68
fffa25d8:	38 84 00 44 	addi    r4,r4,68

// never with order as base
bn_t bn_sub (bn_t *a, const bn_t *b)
{
    bnindex_t i = NWORDS;
    bn_t bw, cf = 0;
fffa25dc:	38 60 00 00 	li      r3,0
    EC_ASSERT(NULL != b);

    a += NWORDS-1;
    b += NWORDS-1;

    while (0 < i--) {
fffa25e0:	42 40 00 4c 	bdz     fffa262c <_Z6bn_subPmPKm+0x60>
        if (cf)
fffa25e4:	06 c3 00 12 	bwz     r3,fffa2608 <_Z6bn_subPmPKm+0x3c>
        {
            cf = (0 == (*a)--);
fffa25e8:	80 6a ff fc 	lwz     r3,-4(r10)
fffa25ec:	39 23 ff ff 	addi    r9,r3,-1
fffa25f0:	91 2a ff fc 	stw     r9,-4(r10)
fffa25f4:	7d 23 00 d0 	neg     r9,r3
fffa25f8:	7c 63 48 38 	and     r3,r3,r9
fffa25fc:	7c 63 00 34 	cntlzw  r3,r3
fffa2600:	20 63 00 1f 	subfic  r3,r3,31
fffa2604:	54 63 0f fe 	rlwinm  r3,r3,1,31,31
        }
        bw = *b;
fffa2608:	84 e4 ff fc 	lwzu    r7,-4(r4)
        cf |= (*a < *(b--));
fffa260c:	85 2a ff fc 	lwzu    r9,-4(r10)
fffa2610:	7d 07 48 10 	subfc   r8,r7,r9
fffa2614:	7d 08 41 10 	subfe   r8,r8,r8
fffa2618:	7d 08 00 d0 	neg     r8,r8
        *(a--) -= bw;
fffa261c:	7d 27 48 50 	subf    r9,r7,r9
        if (cf)
        {
            cf = (0 == (*a)--);
        }
        bw = *b;
        cf |= (*a < *(b--));
fffa2620:	7c 63 43 78 	or      r3,r3,r8
        *(a--) -= bw;
fffa2624:	91 2a 00 00 	stw     r9,0(r10)
fffa2628:	4b ff ff b8 	b       fffa25e0 <_Z6bn_subPmPKm+0x14>
    }

    return cf;
}
fffa262c:	4e 80 00 20 	blr

fffa2630 <_Z14bn_modred_p521PmS_>:
// P521: specific form
// destroys LS bignumber of (a,2*NWORDS)
//
#ifndef EC_POWER64_RED
void bn_modred_p521 (bn_t *r, bn_t *a)
{
fffa2630:	94 21 ff e8 	stwu    r1,-24(r1)
fffa2634:	7c 08 02 a6 	mflr    r0
fffa2638:	1b c1 00 10 	stvd    d30,16(r1)
fffa263c:	7c 9f 23 78 	mr      r31,r4
fffa2640:	90 01 00 1c 	stw     r0,28(r1)
fffa2644:	1b 81 00 08 	stvd    d28,8(r1)
fffa2648:	7c 7e 1b 78 	mr      r30,r3

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != a);
    EC_ASSERT((const bn_t *) r != a);

    al = a+NWORDS;
fffa264c:	3b a4 00 44 	addi    r29,r4,68

    // P521: product is 1042 bits, MSW of double-width bignum always 0
    //
    EC_ASSERT(0 == a[0]);

    BN_COPY(rc, a);
fffa2650:	4b ff fc ad 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_shl(rc, *al);
fffa2654:	80 9f 00 44 	lwz     r4,68(r31)
fffa2658:	7f c3 f3 78 	mr      r3,r30
fffa265c:	4b ff fc c1 	bl      fffa231c <_Z6bn_shlPmm>

    *al &= BN_PRIME_MSW_MASK;
fffa2660:	81 3f 00 44 	lwz     r9,68(r31)

    if (bn_cmp(rc, consts_p()->ec_prime) >= 0)
fffa2664:	7f c3 f3 78 	mr      r3,r30
    EC_ASSERT(0 == a[0]);

    BN_COPY(rc, a);
    bn_shl(rc, *al);

    *al &= BN_PRIME_MSW_MASK;
fffa2668:	55 29 05 fe 	clrlwi  r9,r9,23
fffa266c:	91 3f 00 44 	stw     r9,68(r31)

    if (bn_cmp(rc, consts_p()->ec_prime) >= 0)
fffa2670:	3f e0 ff fa 	lis     r31,-6
fffa2674:	3b ff 71 24 	addi    r31,r31,28964
fffa2678:	7f e4 fb 78 	mr      r4,r31
fffa267c:	4b ff fe 7d 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa2680:	06 83 00 08 	bwltz   r3,fffa2690 <_Z14bn_modred_p521PmS_+0x60>
    {
        bn_sub(rc, consts_p()->ec_prime); // XXX can this happen? (mod-based input)
fffa2684:	7f c3 f3 78 	mr      r3,r30
fffa2688:	7f e4 fb 78 	mr      r4,r31
fffa268c:	4b ff ff 41 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    if (bn_cmp(al, consts_p()->ec_prime) >= 0)
fffa2690:	7f a3 eb 78 	mr      r3,r29
fffa2694:	7f e4 fb 78 	mr      r4,r31
fffa2698:	4b ff fe 61 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa269c:	06 83 00 08 	bwltz   r3,fffa26ac <_Z14bn_modred_p521PmS_+0x7c>
       bn_sub(al, consts_p()->ec_prime);
fffa26a0:	7f a3 eb 78 	mr      r3,r29
fffa26a4:	7f e4 fb 78 	mr      r4,r31
fffa26a8:	4b ff ff 25 	bl      fffa25cc <_Z6bn_subPmPKm>
    {
        EC_ASSERT(!bn_ge_prime(al));         // al must have bitlen <= ec_prime
    }

    bn_add(rc, al);
fffa26ac:	7f c3 f3 78 	mr      r3,r30
fffa26b0:	7f a4 eb 78 	mr      r4,r29
fffa26b4:	4b ff fe bd 	bl      fffa2570 <_Z6bn_addPmPKm>
    if (bn_cmp(rc, consts_p()->ec_prime) >= 0)
fffa26b8:	7f c3 f3 78 	mr      r3,r30
fffa26bc:	7f e4 fb 78 	mr      r4,r31
fffa26c0:	4b ff fe 39 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa26c4:	06 83 00 12 	bwltz   r3,fffa26e8 <_Z14bn_modred_p521PmS_+0xb8>
    {
        bn_sub(rc, consts_p()->ec_prime);
    }
}
fffa26c8:	80 01 00 1c 	lwz     r0,28(r1)
fffa26cc:	17 81 00 08 	lvd     d28,8(r1)
fffa26d0:	7c 08 03 a6 	mtlr    r0
    }

    bn_add(rc, al);
    if (bn_cmp(rc, consts_p()->ec_prime) >= 0)
    {
        bn_sub(rc, consts_p()->ec_prime);
fffa26d4:	7f c3 f3 78 	mr      r3,r30
fffa26d8:	7f e4 fb 78 	mr      r4,r31
    }
}
fffa26dc:	17 c1 00 10 	lvd     d30,16(r1)
fffa26e0:	38 21 00 18 	addi    r1,r1,24
    }

    bn_add(rc, al);
    if (bn_cmp(rc, consts_p()->ec_prime) >= 0)
    {
        bn_sub(rc, consts_p()->ec_prime);
fffa26e4:	4b ff fe e8 	b       fffa25cc <_Z6bn_subPmPKm>
    }
}
fffa26e8:	80 01 00 1c 	lwz     r0,28(r1)
fffa26ec:	17 81 00 08 	lvd     d28,8(r1)
fffa26f0:	7c 08 03 a6 	mtlr    r0
fffa26f4:	17 c1 00 10 	lvd     d30,16(r1)
fffa26f8:	38 21 00 18 	addi    r1,r1,24
fffa26fc:	4e 80 00 20 	blr

fffa2700 <_Z15bn_modmul_primePmPKm>:
    }
}
#endif

void bn_modmul_prime (bn_t *a, const bn_t *b)
{
fffa2700:	94 21 ff 60 	stwu    r1,-160(r1)
fffa2704:	7c 08 02 a6 	mflr    r0
fffa2708:	1b c1 00 98 	stvd    d30,152(r1)
fffa270c:	7c 7f 1b 78 	mr      r31,r3
fffa2710:	7c 85 23 78 	mr      r5,r4
    bn_t prod[ NWORDS+NWORDS ];

    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_mul(prod, a, b);
fffa2714:	38 61 00 08 	addi    r3,r1,8
fffa2718:	7f e4 fb 78 	mr      r4,r31
    }
}
#endif

void bn_modmul_prime (bn_t *a, const bn_t *b)
{
fffa271c:	90 01 00 a4 	stw     r0,164(r1)
    bn_t prod[ NWORDS+NWORDS ];

    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_mul(prod, a, b);
fffa2720:	4b ff fc 95 	bl      fffa23b4 <_Z6bn_mulPmPKmS1_>
#ifdef EC_POWER64_RED
    bn_modred_fast(a, prod);  // accepts upto 46 extra bits => outputs at most 1 extra bit (522)
#else
    bn_modred_p521(a, prod);
fffa2724:	7f e3 fb 78 	mr      r3,r31
fffa2728:	38 81 00 08 	addi    r4,r1,8
fffa272c:	4b ff ff 05 	bl      fffa2630 <_Z14bn_modred_p521PmS_>
#endif
}
fffa2730:	80 01 00 a4 	lwz     r0,164(r1)
fffa2734:	17 c1 00 98 	lvd     d30,152(r1)
fffa2738:	7c 08 03 a6 	mtlr    r0
fffa273c:	38 21 00 a0 	addi    r1,r1,160
fffa2740:	4e 80 00 20 	blr

fffa2744 <_Z20bn_modred_p521_orderPmPKm>:
// so, keep subtracting N until result <N; up to twice is enough
//
// r,a must not overlap
//
void bn_modred_p521_order (bn_t *r, const bn_t *a)
{
fffa2744:	94 21 ff 58 	stwu    r1,-168(r1)
fffa2748:	7c 08 02 a6 	mflr    r0
fffa274c:	1b 81 00 98 	stvd    d28,152(r1)
fffa2750:	7c 9d 23 78 	mr      r29,r4
fffa2754:	90 01 00 ac 	stw     r0,172(r1)
fffa2758:	1b c1 00 a0 	stvd    d30,160(r1)
fffa275c:	7c 7e 1b 78 	mr      r30,r3
    EC_ASSERT(0 == a[0]);

    BN_COPY(r, a);
    bn_shl(r, a[NWORDS]);

    bn_mul(dbl, r, consts_p()->ec_order_qn);
fffa2760:	3f e0 ff fa 	lis     r31,-6

    // P521: product is 1042 bits, MSW of double-width bignum always 0
    //
    EC_ASSERT(0 == a[0]);

    BN_COPY(r, a);
fffa2764:	4b ff fb 99 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_shl(r, a[NWORDS]);
fffa2768:	84 9d 00 44 	lwzu    r4,68(r29)

    bn_mul(dbl, r, consts_p()->ec_order_qn);
fffa276c:	3b ff 71 24 	addi    r31,r31,28964
    // P521: product is 1042 bits, MSW of double-width bignum always 0
    //
    EC_ASSERT(0 == a[0]);

    BN_COPY(r, a);
    bn_shl(r, a[NWORDS]);
fffa2770:	7f c3 f3 78 	mr      r3,r30
fffa2774:	4b ff fb a9 	bl      fffa231c <_Z6bn_shlPmm>

    bn_mul(dbl, r, consts_p()->ec_order_qn);
    bn_shl(dbl, dbl[NWORDS]);            // MS 521 bits of product
fffa2778:	7c 3c 0b 78 	mr      r28,r1
    EC_ASSERT(0 == a[0]);

    BN_COPY(r, a);
    bn_shl(r, a[NWORDS]);

    bn_mul(dbl, r, consts_p()->ec_order_qn);
fffa277c:	38 bf 01 10 	addi    r5,r31,272
fffa2780:	38 61 00 08 	addi    r3,r1,8
fffa2784:	7f c4 f3 78 	mr      r4,r30
fffa2788:	4b ff fc 2d 	bl      fffa23b4 <_Z6bn_mulPmPKmS1_>
    bn_shl(dbl, dbl[NWORDS]);            // MS 521 bits of product
fffa278c:	84 9c 00 4c 	lwzu    r4,76(r28)
fffa2790:	38 61 00 08 	addi    r3,r1,8
fffa2794:	4b ff fb 89 	bl      fffa231c <_Z6bn_shlPmm>
    bn_add(r, dbl);

    bn_mul(dbl, r, consts_p()->ec_order);            // N * floor(A / N)
fffa2798:	3b ff 00 44 	addi    r31,r31,68
    BN_COPY(r, a);
    bn_shl(r, a[NWORDS]);

    bn_mul(dbl, r, consts_p()->ec_order_qn);
    bn_shl(dbl, dbl[NWORDS]);            // MS 521 bits of product
    bn_add(r, dbl);
fffa279c:	7f c3 f3 78 	mr      r3,r30
fffa27a0:	38 81 00 08 	addi    r4,r1,8
fffa27a4:	4b ff fd cd 	bl      fffa2570 <_Z6bn_addPmPKm>

    bn_mul(dbl, r, consts_p()->ec_order);            // N * floor(A / N)
fffa27a8:	7f e5 fb 78 	mr      r5,r31
fffa27ac:	38 61 00 08 	addi    r3,r1,8
fffa27b0:	7f c4 f3 78 	mr      r4,r30
fffa27b4:	4b ff fc 01 	bl      fffa23b4 <_Z6bn_mulPmPKmS1_>
    EC_ASSERT(bn_cmp(dbl, a) <= 0);
    EC_ASSERT(bn_cmp(dbl+NWORDS, a+NWORDS) <= 0);

    BN_COPY(r, a+NWORDS);
fffa27b8:	7f c3 f3 78 	mr      r3,r30
fffa27bc:	7f a4 eb 78 	mr      r4,r29
fffa27c0:	4b ff fb 3d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_sub(r, dbl+NWORDS);               // A - (N * floor(A/N))
fffa27c4:	7f 84 e3 78 	mr      r4,r28
fffa27c8:	7f c3 f3 78 	mr      r3,r30
fffa27cc:	4b ff fe 01 	bl      fffa25cc <_Z6bn_subPmPKm>

    if (bn_cmp(r, consts_p()->ec_order) >= 0)
fffa27d0:	7f c3 f3 78 	mr      r3,r30
fffa27d4:	7f e4 fb 78 	mr      r4,r31
fffa27d8:	4b ff fd 21 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa27dc:	06 83 00 08 	bwltz   r3,fffa27ec <_Z20bn_modred_p521_orderPmPKm+0xa8>
    {
        bn_sub(r, consts_p()->ec_order);
fffa27e0:	7f c3 f3 78 	mr      r3,r30
fffa27e4:	7f e4 fb 78 	mr      r4,r31
fffa27e8:	4b ff fd e5 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    if (bn_cmp(r, consts_p()->ec_order) >= 0)
fffa27ec:	7f c3 f3 78 	mr      r3,r30
fffa27f0:	7f e4 fb 78 	mr      r4,r31
fffa27f4:	4b ff fd 05 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa27f8:	06 83 00 08 	bwltz   r3,fffa2808 <_Z20bn_modred_p521_orderPmPKm+0xc4>
    {
        bn_sub(r, consts_p()->ec_order);       // XXX can this still be 2+ over?
fffa27fc:	7f c3 f3 78 	mr      r3,r30
fffa2800:	7f e4 fb 78 	mr      r4,r31
fffa2804:	4b ff fd c9 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    EC_ASSERT(bn_cmp(r, consts_p()->ec_order) < 0);
}
fffa2808:	80 01 00 ac 	lwz     r0,172(r1)
fffa280c:	17 81 00 98 	lvd     d28,152(r1)
fffa2810:	7c 08 03 a6 	mtlr    r0
fffa2814:	17 c1 00 a0 	lvd     d30,160(r1)
fffa2818:	38 21 00 a8 	addi    r1,r1,168
fffa281c:	4e 80 00 20 	blr

fffa2820 <_Z15bn_modmul_orderPmPKm>:


void bn_modmul_order (bn_t *a, const bn_t *b)
{
fffa2820:	94 21 ff 60 	stwu    r1,-160(r1)
fffa2824:	7c 08 02 a6 	mflr    r0
fffa2828:	1b c1 00 98 	stvd    d30,152(r1)
fffa282c:	7c 7f 1b 78 	mr      r31,r3
fffa2830:	7c 85 23 78 	mr      r5,r4
    bn_t prod[ NWORDS+NWORDS ];

    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_mul(prod, a, b);
fffa2834:	38 61 00 08 	addi    r3,r1,8
fffa2838:	7f e4 fb 78 	mr      r4,r31
    EC_ASSERT(bn_cmp(r, consts_p()->ec_order) < 0);
}


void bn_modmul_order (bn_t *a, const bn_t *b)
{
fffa283c:	90 01 00 a4 	stw     r0,164(r1)
    bn_t prod[ NWORDS+NWORDS ];

    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);

    bn_mul(prod, a, b);
fffa2840:	4b ff fb 75 	bl      fffa23b4 <_Z6bn_mulPmPKmS1_>
    bn_modred_p521_order(a, prod);
fffa2844:	7f e3 fb 78 	mr      r3,r31
fffa2848:	38 81 00 08 	addi    r4,r1,8
fffa284c:	4b ff fe f9 	bl      fffa2744 <_Z20bn_modred_p521_orderPmPKm>
}
fffa2850:	80 01 00 a4 	lwz     r0,164(r1)
fffa2854:	17 c1 00 98 	lvd     d30,152(r1)
fffa2858:	7c 08 03 a6 	mtlr    r0
fffa285c:	38 21 00 a0 	addi    r1,r1,160
fffa2860:	4e 80 00 20 	blr

fffa2864 <_Z9bn_modaddPmPKm>:

// a,b < prime
// never with order as base
//
void bn_modadd (bn_t *a, const bn_t *b)
{
fffa2864:	94 21 ff f0 	stwu    r1,-16(r1)
fffa2868:	7c 08 02 a6 	mflr    r0
fffa286c:	1b c1 00 08 	stvd    d30,8(r1)

    bn_add(a, b);         // P521: can not generate carry (unused MSW bits)
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
fffa2870:	3f e0 ff fa 	lis     r31,-6

// a,b < prime
// never with order as base
//
void bn_modadd (bn_t *a, const bn_t *b)
{
fffa2874:	7c 7e 1b 78 	mr      r30,r3

    bn_add(a, b);         // P521: can not generate carry (unused MSW bits)
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
fffa2878:	3b ff 71 24 	addi    r31,r31,28964

// a,b < prime
// never with order as base
//
void bn_modadd (bn_t *a, const bn_t *b)
{
fffa287c:	90 01 00 14 	stw     r0,20(r1)
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);
    //EC_ASSERT(!bn_ge_prime(a));
    //EC_ASSERT(!bn_ge_prime(b));

    bn_add(a, b);         // P521: can not generate carry (unused MSW bits)
fffa2880:	4b ff fc f1 	bl      fffa2570 <_Z6bn_addPmPKm>
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
fffa2884:	7f c3 f3 78 	mr      r3,r30
fffa2888:	7f e4 fb 78 	mr      r4,r31
fffa288c:	4b ff fc 6d 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa2890:	06 83 00 10 	bwltz   r3,fffa28b0 <_Z9bn_modaddPmPKm+0x4c>
    {
        bn_sub(a, consts_p()->ec_prime);
    }
#endif
}
fffa2894:	80 01 00 14 	lwz     r0,20(r1)
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
    {
        bn_sub(a, consts_p()->ec_prime);
fffa2898:	7f c3 f3 78 	mr      r3,r30
    }
#endif
}
fffa289c:	7c 08 03 a6 	mtlr    r0
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
    {
        bn_sub(a, consts_p()->ec_prime);
fffa28a0:	7f e4 fb 78 	mr      r4,r31
    }
#endif
}
fffa28a4:	17 c1 00 08 	lvd     d30,8(r1)
fffa28a8:	38 21 00 10 	addi    r1,r1,16
                          //       other curves need to handle this carry

#ifndef EC_POWER64_RED
    if (bn_ge_prime(a))
    {
        bn_sub(a, consts_p()->ec_prime);
fffa28ac:	4b ff fd 20 	b       fffa25cc <_Z6bn_subPmPKm>
    }
#endif
}
fffa28b0:	80 01 00 14 	lwz     r0,20(r1)
fffa28b4:	17 c1 00 08 	lvd     d30,8(r1)
fffa28b8:	7c 08 03 a6 	mtlr    r0
fffa28bc:	38 21 00 10 	addi    r1,r1,16
fffa28c0:	4e 80 00 20 	blr

fffa28c4 <_Z9bn_modsubPmPKm>:

// never modular-subtracting with ec_order[], only with ec_prime[]
// therefore, implicit modulus
//
void bn_modsub (bn_t *a, const bn_t *b)
{
fffa28c4:	94 21 ff f0 	stwu    r1,-16(r1)
fffa28c8:	7c 08 02 a6 	mflr    r0
fffa28cc:	1b c1 00 08 	stvd    d30,8(r1)
fffa28d0:	90 01 00 14 	stw     r0,20(r1)
fffa28d4:	7c 7f 1b 78 	mr      r31,r3
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != b);
    EC_ASSERT(!bn_ge_prime(b));

    if (bn_sub(a, b))
fffa28d8:	4b ff fc f5 	bl      fffa25cc <_Z6bn_subPmPKm>
fffa28dc:	06 c3 00 12 	bwz     r3,fffa2900 <_Z9bn_modsubPmPKm+0x3c>
    {
        bn_add(a, consts_p()->ec_prime);
    }
}
fffa28e0:	80 01 00 14 	lwz     r0,20(r1)
    EC_ASSERT(NULL != b);
    EC_ASSERT(!bn_ge_prime(b));

    if (bn_sub(a, b))
    {
        bn_add(a, consts_p()->ec_prime);
fffa28e4:	7f e3 fb 78 	mr      r3,r31
    }
}
fffa28e8:	7c 08 03 a6 	mtlr    r0
fffa28ec:	17 c1 00 08 	lvd     d30,8(r1)
    EC_ASSERT(NULL != b);
    EC_ASSERT(!bn_ge_prime(b));

    if (bn_sub(a, b))
    {
        bn_add(a, consts_p()->ec_prime);
fffa28f0:	3c 80 ff fa 	lis     r4,-6
fffa28f4:	38 84 71 24 	addi    r4,r4,28964
    }
}
fffa28f8:	38 21 00 10 	addi    r1,r1,16
    EC_ASSERT(NULL != b);
    EC_ASSERT(!bn_ge_prime(b));

    if (bn_sub(a, b))
    {
        bn_add(a, consts_p()->ec_prime);
fffa28fc:	4b ff fc 74 	b       fffa2570 <_Z6bn_addPmPKm>
    }
}
fffa2900:	80 01 00 14 	lwz     r0,20(r1)
fffa2904:	17 c1 00 08 	lvd     d30,8(r1)
fffa2908:	7c 08 03 a6 	mtlr    r0
fffa290c:	38 21 00 10 	addi    r1,r1,16
fffa2910:	4e 80 00 20 	blr

fffa2914 <_Z8bn_shl_nPmjj>:

// only rn LS words are touched
//
void bn_shl_n (bn_t r[NWORDS], unsigned int rn, unsigned int bits)
{
fffa2914:	94 21 ff e0 	stwu    r1,-32(r1)
    EC_DEVASSERT(NULL != r);
    EC_ASSERT(rn <= NWORDS);

    r += NWORDS-rn;

    if (bits >= BN_BITS) // unlikely, most modinv shift is <5 bits
fffa2918:	28 05 00 1f 	cmplwi  r5,31
}

// only rn LS words are touched
//
void bn_shl_n (bn_t r[NWORDS], unsigned int rn, unsigned int bits)
{
fffa291c:	1b c1 00 18 	stvd    d30,24(r1)
fffa2920:	7c 08 02 a6 	mflr    r0
    bn_t cf = 0, cfin;

    EC_DEVASSERT(NULL != r);
    EC_ASSERT(rn <= NWORDS);

    r += NWORDS-rn;
fffa2924:	23 e4 00 11 	subfic  r31,r4,17
fffa2928:	57 ff 10 3a 	rlwinm  r31,r31,2,0,29
}

// only rn LS words are touched
//
void bn_shl_n (bn_t r[NWORDS], unsigned int rn, unsigned int bits)
{
fffa292c:	1b 81 00 10 	stvd    d28,16(r1)
fffa2930:	90 01 00 24 	stw     r0,36(r1)
fffa2934:	7c 9e 23 78 	mr      r30,r4
fffa2938:	7c bd 2b 78 	mr      r29,r5
    bn_t cf = 0, cfin;

    EC_DEVASSERT(NULL != r);
    EC_ASSERT(rn <= NWORDS);

    r += NWORDS-rn;
fffa293c:	7f e3 fa 14 	add     r31,r3,r31

    if (bits >= BN_BITS) // unlikely, most modinv shift is <5 bits
fffa2940:	40 a1 00 40 	ble     fffa2980 <_Z8bn_shl_nPmjj+0x6c>
    {
        cfin = bits / BN_BITS;    // whole words
fffa2944:	54 bc d9 7e 	rlwinm  r28,r5,27,5,31

        memmove(r, r+cfin, (NWORDS-cfin)*sizeof(bn_t));
fffa2948:	57 89 10 3a 	rlwinm  r9,r28,2,0,29
fffa294c:	23 9c 00 11 	subfic  r28,r28,17
fffa2950:	57 9c 10 3a 	rlwinm  r28,r28,2,0,29
fffa2954:	7c 9f 4a 14 	add     r4,r31,r9
fffa2958:	7f 85 e3 78 	mr      r5,r28
fffa295c:	7f e3 fb 78 	mr      r3,r31
fffa2960:	91 21 00 08 	stw     r9,8(r1)
fffa2964:	48 00 31 69 	bl      fffa5acc <memmove>
#ifndef BN_POWER64_CLR
        memset(r+NWORDS-cfin, 0, cfin*sizeof(bn_t));
fffa2968:	81 21 00 08 	lwz     r9,8(r1)
fffa296c:	7c 7f e2 14 	add     r3,r31,r28
fffa2970:	38 80 00 00 	li      r4,0
fffa2974:	7d 25 4b 78 	mr      r5,r9
fffa2978:	48 00 30 29 	bl      fffa59a0 <memset>
#else
        bn_clr(r+NWORDS-cfin, cfin);
#endif

        bits %= BN_BITS;
fffa297c:	57 bd 06 fe 	clrlwi  r29,r29,27
    }

    if (bits)
fffa2980:	06 dd 00 1c 	bwz     r29,fffa29b8 <_Z8bn_shl_nPmjj+0xa4>
fffa2984:	57 c9 10 3a 	rlwinm  r9,r30,2,0,29
    {
        r += rn-1;
        while (0<rn--)
        {
            cfin = cf;
            cf = (*r >> (BN_BITS - bits));
fffa2988:	3b de 00 01 	addi    r30,r30,1
fffa298c:	7f c9 03 a6 	mtctr   r30
fffa2990:	7f ff 4a 14 	add     r31,r31,r9

// only rn LS words are touched
//
void bn_shl_n (bn_t r[NWORDS], unsigned int rn, unsigned int bits)
{
    bn_t cf = 0, cfin;
fffa2994:	39 40 00 00 	li      r10,0
    {
        r += rn-1;
        while (0<rn--)
        {
            cfin = cf;
            cf = (*r >> (BN_BITS - bits));
fffa2998:	20 fd 00 20 	subfic  r7,r29,32
    }

    if (bits)
    {
        r += rn-1;
        while (0<rn--)
fffa299c:	42 40 00 1c 	bdz     fffa29b8 <_Z8bn_shl_nPmjj+0xa4>
        {
            cfin = cf;
            cf = (*r >> (BN_BITS - bits));
fffa29a0:	85 1f ff fc 	lwzu    r8,-4(r31)
            *r <<= bits;
fffa29a4:	7d 09 e8 30 	slw     r9,r8,r29
            *r |=  cfin;
fffa29a8:	7d 49 4b 78 	or      r9,r10,r9
fffa29ac:	91 3f 00 00 	stw     r9,0(r31)
    {
        r += rn-1;
        while (0<rn--)
        {
            cfin = cf;
            cf = (*r >> (BN_BITS - bits));
fffa29b0:	7d 0a 3c 30 	srw     r10,r8,r7
fffa29b4:	4b ff ff e8 	b       fffa299c <_Z8bn_shl_nPmjj+0x88>
            *r <<= bits;
            *r |=  cfin;
            --r;
        }
    }
}
fffa29b8:	80 01 00 24 	lwz     r0,36(r1)
fffa29bc:	17 81 00 10 	lvd     d28,16(r1)
fffa29c0:	7c 08 03 a6 	mtlr    r0
fffa29c4:	17 c1 00 18 	lvd     d30,24(r1)
fffa29c8:	38 21 00 20 	addi    r1,r1,32
fffa29cc:	4e 80 00 20 	blr

fffa29d0 <_Z7bn_bitsPKm>:

unsigned int bn_bits (const bn_t *a)
{
    unsigned int full = 8*BNBYTES;
fffa29d0:	39 20 00 11 	li      r9,17
fffa29d4:	7d 29 03 a6 	mtctr   r9
fffa29d8:	39 43 ff fc 	addi    r10,r3,-4
fffa29dc:	38 60 02 20 	li      r3,544
    bn_t an;

    for (i=0; i<NWORDS; ++i)
    {
        full -= BN_BITS;
        an = a[i];
fffa29e0:	85 2a 00 04 	lwzu    r9,4(r10)
    bnindex_t i;
    bn_t an;

    for (i=0; i<NWORDS; ++i)
    {
        full -= BN_BITS;
fffa29e4:	38 63 ff e0 	addi    r3,r3,-32
        an = a[i];

        if (!an)
fffa29e8:	06 c9 00 14 	bwz     r9,fffa2a10 <_Z7bn_bitsPKm+0x40>
        {
            continue;
        }

        while (an > 0xff)
fffa29ec:	28 09 00 ff 	cmplwi  r9,255
fffa29f0:	40 81 00 10 	ble     fffa2a00 <_Z7bn_bitsPKm+0x30>
        {
            full += 8;
fffa29f4:	38 63 00 08 	addi    r3,r3,8
            an >>= 8;
fffa29f8:	55 29 c2 3e 	rlwinm  r9,r9,24,8,31
fffa29fc:	4b ff ff f0 	b       fffa29ec <_Z7bn_bitsPKm+0x1c>
        }

        while (an)
        {
            ++full;
            an >>= 1;
fffa2a00:	55 29 f8 7e 	rlwinm  r9,r9,31,1,31
            an >>= 8;
        }

        while (an)
        {
            ++full;
fffa2a04:	38 63 00 01 	addi    r3,r3,1
        {
            full += 8;
            an >>= 8;
        }

        while (an)
fffa2a08:	06 49 07 fc 	bwnz    r9,fffa2a00 <_Z7bn_bitsPKm+0x30>
fffa2a0c:	4e 80 00 20 	blr
fffa2a10:	42 00 ff d0 	bdnz    fffa29e0 <_Z7bn_bitsPKm+0x10>
            ++full;
            an >>= 1;
        }
        return full;
    }
    return 0;
fffa2a14:	38 60 00 00 	li      r3,0
}
fffa2a18:	4e 80 00 20 	blr

fffa2a1c <_Z9bn_modinvPmPKmS1_>:
#define  bn_is_negative(p)  (0x1000 & (*(p)))

// inv stores S during run
//
int bn_modinv(bn_t *inv, const bn_t *a, const bn_t *n)
{
fffa2a1c:	94 21 fe 38 	stwu    r1,-456(r1)
fffa2a20:	7c 08 02 a6 	mflr    r0
fffa2a24:	1b c1 01 c0 	stvd    d30,448(r1)
fffa2a28:	90 61 01 b0 	stw     r3,432(r1)
fffa2a2c:	7c 9f 23 78 	mr      r31,r4
fffa2a30:	90 a1 01 ac 	stw     r5,428(r1)
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != n);
    EC_ASSERT(bn_cmp(a,n) < 0);
    EC_ASSERT(!bn_is_zero(a,0));

    bn_clear(r);
fffa2a34:	38 80 00 00 	li      r4,0
fffa2a38:	38 a0 00 44 	li      r5,68
fffa2a3c:	38 61 01 5c 	addi    r3,r1,348
#define  bn_is_negative(p)  (0x1000 & (*(p)))

// inv stores S during run
//
int bn_modinv(bn_t *inv, const bn_t *a, const bn_t *n)
{
fffa2a40:	90 01 01 cc 	stw     r0,460(r1)
fffa2a44:	1b 81 01 b8 	stvd    d28,440(r1)
    EC_ASSERT(NULL != a);
    EC_ASSERT(NULL != n);
    EC_ASSERT(bn_cmp(a,n) < 0);
    EC_ASSERT(!bn_is_zero(a,0));

    bn_clear(r);
fffa2a48:	48 00 2f 59 	bl      fffa59a0 <memset>
    bn_clear(s);
fffa2a4c:	38 a0 00 44 	li      r5,68
fffa2a50:	38 80 00 00 	li      r4,0
fffa2a54:	38 61 01 18 	addi    r3,r1,280
fffa2a58:	48 00 2f 49 	bl      fffa59a0 <memset>
    BN_LSW(s) = 1;

    BN_COPY(u, n);
fffa2a5c:	80 81 01 ac 	lwz     r4,428(r1)
    EC_ASSERT(bn_cmp(a,n) < 0);
    EC_ASSERT(!bn_is_zero(a,0));

    bn_clear(r);
    bn_clear(s);
    BN_LSW(s) = 1;
fffa2a60:	39 20 00 01 	li      r9,1

    BN_COPY(u, n);
fffa2a64:	38 61 00 d4 	addi    r3,r1,212
    EC_ASSERT(bn_cmp(a,n) < 0);
    EC_ASSERT(!bn_is_zero(a,0));

    bn_clear(r);
    bn_clear(s);
    BN_LSW(s) = 1;
fffa2a68:	91 21 01 58 	stw     r9,344(r1)

    BN_COPY(u, n);
fffa2a6c:	4b ff f8 91 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    BN_COPY(v, a);
fffa2a70:	7f e4 fb 78 	mr      r4,r31
fffa2a74:	38 61 00 90 	addi    r3,r1,144
fffa2a78:	4b ff f8 85 	bl      fffa22fc <_Z7BN_COPYPmPKm>

    // ub = bn_bits(u);
    ub = EC_PRIMEBITS;    // P521: only ec_prime or ec_order possible
    vb = bn_bits(v);
fffa2a7c:	38 61 00 90 	addi    r3,r1,144
fffa2a80:	4b ff ff 51 	bl      fffa29d0 <_Z7bn_bitsPKm>
{

    bn_t r[ NWORDS ], s[ NWORDS ],  u[ NWORDS ], v[ NWORDS ],
                     ss[ NWORDS ], vs[ NWORDS ];   // shifted S,V
    unsigned int shl, ub, vb;                      // shift amount; bitcount
    bn_t *pr = r, *ps = s, *pu = u, *pv = v, *pt;
fffa2a84:	39 21 01 5c 	addi    r9,r1,348
fffa2a88:	91 21 01 a8 	stw     r9,424(r1)
    BN_COPY(u, n);
    BN_COPY(v, a);

    // ub = bn_bits(u);
    ub = EC_PRIMEBITS;    // P521: only ec_prime or ec_order possible
    vb = bn_bits(v);
fffa2a8c:	7c 7d 1b 78 	mr      r29,r3
{

    bn_t r[ NWORDS ], s[ NWORDS ],  u[ NWORDS ], v[ NWORDS ],
                     ss[ NWORDS ], vs[ NWORDS ];   // shifted S,V
    unsigned int shl, ub, vb;                      // shift amount; bitcount
    bn_t *pr = r, *ps = s, *pu = u, *pv = v, *pt;
fffa2a90:	3b 81 00 90 	addi    r28,r1,144
fffa2a94:	3b c1 00 d4 	addi    r30,r1,212
fffa2a98:	3b e1 01 18 	addi    r31,r1,280

    BN_COPY(u, n);
    BN_COPY(v, a);

    // ub = bn_bits(u);
    ub = EC_PRIMEBITS;    // P521: only ec_prime or ec_order possible
fffa2a9c:	38 60 02 09 	li      r3,521
    vb = bn_bits(v);

    while (1 < vb)
fffa2aa0:	28 1d 00 01 	cmplwi  r29,1
fffa2aa4:	40 81 00 e8 	ble     fffa2b8c <_Z9bn_modinvPmPKmS1_+0x170>
    {
        EC_ASSERT(ub >= vb);
        shl = ub-vb;
fffa2aa8:	7d 3d 18 50 	subf    r9,r29,r3

        BN_COPY(vs, pv);
fffa2aac:	7f 84 e3 78 	mr      r4,r28
fffa2ab0:	38 61 00 08 	addi    r3,r1,8
fffa2ab4:	91 21 01 b4 	stw     r9,436(r1)
fffa2ab8:	4b ff f8 45 	bl      fffa22fc <_Z7BN_COPYPmPKm>
        BN_COPY(ss, ps);
fffa2abc:	38 61 00 4c 	addi    r3,r1,76
fffa2ac0:	7f e4 fb 78 	mr      r4,r31
fffa2ac4:	4b ff f8 39 	bl      fffa22fc <_Z7BN_COPYPmPKm>
        if (shl)
fffa2ac8:	81 21 01 b4 	lwz     r9,436(r1)
fffa2acc:	06 c9 00 14 	bwz     r9,fffa2af4 <_Z9bn_modinvPmPKmS1_+0xd8>
        {
            bn_shl_n(vs, NWORDS, shl);
fffa2ad0:	7d 25 4b 78 	mr      r5,r9
fffa2ad4:	38 61 00 08 	addi    r3,r1,8
fffa2ad8:	38 80 00 11 	li      r4,17
fffa2adc:	4b ff fe 39 	bl      fffa2914 <_Z8bn_shl_nPmjj>
            bn_shl_n(ss, NWORDS, shl);
fffa2ae0:	81 21 01 b4 	lwz     r9,436(r1)
fffa2ae4:	38 61 00 4c 	addi    r3,r1,76
fffa2ae8:	38 80 00 11 	li      r4,17
fffa2aec:	7d 25 4b 78 	mr      r5,r9
fffa2af0:	4b ff fe 25 	bl      fffa2914 <_Z8bn_shl_nPmjj>
        }

        if (bn_is_negative(pv) == bn_is_negative(pu))
fffa2af4:	81 5e 00 00 	lwz     r10,0(r30)
fffa2af8:	81 3c 00 00 	lwz     r9,0(r28)
        {
            bn_sub(pu, vs);
fffa2afc:	7f c3 f3 78 	mr      r3,r30
        {
            bn_shl_n(vs, NWORDS, shl);
            bn_shl_n(ss, NWORDS, shl);
        }

        if (bn_is_negative(pv) == bn_is_negative(pu))
fffa2b00:	7d 49 4a 78 	xor     r9,r10,r9
        {
            bn_sub(pu, vs);
fffa2b04:	38 81 00 08 	addi    r4,r1,8
        {
            bn_shl_n(vs, NWORDS, shl);
            bn_shl_n(ss, NWORDS, shl);
        }

        if (bn_is_negative(pv) == bn_is_negative(pu))
fffa2b08:	07 09 98 0c 	bb1wi   r9,19,fffa2b20 <_Z9bn_modinvPmPKmS1_+0x104>
        {
            bn_sub(pu, vs);
fffa2b0c:	4b ff fa c1 	bl      fffa25cc <_Z6bn_subPmPKm>
            bn_sub(pr, ss);
fffa2b10:	80 61 01 a8 	lwz     r3,424(r1)
fffa2b14:	38 81 00 4c 	addi    r4,r1,76
fffa2b18:	4b ff fa b5 	bl      fffa25cc <_Z6bn_subPmPKm>
fffa2b1c:	48 00 00 14 	b       fffa2b30 <_Z9bn_modinvPmPKmS1_+0x114>
        }
        else
        {
            bn_add(pu, vs);
fffa2b20:	4b ff fa 51 	bl      fffa2570 <_Z6bn_addPmPKm>
            bn_add(pr, ss);
fffa2b24:	80 61 01 a8 	lwz     r3,424(r1)
fffa2b28:	38 81 00 4c 	addi    r4,r1,76
fffa2b2c:	4b ff fa 45 	bl      fffa2570 <_Z6bn_addPmPKm>
        }

        if (bn_is_negative(pu))
fffa2b30:	81 3e 00 00 	lwz     r9,0(r30)
            bn_sub(ss, pu);
            ub = bn_bits(ss);
        }
        else
        {
            ub = bn_bits(pu);
fffa2b34:	7f c3 f3 78 	mr      r3,r30
        {
            bn_add(pu, vs);
            bn_add(pr, ss);
        }

        if (bn_is_negative(pu))
fffa2b38:	07 89 98 12 	bb0wi   r9,19,fffa2b5c <_Z9bn_modinvPmPKmS1_+0x140>
        {
            bn_clear(ss);
fffa2b3c:	38 80 00 00 	li      r4,0
fffa2b40:	38 a0 00 44 	li      r5,68
fffa2b44:	38 61 00 4c 	addi    r3,r1,76
fffa2b48:	48 00 2e 59 	bl      fffa59a0 <memset>
            bn_sub(ss, pu);
fffa2b4c:	38 61 00 4c 	addi    r3,r1,76
fffa2b50:	7f c4 f3 78 	mr      r4,r30
fffa2b54:	4b ff fa 79 	bl      fffa25cc <_Z6bn_subPmPKm>
            ub = bn_bits(ss);
fffa2b58:	38 61 00 4c 	addi    r3,r1,76
        }
        else
        {
            ub = bn_bits(pu);
fffa2b5c:	4b ff fe 75 	bl      fffa29d0 <_Z7bn_bitsPKm>
        }

        if (ub < vb)
fffa2b60:	05 03 ef a0 	cmplwbge r3,r29,fffa2aa0 <_Z9bn_modinvPmPKmS1_+0x84>
fffa2b64:	7f c9 f3 78 	mr      r9,r30
fffa2b68:	7f 9e e3 78 	mr      r30,r28
fffa2b6c:	7d 3c 4b 78 	mr      r28,r9
fffa2b70:	81 21 01 a8 	lwz     r9,424(r1)
fffa2b74:	93 e1 01 a8 	stw     r31,424(r1)
            pt = pu;
            pu = pv;
            pv = pt;

            pt = ps;
            ps = pr;
fffa2b78:	7d 3f 4b 78 	mr      r31,r9
        else
        {
            ub = bn_bits(pu);
        }

        if (ub < vb)
fffa2b7c:	7c 69 1b 78 	mr      r9,r3
fffa2b80:	7f a3 eb 78 	mr      r3,r29
fffa2b84:	7d 3d 4b 78 	mr      r29,r9
fffa2b88:	4b ff ff 18 	b       fffa2aa0 <_Z9bn_modinvPmPKmS1_+0x84>
            ps = pr;
            pr = pt;
        }
    }

    if (bn_is_negative(pv))
fffa2b8c:	81 3c 00 00 	lwz     r9,0(r28)
fffa2b90:	07 89 98 16 	bb0wi   r9,19,fffa2bbc <_Z9bn_modinvPmPKmS1_+0x1a0>
    {
        BN_COPY(ss, ps);
fffa2b94:	38 61 00 4c 	addi    r3,r1,76
fffa2b98:	7f e4 fb 78 	mr      r4,r31
fffa2b9c:	4b ff f7 61 	bl      fffa22fc <_Z7BN_COPYPmPKm>
        bn_clear(ps);
fffa2ba0:	38 80 00 00 	li      r4,0
fffa2ba4:	7f e3 fb 78 	mr      r3,r31
fffa2ba8:	38 a0 00 44 	li      r5,68
fffa2bac:	48 00 2d f5 	bl      fffa59a0 <memset>
        bn_sub(ps, ss);
fffa2bb0:	7f e3 fb 78 	mr      r3,r31
fffa2bb4:	38 81 00 4c 	addi    r4,r1,76
fffa2bb8:	4b ff fa 15 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    if (bn_is_negative(ps))
fffa2bbc:	81 3f 00 00 	lwz     r9,0(r31)
fffa2bc0:	07 89 98 08 	bb0wi   r9,19,fffa2bd0 <_Z9bn_modinvPmPKmS1_+0x1b4>
    {
        bn_add(ps, n);
fffa2bc4:	80 81 01 ac 	lwz     r4,428(r1)
fffa2bc8:	7f e3 fb 78 	mr      r3,r31
fffa2bcc:	4b ff f9 a5 	bl      fffa2570 <_Z6bn_addPmPKm>
    }

    if (bn_cmp(ps, n) >= 0)
fffa2bd0:	80 81 01 ac 	lwz     r4,428(r1)
fffa2bd4:	7f e3 fb 78 	mr      r3,r31
fffa2bd8:	4b ff f9 21 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa2bdc:	06 83 00 08 	bwltz   r3,fffa2bec <_Z9bn_modinvPmPKmS1_+0x1d0>
    {
        bn_sub(ps, n);
fffa2be0:	80 81 01 ac 	lwz     r4,428(r1)
fffa2be4:	7f e3 fb 78 	mr      r3,r31
fffa2be8:	4b ff f9 e5 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    BN_COPY(inv, ps);
fffa2bec:	80 61 01 b0 	lwz     r3,432(r1)
fffa2bf0:	7f e4 fb 78 	mr      r4,r31
fffa2bf4:	4b ff f7 09 	bl      fffa22fc <_Z7BN_COPYPmPKm>

    return 1;
}
fffa2bf8:	80 01 01 cc 	lwz     r0,460(r1)
fffa2bfc:	17 81 01 b8 	lvd     d28,440(r1)
fffa2c00:	7c 08 03 a6 	mtlr    r0
fffa2c04:	17 c1 01 c0 	lvd     d30,448(r1)
fffa2c08:	38 60 00 01 	li      r3,1
fffa2c0c:	38 21 01 c8 	addi    r1,r1,456
fffa2c10:	4e 80 00 20 	blr

fffa2c14 <_Z7bn_readPmPKhj>:
}

#else

void bn_read(bn_t *r, const unsigned char *data, size_t dlen)
{
fffa2c14:	94 21 ff e0 	stwu    r1,-32(r1)
fffa2c18:	7c 08 02 a6 	mflr    r0
fffa2c1c:	1b c1 00 18 	stvd    d30,24(r1)
    bnindex_t i, whole = dlen / sizeof(bn_t),
                   rem = dlen % sizeof(bn_t);
fffa2c20:	54 be 07 be 	clrlwi  r30,r5,30

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != data);
    EC_ASSERT(dlen <= EC_PRIMEBYTES);

    acc = whole + (!!rem);
fffa2c24:	7f fe 00 d0 	neg     r31,r30
fffa2c28:	7f df f8 38 	and     r31,r30,r31
fffa2c2c:	7f ff 00 34 	cntlzw  r31,r31
fffa2c30:	3b ff ff e0 	addi    r31,r31,-32
}

#else

void bn_read(bn_t *r, const unsigned char *data, size_t dlen)
{
fffa2c34:	1b 81 00 10 	stvd    d28,16(r1)

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != data);
    EC_ASSERT(dlen <= EC_PRIMEBYTES);

    acc = whole + (!!rem);
fffa2c38:	57 ff 0f fe 	rlwinm  r31,r31,1,31,31

#else

void bn_read(bn_t *r, const unsigned char *data, size_t dlen)
{
    bnindex_t i, whole = dlen / sizeof(bn_t),
fffa2c3c:	54 bc f0 be 	rlwinm  r28,r5,30,2,31

    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != data);
    EC_ASSERT(dlen <= EC_PRIMEBYTES);

    acc = whole + (!!rem);
fffa2c40:	7f bf e2 14 	add     r29,r31,r28
    if (acc < NWORDS) // unused MS words
fffa2c44:	28 1d 00 10 	cmplwi  r29,16
}

#else

void bn_read(bn_t *r, const unsigned char *data, size_t dlen)
{
fffa2c48:	90 01 00 24 	stw     r0,36(r1)
fffa2c4c:	7c 69 1b 78 	mr      r9,r3
fffa2c50:	7c 8a 23 78 	mr      r10,r4
    EC_ASSERT(NULL != r);
    EC_ASSERT(NULL != data);
    EC_ASSERT(dlen <= EC_PRIMEBYTES);

    acc = whole + (!!rem);
    if (acc < NWORDS) // unused MS words
fffa2c54:	41 a1 00 28 	bgt     fffa2c7c <_Z7bn_readPmPKhj+0x68>
    {
        acc = NWORDS - acc;
fffa2c58:	23 bd 00 11 	subfic  r29,r29,17
#ifndef BN_POWER64_CLR
        memset(r, 0, acc*sizeof(bn_t));
fffa2c5c:	57 bd 10 3a 	rlwinm  r29,r29,2,0,29
fffa2c60:	38 80 00 00 	li      r4,0
fffa2c64:	7f a5 eb 78 	mr      r5,r29
fffa2c68:	91 41 00 0c 	stw     r10,12(r1)
fffa2c6c:	90 61 00 08 	stw     r3,8(r1)
fffa2c70:	48 00 2d 31 	bl      fffa59a0 <memset>
#else
        bn_clr(r, acc);
#endif
        r += acc;
fffa2c74:	15 21 00 08 	lvd     d9,8(r1)
fffa2c78:	7d 29 ea 14 	add     r9,r9,r29
    }

    acc = 0;
    if (rem)
fffa2c7c:	06 df 00 06 	bwz     r31,fffa2c88 <_Z7bn_readPmPKhj+0x74>
    {
        ++whole;
fffa2c80:	3b 9c 00 01 	addi    r28,r28,1
fffa2c84:	48 00 00 08 	b       fffa2c8c <_Z7bn_readPmPKhj+0x78>
    }
    else
    {
        rem = sizeof(bn_t);
fffa2c88:	3b c0 00 04 	li      r30,4
fffa2c8c:	39 29 ff fc 	addi    r9,r9,-4
    }

    while (0 < whole--)
fffa2c90:	2c 1c 00 00 	cmpwi   r28,0
fffa2c94:	3b 9c ff ff 	addi    r28,r28,-1
fffa2c98:	41 82 00 34 	beq     fffa2ccc <_Z7bn_readPmPKhj+0xb8>
fffa2c9c:	7f c9 03 a6 	mtctr   r30
fffa2ca0:	39 00 00 00 	li      r8,0
fffa2ca4:	38 e0 00 00 	li      r7,0
    {
        for (i=0; i<rem; ++i)
        {
            acc = (acc <<8) + *(data++);
fffa2ca8:	7c ca 38 ae 	lbzx    r6,r10,r7
fffa2cac:	55 08 40 2e 	rlwinm  r8,r8,8,0,23
fffa2cb0:	7d 06 42 14 	add     r8,r6,r8
        rem = sizeof(bn_t);
    }

    while (0 < whole--)
    {
        for (i=0; i<rem; ++i)
fffa2cb4:	38 e7 00 01 	addi    r7,r7,1
fffa2cb8:	42 00 ff f0 	bdnz    fffa2ca8 <_Z7bn_readPmPKhj+0x94>
fffa2cbc:	7d 4a f2 14 	add     r10,r10,r30
        {
            acc = (acc <<8) + *(data++);
        }
        *(r++) = acc;
fffa2cc0:	95 09 00 04 	stwu    r8,4(r9)
        acc = 0;
        rem = sizeof(bn_t);
fffa2cc4:	3b c0 00 04 	li      r30,4
fffa2cc8:	4b ff ff c8 	b       fffa2c90 <_Z7bn_readPmPKhj+0x7c>
    }
}
fffa2ccc:	80 01 00 24 	lwz     r0,36(r1)
fffa2cd0:	17 81 00 10 	lvd     d28,16(r1)
fffa2cd4:	7c 08 03 a6 	mtlr    r0
fffa2cd8:	17 c1 00 18 	lvd     d30,24(r1)
fffa2cdc:	38 21 00 20 	addi    r1,r1,32
fffa2ce0:	4e 80 00 20 	blr

fffa2ce4 <_Z10bn_read_ptPmPKh>:

void bn_read_pt(bn_t *r, const unsigned char *data)
{
    return bn_read(r, data, EC_PRIMEBYTES);
fffa2ce4:	38 a0 00 42 	li      r5,66
fffa2ce8:	4b ff ff 2c 	b       fffa2c14 <_Z7bn_readPmPKhj>

fffa2cec <_Z12bn_read_hashPmPKh>:
}

void bn_read_hash(bn_t *r, const unsigned char *data)
{
    return bn_read(r, data, EC_HASHBYTES);
fffa2cec:	38 a0 00 40 	li      r5,64
fffa2cf0:	4b ff ff 24 	b       fffa2c14 <_Z7bn_readPmPKhj>

fffa2cf4 <_Z20ec_projective2affinePmPKm>:
#define  ec_set_infinity(p)  bn_clear(p)

// (x) is transformed back to affine from projective (X*Z)
//
void ec_projective2affine (bn_t *x, const bn_t *z)
{
fffa2cf4:	94 21 ff a0 	stwu    r1,-96(r1)
fffa2cf8:	7c 08 02 a6 	mflr    r0
    EC_ASSERT(NULL != z);

    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(z));

    bn_modinv(zinv, z, consts_p()->ec_prime);
fffa2cfc:	3c a0 ff fa 	lis     r5,-6
#define  ec_set_infinity(p)  bn_clear(p)

// (x) is transformed back to affine from projective (X*Z)
//
void ec_projective2affine (bn_t *x, const bn_t *z)
{
fffa2d00:	1b c1 00 58 	stvd    d30,88(r1)
    EC_ASSERT(NULL != z);

    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(z));

    bn_modinv(zinv, z, consts_p()->ec_prime);
fffa2d04:	38 a5 71 24 	addi    r5,r5,28964
#define  ec_set_infinity(p)  bn_clear(p)

// (x) is transformed back to affine from projective (X*Z)
//
void ec_projective2affine (bn_t *x, const bn_t *z)
{
fffa2d08:	7c 7f 1b 78 	mr      r31,r3
    EC_ASSERT(NULL != z);

    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(z));

    bn_modinv(zinv, z, consts_p()->ec_prime);
fffa2d0c:	38 61 00 08 	addi    r3,r1,8
#define  ec_set_infinity(p)  bn_clear(p)

// (x) is transformed back to affine from projective (X*Z)
//
void ec_projective2affine (bn_t *x, const bn_t *z)
{
fffa2d10:	90 01 00 64 	stw     r0,100(r1)
    EC_ASSERT(NULL != z);

    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(z));

    bn_modinv(zinv, z, consts_p()->ec_prime);
fffa2d14:	4b ff fd 09 	bl      fffa2a1c <_Z9bn_modinvPmPKmS1_>
    bn_modmul_prime(x, zinv);
fffa2d18:	7f e3 fb 78 	mr      r3,r31
fffa2d1c:	38 81 00 08 	addi    r4,r1,8
fffa2d20:	4b ff f9 e1 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
#ifdef EC_POWER64_RED
    bn_modred_slow(x);
#endif
}
fffa2d24:	80 01 00 64 	lwz     r0,100(r1)
fffa2d28:	17 c1 00 58 	lvd     d30,88(r1)
fffa2d2c:	7c 08 03 a6 	mtlr    r0
fffa2d30:	38 21 00 60 	addi    r1,r1,96
fffa2d34:	4e 80 00 20 	blr

fffa2d38 <_Z9ec_doublePmS_S_>:
// P521: curve has a==-3
//
// return 1 if point in infinity
//
int ec_double (bn_t *x, bn_t *y, bn_t *z)
{
fffa2d38:	94 21 fe 88 	stwu    r1,-376(r1)
fffa2d3c:	7c 08 02 a6 	mflr    r0
fffa2d40:	1b 81 01 68 	stvd    d28,360(r1)
fffa2d44:	7c 7d 1b 78 	mr      r29,r3
fffa2d48:	1b c1 01 70 	stvd    d30,368(r1)
#endif
    bn_modsub(a, y);
    BN_COPY(y, a);            // Y = A * (4*C - D) - 8 * y^2 * B^2

#else // !EC_POWER64_ALG
    BN_COPY(a, x);
fffa2d4c:	38 61 01 18 	addi    r3,r1,280
// P521: curve has a==-3
//
// return 1 if point in infinity
//
int ec_double (bn_t *x, bn_t *y, bn_t *z)
{
fffa2d50:	7c be 2b 78 	mr      r30,r5
fffa2d54:	7c 9f 23 78 	mr      r31,r4
#endif
    bn_modsub(a, y);
    BN_COPY(y, a);            // Y = A * (4*C - D) - 8 * y^2 * B^2

#else // !EC_POWER64_ALG
    BN_COPY(a, x);
fffa2d58:	7f a4 eb 78 	mr      r4,r29
// P521: curve has a==-3
//
// return 1 if point in infinity
//
int ec_double (bn_t *x, bn_t *y, bn_t *z)
{
fffa2d5c:	90 01 01 7c 	stw     r0,380(r1)
#endif
    bn_modsub(a, y);
    BN_COPY(y, a);            // Y = A * (4*C - D) - 8 * y^2 * B^2

#else // !EC_POWER64_ALG
    BN_COPY(a, x);
fffa2d60:	4b ff f5 9d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    BN_COPY(d, z);
fffa2d64:	38 61 00 4c 	addi    r3,r1,76
fffa2d68:	7f c4 f3 78 	mr      r4,r30
fffa2d6c:	4b ff f5 91 	bl      fffa22fc <_Z7BN_COPYPmPKm>

    bn_modmul_prime(a, x);
fffa2d70:	38 61 01 18 	addi    r3,r1,280
fffa2d74:	7f a4 eb 78 	mr      r4,r29
fffa2d78:	4b ff f9 89 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(d, z);
fffa2d7c:	38 61 00 4c 	addi    r3,r1,76
fffa2d80:	7f c4 f3 78 	mr      r4,r30
fffa2d84:	4b ff f9 7d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(a, d);
fffa2d88:	38 61 01 18 	addi    r3,r1,280
fffa2d8c:	38 81 00 4c 	addi    r4,r1,76
fffa2d90:	4b ff fb 35 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
    BN_COPY(d, a);
fffa2d94:	38 61 00 4c 	addi    r3,r1,76
fffa2d98:	38 81 01 18 	addi    r4,r1,280
fffa2d9c:	4b ff f5 61 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modadd(a, a);
fffa2da0:	38 61 01 18 	addi    r3,r1,280
fffa2da4:	7c 64 1b 78 	mr      r4,r3
fffa2da8:	4b ff fa bd 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(a, d);          // A = 3 * (x^2 - z^2)
fffa2dac:	38 61 01 18 	addi    r3,r1,280
fffa2db0:	38 81 00 4c 	addi    r4,r1,76
fffa2db4:	4b ff fa b1 	bl      fffa2864 <_Z9bn_modaddPmPKm>
                              // P521: generally, A = 3 * x^2 - a * z^2

    BN_COPY(b, z);
fffa2db8:	38 61 00 d4 	addi    r3,r1,212
fffa2dbc:	7f c4 f3 78 	mr      r4,r30
fffa2dc0:	4b ff f5 3d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(b, y);    // B = y * z
fffa2dc4:	38 61 00 d4 	addi    r3,r1,212
fffa2dc8:	7f e4 fb 78 	mr      r4,r31
fffa2dcc:	4b ff f9 35 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    BN_COPY(c, y);
fffa2dd0:	38 61 00 90 	addi    r3,r1,144
fffa2dd4:	7f e4 fb 78 	mr      r4,r31
fffa2dd8:	4b ff f5 25 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(c, b);
fffa2ddc:	38 61 00 90 	addi    r3,r1,144
fffa2de0:	38 81 00 d4 	addi    r4,r1,212
fffa2de4:	4b ff f9 1d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(c, x);    // C = x * y * B
fffa2de8:	38 61 00 90 	addi    r3,r1,144
fffa2dec:	7f a4 eb 78 	mr      r4,r29
fffa2df0:	4b ff f9 11 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    BN_COPY(z, b);
fffa2df4:	7f c3 f3 78 	mr      r3,r30
fffa2df8:	38 81 00 d4 	addi    r4,r1,212
fffa2dfc:	4b ff f5 01 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(z, b);
fffa2e00:	7f c3 f3 78 	mr      r3,r30
fffa2e04:	38 81 00 d4 	addi    r4,r1,212
fffa2e08:	4b ff f8 f9 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(z, b);
fffa2e0c:	7f c3 f3 78 	mr      r3,r30
fffa2e10:	38 81 00 d4 	addi    r4,r1,212
fffa2e14:	4b ff f8 ed 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modadd(z, z);
fffa2e18:	7f c3 f3 78 	mr      r3,r30
fffa2e1c:	7f c4 f3 78 	mr      r4,r30
fffa2e20:	4b ff fa 45 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(z, z);
fffa2e24:	7f c3 f3 78 	mr      r3,r30
fffa2e28:	7f c4 f3 78 	mr      r4,r30
fffa2e2c:	4b ff fa 39 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(z, z);          // Z = 8 * B^3
fffa2e30:	7f c3 f3 78 	mr      r3,r30
fffa2e34:	7f c4 f3 78 	mr      r4,r30
fffa2e38:	4b ff fa 2d 	bl      fffa2864 <_Z9bn_modaddPmPKm>

    BN_COPY(t, c);
fffa2e3c:	38 61 00 08 	addi    r3,r1,8
fffa2e40:	38 81 00 90 	addi    r4,r1,144
fffa2e44:	4b ff f4 b9 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modadd(t, t);
fffa2e48:	38 61 00 08 	addi    r3,r1,8
fffa2e4c:	7c 64 1b 78 	mr      r4,r3
fffa2e50:	4b ff fa 15 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(t, t);
fffa2e54:	38 61 00 08 	addi    r3,r1,8
fffa2e58:	7c 64 1b 78 	mr      r4,r3
fffa2e5c:	4b ff fa 09 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(t, t);
fffa2e60:	38 61 00 08 	addi    r3,r1,8
fffa2e64:	7c 64 1b 78 	mr      r4,r3
fffa2e68:	4b ff f9 fd 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    BN_COPY(d, a);
fffa2e6c:	38 61 00 4c 	addi    r3,r1,76
fffa2e70:	38 81 01 18 	addi    r4,r1,280
fffa2e74:	4b ff f4 89 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(d, a);
fffa2e78:	38 61 00 4c 	addi    r3,r1,76
fffa2e7c:	38 81 01 18 	addi    r4,r1,280
fffa2e80:	4b ff f8 81 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(d, t);          // D = A^2 - 8*C
fffa2e84:	38 61 00 4c 	addi    r3,r1,76
fffa2e88:	38 81 00 08 	addi    r4,r1,8
fffa2e8c:	4b ff fa 39 	bl      fffa28c4 <_Z9bn_modsubPmPKm>

    BN_COPY(x, b);
fffa2e90:	7f a3 eb 78 	mr      r3,r29
fffa2e94:	38 81 00 d4 	addi    r4,r1,212
fffa2e98:	4b ff f4 65 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(x, d);
fffa2e9c:	7f a3 eb 78 	mr      r3,r29
fffa2ea0:	38 81 00 4c 	addi    r4,r1,76
fffa2ea4:	4b ff f8 5d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modadd(x, x);          // X = 2 * B * D
fffa2ea8:	7f a3 eb 78 	mr      r3,r29
fffa2eac:	7f a4 eb 78 	mr      r4,r29
fffa2eb0:	4b ff f9 b5 	bl      fffa2864 <_Z9bn_modaddPmPKm>

    bn_modadd(c, c);
fffa2eb4:	38 61 00 90 	addi    r3,r1,144
fffa2eb8:	7c 64 1b 78 	mr      r4,r3
fffa2ebc:	4b ff f9 a9 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(c, c);
fffa2ec0:	38 61 00 90 	addi    r3,r1,144
fffa2ec4:	7c 64 1b 78 	mr      r4,r3
fffa2ec8:	4b ff f9 9d 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modsub(c, d);
fffa2ecc:	38 61 00 90 	addi    r3,r1,144
fffa2ed0:	38 81 00 4c 	addi    r4,r1,76
fffa2ed4:	4b ff f9 f1 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
    bn_modmul_prime(a, c);    // (A * (4*C - D))
fffa2ed8:	38 61 01 18 	addi    r3,r1,280
fffa2edc:	38 81 00 90 	addi    r4,r1,144
fffa2ee0:	4b ff f8 21 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    bn_modmul_prime(y, b);
fffa2ee4:	7f e3 fb 78 	mr      r3,r31
fffa2ee8:	38 81 00 d4 	addi    r4,r1,212
fffa2eec:	4b ff f8 15 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(y, y);
fffa2ef0:	7f e3 fb 78 	mr      r3,r31
fffa2ef4:	7f e4 fb 78 	mr      r4,r31
fffa2ef8:	4b ff f8 09 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modadd(y, y);
fffa2efc:	7f e3 fb 78 	mr      r3,r31
fffa2f00:	7f e4 fb 78 	mr      r4,r31
fffa2f04:	4b ff f9 61 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(y, y);
fffa2f08:	7f e3 fb 78 	mr      r3,r31
fffa2f0c:	7f e4 fb 78 	mr      r4,r31
fffa2f10:	4b ff f9 55 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(y, y);          // (8 * y^2 * B^2)
fffa2f14:	7f e3 fb 78 	mr      r3,r31
fffa2f18:	7f e4 fb 78 	mr      r4,r31
fffa2f1c:	4b ff f9 49 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modsub(a, y);
fffa2f20:	38 61 01 18 	addi    r3,r1,280
fffa2f24:	7f e4 fb 78 	mr      r4,r31
fffa2f28:	4b ff f9 9d 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
    BN_COPY(y, a);            // Y = A * (4*C - D) - 8 * y^2 * B^2
fffa2f2c:	7f e3 fb 78 	mr      r3,r31
fffa2f30:	38 81 01 18 	addi    r4,r1,280
fffa2f34:	4b ff f3 c9 	bl      fffa22fc <_Z7BN_COPYPmPKm>
#endif

    return 0;
}
fffa2f38:	80 01 01 7c 	lwz     r0,380(r1)
fffa2f3c:	17 81 01 68 	lvd     d28,360(r1)
fffa2f40:	7c 08 03 a6 	mtlr    r0
fffa2f44:	17 c1 01 70 	lvd     d30,368(r1)
fffa2f48:	38 60 00 00 	li      r3,0
fffa2f4c:	38 21 01 78 	addi    r1,r1,376
fffa2f50:	4e 80 00 20 	blr

fffa2f54 <_Z6ec_addPmS_S_PKmS1_S1_>:

// returns 1 if result is at infinity, 0 otherwise
//
int ec_add (bn_t *x1,       bn_t *y1,       bn_t *z1,
             const bn_t *x2, const bn_t *y2, const bn_t *z2)
{
fffa2f54:	94 21 fe 38 	stwu    r1,-456(r1)
fffa2f58:	7c 08 02 a6 	mflr    r0
fffa2f5c:	1b 81 01 b8 	stvd    d28,440(r1)
fffa2f60:	7c 9d 23 78 	mr      r29,r4
    EC_ASSERT(!bn_ge_prime(z1));
    EC_ASSERT(!bn_ge_prime(x2));
    EC_ASSERT(!bn_ge_prime(y2));
    EC_ASSERT(!bn_ge_prime(z2));

    inf1 = ec_is_infinity(x1, y1, z1);
fffa2f64:	38 80 00 00 	li      r4,0

// returns 1 if result is at infinity, 0 otherwise
//
int ec_add (bn_t *x1,       bn_t *y1,       bn_t *z1,
             const bn_t *x2, const bn_t *y2, const bn_t *z2)
{
fffa2f68:	1b c1 01 c0 	stvd    d30,448(r1)
fffa2f6c:	90 01 01 cc 	stw     r0,460(r1)
fffa2f70:	7c 7f 1b 78 	mr      r31,r3
fffa2f74:	7c be 2b 78 	mr      r30,r5
fffa2f78:	18 c1 01 a8 	stvd    d6,424(r1)
fffa2f7c:	7d 1c 43 78 	mr      r28,r8
    EC_ASSERT(!bn_ge_prime(z1));
    EC_ASSERT(!bn_ge_prime(x2));
    EC_ASSERT(!bn_ge_prime(y2));
    EC_ASSERT(!bn_ge_prime(z2));

    inf1 = ec_is_infinity(x1, y1, z1);
fffa2f80:	4b ff f5 b9 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
fffa2f84:	39 20 00 00 	li      r9,0
fffa2f88:	06 c3 00 12 	bwz     r3,fffa2fac <_Z6ec_addPmS_S_PKmS1_S1_+0x58>
fffa2f8c:	7f a3 eb 78 	mr      r3,r29
fffa2f90:	38 80 00 00 	li      r4,0
fffa2f94:	4b ff f5 a5 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
fffa2f98:	7d 23 00 d0 	neg     r9,r3
fffa2f9c:	7d 23 18 38 	and     r3,r9,r3
fffa2fa0:	7c 69 00 34 	cntlzw  r9,r3
fffa2fa4:	39 29 ff e0 	addi    r9,r9,-32
fffa2fa8:	55 29 0f fe 	rlwinm  r9,r9,1,31,31
    inf2 = ec_is_infinity(x2, y2, z2);
fffa2fac:	80 61 01 a8 	lwz     r3,424(r1)
fffa2fb0:	38 80 00 00 	li      r4,0
fffa2fb4:	91 21 01 b0 	stw     r9,432(r1)
fffa2fb8:	4b ff f5 81 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
fffa2fbc:	81 21 01 b0 	lwz     r9,432(r1)
fffa2fc0:	06 c3 00 0e 	bwz     r3,fffa2fdc <_Z6ec_addPmS_S_PKmS1_S1_+0x88>
fffa2fc4:	80 61 01 ac 	lwz     r3,428(r1)
fffa2fc8:	38 80 00 00 	li      r4,0
fffa2fcc:	4b ff f5 6d 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
    EC_ASSERT(!bn_ge_prime(z1));
    EC_ASSERT(!bn_ge_prime(x2));
    EC_ASSERT(!bn_ge_prime(y2));
    EC_ASSERT(!bn_ge_prime(z2));

    inf1 = ec_is_infinity(x1, y1, z1);
fffa2fd0:	81 21 01 b0 	lwz     r9,432(r1)
fffa2fd4:	7d 2a 4b 78 	mr      r10,r9
    inf2 = ec_is_infinity(x2, y2, z2);
fffa2fd8:	06 43 00 f6 	bwnz    r3,fffa31c4 <_Z6ec_addPmS_S_PKmS1_S1_+0x270>
    if (inf2)
    {
        return inf1;
    }

    if (inf1)
fffa2fdc:	06 c9 00 16 	bwz     r9,fffa3008 <_Z6ec_addPmS_S_PKmS1_S1_+0xb4>
    {
        BN_COPY(x1, x2);
fffa2fe0:	80 81 01 a8 	lwz     r4,424(r1)
fffa2fe4:	7f e3 fb 78 	mr      r3,r31
fffa2fe8:	4b ff f3 15 	bl      fffa22fc <_Z7BN_COPYPmPKm>
        BN_COPY(y1, y2);
fffa2fec:	80 81 01 ac 	lwz     r4,428(r1)
fffa2ff0:	7f a3 eb 78 	mr      r3,r29
fffa2ff4:	4b ff f3 09 	bl      fffa22fc <_Z7BN_COPYPmPKm>
        BN_COPY(z1, z2);
fffa2ff8:	7f c3 f3 78 	mr      r3,r30
fffa2ffc:	7f 84 e3 78 	mr      r4,r28
fffa3000:	4b ff f2 fd 	bl      fffa22fc <_Z7BN_COPYPmPKm>
fffa3004:	48 00 01 bc 	b       fffa31c0 <_Z6ec_addPmS_S_PKmS1_S1_+0x26c>
        return 0;          // (x1,y1,z1) not infinity (checked above)
    }

    if (!bn_cmp(x1, x2) && !bn_cmp(y1, y2))
fffa3008:	80 81 01 a8 	lwz     r4,424(r1)
fffa300c:	7f e3 fb 78 	mr      r3,r31
fffa3010:	4b ff f4 e9 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa3014:	06 43 00 16 	bwnz    r3,fffa3040 <_Z6ec_addPmS_S_PKmS1_S1_+0xec>
fffa3018:	80 81 01 ac 	lwz     r4,428(r1)
fffa301c:	7f a3 eb 78 	mr      r3,r29
fffa3020:	4b ff f4 d9 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa3024:	06 43 00 0e 	bwnz    r3,fffa3040 <_Z6ec_addPmS_S_PKmS1_S1_+0xec>
    {
        return ec_double(x1, y1, z1);
fffa3028:	7f e3 fb 78 	mr      r3,r31
fffa302c:	7f a4 eb 78 	mr      r4,r29
fffa3030:	7f c5 f3 78 	mr      r5,r30
fffa3034:	4b ff fd 05 	bl      fffa2d38 <_Z9ec_doublePmS_S_>
fffa3038:	7c 6a 1b 78 	mr      r10,r3
fffa303c:	48 00 01 88 	b       fffa31c4 <_Z6ec_addPmS_S_PKmS1_S1_+0x270>
#ifdef EC_POWER64_RED
    bn_modred_slow(x1);
#endif

#else // !EC_POWER64_ALG
    BN_COPY(t1, y1);
fffa3040:	38 61 00 4c 	addi    r3,r1,76
fffa3044:	7f a4 eb 78 	mr      r4,r29
fffa3048:	4b ff f2 b5 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(t1, z2);    // t1 = y1 * z2
fffa304c:	38 61 00 4c 	addi    r3,r1,76
fffa3050:	7f 84 e3 78 	mr      r4,r28
fffa3054:	4b ff f6 ad 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    BN_COPY(a, y2);
fffa3058:	80 81 01 ac 	lwz     r4,428(r1)
fffa305c:	38 61 01 5c 	addi    r3,r1,348
fffa3060:	4b ff f2 9d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(a, z1);     // A = y2 * z1 - y1 * z2
fffa3064:	38 61 01 5c 	addi    r3,r1,348
fffa3068:	7f c4 f3 78 	mr      r4,r30
fffa306c:	4b ff f6 95 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(a, t1);
fffa3070:	38 61 01 5c 	addi    r3,r1,348
fffa3074:	38 81 00 4c 	addi    r4,r1,76
fffa3078:	4b ff f8 4d 	bl      fffa28c4 <_Z9bn_modsubPmPKm>

    bn_modmul_prime(x1, z2);    // x1 := x1 * z2     orig x1 no longer used
fffa307c:	7f e3 fb 78 	mr      r3,r31
fffa3080:	7f 84 e3 78 	mr      r4,r28
fffa3084:	4b ff f6 7d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    BN_COPY(b, x2);
fffa3088:	80 81 01 a8 	lwz     r4,424(r1)
fffa308c:	38 61 01 18 	addi    r3,r1,280
fffa3090:	4b ff f2 6d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(b, z1);
fffa3094:	38 61 01 18 	addi    r3,r1,280
fffa3098:	7f c4 f3 78 	mr      r4,r30
fffa309c:	4b ff f6 65 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(b, x1);           // B = x2 * z1 - x1 * z2
fffa30a0:	38 61 01 18 	addi    r3,r1,280
fffa30a4:	7f e4 fb 78 	mr      r4,r31
fffa30a8:	4b ff f8 1d 	bl      fffa28c4 <_Z9bn_modsubPmPKm>

    BN_COPY(bs, b);
fffa30ac:	38 61 00 90 	addi    r3,r1,144
fffa30b0:	38 81 01 18 	addi    r4,r1,280
fffa30b4:	4b ff f2 49 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(bs, bs);    // B^2
fffa30b8:	38 61 00 90 	addi    r3,r1,144
fffa30bc:	7c 64 1b 78 	mr      r4,r3
fffa30c0:	4b ff f6 41 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    BN_COPY(c, a);
fffa30c4:	38 61 00 d4 	addi    r3,r1,212
fffa30c8:	38 81 01 5c 	addi    r4,r1,348
fffa30cc:	4b ff f2 31 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(c, c);
fffa30d0:	38 61 00 d4 	addi    r3,r1,212
fffa30d4:	7c 64 1b 78 	mr      r4,r3
fffa30d8:	4b ff f6 29 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(c, z1);
fffa30dc:	38 61 00 d4 	addi    r3,r1,212
fffa30e0:	7f c4 f3 78 	mr      r4,r30
fffa30e4:	4b ff f6 1d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(c, z2);
fffa30e8:	38 61 00 d4 	addi    r3,r1,212
fffa30ec:	7f 84 e3 78 	mr      r4,r28
fffa30f0:	4b ff f6 11 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    BN_COPY(t2, b);
fffa30f4:	38 61 00 08 	addi    r3,r1,8
fffa30f8:	38 81 01 18 	addi    r4,r1,280
fffa30fc:	4b ff f2 01 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modadd(t2, x1);
fffa3100:	38 61 00 08 	addi    r3,r1,8
fffa3104:	7f e4 fb 78 	mr      r4,r31
fffa3108:	4b ff f7 5d 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modadd(t2, x1);
fffa310c:	38 61 00 08 	addi    r3,r1,8
fffa3110:	7f e4 fb 78 	mr      r4,r31
fffa3114:	4b ff f7 51 	bl      fffa2864 <_Z9bn_modaddPmPKm>
    bn_modmul_prime(t2, bs);
fffa3118:	38 61 00 08 	addi    r3,r1,8
fffa311c:	38 81 00 90 	addi    r4,r1,144
fffa3120:	4b ff f5 e1 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(c, t2);           // C = A^2 * z1 * z2 - B^3
fffa3124:	38 61 00 d4 	addi    r3,r1,212
fffa3128:	38 81 00 08 	addi    r4,r1,8
fffa312c:	4b ff f7 99 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
                                //     - 2 B^2 * x1 * z1

    bn_modmul_prime(z1, z2);
fffa3130:	7f c3 f3 78 	mr      r3,r30
fffa3134:	7f 84 e3 78 	mr      r4,r28
fffa3138:	4b ff f5 c9 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(z1, b);
fffa313c:	7f c3 f3 78 	mr      r3,r30
fffa3140:	38 81 01 18 	addi    r4,r1,280
fffa3144:	4b ff f5 bd 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(z1, bs);    // z1 * z2 * B^3
fffa3148:	7f c3 f3 78 	mr      r3,r30
fffa314c:	38 81 00 90 	addi    r4,r1,144
fffa3150:	4b ff f5 b1 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>

    bn_modmul_prime(t1, b);
fffa3154:	38 61 00 4c 	addi    r3,r1,76
fffa3158:	38 81 01 18 	addi    r4,r1,280
fffa315c:	4b ff f5 a5 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modmul_prime(t1, bs);    // (B^3 * y1 * z2)
fffa3160:	38 61 00 4c 	addi    r3,r1,76
fffa3164:	38 81 00 90 	addi    r4,r1,144
fffa3168:	4b ff f5 99 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    // A(B 2 X1 Z2 ? C)
    bn_modmul_prime(x1, bs);    // (B^2 * x1 * z2)
fffa316c:	7f e3 fb 78 	mr      r3,r31
fffa3170:	38 81 00 90 	addi    r4,r1,144
fffa3174:	4b ff f5 8d 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(x1, c);
fffa3178:	7f e3 fb 78 	mr      r3,r31
fffa317c:	38 81 00 d4 	addi    r4,r1,212
fffa3180:	4b ff f7 45 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
    bn_modmul_prime(x1, a);     // A *  (B^2 * x1 * z2 - C)
fffa3184:	7f e3 fb 78 	mr      r3,r31
fffa3188:	38 81 01 5c 	addi    r4,r1,348
fffa318c:	4b ff f5 75 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
    bn_modsub(x1, t1);
fffa3190:	7f e3 fb 78 	mr      r3,r31
fffa3194:	38 81 00 4c 	addi    r4,r1,76
fffa3198:	4b ff f7 2d 	bl      fffa28c4 <_Z9bn_modsubPmPKm>
    BN_COPY(y1, x1);            // Y =
fffa319c:	7f a3 eb 78 	mr      r3,r29
fffa31a0:	7f e4 fb 78 	mr      r4,r31
fffa31a4:	4b ff f1 59 	bl      fffa22fc <_Z7BN_COPYPmPKm>

    BN_COPY(x1, b);
fffa31a8:	7f e3 fb 78 	mr      r3,r31
fffa31ac:	38 81 01 18 	addi    r4,r1,280
fffa31b0:	4b ff f1 4d 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_prime(x1, c);     // X = B * C
fffa31b4:	7f e3 fb 78 	mr      r3,r31
fffa31b8:	38 81 00 d4 	addi    r4,r1,212
fffa31bc:	4b ff f5 45 	bl      fffa2700 <_Z15bn_modmul_primePmPKm>
#endif

    return 0;
fffa31c0:	39 40 00 00 	li      r10,0
}
fffa31c4:	80 01 01 cc 	lwz     r0,460(r1)
fffa31c8:	17 81 01 b8 	lvd     d28,440(r1)
fffa31cc:	7c 08 03 a6 	mtlr    r0
fffa31d0:	17 c1 01 c0 	lvd     d30,448(r1)
fffa31d4:	7d 43 53 78 	mr      r3,r10
fffa31d8:	38 21 01 c8 	addi    r1,r1,456
fffa31dc:	4e 80 00 20 	blr

fffa31e0 <_Z11ec_multiplyPmS_S_PKm>:
//
// LIMIT: processes up to EC_PRIMEBITS in coefficient
// z and k must not overlap
//
int ec_multiply (bn_t *x, bn_t *y, bn_t *z, const bn_t *k)
{
fffa31e0:	94 21 ff 10 	stwu    r1,-240(r1)
fffa31e4:	7c 08 02 a6 	mflr    r0
fffa31e8:	1b 81 00 e0 	stvd    d28,224(r1)
fffa31ec:	7c 7d 1b 78 	mr      r29,r3
    EC_ASSERT(NULL != y);
    EC_ASSERT(NULL != k);
    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(y));

    i=bn_bits(k);
fffa31f0:	7c c3 33 78 	mr      r3,r6
//
// LIMIT: processes up to EC_PRIMEBITS in coefficient
// z and k must not overlap
//
int ec_multiply (bn_t *x, bn_t *y, bn_t *z, const bn_t *k)
{
fffa31f4:	90 01 00 f4 	stw     r0,244(r1)
fffa31f8:	7c 9c 23 78 	mr      r28,r4
fffa31fc:	1b c1 00 e8 	stvd    d30,232(r1)
fffa3200:	7c df 33 78 	mr      r31,r6
fffa3204:	7c be 2b 78 	mr      r30,r5
    EC_ASSERT(NULL != y);
    EC_ASSERT(NULL != k);
    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(y));

    i=bn_bits(k);
fffa3208:	4b ff f7 c9 	bl      fffa29d0 <_Z7bn_bitsPKm>
fffa320c:	7c 69 1b 78 	mr      r9,r3
    k += NWORDS-1;

    BN_COPY(px, x);
fffa3210:	7f a4 eb 78 	mr      r4,r29
fffa3214:	38 61 00 90 	addi    r3,r1,144
fffa3218:	91 21 00 dc 	stw     r9,220(r1)
fffa321c:	4b ff f0 e1 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    BN_COPY(py, y);
fffa3220:	38 61 00 4c 	addi    r3,r1,76
fffa3224:	7f 84 e3 78 	mr      r4,r28
fffa3228:	4b ff f0 d5 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_clear(x);
fffa322c:	38 80 00 00 	li      r4,0
fffa3230:	38 a0 00 44 	li      r5,68
fffa3234:	7f a3 eb 78 	mr      r3,r29
fffa3238:	48 00 27 69 	bl      fffa59a0 <memset>
    bn_clear(y);
fffa323c:	38 80 00 00 	li      r4,0
fffa3240:	38 a0 00 44 	li      r5,68
fffa3244:	7f 83 e3 78 	mr      r3,r28
fffa3248:	48 00 27 59 	bl      fffa59a0 <memset>

    bn_clear(z);
fffa324c:	38 80 00 00 	li      r4,0
fffa3250:	38 a0 00 44 	li      r5,68
fffa3254:	7f c3 f3 78 	mr      r3,r30
fffa3258:	48 00 27 49 	bl      fffa59a0 <memset>
    BN_LSW(z) = 1;       // (x,y)   -> (x, y, 1)  in projective coordinates
fffa325c:	39 40 00 01 	li      r10,1
fffa3260:	91 5e 00 40 	stw     r10,64(r30)
    BN_COPY(pz, z);      // (px,py) -> (px,py,1)
fffa3264:	38 61 00 08 	addi    r3,r1,8
fffa3268:	7f c4 f3 78 	mr      r4,r30
fffa326c:	4b ff f0 91 	bl      fffa22fc <_Z7BN_COPYPmPKm>
fffa3270:	81 21 00 dc 	lwz     r9,220(r1)
    EC_ASSERT(NULL != k);
    EC_ASSERT(!bn_ge_prime(x));
    EC_ASSERT(!bn_ge_prime(y));

    i=bn_bits(k);
    k += NWORDS-1;
fffa3274:	3b ff 00 40 	addi    r31,r31,64
fffa3278:	39 29 ff ff 	addi    r9,r9,-1
int ec_multiply (bn_t *x, bn_t *y, bn_t *z, const bn_t *k)
{

    bn_t px[ NWORDS ], py[ NWORDS ], pz[ NWORDS ];
    unsigned int i;
    bn_t mask = 1;
fffa327c:	39 40 00 01 	li      r10,1
    BN_DUMP(i,y);
    BN_DUMP(i,z);
    BN_DUMP(i,px);
    BN_DUMP(i,py);
    BN_DUMP(i,pz);
    while (0 < i--)
fffa3280:	2c 09 ff ff 	cmpwi   r9,-1
fffa3284:	41 82 00 78 	beq     fffa32fc <_Z11ec_multiplyPmS_S_PKm+0x11c>
    {
        if (mask & *k)
fffa3288:	81 1f 00 00 	lwz     r8,0(r31)
fffa328c:	7d 48 40 38 	and     r8,r10,r8
fffa3290:	06 c8 00 18 	bwz     r8,fffa32c0 <_Z11ec_multiplyPmS_S_PKm+0xe0>
        {
            ec_add(x, y, z, px, py, pz);
fffa3294:	7f a3 eb 78 	mr      r3,r29
fffa3298:	7f 84 e3 78 	mr      r4,r28
fffa329c:	7f c5 f3 78 	mr      r5,r30
fffa32a0:	38 c1 00 90 	addi    r6,r1,144
fffa32a4:	38 e1 00 4c 	addi    r7,r1,76
fffa32a8:	39 01 00 08 	addi    r8,r1,8
fffa32ac:	91 21 00 dc 	stw     r9,220(r1)
fffa32b0:	91 41 00 d8 	stw     r10,216(r1)
fffa32b4:	4b ff fc a1 	bl      fffa2f54 <_Z6ec_addPmS_S_PKmS1_S1_>
fffa32b8:	81 41 00 d8 	lwz     r10,216(r1)
fffa32bc:	81 21 00 dc 	lwz     r9,220(r1)
        }

        if (0 < i)
fffa32c0:	06 c9 00 12 	bwz     r9,fffa32e4 <_Z11ec_multiplyPmS_S_PKm+0x104>
        {
            ec_double(px, py, pz);
fffa32c4:	38 61 00 90 	addi    r3,r1,144
fffa32c8:	38 81 00 4c 	addi    r4,r1,76
fffa32cc:	38 a1 00 08 	addi    r5,r1,8
fffa32d0:	91 21 00 dc 	stw     r9,220(r1)
fffa32d4:	91 41 00 d8 	stw     r10,216(r1)
fffa32d8:	4b ff fa 61 	bl      fffa2d38 <_Z9ec_doublePmS_S_>
fffa32dc:	81 41 00 d8 	lwz     r10,216(r1)
fffa32e0:	81 21 00 dc 	lwz     r9,220(r1)
        BN_DUMP(i,y);
        BN_DUMP(i,z);
        BN_DUMP(i,px);
        BN_DUMP(i,py);
        BN_DUMP(i,pz);
        mask <<= 1;
fffa32e4:	55 4a 08 3c 	rlwinm  r10,r10,1,0,30
        if (!mask)
fffa32e8:	06 4a 00 06 	bwnz    r10,fffa32f4 <_Z11ec_multiplyPmS_S_PKm+0x114>
        {
            --k;
fffa32ec:	3b ff ff fc 	addi    r31,r31,-4
            mask = 1;
fffa32f0:	39 40 00 01 	li      r10,1
fffa32f4:	39 29 ff ff 	addi    r9,r9,-1
fffa32f8:	4b ff ff 88 	b       fffa3280 <_Z11ec_multiplyPmS_S_PKm+0xa0>
        }
    }
        BN_EXIT();

    return 0;
}
fffa32fc:	80 01 00 f4 	lwz     r0,244(r1)
fffa3300:	17 81 00 e0 	lvd     d28,224(r1)
fffa3304:	7c 08 03 a6 	mtlr    r0
fffa3308:	17 c1 00 e8 	lvd     d30,232(r1)
fffa330c:	38 60 00 00 	li      r3,0
fffa3310:	38 21 00 f0 	addi    r1,r1,240
fffa3314:	4e 80 00 20 	blr

fffa3318 <_Z9ec_verifyPKhS0_S0_>:
{
    bn_t r[ NWORDS ],  s[ NWORDS ],  e[ NWORDS ],
    px[ NWORDS ], py[ NWORDS ], pz[ NWORDS ],
    u1[ NWORDS ], u2[ NWORDS ];

    if ((NULL == publicpt) || (NULL == signature) || (NULL == hash))
fffa3318:	06 c3 00 fc 	bwz     r3,fffa3510 <_Z9ec_verifyPKhS0_S0_+0x1f8>
fffa331c:	06 c5 00 fa 	bwz     r5,fffa3510 <_Z9ec_verifyPKhS0_S0_+0x1f8>
fffa3320:	06 c4 00 f8 	bwz     r4,fffa3510 <_Z9ec_verifyPKhS0_S0_+0x1f8>
//=====================================================  public function  ====

int ec_verify (const unsigned char *publicpt,    /* 2*EC_COORDBYTES */
               const unsigned char *hash,        /*   EC_HASHBYTES  */
               const unsigned char *signature)   /* 2*EC_COORDBYTES */
{
fffa3324:	94 21 fd c8 	stwu    r1,-568(r1)
fffa3328:	7c 08 02 a6 	mflr    r0
fffa332c:	1b c1 02 30 	stvd    d30,560(r1)
fffa3330:	1b 81 02 28 	stvd    d28,552(r1)
fffa3334:	7c be 2b 78 	mr      r30,r5
fffa3338:	7c 7f 1b 78 	mr      r31,r3
fffa333c:	7c 9d 23 78 	mr      r29,r4
    if ((NULL == publicpt) || (NULL == signature) || (NULL == hash))
    {
        return -1;
    }

    bn_read_pt  (r,  signature);
fffa3340:	38 61 01 e4 	addi    r3,r1,484
fffa3344:	7c a4 2b 78 	mr      r4,r5
//=====================================================  public function  ====

int ec_verify (const unsigned char *publicpt,    /* 2*EC_COORDBYTES */
               const unsigned char *hash,        /*   EC_HASHBYTES  */
               const unsigned char *signature)   /* 2*EC_COORDBYTES */
{
fffa3348:	90 01 02 3c 	stw     r0,572(r1)
    if ((NULL == publicpt) || (NULL == signature) || (NULL == hash))
    {
        return -1;
    }

    bn_read_pt  (r,  signature);
fffa334c:	4b ff f9 99 	bl      fffa2ce4 <_Z10bn_read_ptPmPKh>
    bn_read_pt  (s,  signature +EC_COORDBYTES);
fffa3350:	38 9e 00 42 	addi    r4,r30,66
fffa3354:	38 61 01 a0 	addi    r3,r1,416
fffa3358:	4b ff f9 8d 	bl      fffa2ce4 <_Z10bn_read_ptPmPKh>
    bn_read_hash(e,  hash);
fffa335c:	38 61 01 5c 	addi    r3,r1,348
fffa3360:	7f a4 eb 78 	mr      r4,r29
fffa3364:	4b ff f9 89 	bl      fffa2cec <_Z12bn_read_hashPmPKh>
    bn_read_pt  (px, publicpt);
fffa3368:	7f e4 fb 78 	mr      r4,r31
fffa336c:	38 61 01 18 	addi    r3,r1,280
fffa3370:	4b ff f9 75 	bl      fffa2ce4 <_Z10bn_read_ptPmPKh>
    bn_read_pt  (py, publicpt +EC_COORDBYTES);
fffa3374:	38 9f 00 42 	addi    r4,r31,66

    if (bn_ge_order(r)  || bn_ge_order(s)  ||
fffa3378:	3f e0 ff fa 	lis     r31,-6
fffa337c:	3b ff 71 24 	addi    r31,r31,28964

    bn_read_pt  (r,  signature);
    bn_read_pt  (s,  signature +EC_COORDBYTES);
    bn_read_hash(e,  hash);
    bn_read_pt  (px, publicpt);
    bn_read_pt  (py, publicpt +EC_COORDBYTES);
fffa3380:	38 61 00 d4 	addi    r3,r1,212

    if (bn_ge_order(r)  || bn_ge_order(s)  ||
fffa3384:	3b df 00 44 	addi    r30,r31,68

    bn_read_pt  (r,  signature);
    bn_read_pt  (s,  signature +EC_COORDBYTES);
    bn_read_hash(e,  hash);
    bn_read_pt  (px, publicpt);
    bn_read_pt  (py, publicpt +EC_COORDBYTES);
fffa3388:	4b ff f9 5d 	bl      fffa2ce4 <_Z10bn_read_ptPmPKh>

    if (bn_ge_order(r)  || bn_ge_order(s)  ||
fffa338c:	38 61 01 e4 	addi    r3,r1,484
fffa3390:	7f c4 f3 78 	mr      r4,r30
fffa3394:	4b ff f1 65 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
        bn_is_zero(s,0) || bn_is_zero(r,0))
fffa3398:	06 83 00 06 	bwltz   r3,fffa33a4 <_Z9ec_verifyPKhS0_S0_+0x8c>
    {
        return 0;                // assume user messed with signature
fffa339c:	38 60 00 00 	li      r3,0
fffa33a0:	48 00 01 58 	b       fffa34f8 <_Z9ec_verifyPKhS0_S0_+0x1e0>
    bn_read_pt  (s,  signature +EC_COORDBYTES);
    bn_read_hash(e,  hash);
    bn_read_pt  (px, publicpt);
    bn_read_pt  (py, publicpt +EC_COORDBYTES);

    if (bn_ge_order(r)  || bn_ge_order(s)  ||
fffa33a4:	38 61 01 a0 	addi    r3,r1,416
fffa33a8:	7f c4 f3 78 	mr      r4,r30
fffa33ac:	4b ff f1 4d 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa33b0:	06 03 07 f6 	bwgez   r3,fffa339c <_Z9ec_verifyPKhS0_S0_+0x84>
        bn_is_zero(s,0) || bn_is_zero(r,0))
fffa33b4:	38 61 01 a0 	addi    r3,r1,416
fffa33b8:	38 80 00 00 	li      r4,0
fffa33bc:	4b ff f1 7d 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
    bn_read_pt  (s,  signature +EC_COORDBYTES);
    bn_read_hash(e,  hash);
    bn_read_pt  (px, publicpt);
    bn_read_pt  (py, publicpt +EC_COORDBYTES);

    if (bn_ge_order(r)  || bn_ge_order(s)  ||
fffa33c0:	06 43 07 ee 	bwnz    r3,fffa339c <_Z9ec_verifyPKhS0_S0_+0x84>
        bn_is_zero(s,0) || bn_is_zero(r,0))
fffa33c4:	38 61 01 e4 	addi    r3,r1,484
fffa33c8:	38 80 00 00 	li      r4,0
fffa33cc:	4b ff f1 6d 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
fffa33d0:	06 43 07 e6 	bwnz    r3,fffa339c <_Z9ec_verifyPKhS0_S0_+0x84>
    {
        return 0;                // assume user messed with signature
    }

    if (bn_ge_prime(px)  || bn_ge_prime(py)  ||
fffa33d4:	38 61 01 18 	addi    r3,r1,280
fffa33d8:	7f e4 fb 78 	mr      r4,r31
fffa33dc:	4b ff f1 1d 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
        bn_is_zero(px,0) || bn_is_zero(py,0))
fffa33e0:	06 83 00 06 	bwltz   r3,fffa33ec <_Z9ec_verifyPKhS0_S0_+0xd4>
    px[ NWORDS ], py[ NWORDS ], pz[ NWORDS ],
    u1[ NWORDS ], u2[ NWORDS ];

    if ((NULL == publicpt) || (NULL == signature) || (NULL == hash))
    {
        return -1;
fffa33e4:	38 60 ff ff 	li      r3,-1
fffa33e8:	48 00 01 10 	b       fffa34f8 <_Z9ec_verifyPKhS0_S0_+0x1e0>
        bn_is_zero(s,0) || bn_is_zero(r,0))
    {
        return 0;                // assume user messed with signature
    }

    if (bn_ge_prime(px)  || bn_ge_prime(py)  ||
fffa33ec:	38 61 00 d4 	addi    r3,r1,212
fffa33f0:	7f e4 fb 78 	mr      r4,r31
fffa33f4:	4b ff f1 05 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa33f8:	06 03 07 f6 	bwgez   r3,fffa33e4 <_Z9ec_verifyPKhS0_S0_+0xcc>
        bn_is_zero(px,0) || bn_is_zero(py,0))
fffa33fc:	38 61 01 18 	addi    r3,r1,280
fffa3400:	38 80 00 00 	li      r4,0
fffa3404:	4b ff f1 35 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
        bn_is_zero(s,0) || bn_is_zero(r,0))
    {
        return 0;                // assume user messed with signature
    }

    if (bn_ge_prime(px)  || bn_ge_prime(py)  ||
fffa3408:	06 43 07 ee 	bwnz    r3,fffa33e4 <_Z9ec_verifyPKhS0_S0_+0xcc>
        bn_is_zero(px,0) || bn_is_zero(py,0))
fffa340c:	38 61 00 d4 	addi    r3,r1,212
fffa3410:	38 80 00 00 	li      r4,0
fffa3414:	4b ff f1 25 	bl      fffa2538 <_Z10bn_is_zeroPKmj>
fffa3418:	06 43 07 e6 	bwnz    r3,fffa33e4 <_Z9ec_verifyPKhS0_S0_+0xcc>
    {
        return -1;               // admin fault; should not happen
    }

    bn_modinv(u1, s, consts_p()->ec_order);      // s no longer needed (NLN)
fffa341c:	7f c5 f3 78 	mr      r5,r30
fffa3420:	38 81 01 a0 	addi    r4,r1,416
fffa3424:	38 61 00 4c 	addi    r3,r1,76
fffa3428:	4b ff f5 f5 	bl      fffa2a1c <_Z9bn_modinvPmPKmS1_>
    BN_COPY(u2, r);
fffa342c:	38 61 00 08 	addi    r3,r1,8
fffa3430:	38 81 01 e4 	addi    r4,r1,484
fffa3434:	4b ff ee c9 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    bn_modmul_order(u2, u1);
fffa3438:	38 61 00 08 	addi    r3,r1,8
fffa343c:	38 81 00 4c 	addi    r4,r1,76
fffa3440:	4b ff f3 e1 	bl      fffa2820 <_Z15bn_modmul_orderPmPKm>
    bn_modmul_order(u1, e);          // e NLN
fffa3444:	38 61 00 4c 	addi    r3,r1,76
fffa3448:	38 81 01 5c 	addi    r4,r1,348
fffa344c:	4b ff f3 d5 	bl      fffa2820 <_Z15bn_modmul_orderPmPKm>

    // reuse (e,s) for base multiplication
    BN_COPY(e, consts_p()->prime_px);            // (e,s) <- (base point)
fffa3450:	38 61 01 5c 	addi    r3,r1,348
fffa3454:	38 9f 00 88 	addi    r4,r31,136
fffa3458:	4b ff ee a5 	bl      fffa22fc <_Z7BN_COPYPmPKm>
    BN_COPY(s, consts_p()->prime_py);
fffa345c:	38 61 01 a0 	addi    r3,r1,416
fffa3460:	38 9f 00 cc 	addi    r4,r31,204
fffa3464:	4b ff ee 99 	bl      fffa22fc <_Z7BN_COPYPmPKm>

    ec_multiply(px, py, pz, u2);     // (px,py,pz) = u2 * (px,py);  u2 NLN
fffa3468:	38 81 00 d4 	addi    r4,r1,212
fffa346c:	38 a1 00 90 	addi    r5,r1,144
fffa3470:	38 c1 00 08 	addi    r6,r1,8
fffa3474:	38 61 01 18 	addi    r3,r1,280
fffa3478:	4b ff fd 69 	bl      fffa31e0 <_Z11ec_multiplyPmS_S_PKm>
    ec_multiply(e,  s,  u2, u1);     // (s, e, u2) = u1 * (gx,gy);  u1 NLN
fffa347c:	38 81 01 a0 	addi    r4,r1,416
fffa3480:	38 a1 00 08 	addi    r5,r1,8
fffa3484:	38 c1 00 4c 	addi    r6,r1,76
fffa3488:	38 61 01 5c 	addi    r3,r1,348
fffa348c:	4b ff fd 55 	bl      fffa31e0 <_Z11ec_multiplyPmS_S_PKm>

    if (ec_add(px, py, pz, e, s, u2))  // u1 * base + u2 * public
fffa3490:	38 61 01 18 	addi    r3,r1,280
fffa3494:	38 81 00 d4 	addi    r4,r1,212
fffa3498:	38 a1 00 90 	addi    r5,r1,144
fffa349c:	38 c1 01 5c 	addi    r6,r1,348
fffa34a0:	38 e1 01 a0 	addi    r7,r1,416
fffa34a4:	39 01 00 08 	addi    r8,r1,8
fffa34a8:	4b ff fa ad 	bl      fffa2f54 <_Z6ec_addPmS_S_PKmS1_S1_>
fffa34ac:	06 43 07 78 	bwnz    r3,fffa339c <_Z9ec_verifyPKhS0_S0_+0x84>
    {
        return 0;                  // reached infinity (SNH with sig)
    }

    ec_projective2affine(px, pz);
fffa34b0:	38 61 01 18 	addi    r3,r1,280
fffa34b4:	38 81 00 90 	addi    r4,r1,144
fffa34b8:	4b ff f8 3d 	bl      fffa2cf4 <_Z20ec_projective2affinePmPKm>

    if (bn_ge_order(px))
fffa34bc:	38 61 01 18 	addi    r3,r1,280
fffa34c0:	7f c4 f3 78 	mr      r4,r30
fffa34c4:	4b ff f0 35 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa34c8:	06 83 00 08 	bwltz   r3,fffa34d8 <_Z9ec_verifyPKhS0_S0_+0x1c0>
    {
        bn_sub(px, consts_p()->ec_order);    // px mod order
fffa34cc:	38 61 01 18 	addi    r3,r1,280
fffa34d0:	7f c4 f3 78 	mr      r4,r30
fffa34d4:	4b ff f0 f9 	bl      fffa25cc <_Z6bn_subPmPKm>
    }

    return (! bn_cmp(r, px));
fffa34d8:	38 61 01 e4 	addi    r3,r1,484
fffa34dc:	38 81 01 18 	addi    r4,r1,280
fffa34e0:	4b ff f0 19 	bl      fffa24f8 <_Z6bn_cmpPKmS0_>
fffa34e4:	7d 23 00 d0 	neg     r9,r3
fffa34e8:	7d 23 18 38 	and     r3,r9,r3
fffa34ec:	7c 63 00 34 	cntlzw  r3,r3
fffa34f0:	20 63 00 1f 	subfic  r3,r3,31
fffa34f4:	54 63 0f fe 	rlwinm  r3,r3,1,31,31
}
fffa34f8:	80 01 02 3c 	lwz     r0,572(r1)
fffa34fc:	17 81 02 28 	lvd     d28,552(r1)
fffa3500:	7c 08 03 a6 	mtlr    r0
fffa3504:	17 c1 02 30 	lvd     d30,560(r1)
fffa3508:	38 21 02 38 	addi    r1,r1,568
fffa350c:	4e 80 00 20 	blr
    px[ NWORDS ], py[ NWORDS ], pz[ NWORDS ],
    u1[ NWORDS ], u2[ NWORDS ];

    if ((NULL == publicpt) || (NULL == signature) || (NULL == hash))
    {
        return -1;
fffa3510:	38 60 ff ff 	li      r3,-1
    {
        bn_sub(px, consts_p()->ec_order);    // px mod order
    }

    return (! bn_cmp(r, px));
}
fffa3514:	4e 80 00 20 	blr

fffa3518 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>:
    }
    FAPI_INF("Exiting recoverPibErr");
    return pibErr;
}
#endif
static fapi2::ReturnCode handle_scom_error(const uint32_t i_addr, uint64_t *io_data,
fffa3518:	94 21 ff f0 	stwu    r1,-16(r1)
    {

    }
    SBE_SCOM_FAILURE()
    {
        fapi2::current_err = RC_SBE_SCOM_FAILURE;
fffa351c:	3d 40 00 98 	lis     r10,152
fffa3520:	1b c1 00 08 	stvd    d30,8(r1)
fffa3524:	61 4a 3a b6 	ori     r10,r10,15030
fffa3528:	7c 08 02 a6 	mflr    r0
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("SBE encountered a SCOM failure");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SCOM_FAILURE;
fffa352c:	3f c0 ff fb 	lis     r30,-5
fffa3530:	39 3e bb e8 	addi    r9,r30,-17432
    {

    }
    SBE_SCOM_FAILURE()
    {
        fapi2::current_err = RC_SBE_SCOM_FAILURE;
fffa3534:	91 4d 46 f0 	stw     r10,18160(r13)
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("SBE encountered a SCOM failure");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SCOM_FAILURE;
fffa3538:	91 5e bb e8 	stw     r10,-17432(r30)
        fapi2::g_FfdcData.ffdcLength = 2 * sizeof(sbeFfdc_t);
fffa353c:	39 40 00 18 	li      r10,24
fffa3540:	90 01 00 14 	stw     r0,20(r1)
fffa3544:	91 49 00 04 	stw     r10,4(r9)
template<typename T>
inline uint64_t convertType( T& i_value )
{
    // for simplicity sake, all FFDC chunks from the SBE
    // are going to be sent as a uint64_t
    return static_cast<uint64_t>(i_value);
fffa3548:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa354c:	91 49 00 0c 	stw     r10,12(r9)
{
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
fffa3550:	91 49 00 18 	stw     r10,24(r9)

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa3554:	39 00 00 04 	li      r8,4
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa3558:	39 40 00 01 	li      r10,1
    };

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa355c:	90 69 00 10 	stw     r3,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa3560:	91 09 00 08 	stw     r8,8(r9)
{
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
fffa3564:	90 a9 00 1c 	stw     r5,28(r9)
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa3568:	91 49 00 14 	stw     r10,20(r9)
fffa356c:	7c 66 1b 78 	mr      r6,r3
fffa3570:	7c bf 2b 78 	mr      r31,r5
    //if (PIB_NO_ERROR == i_pibRc)
    //{
    //    return FAPI2_RC_SUCCESS;
    //}

    PLAT_FAPI_ASSERT( false,
fffa3574:	3c 60 58 43 	lis     r3,22595
fffa3578:	14 e4 00 00 	lvd     d7,0(r4)
fffa357c:	60 63 00 04 	ori     r3,r3,4
fffa3580:	3b ff ff ff 	addi    r31,r31,-1
fffa3584:	48 00 05 cd 	bl      fffa3b50 <pk_trace_big>
fffa3588:	28 1f 00 06 	cmplwi  r31,6
                      "SCOM : pcb pib error, pibRc[0x%08X] Translated_ScomAddr[0x%08X]"
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
fffa358c:	38 60 00 00 	li      r3,0
fffa3590:	41 81 00 14 	bgt     fffa35a4 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7+0x8c>
fffa3594:	3d 20 ff fa 	lis     r9,-6
fffa3598:	57 ff 10 3a 	rlwinm  r31,r31,2,0,29
fffa359c:	39 29 73 00 	addi    r9,r9,29440
fffa35a0:	7c 69 f8 2e 	lwzx    r3,r9,r31
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
    return fapi2::current_err;
}
fffa35a4:	80 01 00 14 	lwz     r0,20(r1)
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
fffa35a8:	90 7e bb e8 	stw     r3,-17432(r30)
    return fapi2::current_err;
}
fffa35ac:	7c 08 03 a6 	mtlr    r0
fffa35b0:	17 c1 00 08 	lvd     d30,8(r1)
                      "SCOM : pcb pib error, pibRc[0x%08X] Translated_ScomAddr[0x%08X]"
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
fffa35b4:	90 6d 46 f0 	stw     r3,18160(r13)
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
    return fapi2::current_err;
}
fffa35b8:	38 21 00 10 	addi    r1,r1,16
fffa35bc:	4e 80 00 20 	blr

fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>:

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fffa35c0:	94 21 ff f0 	stwu    r1,-16(r1)
fffa35c4:	7c 08 02 a6 	mflr    r0
fffa35c8:	1b c1 00 08 	stvd    d30,8(r1)
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fffa35cc:	7c 83 23 78 	mr      r3,r4
    return fapi2::current_err;
}

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fffa35d0:	7c 9e 23 78 	mr      r30,r4
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fffa35d4:	7c a4 2b 78 	mr      r4,r5
    return fapi2::current_err;
}

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fffa35d8:	7c bf 2b 78 	mr      r31,r5
fffa35dc:	90 01 00 14 	stw     r0,20(r1)
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fffa35e0:	48 00 00 b5 	bl      fffa3694 <getscom_abs>
fffa35e4:	7c 65 1b 78 	mr      r5,r3
        ///
        /// @brief Constructor.
        /// @param[in] i_rc the rc to set
        ///
        ReturnCode(const uint32_t i_rc = FAPI2_RC_SUCCESS):
            iv_rc(i_rc)
fffa35e8:	38 60 00 00 	li      r3,0
    FAPI_DBG("getScom: Address: 0x%08X returned pibRc: 0x%08X, data HI: 0x%08X, "
             "data LO: 0x%08X", l_addr, l_pibRc, (*o_data >> 32),
             static_cast<uint32_t>(*o_data & 0xFFFFFFFF));

    return (l_pibRc == PIB_NO_ERROR) ? fapi2::ReturnCode(FAPI2_RC_SUCCESS) :
            handle_scom_error(l_addr, o_data, l_pibRc, true);
fffa35ec:	06 c5 00 0a 	bwz     r5,fffa3600 <_ZN5fapi216getscom_abs_wrapEPKvmPy+0x40>
fffa35f0:	7f c3 f3 78 	mr      r3,r30
fffa35f4:	7f e4 fb 78 	mr      r4,r31
fffa35f8:	54 a5 06 3e 	clrlwi  r5,r5,24
fffa35fc:	4b ff ff 1d 	bl      fffa3518 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>
}
fffa3600:	80 01 00 14 	lwz     r0,20(r1)
fffa3604:	17 c1 00 08 	lvd     d30,8(r1)
fffa3608:	7c 08 03 a6 	mtlr    r0
fffa360c:	38 21 00 10 	addi    r1,r1,16
fffa3610:	4e 80 00 20 	blr

fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>:

fapi2::ReturnCode putscom_abs_wrap(const void *i_target,
                                    const uint32_t i_addr, uint64_t i_data)
{
fffa3614:	94 21 ff e8 	stwu    r1,-24(r1)
fffa3618:	7c 08 02 a6 	mflr    r0
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target,i_addr);
#endif
    l_pibRc = putscom_abs(l_addr, i_data);
fffa361c:	7c 83 23 78 	mr      r3,r4
            handle_scom_error(l_addr, o_data, l_pibRc, true);
}

fapi2::ReturnCode putscom_abs_wrap(const void *i_target,
                                    const uint32_t i_addr, uint64_t i_data)
{
fffa3620:	1b c1 00 10 	stvd    d30,16(r1)
fffa3624:	18 a1 00 08 	stvd    d5,8(r1)
fffa3628:	90 01 00 1c 	stw     r0,28(r1)
fffa362c:	7c 9f 23 78 	mr      r31,r4
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target,i_addr);
#endif
    l_pibRc = putscom_abs(l_addr, i_data);
fffa3630:	48 00 00 55 	bl      fffa3684 <putscom_abs>
fffa3634:	7c 65 1b 78 	mr      r5,r3
fffa3638:	38 60 00 00 	li      r3,0
    FAPI_DBG("putScom: address: 0x%08X, data HI: 0x%08X, data LO: 0x%08X : returned pibRc: 0x%08X", l_addr, (i_data >> 32),
             static_cast<uint32_t>(i_data & 0xFFFFFFFF), l_pibRc);

    return (l_pibRc == PIB_NO_ERROR) ? fapi2::ReturnCode(FAPI2_RC_SUCCESS) :
            handle_scom_error(l_addr, &i_data, l_pibRc, false);
fffa363c:	06 c5 00 0a 	bwz     r5,fffa3650 <_ZN5fapi216putscom_abs_wrapEPKvmy+0x3c>
fffa3640:	7f e3 fb 78 	mr      r3,r31
fffa3644:	38 81 00 08 	addi    r4,r1,8
fffa3648:	54 a5 06 3e 	clrlwi  r5,r5,24
fffa364c:	4b ff fe cd 	bl      fffa3518 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>
}
fffa3650:	80 01 00 1c 	lwz     r0,28(r1)
fffa3654:	17 c1 00 10 	lvd     d30,16(r1)
fffa3658:	7c 08 03 a6 	mtlr    r0
fffa365c:	38 21 00 18 	addi    r1,r1,24
fffa3660:	4e 80 00 20 	blr

fffa3664 <_ZN5fapi218plat_getChipTargetEv>:
#if defined(__SBEMFW_MEASUREMENT__) || defined(__SBEVFW_VERIFICATION__)
    fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP> plat_getChipTarget()
    {
         // Get the chip default specific target
         return ((fapi2::plat_target_handle_t)0x0);
    }
fffa3664:	38 60 00 00 	li      r3,0
fffa3668:	4e 80 00 20 	blr

fffa366c <_ZNK5fapi218plat_target_handle17getFapiTargetTypeEv>:
    TargetType plat_target_handle_t::getFapiTargetType() const
    {
         // Get the chip specific target
         return (TARGET_TYPE_PROC_CHIP);
    }
fffa366c:	38 60 00 00 	li      r3,0
fffa3670:	38 80 00 04 	li      r4,4
fffa3674:	4e 80 00 20 	blr

fffa3678 <_GLOBAL__sub_I__ZN5fapi211current_errE>:
fffa3678:	39 20 00 00 	li      r9,0
fffa367c:	91 2d 46 f0 	stw     r9,18160(r13)
fffa3680:	4e 80 00 20 	blr

fffa3684 <putscom_abs>:

uint32_t putscom_abs(const uint32_t i_address, uint64_t i_data)
{

    // Perform the Store Virtual Double instruction
    PPE_STVD(i_address, i_data);
fffa3684:	18 a3 00 00 	stvd    d5,0(r3)

    // Get the MSR[SIBRC] as the return code
    uint32_t rc = mfmsr();
fffa3688:	7c 60 00 a6 	mfmsr   r3
    rc = ((rc & MSR_SIBRC) >> (32 - (MSR_SIBRC_START_BIT + MSR_SIBRC_LEN)));
    return (rc);

}
fffa368c:	54 63 67 7e 	rlwinm  r3,r3,12,29,31
fffa3690:	4e 80 00 20 	blr

fffa3694 <getscom_abs>:

uint32_t getscom_abs( const uint32_t i_address, uint64_t* o_data)
{
    uint64_t temp;
    // Perform the Load Virtual Double instruction
    PPE_LVD(i_address, temp);
fffa3694:	15 03 00 00 	lvd     d8,0(r3)
    PPE_STVD(o_data, temp);
fffa3698:	19 04 00 00 	stvd    d8,0(r4)

    // Get the MSR[SIBRC] as the return code
    uint32_t rc = mfmsr();
fffa369c:	7c 60 00 a6 	mfmsr   r3
    rc = ((rc & MSR_SIBRC) >> (32 - (MSR_SIBRC_START_BIT + MSR_SIBRC_LEN)));
    return (rc);
}
fffa36a0:	54 63 67 7e 	rlwinm  r3,r3,12,29,31
fffa36a4:	4e 80 00 20 	blr

fffa36a8 <__pk_start_threads>:
// This is considered part of pk_start_threads() and so is also considered a
// 'core' routine.

void
__pk_start_threads(void)
{
fffa36a8:	94 21 ff f8 	stwu    r1,-8(r1)
fffa36ac:	7c 08 02 a6 	mflr    r0
fffa36b0:	90 01 00 0c 	stw     r0,12(r1)
    PK_START_THREADS_HOOK;

    __pk_next_thread_resume();
fffa36b4:	4b ff cb 1d 	bl      fffa01d0 <__pk_next_thread_resume>

    PK_PANIC(PK_START_THREADS_RETURNED);
fffa36b8:	7f e4 18 08 	twu     r4,r3
}
fffa36bc:	80 01 00 0c 	lwz     r0,12(r1)
fffa36c0:	7c 08 03 a6 	mtlr    r0
fffa36c4:	38 21 00 08 	addi    r1,r1,8
fffa36c8:	4e 80 00 20 	blr

fffa36cc <__pk_thread_map>:
__pk_thread_map(PkThread* thread)
{
    PkThreadPriority priority;

    priority = thread->priority;
    __pk_priority_map[priority] = thread;
fffa36cc:	89 43 00 10 	lbz     r10,16(r3)
fffa36d0:	39 0d 02 80 	addi    r8,r13,640
fffa36d4:	55 49 10 3a 	rlwinm  r9,r10,2,0,29
fffa36d8:	7c 68 49 2e 	stwx    r3,r8,r9

    if (thread->state == PK_THREAD_STATE_SUSPENDED_RUNNABLE)
fffa36dc:	89 23 00 11 	lbz     r9,17(r3)
fffa36e0:	06 c9 08 10 	cmpwibeq r9,1,fffa3700 <__pk_thread_map+0x34>
    {

        __pk_thread_queue_insert(&__pk_run_queue, priority);

    }
    else if (thread->flags & PK_THREAD_FLAG_SEMAPHORE_PEND)
fffa36e4:	89 23 00 12 	lbz     r9,18(r3)
fffa36e8:	07 89 f8 22 	bb0wi   r9,31,fffa372c <__pk_thread_map+0x60>
    {

        if (thread->semaphore->count)
fffa36ec:	81 23 00 0c 	lwz     r9,12(r3)
fffa36f0:	81 09 00 04 	lwz     r8,4(r9)
fffa36f4:	06 c8 00 12 	bwz     r8,fffa3718 <__pk_thread_map+0x4c>
        {

            thread->semaphore->count--;
fffa36f8:	39 08 ff ff 	addi    r8,r8,-1
fffa36fc:	91 09 00 04 	stw     r8,4(r9)
}

static inline void
__pk_thread_queue_insert(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue |= (0x80000000u >> priority);
fffa3700:	81 2d 03 1c 	lwz     r9,796(r13)
fffa3704:	3d 00 80 00 	lis     r8,-32768
fffa3708:	7d 0a 54 30 	srw     r10,r8,r10
fffa370c:	7d 4a 4b 78 	or      r10,r10,r9
fffa3710:	91 4d 03 1c 	stw     r10,796(r13)
fffa3714:	48 00 00 18 	b       fffa372c <__pk_thread_map+0x60>
fffa3718:	81 09 00 00 	lwz     r8,0(r9)
fffa371c:	3c e0 80 00 	lis     r7,-32768
fffa3720:	7c ea 54 30 	srw     r10,r7,r10
fffa3724:	7d 4a 43 78 	or      r10,r10,r8
fffa3728:	91 49 00 00 	stw     r10,0(r9)
            __pk_thread_queue_insert(&(thread->semaphore->pending_threads),
                                     priority);
        }
    }

    thread->state = PK_THREAD_STATE_MAPPED;
fffa372c:	39 20 00 02 	li      r9,2
fffa3730:	99 23 00 11 	stb     r9,17(r3)
fffa3734:	4e 80 00 20 	blr

fffa3738 <__pk_thread_unmap>:
__pk_thread_unmap(PkThread* thread)
{
    PkThreadPriority priority;

    priority = thread->priority;
    __pk_priority_map[priority] = 0;
fffa3738:	89 23 00 10 	lbz     r9,16(r3)
fffa373c:	39 0d 02 80 	addi    r8,r13,640
fffa3740:	55 2a 10 3a 	rlwinm  r10,r9,2,0,29
fffa3744:	38 e0 00 00 	li      r7,0
fffa3748:	7c e8 51 2e 	stwx    r7,r8,r10
}

static inline int
__pk_thread_queue_member(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
return ((*queue >> (31 - priority)) & 1);
fffa374c:	81 0d 03 1c 	lwz     r8,796(r13)
fffa3750:	89 43 00 10 	lbz     r10,16(r3)
fffa3754:	21 4a 00 1f 	subfic  r10,r10,31
fffa3758:	7d 0a 54 30 	srw     r10,r8,r10

    if (__pk_thread_is_runnable(thread))
fffa375c:	07 8a f8 12 	bb0wi   r10,31,fffa3780 <__pk_thread_unmap+0x48>
    {

        thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fffa3760:	39 40 00 01 	li      r10,1
}

static inline void
__pk_thread_queue_delete(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue &= ~(0x80000000u >> priority);
fffa3764:	81 0d 03 1c 	lwz     r8,796(r13)
fffa3768:	99 43 00 11 	stb     r10,17(r3)
fffa376c:	3d 40 80 00 	lis     r10,-32768
fffa3770:	7d 49 4c 30 	srw     r9,r10,r9
fffa3774:	7d 09 48 78 	andc    r9,r8,r9
fffa3778:	91 2d 03 1c 	stw     r9,796(r13)
fffa377c:	4e 80 00 20 	blr

    }
    else
    {

        thread->state = PK_THREAD_STATE_SUSPENDED_BLOCKED;
fffa3780:	39 40 00 03 	li      r10,3
fffa3784:	99 43 00 11 	stb     r10,17(r3)

        if (thread->flags & PK_THREAD_FLAG_SEMAPHORE_PEND)
fffa3788:	89 43 00 12 	lbz     r10,18(r3)
fffa378c:	07 8a f8 0e 	bb0wi   r10,31,fffa37a8 <__pk_thread_unmap+0x70>
        {
            __pk_thread_queue_delete(&(thread->semaphore->pending_threads),
fffa3790:	81 03 00 0c 	lwz     r8,12(r3)
fffa3794:	3d 40 80 00 	lis     r10,-32768
fffa3798:	80 e8 00 00 	lwz     r7,0(r8)
fffa379c:	7d 49 4c 30 	srw     r9,r10,r9
fffa37a0:	7c e9 48 78 	andc    r9,r7,r9
fffa37a4:	91 28 00 00 	stw     r9,0(r8)
fffa37a8:	4e 80 00 20 	blr

fffa37ac <__pk_schedule>:
}

static inline PkThreadPriority
__pk_thread_queue_min(volatile PkThreadQueue* queue)
{
return cntlzw(*queue);
fffa37ac:	81 2d 03 1c 	lwz     r9,796(r13)
fffa37b0:	7d 29 00 34 	cntlzw  r9,r9
fffa37b4:	55 29 06 3e 	clrlwi  r9,r9,24
// end of interrupt processing.

void
__pk_schedule(void)
{
    __pk_next_priority = __pk_thread_queue_min(&__pk_run_queue);
fffa37b8:	99 2d 03 0c 	stb     r9,780(r13)
    __pk_next_thread = __pk_priority_map[__pk_next_priority];
fffa37bc:	39 4d 02 80 	addi    r10,r13,640
fffa37c0:	89 2d 03 0c 	lbz     r9,780(r13)
fffa37c4:	55 29 10 3a 	rlwinm  r9,r9,2,0,29
fffa37c8:	7d 2a 48 2e 	lwzx    r9,r10,r9
fffa37cc:	91 2d 03 10 	stw     r9,784(r13)

    if ((__pk_next_thread == 0) ||
fffa37d0:	06 c9 00 06 	bwz     r9,fffa37dc <__pk_schedule+0x30>
fffa37d4:	81 4d 03 14 	lwz     r10,788(r13)
fffa37d8:	04 c9 50 1a 	cmpwbeq r9,r10,fffa380c <__pk_schedule+0x60>
        (__pk_next_thread != __pk_current_thread))
    {

        if (__pk_kernel_mode_thread())
fffa37dc:	7d 30 42 a6 	mfsprg  r9,0
fffa37e0:	06 09 00 16 	bwgez   r9,fffa380c <__pk_schedule+0x60>
        {
            if (__pk_kernel_context_thread())
fffa37e4:	7d 30 42 a6 	mfsprg  r9,0
fffa37e8:	3d 40 80 00 	lis     r10,-32768
fffa37ec:	55 29 00 02 	rlwinm  r9,r9,0,0,1
fffa37f0:	04 49 50 0a 	cmpwbne r9,r10,fffa3804 <__pk_schedule+0x58>
            {
                if (__pk_current_thread != 0)
fffa37f4:	81 2d 03 14 	lwz     r9,788(r13)
fffa37f8:	06 c9 00 04 	bwz     r9,fffa3800 <__pk_schedule+0x54>
                {
                    __pk_switch();
fffa37fc:	4b ff ca 70 	b       fffa026c <__ctx_switch>
                }
                else
                {
                    __pk_next_thread_resume();
fffa3800:	4b ff c9 d0 	b       fffa01d0 <__pk_next_thread_resume>
                }
            }
            else
            {
                __pk_delayed_switch = 1;
fffa3804:	39 20 00 01 	li      r9,1
fffa3808:	91 2d 03 18 	stw     r9,792(r13)
fffa380c:	4e 80 00 20 	blr

fffa3810 <__pk_thread_delete>:
// Note that we do not create trace events for unmapped threads since the trace
// tag only encodes the priority, which may be in use by a mapped thread.

void
__pk_thread_delete(PkThread* thread, PkThreadState final_state)
{
fffa3810:	94 21 ff e8 	stwu    r1,-24(r1)
fffa3814:	7c 08 02 a6 	mflr    r0
fffa3818:	1b 81 00 08 	stvd    d28,8(r1)
fffa381c:	90 01 00 1c 	stw     r0,28(r1)
fffa3820:	1b c1 00 10 	stvd    d30,16(r1)
fffa3824:	7c 7c 1b 78 	mr      r28,r3
fffa3828:	7c 9d 23 78 	mr      r29,r4

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa382c:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fffa3830:	7c 00 01 46 	wrteei  0
// Interrupts must be disabled at entry.

static inline int
__pk_thread_is_mapped(PkThread* thread)
{
    return (thread->state == PK_THREAD_STATE_MAPPED);
fffa3834:	8b e3 00 11 	lbz     r31,17(r3)
fffa3838:	6b ff 00 02 	xori    r31,r31,2
fffa383c:	3b ff ff ff 	addi    r31,r31,-1
fffa3840:	57 ff 0f fe 	rlwinm  r31,r31,1,31,31

    pk_critical_section_enter(&ctx);

    mapped = __pk_thread_is_mapped(thread);

    if (mapped)
fffa3844:	06 df 00 04 	bwz     r31,fffa384c <__pk_thread_delete+0x3c>
    {
        __pk_thread_unmap(thread);
fffa3848:	4b ff fe f1 	bl      fffa3738 <__pk_thread_unmap>
    }

    __pk_timer_cancel(&(thread->timer));
fffa384c:	38 7c 00 18 	addi    r3,r28,24
fffa3850:	4b ff cd 21 	bl      fffa0570 <__pk_timer_cancel>
    thread->state = final_state;
fffa3854:	9b bc 00 11 	stb     r29,17(r28)

    if (mapped)
fffa3858:	06 df 00 0c 	bwz     r31,fffa3870 <__pk_thread_delete+0x60>
            {
                PK_KERN_TRACE("THREAD_COMPLETED(%d)", thread->priority);
            }
        }

        if (thread == __pk_current_thread)
fffa385c:	81 2d 03 14 	lwz     r9,788(r13)
fffa3860:	04 5c 48 06 	cmpwbne r28,r9,fffa386c <__pk_thread_delete+0x5c>
        {
            __pk_current_thread = 0;
fffa3864:	39 20 00 00 	li      r9,0
fffa3868:	91 2d 03 14 	stw     r9,788(r13)
        }

        __pk_schedule();
fffa386c:	4b ff ff 41 	bl      fffa37ac <__pk_schedule>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa3870:	7f c0 01 24 	mtmsr   r30
    }

    pk_critical_section_exit(&ctx);
}
fffa3874:	80 01 00 1c 	lwz     r0,28(r1)
fffa3878:	17 81 00 08 	lvd     d28,8(r1)
fffa387c:	7c 08 03 a6 	mtlr    r0
fffa3880:	17 c1 00 10 	lvd     d30,16(r1)
fffa3884:	38 21 00 18 	addi    r1,r1,24
fffa3888:	4e 80 00 20 	blr

fffa388c <__pk_thread_timeout>:
// Note that we do not create trace events for unmapped threads since the trace
// tag only encodes the priority, which may be in use by a mapped thread.

void
__pk_thread_timeout(void* arg)
{
fffa388c:	94 21 ff f0 	stwu    r1,-16(r1)
fffa3890:	7c 08 02 a6 	mflr    r0
fffa3894:	1b c1 00 08 	stvd    d30,8(r1)
fffa3898:	90 01 00 14 	stw     r0,20(r1)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa389c:	7f e0 00 a6 	mfmsr   r31

wrteei(0);
fffa38a0:	7c 00 01 46 	wrteei  0
    PkMachineContext ctx;
    PkThread* thread = (PkThread*)arg;

    pk_critical_section_enter(&ctx);

    switch (thread->state)
fffa38a4:	89 23 00 11 	lbz     r9,17(r3)
fffa38a8:	06 c9 10 0a 	cmpwibeq r9,2,fffa38bc <__pk_thread_timeout+0x30>
fffa38ac:	06 c9 18 26 	cmpwibeq r9,3,fffa38f8 <__pk_thread_timeout+0x6c>
fffa38b0:	06 c9 08 2e 	cmpwibeq r9,1,fffa390c <__pk_thread_timeout+0x80>
            thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
            thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
            break;

        default:
            PK_PANIC(PK_THREAD_TIMEOUT_STATE);
fffa38b4:	7f e4 38 08 	twu     r4,r7
fffa38b8:	48 00 00 54 	b       fffa390c <__pk_thread_timeout+0x80>
}

static inline int
__pk_thread_queue_member(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
return ((*queue >> (31 - priority)) & 1);
fffa38bc:	89 03 00 10 	lbz     r8,16(r3)
fffa38c0:	81 4d 03 1c 	lwz     r10,796(r13)
fffa38c4:	21 28 00 1f 	subfic  r9,r8,31
fffa38c8:	7d 4a 4c 30 	srw     r10,r10,r9

    switch (thread->state)
    {

        case PK_THREAD_STATE_MAPPED:
            if (!__pk_thread_is_runnable(thread))
fffa38cc:	07 0a f8 20 	bb1wi   r10,31,fffa390c <__pk_thread_timeout+0x80>
            {
                thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
fffa38d0:	89 43 00 12 	lbz     r10,18(r3)
}

static inline void
__pk_thread_queue_insert(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue |= (0x80000000u >> priority);
fffa38d4:	3d 20 80 00 	lis     r9,-32768
fffa38d8:	61 4a 00 04 	ori     r10,r10,4
fffa38dc:	99 43 00 12 	stb     r10,18(r3)
fffa38e0:	81 4d 03 1c 	lwz     r10,796(r13)
fffa38e4:	7d 29 44 30 	srw     r9,r9,r8
fffa38e8:	7d 29 53 78 	or      r9,r9,r10
fffa38ec:	91 2d 03 1c 	stw     r9,796(r13)
                __pk_thread_queue_insert(&__pk_run_queue, thread->priority);
                __pk_schedule();
fffa38f0:	4b ff fe bd 	bl      fffa37ac <__pk_schedule>
fffa38f4:	48 00 00 18 	b       fffa390c <__pk_thread_timeout+0x80>

        case PK_THREAD_STATE_SUSPENDED_RUNNABLE:
            break;

        case PK_THREAD_STATE_SUSPENDED_BLOCKED:
            thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
fffa38f8:	89 23 00 12 	lbz     r9,18(r3)
fffa38fc:	61 29 00 04 	ori     r9,r9,4
fffa3900:	99 23 00 12 	stb     r9,18(r3)
            thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fffa3904:	39 20 00 01 	li      r9,1
fffa3908:	99 23 00 11 	stb     r9,17(r3)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa390c:	7f e0 01 24 	mtmsr   r31
        default:
            PK_PANIC(PK_THREAD_TIMEOUT_STATE);
    }

    pk_critical_section_exit(&ctx);
}
fffa3910:	80 01 00 14 	lwz     r0,20(r1)
fffa3914:	17 c1 00 08 	lvd     d30,8(r1)
fffa3918:	7c 08 03 a6 	mtlr    r0
fffa391c:	38 21 00 10 	addi    r1,r1,16
fffa3920:	4e 80 00 20 	blr

fffa3924 <pk_start_threads>:
int
pk_start_threads(void)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(__pk_kernel_mode_thread(), PK_ILLEGAL_CONTEXT_THREAD);
fffa3924:	7d 30 42 a6 	mfsprg  r9,0
fffa3928:	38 60 fe fe 	li      r3,-258
fffa392c:	06 89 00 16 	bwltz   r9,fffa3958 <pk_start_threads+0x34>

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa3930:	7d 20 00 a6 	mfmsr   r9

wrteei(0);
fffa3934:	7c 00 01 46 	wrteei  0
    }

    __pk_call_pk_start_threads();
fffa3938:	3d 20 ff fa 	lis     r9,-6
fffa393c:	81 4d 03 24 	lwz     r10,804(r13)
fffa3940:	39 29 36 a8 	addi    r9,r9,13992
fffa3944:	7d 41 53 78 	mr      r1,r10
fffa3948:	7d 28 03 a6 	mtlr    r9
fffa394c:	4e 80 00 21 	blrl
fffa3950:	7f e4 18 08 	twu     r4,r3

    return 0;
fffa3954:	38 60 00 00 	li      r3,0
}
fffa3958:	4e 80 00 20 	blr

fffa395c <pk_thread_resume>:
{
    PkMachineContext ctx;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_RESUME1);
fffa395c:	06 c3 00 38 	bwz     r3,fffa39cc <pk_thread_resume+0x70>
/// \retval -PK_PRIORITY_IN_USE_AT_RESUME Another thread is already mapped at
/// the priority of the \a thread.

int
pk_thread_resume(PkThread* thread)
{
fffa3960:	94 21 ff f0 	stwu    r1,-16(r1)
fffa3964:	7c 08 02 a6 	mflr    r0
fffa3968:	1b c1 00 08 	stvd    d30,8(r1)
fffa396c:	90 01 00 14 	stw     r0,20(r1)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa3970:	7f e0 00 a6 	mfmsr   r31

wrteei(0);
fffa3974:	7c 00 01 46 	wrteei  0
fffa3978:	89 03 00 11 	lbz     r8,17(r3)

    pk_critical_section_enter(&ctx);

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF_CRITICAL(!__pk_thread_is_active(thread),
fffa397c:	39 48 ff fc 	addi    r10,r8,-4
fffa3980:	28 0a 00 01 	cmplwi  r10,1
fffa3984:	41 a1 00 10 	bgt     fffa3994 <pk_thread_resume+0x38>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa3988:	7f e0 01 24 	mtmsr   r31
fffa398c:	38 60 fe fb 	li      r3,-261
fffa3990:	48 00 00 44 	b       fffa39d4 <pk_thread_resume+0x78>
                             PK_INVALID_THREAD_AT_RESUME2,
                             &ctx);
    }

    if (!__pk_thread_is_mapped(thread))
fffa3994:	06 c8 10 16 	cmpwibeq r8,2,fffa39c0 <pk_thread_resume+0x64>
    {

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF_CRITICAL(__pk_priority_map[thread->priority] != 0,
fffa3998:	89 23 00 10 	lbz     r9,16(r3)
fffa399c:	39 4d 02 80 	addi    r10,r13,640
fffa39a0:	55 29 10 3a 	rlwinm  r9,r9,2,0,29
fffa39a4:	7d 2a 48 2e 	lwzx    r9,r10,r9
fffa39a8:	06 c9 00 08 	bwz     r9,fffa39b8 <pk_thread_resume+0x5c>
fffa39ac:	7f e0 01 24 	mtmsr   r31
fffa39b0:	38 60 fc f8 	li      r3,-776
fffa39b4:	48 00 00 20 	b       fffa39d4 <pk_thread_resume+0x78>
                                 PK_PRIORITY_IN_USE_AT_RESUME,
                                 &ctx);
        }

        __pk_thread_map(thread);
fffa39b8:	4b ff fd 15 	bl      fffa36cc <__pk_thread_map>
        __pk_schedule();
fffa39bc:	4b ff fd f1 	bl      fffa37ac <__pk_schedule>
fffa39c0:	7f e0 01 24 	mtmsr   r31
    }

    pk_critical_section_exit(&ctx);

    return PK_OK;
fffa39c4:	38 60 00 00 	li      r3,0
fffa39c8:	48 00 00 0c 	b       fffa39d4 <pk_thread_resume+0x78>
{
    PkMachineContext ctx;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_RESUME1);
fffa39cc:	38 60 fe fc 	li      r3,-260
fffa39d0:	4e 80 00 20 	blr
    }

    pk_critical_section_exit(&ctx);

    return PK_OK;
}
fffa39d4:	80 01 00 14 	lwz     r0,20(r1)
fffa39d8:	17 c1 00 08 	lvd     d30,8(r1)
fffa39dc:	7c 08 03 a6 	mtlr    r0
fffa39e0:	38 21 00 10 	addi    r1,r1,16
fffa39e4:	4e 80 00 20 	blr

fffa39e8 <pk_complete>:
int
pk_complete(void)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
fffa39e8:	7d 30 42 a6 	mfsprg  r9,0
fffa39ec:	3d 40 80 00 	lis     r10,-32768
fffa39f0:	55 29 00 02 	rlwinm  r9,r9,0,0,1
fffa39f4:	38 60 ff 00 	li      r3,-256
fffa39f8:	04 49 50 16 	cmpwbne r9,r10,fffa3a24 <pk_complete+0x3c>

// Note: Casting __pk_current_thread removes the 'volatile' attribute.

int
pk_complete(void)
{
fffa39fc:	94 21 ff f8 	stwu    r1,-8(r1)
fffa3a00:	7c 08 02 a6 	mflr    r0
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
fffa3a04:	80 6d 03 14 	lwz     r3,788(r13)
fffa3a08:	38 80 00 04 	li      r4,4

// Note: Casting __pk_current_thread removes the 'volatile' attribute.

int
pk_complete(void)
{
fffa3a0c:	90 01 00 0c 	stw     r0,12(r1)
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
fffa3a10:	4b ff fe 01 	bl      fffa3810 <__pk_thread_delete>
                       PK_THREAD_STATE_COMPLETED);

    return PK_OK;
}
fffa3a14:	80 01 00 0c 	lwz     r0,12(r1)
fffa3a18:	7c 08 03 a6 	mtlr    r0
fffa3a1c:	38 21 00 08 	addi    r1,r1,8
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
                       PK_THREAD_STATE_COMPLETED);

    return PK_OK;
fffa3a20:	38 60 00 00 	li      r3,0
}
fffa3a24:	4e 80 00 20 	blr

fffa3a28 <pk_thread_create>:
                 PkThreadRoutine  thread_routine,
                 void*              arg,
                 PkAddress        stack,
                 size_t            stack_size,
                 PkThreadPriority priority)
{
fffa3a28:	94 21 ff d8 	stwu    r1,-40(r1)
fffa3a2c:	7c 08 02 a6 	mflr    r0
fffa3a30:	1b c1 00 20 	stvd    d30,32(r1)
fffa3a34:	90 01 00 2c 	stw     r0,44(r1)
fffa3a38:	1b 81 00 18 	stvd    d28,24(r1)
fffa3a3c:	7c 7f 1b 78 	mr      r31,r3
fffa3a40:	18 c1 00 08 	stvd    d6,8(r1)
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_CREATE);
fffa3a44:	3b c0 fe e3 	li      r30,-285
fffa3a48:	06 c3 00 48 	bwz     r3,fffa3ad8 <pk_thread_create+0xb0>
fffa3a4c:	7c 9d 23 78 	mr      r29,r4
        PK_ERROR_IF((thread_routine == 0) ||
fffa3a50:	3b c0 fc fe 	li      r30,-770
fffa3a54:	06 c4 00 42 	bwz     r4,fffa3ad8 <pk_thread_create+0xb0>
fffa3a58:	28 08 00 1f 	cmplwi  r8,31
fffa3a5c:	41 81 00 7c 	bgt     fffa3ad8 <pk_thread_create+0xb0>
                    (priority >= PK_THREADS),
                    PK_INVALID_ARGUMENT_THREAD1);
    }

    rc = __pk_stack_init(&stack, &stack_size);
fffa3a60:	38 61 00 08 	addi    r3,r1,8
fffa3a64:	38 81 00 0c 	addi    r4,r1,12
fffa3a68:	91 01 00 10 	stw     r8,16(r1)
fffa3a6c:	7c bc 2b 78 	mr      r28,r5
fffa3a70:	4b ff d0 ad 	bl      fffa0b1c <__pk_stack_init>
fffa3a74:	7c 7e 1b 78 	mr      r30,r3

    if (rc)
fffa3a78:	81 01 00 10 	lwz     r8,16(r1)
fffa3a7c:	06 43 00 2e 	bwnz    r3,fffa3ad8 <pk_thread_create+0xb0>
    {
        return rc;
    }

    thread->saved_stack_pointer = stack;
fffa3a80:	15 21 00 08 	lvd     d9,8(r1)
fffa3a84:	91 3f 00 00 	stw     r9,0(r31)
    thread->stack_base = stack;

    if (PK_STACK_DIRECTION < 0)
    {

        thread->stack_limit = stack - stack_size;
fffa3a88:	7d 4a 48 50 	subf    r10,r10,r9
    {
        return rc;
    }

    thread->saved_stack_pointer = stack;
    thread->stack_base = stack;
fffa3a8c:	91 3f 00 08 	stw     r9,8(r31)

    if (PK_STACK_DIRECTION < 0)
    {

        thread->stack_limit = stack - stack_size;
fffa3a90:	91 5f 00 04 	stw     r10,4(r31)

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF(thread->stack_limit > thread->stack_base,
fffa3a94:	05 aa 48 20 	cmplwbgt r10,r9,fffa3ad4 <pk_thread_create+0xac>
        }
    }

    thread->semaphore = 0;
    thread->priority = priority;
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fffa3a98:	39 20 00 01 	li      r9,1
            PK_ERROR_IF(thread->stack_limit < thread->stack_base,
                        PK_INVALID_ARGUMENT_THREAD3);
        }
    }

    thread->semaphore = 0;
fffa3a9c:	90 7f 00 0c 	stw     r3,12(r31)
    thread->priority = priority;
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
    thread->flags = 0;
fffa3aa0:	98 7f 00 12 	stb     r3,18(r31)
                        PK_INVALID_ARGUMENT_THREAD3);
        }
    }

    thread->semaphore = 0;
    thread->priority = priority;
fffa3aa4:	99 1f 00 10 	stb     r8,16(r31)
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fffa3aa8:	99 3f 00 11 	stb     r9,17(r31)
    thread->flags = 0;

    pk_timer_create(&(thread->timer),
fffa3aac:	3c 80 ff fa 	lis     r4,-6
fffa3ab0:	7f e5 fb 78 	mr      r5,r31
fffa3ab4:	38 7f 00 18 	addi    r3,r31,24
fffa3ab8:	38 84 38 8c 	addi    r4,r4,14476
fffa3abc:	48 00 00 39 	bl      fffa3af4 <pk_timer_create>
                    __pk_thread_timeout,
                    (void*)thread);

    __pk_thread_context_initialize(thread, thread_routine, arg);
fffa3ac0:	7f e3 fb 78 	mr      r3,r31
fffa3ac4:	7f a4 eb 78 	mr      r4,r29
fffa3ac8:	7f 85 e3 78 	mr      r5,r28
fffa3acc:	48 00 01 59 	bl      fffa3c24 <__pk_thread_context_initialize>

    return rc;
fffa3ad0:	48 00 00 08 	b       fffa3ad8 <pk_thread_create+0xb0>

        thread->stack_limit = stack - stack_size;

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF(thread->stack_limit > thread->stack_base,
fffa3ad4:	3b c0 fc fd 	li      r30,-771
                    (void*)thread);

    __pk_thread_context_initialize(thread, thread_routine, arg);

    return rc;
}
fffa3ad8:	80 01 00 2c 	lwz     r0,44(r1)
fffa3adc:	7f c3 f3 78 	mr      r3,r30
fffa3ae0:	7c 08 03 a6 	mtlr    r0
fffa3ae4:	17 81 00 18 	lvd     d28,24(r1)
fffa3ae8:	17 c1 00 20 	lvd     d30,32(r1)
fffa3aec:	38 21 00 28 	addi    r1,r1,40
fffa3af0:	4e 80 00 20 	blr

fffa3af4 <pk_timer_create>:

int
pk_timer_create(PkTimer*         timer,
                PkTimerCallback callback,
                void*             arg)
{
fffa3af4:	94 21 ff e8 	stwu    r1,-24(r1)
fffa3af8:	7c 08 02 a6 	mflr    r0
fffa3afc:	1b c1 00 10 	stvd    d30,16(r1)
fffa3b00:	90 01 00 1c 	stw     r0,28(r1)
fffa3b04:	1b 81 00 08 	stvd    d28,8(r1)
fffa3b08:	7c 7f 1b 78 	mr      r31,r3
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((timer == 0), PK_INVALID_TIMER_AT_CREATE);
fffa3b0c:	06 c3 00 14 	bwz     r3,fffa3b34 <pk_timer_create+0x40>
fffa3b10:	7c be 2b 78 	mr      r30,r5
fffa3b14:	7c 9d 23 78 	mr      r29,r4
    }

    pk_deque_element_create((PkDeque*)timer);
fffa3b18:	4b ff c9 11 	bl      fffa0428 <pk_deque_element_create>
    timer->timeout = 0;
fffa3b1c:	39 00 00 00 	li      r8,0
fffa3b20:	39 20 00 00 	li      r9,0
fffa3b24:	19 1f 00 08 	stvd    d8,8(r31)
    timer->callback = callback;
fffa3b28:	1b bf 00 10 	stvd    d29,16(r31)
    timer->arg = arg;

    return PK_OK;
fffa3b2c:	38 60 00 00 	li      r3,0
fffa3b30:	48 00 00 08 	b       fffa3b38 <pk_timer_create+0x44>
                PkTimerCallback callback,
                void*             arg)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((timer == 0), PK_INVALID_TIMER_AT_CREATE);
fffa3b34:	38 60 fd fa 	li      r3,-518
    timer->timeout = 0;
    timer->callback = callback;
    timer->arg = arg;

    return PK_OK;
}
fffa3b38:	80 01 00 1c 	lwz     r0,28(r1)
fffa3b3c:	17 81 00 08 	lvd     d28,8(r1)
fffa3b40:	7c 08 03 a6 	mtlr    r0
fffa3b44:	17 c1 00 10 	lvd     d30,16(r1)
fffa3b48:	38 21 00 18 	addi    r1,r1,24
fffa3b4c:	4e 80 00 20 	blr

fffa3b50 <pk_trace_big>:
#include "pk_trace.h"

#if (PK_TRACE_SUPPORT)
void pk_trace_big(uint32_t i_hash_and_count,
                  uint64_t i_parm1, uint64_t i_parm2)
{
fffa3b50:	94 21 ff e0 	stwu    r1,-32(r1)
fffa3b54:	7c 08 02 a6 	mflr    r0
fffa3b58:	1b 81 00 10 	stvd    d28,16(r1)
fffa3b5c:	1b c1 00 18 	stvd    d30,24(r1)
fffa3b60:	90 01 00 24 	stw     r0,36(r1)
fffa3b64:	7c bc 2b 78 	mr      r28,r5
fffa3b68:	7c dd 33 78 	mr      r29,r6
fffa3b6c:	7d 1f 43 78 	mr      r31,r8
fffa3b70:	7c fe 3b 78 	mr      r30,r7
    uint32_t            parm_size;
    uint32_t            cur_offset;
    uint32_t            footer_offset;

    //fill in the footer data
    tb64 = pk_timebase_get();
fffa3b74:	90 61 00 08 	stw     r3,8(r1)
fffa3b78:	4b ff cd a9 	bl      fffa0920 <pk_timebase_get>
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fffa3b7c:	80 01 00 08 	lwz     r0,8(r1)
    //fill in the footer data
    tb64 = pk_timebase_get();
    footer.parms.word32 = i_hash_and_count; //this has the parm count and hash
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;
fffa3b80:	39 20 00 02 	li      r9,2
fffa3b84:	51 24 07 be 	rlwimi  r4,r9,0,30,31

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fffa3b88:	54 09 06 3e 	clrlwi  r9,r0,24
fffa3b8c:	28 09 00 02 	cmplwi  r9,2
    {
        parm_size = 8;
fffa3b90:	38 a0 00 08 	li      r5,8
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fffa3b94:	40 81 00 08 	ble     fffa3b9c <pk_trace_big+0x4c>
    {
        parm_size = 8;
    }
    else
    {
        parm_size = 16;
fffa3b98:	38 a0 00 10 	li      r5,16

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fffa3b9c:	7d 00 00 a6 	mfmsr   r8
fffa3ba0:	7d 09 03 a6 	mtctr   r8

wrteei(0);
fffa3ba4:	7c 00 01 46 	wrteei  0

    //*****The following operations must be done atomically*****
    pk_critical_section_enter(&ctx);

    //load in the offset in the cb for the entry we are adding
    cur_offset = g_pk_trace_buf.state.offset;
fffa3ba8:	39 4d 03 40 	addi    r10,r13,832
fffa3bac:	81 2a 00 34 	lwz     r9,52(r10)
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fffa3bb0:	90 6a 00 30 	stw     r3,48(r10)

    //load in the offset in the cb for the entry we are adding
    cur_offset = g_pk_trace_buf.state.offset;

    //Find the offset for the footer (at the end of the entry)
    footer_offset = cur_offset + parm_size;
fffa3bb4:	7c c5 4a 14 	add     r6,r5,r9

    //calculate the address of the footer
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[footer_offset & PK_TRACE_CB_MASK];
fffa3bb8:	54 c8 05 3e 	clrlwi  r8,r6,20
fffa3bbc:	39 08 00 30 	addi    r8,r8,48
fffa3bc0:	7d 08 52 14 	add     r8,r8,r10
fffa3bc4:	38 e8 00 08 	addi    r7,r8,8

    //calculate the offset for the next entry in the cb
    state.offset = footer_offset + sizeof(PkTraceBig);
fffa3bc8:	38 c6 00 08 	addi    r6,r6,8
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fffa3bcc:	90 ca 00 34 	stw     r6,52(r10)

    //write the data to the circular buffer including the
    //timesamp, string hash, and 16bit parameter
    *ptr64 = footer.word64;
fffa3bd0:	90 08 00 08 	stw     r0,8(r8)
fffa3bd4:	90 87 00 04 	stw     r4,4(r7)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fffa3bd8:	7d 09 02 a6 	mfctr   r8
fffa3bdc:	7d 00 01 24 	mtmsr   r8
    pk_critical_section_exit(&ctx);


    //write parm values to the circular buffer
    footer_ptr = (PkTraceBig*)ptr64;
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[cur_offset & PK_TRACE_CB_MASK];
fffa3be0:	55 28 05 3e 	clrlwi  r8,r9,20
    *ptr64 = i_parm1;
fffa3be4:	39 4a 00 08 	addi    r10,r10,8
fffa3be8:	7d 0a 42 14 	add     r8,r10,r8
fffa3bec:	1b 88 00 30 	stvd    d28,48(r8)

    if(parm_size > 8)
fffa3bf0:	06 c5 40 0a 	cmpwibeq r5,8,fffa3c04 <pk_trace_big+0xb4>
    {
        ptr64 = (uint64_t*)&g_pk_trace_buf.cb[(cur_offset + 8) & PK_TRACE_CB_MASK];
fffa3bf4:	39 29 00 08 	addi    r9,r9,8
fffa3bf8:	55 29 05 3e 	clrlwi  r9,r9,20
        *ptr64 = i_parm2;
fffa3bfc:	7d 2a 4a 14 	add     r9,r10,r9
fffa3c00:	1b c9 00 30 	stvd    d30,48(r9)
    }

    //Mark the trace entry update as being completed
    footer_ptr->parms.complete = 1;
fffa3c04:	39 20 00 01 	li      r9,1
fffa3c08:	99 27 00 02 	stb     r9,2(r7)

}
fffa3c0c:	80 01 00 24 	lwz     r0,36(r1)
fffa3c10:	17 81 00 10 	lvd     d28,16(r1)
fffa3c14:	7c 08 03 a6 	mtlr    r0
fffa3c18:	17 c1 00 18 	lvd     d30,24(r1)
fffa3c1c:	38 21 00 20 	addi    r1,r1,32
fffa3c20:	4e 80 00 20 	blr

fffa3c24 <__pk_thread_context_initialize>:
fffa3c24:	80 c3 00 00 	lwz     r6,0(r3)
fffa3c28:	94 c6 ff a8 	stwu    r6,-88(r6)
fffa3c2c:	38 e0 00 00 	li      r7,0
fffa3c30:	90 e6 00 08 	stw     r7,8(r6)
fffa3c34:	3c e0 ff fa 	lis     r7,-6
fffa3c38:	60 e7 39 e8 	ori     r7,r7,14824
fffa3c3c:	90 e6 00 5c 	stw     r7,92(r6)
fffa3c40:	90 a6 00 18 	stw     r5,24(r6)
fffa3c44:	38 e0 04 04 	li      r7,1028
fffa3c48:	90 e6 00 1c 	stw     r7,28(r6)
fffa3c4c:	38 e0 05 05 	li      r7,1285
fffa3c50:	90 e6 00 20 	stw     r7,32(r6)
fffa3c54:	38 e0 06 06 	li      r7,1542
fffa3c58:	90 e6 00 24 	stw     r7,36(r6)
fffa3c5c:	38 e0 00 00 	li      r7,0
fffa3c60:	90 e6 00 38 	stw     r7,56(r6)
fffa3c64:	90 e6 00 3c 	stw     r7,60(r6)
fffa3c68:	90 86 00 40 	stw     r4,64(r6)
fffa3c6c:	80 ed 03 08 	lwz     r7,776(r13)
fffa3c70:	90 e6 00 44 	stw     r7,68(r6)
fffa3c74:	38 e0 00 00 	li      r7,0
fffa3c78:	90 e6 00 10 	stw     r7,16(r6)
fffa3c7c:	38 e0 07 07 	li      r7,1799
fffa3c80:	90 e6 00 28 	stw     r7,40(r6)
fffa3c84:	38 e0 08 08 	li      r7,2056
fffa3c88:	90 e6 00 2c 	stw     r7,44(r6)
fffa3c8c:	38 e0 09 09 	li      r7,2313
fffa3c90:	90 e6 00 30 	stw     r7,48(r6)
fffa3c94:	38 e0 10 10 	li      r7,4112
fffa3c98:	90 e6 00 34 	stw     r7,52(r6)
fffa3c9c:	38 e0 28 28 	li      r7,10280
fffa3ca0:	90 e6 00 48 	stw     r7,72(r6)
fffa3ca4:	38 e0 29 29 	li      r7,10537
fffa3ca8:	90 e6 00 4c 	stw     r7,76(r6)
fffa3cac:	38 e0 30 30 	li      r7,12336
fffa3cb0:	90 e6 00 50 	stw     r7,80(r6)
fffa3cb4:	38 e0 31 31 	li      r7,12593
fffa3cb8:	90 e6 00 54 	stw     r7,84(r6)
fffa3cbc:	3c e0 80 00 	lis     r7,-32768
fffa3cc0:	90 e6 00 0c 	stw     r7,12(r6)
fffa3cc4:	90 c3 00 00 	stw     r6,0(r3)
fffa3cc8:	4e 80 00 20 	blr

fffa3ccc <_Z12checkSbeRolev>:
#include <p10_scom_perv_e.H>

using namespace fapi2;

uint32_t checkSbeRole()
{
fffa3ccc:	94 21 ff d8 	stwu    r1,-40(r1)
fffa3cd0:	7c 08 02 a6 	mflr    r0
    do
    {
        fapi2::buffer<uint64_t> cbsreg;
        fapi2::buffer<uint64_t> scratchreg8;
        fapi2::buffer<uint64_t> scratchreg6;
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_CBS_ENVSTAT_RO, &cbsreg());
fffa3cd4:	3c 60 00 05 	lis     r3,5
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa3cd8:	39 20 00 00 	li      r9,0
fffa3cdc:	39 00 00 00 	li      r8,0
fffa3ce0:	38 81 00 18 	addi    r4,r1,24
fffa3ce4:	60 63 00 04 	ori     r3,r3,4
fffa3ce8:	19 01 00 18 	stvd    d8,24(r1)
fffa3cec:	19 01 00 10 	stvd    d8,16(r1)
fffa3cf0:	19 01 00 08 	stvd    d8,8(r1)
#include <p10_scom_perv_e.H>

using namespace fapi2;

uint32_t checkSbeRole()
{
fffa3cf4:	90 01 00 2c 	stw     r0,44(r1)
    do
    {
        fapi2::buffer<uint64_t> cbsreg;
        fapi2::buffer<uint64_t> scratchreg8;
        fapi2::buffer<uint64_t> scratchreg6;
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_CBS_ENVSTAT_RO, &cbsreg());
fffa3cf8:	4b ff f9 9d 	bl      fffa3694 <getscom_abs>
        SBE_INFO(SBE_FUNC "CBS_ENVSTAT_REG value is 0x%08X %08X", ((cbsreg >> 32) & 0xFFFFFFFF), (cbsreg & 0xFFFFFFFF));
fffa3cfc:	14 a1 00 18 	lvd     d5,24(r1)
fffa3d00:	3c 60 47 58 	lis     r3,18264
fffa3d04:	38 e0 00 00 	li      r7,0
fffa3d08:	39 00 00 00 	li      r8,0
fffa3d0c:	60 63 00 02 	ori     r3,r3,2
fffa3d10:	4b ff fe 41 	bl      fffa3b50 <pk_trace_big>

        //Read Scratch register 8.
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_8_RW, &scratchreg8());
fffa3d14:	3c 60 00 05 	lis     r3,5
fffa3d18:	38 81 00 10 	addi    r4,r1,16
fffa3d1c:	60 63 00 3f 	ori     r3,r3,63
fffa3d20:	4b ff f9 75 	bl      fffa3694 <getscom_abs>
        SBE_INFO(SBE_FUNC "SCRTATCH_REG 8 is 0x%08X %08X",
            ((scratchreg8 >> 32) & 0xFFFFFFFF), (scratchreg8 & 0xFFFFFFFF));
fffa3d24:	3c 60 31 1b 	lis     r3,12571
fffa3d28:	14 a1 00 10 	lvd     d5,16(r1)
fffa3d2c:	60 63 00 02 	ori     r3,r3,2
fffa3d30:	38 e0 00 00 	li      r7,0
fffa3d34:	39 00 00 00 	li      r8,0
fffa3d38:	4b ff fe 19 	bl      fffa3b50 <pk_trace_big>

        if(scratchreg8.getBit<5>())
fffa3d3c:	81 21 00 10 	lwz     r9,16(r1)
fffa3d40:	07 89 28 38 	bb0wi   r9,5,fffa3db0 <_Z12checkSbeRolev+0xe4>
        {
            //Read Scratch Reg 6.
            rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_6_RW, &scratchreg6());
fffa3d44:	3c 60 00 05 	lis     r3,5
fffa3d48:	38 81 00 08 	addi    r4,r1,8
fffa3d4c:	60 63 00 3d 	ori     r3,r3,61
fffa3d50:	4b ff f9 45 	bl      fffa3694 <getscom_abs>
            SBE_INFO(SBE_FUNC "SCRATCH_REG 6 is 0x%08X %08X",
                      ((scratchreg6 >> 32) & 0xFFFFFFFF), (scratchreg6 & 0xFFFFFFFF));
fffa3d54:	3c 60 75 d2 	lis     r3,30162
fffa3d58:	14 a1 00 08 	lvd     d5,8(r1)
fffa3d5c:	60 63 00 02 	ori     r3,r3,2
fffa3d60:	38 e0 00 00 	li      r7,0
fffa3d64:	39 00 00 00 	li      r8,0
fffa3d68:	4b ff fd e9 	bl      fffa3b50 <pk_trace_big>
            if ( scratchreg6.getBit<24>() )
fffa3d6c:	81 41 00 08 	lwz     r10,8(r1)
fffa3d70:	81 21 00 18 	lwz     r9,24(r1)
fffa3d74:	07 8a c0 14 	bb0wi   r10,24,fffa3d9c <_Z12checkSbeRolev+0xd0>
            {
                sbeRole = SBE_ROLE_MASTER;
                if( !((cbsreg >> 32) & 0x8000000) )
fffa3d78:	07 09 20 0a 	bb1wi   r9,4,fffa3d8c <_Z12checkSbeRolev+0xc0>
                {
                    SBE_INFO(SBE_FUNC "SBE Role is Secondary");
fffa3d7c:	3c 60 e0 b1 	lis     r3,-8015
fffa3d80:	4b ff c9 41 	bl      fffa06c0 <pk_trace_tiny>
                    sbeRole = SBE_ROLE_SLAVE;
fffa3d84:	38 60 00 01 	li      r3,1
fffa3d88:	48 00 00 30 	b       fffa3db8 <_Z12checkSbeRolev+0xec>
                }
                else
                {
                    SBE_INFO(SBE_FUNC "SBE Role is Master");
fffa3d8c:	3c 60 2c 35 	lis     r3,11317
fffa3d90:	4b ff c9 31 	bl      fffa06c0 <pk_trace_tiny>
            rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_6_RW, &scratchreg6());
            SBE_INFO(SBE_FUNC "SCRATCH_REG 6 is 0x%08X %08X",
                      ((scratchreg6 >> 32) & 0xFFFFFFFF), (scratchreg6 & 0xFFFFFFFF));
            if ( scratchreg6.getBit<24>() )
            {
                sbeRole = SBE_ROLE_MASTER;
fffa3d94:	38 60 00 00 	li      r3,0
fffa3d98:	48 00 00 20 	b       fffa3db8 <_Z12checkSbeRolev+0xec>
                }
            }
            else
            {
               //ALT master
               if( ((cbsreg >> 32) & 0x8000000) )
fffa3d9c:	07 89 27 f0 	bb0wi   r9,4,fffa3d7c <_Z12checkSbeRolev+0xb0>
                {   
                    SBE_INFO(SBE_FUNC "SBE Role is Alt-Master");
fffa3da0:	3c 60 77 66 	lis     r3,30566
fffa3da4:	4b ff c9 1d 	bl      fffa06c0 <pk_trace_tiny>
                    sbeRole = SBE_ROLE_ALT_MASTER;
fffa3da8:	38 60 00 02 	li      r3,2
fffa3dac:	48 00 00 0c 	b       fffa3db8 <_Z12checkSbeRolev+0xec>
                }
            }
        }
        else
        {
            if( (cbsreg >> 32) & 0x8000000 )
fffa3db0:	81 21 00 18 	lwz     r9,24(r1)
fffa3db4:	4b ff ff c4 	b       fffa3d78 <_Z12checkSbeRolev+0xac>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return sbeRole;
    #undef SBEM_FUNC
}
fffa3db8:	80 01 00 2c 	lwz     r0,44(r1)
fffa3dbc:	7c 08 03 a6 	mtlr    r0
fffa3dc0:	38 21 00 28 	addi    r1,r1,40
fffa3dc4:	4e 80 00 20 	blr

fffa3dc8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy>:
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context, uint64_t* sectionSize)
{
fffa3dc8:	94 21 ef d0 	stwu    r1,-4144(r1)
fffa3dcc:	7c 08 02 a6 	mflr    r0
fffa3dd0:	1b 81 10 20 	stvd    d28,4128(r1)
fffa3dd4:	1b c1 10 28 	stvd    d30,4136(r1)
fffa3dd8:	90 81 10 18 	stw     r4,4120(r1)
fffa3ddc:	7c 7f 1b 78 	mr      r31,r3
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fffa3de0:	38 80 00 00 	li      r4,0
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context, uint64_t* sectionSize)
{
fffa3de4:	7c bc 2b 78 	mr      r28,r5
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fffa3de8:	38 61 00 08 	addi    r3,r1,8
fffa3dec:	38 a0 10 00 	li      r5,4096
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context, uint64_t* sectionSize)
{
fffa3df0:	90 01 10 34 	stw     r0,4148(r1)
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fffa3df4:	48 00 1b ad 	bl      fffa59a0 <memset>
    uint32_t xipSectionSize = getXipSize(xipSection);
fffa3df8:	7f e3 fb 78 	mr      r3,r31
fffa3dfc:	48 00 04 2d 	bl      fffa4228 <_Z10getXipSize20p9_xip_section_sbe_t>
fffa3e00:	7c 7d 1b 78 	mr      r29,r3
    uint32_t xipSectionOffset = getXipOffset(xipSection);
fffa3e04:	7f e3 fb 78 	mr      r3,r31
fffa3e08:	48 00 03 fd 	bl      fffa4204 <_Z12getXipOffset20p9_xip_section_sbe_t>
fffa3e0c:	7c 7e 1b 78 	mr      r30,r3
    sbe_local_LFR lfrReg;

    SBE_INFO("Xip section details:Start Offset: [0x%08X] Size: [0x%08X] ", xipSectionOffset, xipSectionSize);
fffa3e10:	3c 60 10 fc 	lis     r3,4348
fffa3e14:	60 63 00 02 	ori     r3,r3,2
fffa3e18:	7f c5 f3 78 	mr      r5,r30
fffa3e1c:	7f a6 eb 78 	mr      r6,r29
fffa3e20:	38 e0 00 00 	li      r7,0
fffa3e24:	39 00 00 00 	li      r8,0
fffa3e28:	4b ff fd 29 	bl      fffa3b50 <pk_trace_big>

    // Load the LFR, to fetch if secondary boots seeprom is in use.
    PPE_LVD(0xc0002040, lfrReg);
fffa3e2c:	3d 00 c0 00 	lis     r8,-16384
fffa3e30:	61 08 20 40 	ori     r8,r8,8256
fffa3e34:	15 08 00 00 	lvd     d8,0(r8)

    SBE_INFO("isSecondaryBootsSeeprom [0x%02x]", (uint8_t)lfrReg.sec_boot_seeprom);
fffa3e38:	55 1f 6f fe 	rlwinm  r31,r8,13,31,31
fffa3e3c:	67 e3 e8 86 	oris    r3,r31,59526
fffa3e40:	4b ff c8 81 	bl      fffa06c0 <pk_trace_tiny>

    Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fffa3e44:	4b ff f8 21 	bl      fffa3664 <_ZN5fapi218plat_getChipTargetEv>
                const bool i_pib_access = true):
                target_chip(i_target_chip),
                engine(i_engine),
                slave(i_slave),
                base_addr(i_pib_access ?
                          SPIM_BASEADDRESS_PIB + this->engine * SPIM_ENGINEOFFSET :
fffa3e48:	39 1f 60 00 	addi    r8,r31,24576
                          SPIM_BASEADDRESS_FSI + this->engine * SPIM_ENGINEOFFSET ),
                pibAccess(i_pib_access)
fffa3e4c:	39 20 00 01 	li      r9,1
fffa3e50:	55 08 28 34 	rlwinm  r8,r8,5,0,26
fffa3e54:	90 61 10 08 	stw     r3,4104(r1)
fffa3e58:	b1 21 10 0e 	sth     r9,4110(r1)
fffa3e5c:	91 01 10 10 	stw     r8,4112(r1)
fffa3e60:	99 21 10 14 	stb     r9,4116(r1)
fffa3e64:	9b e1 10 0c 	stb     r31,4108(r1)
fffa3e68:	7c 1e ea 14 	add     r0,r30,r29
#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context, uint64_t* sectionSize)
{
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
    uint32_t xipSectionSize = getXipSize(xipSection);
fffa3e6c:	7f bf eb 78 	mr      r31,r29
    //   isSecondaryBootsSeeprom = 0 ==> Primary Boots seeprom
    SpiControlHandle handle = SpiControlHandle(i_target_chip,
                          (lfrReg.sec_boot_seeprom ? SPI_ENGINE_BACKUP_BOOT_SEEPROM : SPI_ENGINE_PRIMARY_BOOT_SEEPROM));

    //Calculate SAH512 hash by reading chunks as per buf size
    while(xipSectionSize >= SPI_READ_SIZE_BYTES)
fffa3e70:	28 1f 0f ff 	cmplwi  r31,4095
fffa3e74:	7c 9f 00 50 	subf    r4,r31,r0
fffa3e78:	40 81 00 48 	ble     fffa3ec0 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy+0xf8>
    {
        spi_read(handle, xipSectionOffset, SPI_READ_SIZE_BYTES, DISCARD_ECC_ACCESS, (uint8_t *)&buf);
fffa3e7c:	38 a0 10 00 	li      r5,4096
fffa3e80:	38 c0 00 02 	li      r6,2
fffa3e84:	38 e1 00 08 	addi    r7,r1,8
fffa3e88:	38 61 10 08 	addi    r3,r1,4104
fffa3e8c:	90 01 10 1c 	stw     r0,4124(r1)
fffa3e90:	48 00 27 d9 	bl      fffa6668 <spi_read>
        SHA512_Update(context, (uint8_t *)&buf, SPI_READ_SIZE_BYTES);
fffa3e94:	80 61 10 18 	lwz     r3,4120(r1)
fffa3e98:	38 81 00 08 	addi    r4,r1,8
fffa3e9c:	38 a0 10 00 	li      r5,4096
fffa3ea0:	48 00 0a 79 	bl      fffa4918 <SHA512_Update>
        xipSectionOffset += SPI_READ_SIZE_BYTES;
        xipSectionSize -= SPI_READ_SIZE_BYTES;
        *sectionSize += SPI_READ_SIZE_BYTES;
fffa3ea4:	15 1c 00 00 	lvd     d8,0(r28)
    while(xipSectionSize >= SPI_READ_SIZE_BYTES)
    {
        spi_read(handle, xipSectionOffset, SPI_READ_SIZE_BYTES, DISCARD_ECC_ACCESS, (uint8_t *)&buf);
        SHA512_Update(context, (uint8_t *)&buf, SPI_READ_SIZE_BYTES);
        xipSectionOffset += SPI_READ_SIZE_BYTES;
        xipSectionSize -= SPI_READ_SIZE_BYTES;
fffa3ea8:	3b ff f0 00 	addi    r31,r31,-4096
        *sectionSize += SPI_READ_SIZE_BYTES;
fffa3eac:	31 29 10 00 	addic   r9,r9,4096
fffa3eb0:	7d 08 01 94 	addze   r8,r8
fffa3eb4:	19 1c 00 00 	stvd    d8,0(r28)
fffa3eb8:	80 01 10 1c 	lwz     r0,4124(r1)
fffa3ebc:	4b ff ff b4 	b       fffa3e70 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy+0xa8>
fffa3ec0:	57 a4 00 26 	rlwinm  r4,r29,0,0,19
fffa3ec4:	57 a9 05 3e 	clrlwi  r9,r29,20
fffa3ec8:	7c 84 f2 14 	add     r4,r4,r30
    }

    //Calculate SHA512 hash of left over bytes
    if(xipSectionSize != 0)
fffa3ecc:	06 c9 00 38 	bwz     r9,fffa3f3c <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy+0x174>
    {
        uint32_t xipSectionSizeActual = xipSectionSize;

        //SPI driver reads 8bytes chunk. If the length passed is not 8 Byte
        //alligned, it will not read that data.
        if(xipSectionSize % 8 != 0 )
fffa3ed0:	57 aa 07 7e 	clrlwi  r10,r29,29
fffa3ed4:	7d 3f 4b 78 	mr      r31,r9
fffa3ed8:	06 ca 00 06 	bwz     r10,fffa3ee4 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTXPy+0x11c>
            xipSectionSize += (8 - (xipSectionSize % 8));
fffa3edc:	57 bd 05 38 	rlwinm  r29,r29,0,20,28
fffa3ee0:	3b fd 00 08 	addi    r31,r29,8

        spi_read(handle, xipSectionOffset, xipSectionSize, DISCARD_ECC_ACCESS, (uint8_t *)&buf);
fffa3ee4:	38 c0 00 02 	li      r6,2
fffa3ee8:	38 e1 00 08 	addi    r7,r1,8
fffa3eec:	7f e5 fb 78 	mr      r5,r31
fffa3ef0:	38 61 10 08 	addi    r3,r1,4104
fffa3ef4:	91 21 10 1c 	stw     r9,4124(r1)
fffa3ef8:	48 00 27 71 	bl      fffa6668 <spi_read>
        //FIXME: This is a hack, to ensure if length is unaligned pad bytes of
        //the XIP section are zero.
        //Due to issues in IPL image tool .base setion has junk data
        //insted of zero pads. Once tool has been fixed the below piece of code
        //can be removed.
        memset(&buf[xipSectionSizeActual], 0x00, (xipSectionSize - xipSectionSizeActual));
fffa3efc:	81 21 10 1c 	lwz     r9,4124(r1)
fffa3f00:	39 41 00 08 	addi    r10,r1,8
fffa3f04:	7c a9 f8 50 	subf    r5,r9,r31
fffa3f08:	7c 6a 4a 14 	add     r3,r10,r9
fffa3f0c:	38 80 00 00 	li      r4,0
fffa3f10:	48 00 1a 91 	bl      fffa59a0 <memset>

        //Calculate SHA512 for complete data read from SPI as we are aligning data to 8byte by
	    //padding zero's if unaligned during sigining process
        SHA512_Update(context, (uint8_t *)&buf, xipSectionSize);
fffa3f14:	80 61 10 18 	lwz     r3,4120(r1)
fffa3f18:	38 81 00 08 	addi    r4,r1,8
fffa3f1c:	7f e5 fb 78 	mr      r5,r31
fffa3f20:	48 00 09 f9 	bl      fffa4918 <SHA512_Update>
        *sectionSize += xipSectionSize;
fffa3f24:	14 dc 00 00 	lvd     d6,0(r28)
fffa3f28:	7f e9 fb 78 	mr      r9,r31
fffa3f2c:	39 00 00 00 	li      r8,0
fffa3f30:	7d 29 38 14 	addc    r9,r9,r7
fffa3f34:	7d 08 31 14 	adde    r8,r8,r6
fffa3f38:	19 1c 00 00 	stvd    d8,0(r28)
    }
}
fffa3f3c:	80 01 10 34 	lwz     r0,4148(r1)
fffa3f40:	17 81 10 20 	lvd     d28,4128(r1)
fffa3f44:	7c 08 03 a6 	mtlr    r0
fffa3f48:	17 c1 10 28 	lvd     d30,4136(r1)
fffa3f4c:	38 21 10 30 	addi    r1,r1,4144
fffa3f50:	4e 80 00 20 	blr

fffa3f54 <_Z12tpmExtendPCRmPhm>:
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmExtendPCR(uint32_t pcrNum, uint8_t *hashKey, uint32_t size)
{
fffa3f54:	94 21 ff 78 	stwu    r1,-136(r1)
fffa3f58:	7c 08 02 a6 	mflr    r0
fffa3f5c:	1b 81 00 78 	stvd    d28,120(r1)
fffa3f60:	1b c1 00 80 	stvd    d30,128(r1)
fffa3f64:	90 01 00 8c 	stw     r0,140(r1)
fffa3f68:	7c 9d 23 78 	mr      r29,r4
fffa3f6c:	7c be 2b 78 	mr      r30,r5
fffa3f70:	7c 7c 1b 78 	mr      r28,r3
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        // PM2_PCR_Extend
        uint8_t tpmExtendPCR[72] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x01, 0x82, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
fffa3f74:	3b e1 00 08 	addi    r31,r1,8
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fffa3f78:	4b ff f6 ed 	bl      fffa3664 <_ZN5fapi218plat_getChipTargetEv>
fffa3f7c:	39 20 00 04 	li      r9,4
fffa3f80:	3d 40 00 0c 	lis     r10,12
fffa3f84:	61 4a 00 80 	ori     r10,r10,128
fffa3f88:	90 61 00 50 	stw     r3,80(r1)
fffa3f8c:	99 21 00 54 	stb     r9,84(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        // PM2_PCR_Extend
        uint8_t tpmExtendPCR[72] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x01, 0x82, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
fffa3f90:	7f e3 fb 78 	mr      r3,r31
fffa3f94:	39 20 00 01 	li      r9,1
fffa3f98:	38 80 00 00 	li      r4,0
fffa3f9c:	38 a0 00 48 	li      r5,72
fffa3fa0:	b1 21 00 56 	sth     r9,86(r1)
fffa3fa4:	91 41 00 58 	stw     r10,88(r1)
fffa3fa8:	99 21 00 5c 	stb     r9,92(r1)
fffa3fac:	91 21 00 70 	stw     r9,112(r1)
fffa3fb0:	48 00 19 f1 	bl      fffa59a0 <memset>
fffa3fb4:	39 40 ff 80 	li      r10,-128
fffa3fb8:	99 41 00 08 	stb     r10,8(r1)
fffa3fbc:	39 40 00 02 	li      r10,2
fffa3fc0:	81 21 00 70 	lwz     r9,112(r1)
fffa3fc4:	99 41 00 09 	stb     r10,9(r1)
fffa3fc8:	39 40 00 41 	li      r10,65
fffa3fcc:	99 41 00 0d 	stb     r10,13(r1)
fffa3fd0:	39 00 00 40 	li      r8,64
fffa3fd4:	39 40 ff 82 	li      r10,-126
fffa3fd8:	99 21 00 10 	stb     r9,16(r1)
fffa3fdc:	99 41 00 11 	stb     r10,17(r1)
fffa3fe0:	99 21 00 26 	stb     r9,38(r1)
fffa3fe4:	39 40 00 09 	li      r10,9
fffa3fe8:	39 20 00 0b 	li      r9,11
fffa3fec:	99 01 00 1a 	stb     r8,26(r1)
fffa3ff0:	99 41 00 19 	stb     r10,25(r1)
fffa3ff4:	99 41 00 1d 	stb     r10,29(r1)
fffa3ff8:	99 21 00 28 	stb     r9,40(r1)
        // Add 32 byte input hashKey to the tpmExtendPCR after offset 33. 33-64 ---> hashKey
        uint32_t offset = 33;
        uint32_t pcrOffset = 13;
        for(uint32_t i = 0; i < size; i ++)
fffa3ffc:	39 40 00 00 	li      r10,0
fffa4000:	39 20 00 00 	li      r9,0
fffa4004:	06 c9 00 28 	bwz     r9,fffa4054 <_Z12tpmExtendPCRmPhm+0x100>
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
fffa4008:	7c dd 50 ae 	lbzx    r6,r29,r10
fffa400c:	3c 60 c4 97 	lis     r3,-15209
fffa4010:	7d 45 53 78 	mr      r5,r10
fffa4014:	38 e0 00 00 	li      r7,0
fffa4018:	39 00 00 00 	li      r8,0
fffa401c:	60 63 00 02 	ori     r3,r3,2
fffa4020:	91 41 00 6c 	stw     r10,108(r1)
fffa4024:	91 21 00 70 	stw     r9,112(r1)
fffa4028:	91 41 00 68 	stw     r10,104(r1)
fffa402c:	4b ff fb 25 	bl      fffa3b50 <pk_trace_big>
            tpmExtendPCR[offset + i] = *(hashKey + i);
fffa4030:	80 81 00 6c 	lwz     r4,108(r1)
fffa4034:	81 41 00 68 	lwz     r10,104(r1)
fffa4038:	81 21 00 70 	lwz     r9,112(r1)
fffa403c:	7c fd 20 ae 	lbzx    r7,r29,r4
fffa4040:	7d 1f 52 14 	add     r8,r31,r10
fffa4044:	98 e8 00 21 	stb     r7,33(r8)
fffa4048:	31 4a 00 01 	addic   r10,r10,1
fffa404c:	7d 29 01 94 	addze   r9,r9
fffa4050:	4b ff ff b4 	b       fffa4004 <_Z12tpmExtendPCRmPhm+0xb0>
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
        // Add 32 byte input hashKey to the tpmExtendPCR after offset 33. 33-64 ---> hashKey
        uint32_t offset = 33;
        uint32_t pcrOffset = 13;
        for(uint32_t i = 0; i < size; i ++)
fffa4054:	04 5e 57 da 	cmpwbne r30,r10,fffa4008 <_Z12tpmExtendPCRmPhm+0xb4>
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fffa4058:	3c 60 51 d4 	lis     r3,20948
        for(uint32_t i = 0; i < size; i ++)
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
fffa405c:	39 20 00 48 	li      r9,72
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fffa4060:	60 63 00 01 	ori     r3,r3,1
fffa4064:	7f 85 e3 78 	mr      r5,r28
fffa4068:	38 c0 00 00 	li      r6,0
fffa406c:	38 e0 00 00 	li      r7,0
fffa4070:	39 00 00 00 	li      r8,0
        for(uint32_t i = 0; i < size; i ++)
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
fffa4074:	91 21 00 60 	stw     r9,96(r1)
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fffa4078:	4b ff fa d9 	bl      fffa3b50 <pk_trace_big>
        tpmExtendPCR[pcrOffset] = pcrNum;
        uint8_t *seqBytes = tpmExtendPCR;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fffa407c:	38 61 00 50 	addi    r3,r1,80
fffa4080:	7f e4 fb 78 	mr      r4,r31
fffa4084:	38 a1 00 60 	addi    r5,r1,96
fffa4088:	38 c0 00 41 	li      r6,65
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
        tpmExtendPCR[pcrOffset] = pcrNum;
fffa408c:	9b 81 00 15 	stb     r28,21(r1)
        uint8_t *seqBytes = tpmExtendPCR;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fffa4090:	48 00 16 31 	bl      fffa56c0 <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fffa4094:	7c 7d 1b 78 	mr      r29,r3
fffa4098:	3b c0 00 00 	li      r30,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa409c:	06 c3 00 1c 	bwz     r3,fffa40d4 <_Z12tpmExtendPCRmPhm+0x180>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fffa40a0:	7c 7e 1b 78 	mr      r30,r3
fffa40a4:	3b e0 00 00 	li      r31,0
fffa40a8:	3c 60 0b 85 	lis     r3,2949
fffa40ac:	60 63 00 01 	ori     r3,r3,1
fffa40b0:	7f a5 eb 78 	mr      r5,r29
fffa40b4:	7f e6 fb 78 	mr      r6,r31
fffa40b8:	38 e0 00 00 	li      r7,0
fffa40bc:	39 00 00 00 	li      r8,0
fffa40c0:	4b ff fa 91 	bl      fffa3b50 <pk_trace_big>
            SET_TPM_RC(rc);
fffa40c4:	3d 20 00 05 	lis     r9,5
fffa40c8:	61 29 01 85 	ori     r9,r9,389
fffa40cc:	1b c9 00 00 	stvd    d30,0(r9)
            break;
fffa40d0:	48 00 00 b4 	b       fffa4184 <_Z12tpmExtendPCRmPhm+0x230>
        }
        for(uint32_t i = 0; i < buflen; i++)
fffa40d4:	81 21 00 60 	lwz     r9,96(r1)
fffa40d8:	05 1e 48 0c 	cmplwbge r30,r9,fffa40f0 <_Z12tpmExtendPCRmPhm+0x19c>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fffa40dc:	7c 7f f0 ae 	lbzx    r3,r31,r30
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < buflen; i++)
fffa40e0:	3b de 00 01 	addi    r30,r30,1
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fffa40e4:	64 63 73 a2 	oris    r3,r3,29602
fffa40e8:	4b ff c5 d9 	bl      fffa06c0 <pk_trace_tiny>
fffa40ec:	4b ff ff e8 	b       fffa40d4 <_Z12tpmExtendPCRmPhm+0x180>
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fffa40f0:	89 21 00 0e 	lbz     r9,14(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fffa40f4:	3b e0 00 00 	li      r31,0
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fffa40f8:	55 2a c0 0e 	rlwinm  r10,r9,24,0,7
fffa40fc:	89 21 00 0f 	lbz     r9,15(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fffa4100:	3c 60 ae 8f 	lis     r3,-20849
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fffa4104:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fffa4108:	7d 49 4b 78 	or      r9,r10,r9
fffa410c:	89 41 00 11 	lbz     r10,17(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fffa4110:	60 63 00 01 	ori     r3,r3,1
fffa4114:	7d 2a 53 78 	or      r10,r9,r10
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fffa4118:	89 21 00 10 	lbz     r9,16(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fffa411c:	7f e6 fb 78 	mr      r6,r31
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fffa4120:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fffa4124:	7d 49 4b 78 	or      r9,r10,r9
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fffa4128:	7d 25 4b 78 	mr      r5,r9
fffa412c:	38 e0 00 00 	li      r7,0
fffa4130:	39 00 00 00 	li      r8,0
fffa4134:	7d 3e 4b 78 	mr      r30,r9
fffa4138:	91 21 00 70 	stw     r9,112(r1)
fffa413c:	4b ff fa 15 	bl      fffa3b50 <pk_trace_big>
        if(tpmRc || buflen < 10)
fffa4140:	81 21 00 70 	lwz     r9,112(r1)
fffa4144:	06 49 00 08 	bwnz    r9,fffa4154 <_Z12tpmExtendPCRmPhm+0x200>
fffa4148:	81 21 00 60 	lwz     r9,96(r1)
fffa414c:	28 09 00 09 	cmplwi  r9,9
fffa4150:	41 81 00 34 	bgt     fffa4184 <_Z12tpmExtendPCRmPhm+0x230>
        {
            SBEM_ERROR(SBEM_FUNC "TPM2_Extend PCR response code is non zero for PCR %d.", pcrNum);
fffa4154:	3c 60 3d 85 	lis     r3,15749
fffa4158:	60 63 00 01 	ori     r3,r3,1
fffa415c:	7f 85 e3 78 	mr      r5,r28
fffa4160:	38 c0 00 00 	li      r6,0
fffa4164:	38 e0 00 00 	li      r7,0
fffa4168:	39 00 00 00 	li      r8,0
fffa416c:	4b ff f9 e5 	bl      fffa3b50 <pk_trace_big>
            SET_TPM_RC(tpmRc);
fffa4170:	3d 20 00 05 	lis     r9,5
fffa4174:	61 29 01 85 	ori     r9,r9,389
fffa4178:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fffa417c:	3f a0 02 00 	lis     r29,512
fffa4180:	63 bd 00 01 	ori     r29,r29,1

    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4184:	80 01 00 8c 	lwz     r0,140(r1)
fffa4188:	7f a3 eb 78 	mr      r3,r29
fffa418c:	7c 08 03 a6 	mtlr    r0
fffa4190:	17 81 00 78 	lvd     d28,120(r1)
fffa4194:	17 c1 00 80 	lvd     d30,128(r1)
fffa4198:	38 21 00 88 	addi    r1,r1,136
fffa419c:	4e 80 00 20 	blr

fffa41a0 <_Z17setTPMDeconfigBitv>:

fapi2::ReturnCode setTPMDeconfigBit()
{
fffa41a0:	94 21 ff e8 	stwu    r1,-24(r1)
fffa41a4:	7c 08 02 a6 	mflr    r0
fffa41a8:	90 01 00 1c 	stw     r0,28(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        // putscom 0x10005 0x00080000_00000000
        Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
fffa41ac:	4b ff f4 b9 	bl      fffa3664 <_ZN5fapi218plat_getChipTargetEv>
fffa41b0:	7c 29 0b 78 	mr      r9,r1
fffa41b4:	94 69 00 08 	stwu    r3,8(r9)
        constexpr uint64_t tpmDeconfigMask = 0x0008000000000000ULL;
        rc = putscom_abs_wrap (&target, OTP_SECURITY_SWITCH, tpmDeconfigMask);
fffa41b8:	3c 80 00 01 	lis     r4,1
fffa41bc:	3c a0 00 08 	lis     r5,8
fffa41c0:	7d 23 4b 78 	mr      r3,r9
fffa41c4:	60 84 00 05 	ori     r4,r4,5
fffa41c8:	38 c0 00 00 	li      r6,0
fffa41cc:	4b ff f4 49 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa41d0:	7c 65 1b 78 	mr      r5,r3
        if(rc)
fffa41d4:	06 c3 00 10 	bwz     r3,fffa41f4 <_Z17setTPMDeconfigBitv+0x54>
        {
            SBEM_ERROR(SBEM_FUNC " putscom failed on OTP_SECURITY_SWITCH with rc 0x%08X", rc);
fffa41d8:	3c 60 be 95 	lis     r3,-16747
fffa41dc:	60 63 00 01 	ori     r3,r3,1
fffa41e0:	38 c0 00 00 	li      r6,0
fffa41e4:	38 e0 00 00 	li      r7,0
fffa41e8:	39 00 00 00 	li      r8,0
fffa41ec:	4b ff f9 65 	bl      fffa3b50 <pk_trace_big>
            // If we are unsuccessful in setting the deconfig bit we are in an
            // untrusted unsecure state, we must halt
            pk_halt();
fffa41f0:	4b ff bf b5 	bl      fffa01a4 <pk_halt>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa41f4:	80 01 00 1c 	lwz     r0,28(r1)
fffa41f8:	7c 08 03 a6 	mtlr    r0
fffa41fc:	38 21 00 18 	addi    r1,r1,24
fffa4200:	4e 80 00 20 	blr

fffa4204 <_Z12getXipOffset20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return pSection->iv_offset;
fffa4204:	1c 63 00 0c 	mulli   r3,r3,12
fffa4208:	3c 63 ff 80 	addis   r3,r3,-128
}
fffa420c:	80 63 00 40 	lwz     r3,64(r3)
fffa4210:	4e 80 00 20 	blr

fffa4214 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return pSection->iv_offset;
fffa4214:	1c 63 00 0c 	mulli   r3,r3,12
fffa4218:	3c 63 ff 80 	addis   r3,r3,-128
    uint8_t *base = (uint8_t*)(SBE_BASE_ORIGIN);
#else
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif

    return ( (uint32_t)base + getXipOffset(xipSection));
fffa421c:	80 63 00 40 	lwz     r3,64(r3)
}
fffa4220:	3c 63 ff 80 	addis   r3,r3,-128
fffa4224:	4e 80 00 20 	blr

fffa4228 <_Z10getXipSize20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return (pSection->iv_size);
fffa4228:	1c 63 00 0c 	mulli   r3,r3,12
fffa422c:	3c 63 ff 80 	addis   r3,r3,-128
}
fffa4230:	80 63 00 44 	lwz     r3,68(r3)
fffa4234:	4e 80 00 20 	blr

fffa4238 <_ZL16SHA512_TransformP11_SHA512_CTXPKy>:
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fffa4238:	94 21 ff 38 	stwu    r1,-200(r1)
fffa423c:	7c 08 02 a6 	mflr    r0
fffa4240:	90 81 00 98 	stw     r4,152(r1)
                 "sub  %0,2,%0 \n\t" // because subi does not work
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
fffa4244:	14 83 00 00 	lvd     d4,0(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fffa4248:	1b c1 00 c0 	stvd    d30,192(r1)
                 "sub  %0,2,%0 \n\t" // because subi does not work
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
fffa424c:	18 81 00 10 	stvd    d4,16(r1)
    b = context->state[1];
fffa4250:	14 a3 00 08 	lvd     d5,8(r3)
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];
fffa4254:	17 c3 00 38 	lvd     d30,56(r3)
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
fffa4258:	18 a1 00 18 	stvd    d5,24(r1)
    c = context->state[2];
fffa425c:	14 c3 00 10 	lvd     d6,16(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fffa4260:	90 01 00 cc 	stw     r0,204(r1)
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
fffa4264:	18 c1 00 30 	stvd    d6,48(r1)
    d = context->state[3];
fffa4268:	14 e3 00 18 	lvd     d7,24(r3)


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
    uint64_t a, b, c, d, e, f, g, h, s0, s1;
    uint64_t T1, T2, *W512 = (uint64_t*)context->buffer;
fffa426c:	38 03 00 50 	addi    r0,r3,80

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
fffa4270:	18 e1 00 20 	stvd    d7,32(r1)
    e = context->state[4];
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];
fffa4274:	1b c1 00 40 	stvd    d30,64(r1)
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
fffa4278:	15 03 00 28 	lvd     d8,40(r3)
fffa427c:	3b e0 00 10 	li      r31,16


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
    uint64_t a, b, c, d, e, f, g, h, s0, s1;
    uint64_t T1, T2, *W512 = (uint64_t*)context->buffer;
fffa4280:	7c 08 03 a6 	mtlr    r0
fffa4284:	7f e9 03 a6 	mtctr   r31
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
fffa4288:	19 01 00 28 	stvd    d8,40(r1)
    g = context->state[6];
fffa428c:	15 23 00 30 	lvd     d9,48(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fffa4290:	1b 81 00 b8 	stvd    d28,184(r1)
    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
fffa4294:	17 83 00 20 	lvd     d28,32(r3)
    f = context->state[5];
    g = context->state[6];
fffa4298:	19 21 00 38 	stvd    d9,56(r1)
    h = context->state[7];
fffa429c:	39 40 00 00 	li      r10,0

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fffa42a0:	57 9f 70 22 	rlwinm  r31,r28,14,0,17
fffa42a4:	57 a4 74 be 	rlwinm  r4,r29,14,18,31
fffa42a8:	7f e4 23 78 	or      r4,r31,r4
fffa42ac:	90 81 00 9c 	stw     r4,156(r1)
fffa42b0:	57 80 74 be 	rlwinm  r0,r28,14,18,31
fffa42b4:	57 a4 70 22 	rlwinm  r4,r29,14,0,17
fffa42b8:	7c 85 03 78 	or      r5,r4,r0
fffa42bc:	57 9f 90 1a 	rlwinm  r31,r28,18,0,13
fffa42c0:	57 a4 93 be 	rlwinm  r4,r29,18,14,31
fffa42c4:	7f ff 23 78 	or      r31,r31,r4
fffa42c8:	57 a0 90 1a 	rlwinm  r0,r29,18,0,13
fffa42cc:	57 84 93 be 	rlwinm  r4,r28,18,14,31
fffa42d0:	7c 00 23 78 	or      r0,r0,r4
fffa42d4:	81 01 00 98 	lwz     r8,152(r1)
fffa42d8:	7c a0 02 78 	xor     r0,r5,r0
fffa42dc:	90 01 00 a0 	stw     r0,160(r1)
fffa42e0:	3f c0 ff fa 	lis     r30,-6
fffa42e4:	80 01 00 9c 	lwz     r0,156(r1)
fffa42e8:	7d 28 52 14 	add     r9,r8,r10
fffa42ec:	3b de 73 20 	addi    r30,r30,29472
fffa42f0:	14 c9 00 00 	lvd     d6,0(r9)
fffa42f4:	7c 1f fa 78 	xor     r31,r0,r31
fffa42f8:	7d 3e 52 14 	add     r9,r30,r10
fffa42fc:	57 80 b8 10 	rlwinm  r0,r28,23,0,8
fffa4300:	57 be ba 7e 	rlwinm  r30,r29,23,9,31
fffa4304:	80 81 00 a0 	lwz     r4,160(r1)
fffa4308:	7f de 03 78 	or      r30,r30,r0
fffa430c:	57 a5 b8 10 	rlwinm  r5,r29,23,0,8
fffa4310:	57 80 ba 7e 	rlwinm  r0,r28,23,9,31
fffa4314:	7c 00 2b 78 	or      r0,r0,r5
fffa4318:	7c 9e f2 78 	xor     r30,r4,r30
fffa431c:	7f e0 02 78 	xor     r0,r31,r0
fffa4320:	90 01 00 54 	stw     r0,84(r1)
fffa4324:	93 c1 00 50 	stw     r30,80(r1)
fffa4328:	15 09 00 00 	lvd     d8,0(r9)
fffa432c:	17 c1 00 50 	lvd     d30,80(r1)
fffa4330:	7d 29 38 14 	addc    r9,r9,r7
fffa4334:	7d 08 31 14 	adde    r8,r8,r6
fffa4338:	7d 29 f8 14 	addc    r9,r9,r31
fffa433c:	7d 08 f1 14 	adde    r8,r8,r30
fffa4340:	83 e1 00 38 	lwz     r31,56(r1)
fffa4344:	83 c1 00 28 	lwz     r30,40(r1)
fffa4348:	7f e0 e0 78 	andc    r0,r31,r28
fffa434c:	7f df e0 38 	and     r31,r30,r28
fffa4350:	7c 1f fa 78 	xor     r31,r0,r31
fffa4354:	80 a1 00 3c 	lwz     r5,60(r1)
fffa4358:	93 e1 00 48 	stw     r31,72(r1)
fffa435c:	83 e1 00 2c 	lwz     r31,44(r1)
fffa4360:	7c a4 e8 78 	andc    r4,r5,r29
fffa4364:	7f e0 e8 38 	and     r0,r31,r29
fffa4368:	7c 80 02 78 	xor     r0,r4,r0
fffa436c:	90 01 00 4c 	stw     r0,76(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa4370:	80 01 00 10 	lwz     r0,16(r1)
fffa4374:	17 c1 00 48 	lvd     d30,72(r1)
fffa4378:	7d 29 f8 14 	addc    r9,r9,r31
fffa437c:	7d 08 f1 14 	adde    r8,r8,r30
fffa4380:	7f e8 02 a6 	mflr    r31
fffa4384:	83 c1 00 34 	lwz     r30,52(r1)
fffa4388:	7c 9f 52 14 	add     r4,r31,r10
    h = context->state[7];

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fffa438c:	18 c4 00 00 	stvd    d6,0(r4)
fffa4390:	14 81 00 40 	lvd     d4,64(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa4394:	80 e1 00 18 	lwz     r7,24(r1)
    h = context->state[7];

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fffa4398:	7d 29 28 14 	addc    r9,r9,r5
fffa439c:	7d 08 21 14 	adde    r8,r8,r4
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa43a0:	83 e1 00 1c 	lwz     r31,28(r1)
fffa43a4:	80 a1 00 30 	lwz     r5,48(r1)
fffa43a8:	80 81 00 14 	lwz     r4,20(r1)
fffa43ac:	7c a6 3a 78 	xor     r6,r5,r7
fffa43b0:	7f c7 fa 78 	xor     r7,r30,r31
fffa43b4:	83 c1 00 18 	lwz     r30,24(r1)
fffa43b8:	7c c6 00 38 	and     r6,r6,r0
fffa43bc:	7c e7 20 38 	and     r7,r7,r4
fffa43c0:	83 e1 00 34 	lwz     r31,52(r1)
fffa43c4:	7c a4 f0 38 	and     r4,r5,r30
fffa43c8:	80 01 00 1c 	lwz     r0,28(r1)
fffa43cc:	7c c4 22 78 	xor     r4,r6,r4
fffa43d0:	80 a1 00 10 	lwz     r5,16(r1)
fffa43d4:	7f e6 00 38 	and     r6,r31,r0
fffa43d8:	90 81 00 58 	stw     r4,88(r1)
fffa43dc:	80 81 00 14 	lwz     r4,20(r1)
fffa43e0:	7c e6 32 78 	xor     r6,r7,r6
fffa43e4:	83 e1 00 14 	lwz     r31,20(r1)
fffa43e8:	90 c1 00 5c 	stw     r6,92(r1)
fffa43ec:	54 be f0 02 	rlwinm  r30,r5,30,0,1
fffa43f0:	54 86 f0 be 	rlwinm  r6,r4,30,2,31
fffa43f4:	7c de f3 78 	or      r30,r6,r30
fffa43f8:	54 a7 f0 be 	rlwinm  r7,r5,30,2,31
fffa43fc:	54 86 f0 02 	rlwinm  r6,r4,30,0,1
fffa4400:	7c e4 33 78 	or      r4,r7,r6
fffa4404:	57 e0 20 36 	rlwinm  r0,r31,4,0,27
fffa4408:	57 e6 27 3e 	rlwinm  r6,r31,4,28,31
fffa440c:	54 bf 27 3e 	rlwinm  r31,r5,4,28,31
fffa4410:	7c 00 fb 78 	or      r0,r0,r31
fffa4414:	54 a7 20 36 	rlwinm  r7,r5,4,0,27
fffa4418:	7c e7 33 78 	or      r7,r7,r6
fffa441c:	7f c6 02 78 	xor     r6,r30,r0
fffa4420:	80 01 00 14 	lwz     r0,20(r1)
fffa4424:	7c 87 3a 78 	xor     r7,r4,r7
fffa4428:	54 1f c9 fe 	rlwinm  r31,r0,25,7,31
fffa442c:	54 a4 c8 0c 	rlwinm  r4,r5,25,0,6
fffa4430:	7f ff 23 78 	or      r31,r31,r4
fffa4434:	54 00 c8 0c 	rlwinm  r0,r0,25,0,6
fffa4438:	54 a4 c9 fe 	rlwinm  r4,r5,25,7,31
fffa443c:	7c 84 03 78 	or      r4,r4,r0
fffa4440:	7c df fa 78 	xor     r31,r6,r31
fffa4444:	7c e4 22 78 	xor     r4,r7,r4
fffa4448:	93 e1 00 60 	stw     r31,96(r1)
fffa444c:	90 81 00 64 	stw     r4,100(r1)
fffa4450:	17 c1 00 58 	lvd     d30,88(r1)
fffa4454:	14 81 00 60 	lvd     d4,96(r1)
fffa4458:	39 4a 00 08 	addi    r10,r10,8
fffa445c:	7c ff 28 14 	addc    r7,r31,r5
fffa4460:	7c de 21 14 	adde    r6,r30,r4
        h = g;
        g = f;
        f = e;
        e = d + T1;
fffa4464:	14 81 00 20 	lvd     d4,32(r1)
fffa4468:	7f e5 48 14 	addc    r31,r5,r9
fffa446c:	7f c4 41 14 	adde    r30,r4,r8
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fffa4470:	7c a7 48 14 	addc    r5,r7,r9
fffa4474:	7c 86 41 14 	adde    r4,r6,r8
fffa4478:	18 81 00 08 	stvd    d4,8(r1)
fffa447c:	14 a1 00 30 	lvd     d5,48(r1)
fffa4480:	18 a1 00 20 	stvd    d5,32(r1)
fffa4484:	14 c1 00 38 	lvd     d6,56(r1)
fffa4488:	18 c1 00 40 	stvd    d6,64(r1)
fffa448c:	42 40 00 34 	bdz     fffa44c0 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x288>
fffa4490:	14 81 00 28 	lvd     d4,40(r1)
fffa4494:	1b 81 00 28 	stvd    d28,40(r1)
fffa4498:	18 81 00 38 	stvd    d4,56(r1)
fffa449c:	14 a1 00 18 	lvd     d5,24(r1)
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
        T2 = Sigma0_512(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + T1;
fffa44a0:	7f dc f3 78 	mr      r28,r30
fffa44a4:	18 a1 00 30 	stvd    d5,48(r1)
fffa44a8:	14 c1 00 10 	lvd     d6,16(r1)
fffa44ac:	7f fd fb 78 	mr      r29,r31
fffa44b0:	18 c1 00 18 	stvd    d6,24(r1)
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fffa44b4:	14 e1 00 08 	lvd     d7,8(r1)
fffa44b8:	18 e1 00 10 	stvd    d7,16(r1)
fffa44bc:	4b ff fd e4 	b       fffa42a0 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x68>
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];

    j = 0;
    do {
fffa44c0:	38 e0 00 40 	li      r7,64
fffa44c4:	7c e9 03 a6 	mtctr   r7
fffa44c8:	39 40 00 10 	li      r10,16
fffa44cc:	38 ca 00 01 	addi    r6,r10,1
        j++;
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
fffa44d0:	7c e8 02 a6 	mflr    r7
fffa44d4:	54 c9 1e 78 	rlwinm  r9,r6,3,25,28
fffa44d8:	7d 27 4a 14 	add     r9,r7,r9
fffa44dc:	15 09 00 00 	lvd     d8,0(r9)
fffa44e0:	90 c1 00 50 	stw     r6,80(r1)
        s0 = sigma0_512(s0);
fffa44e4:	55 27 c2 3e 	rlwinm  r7,r9,24,8,31
fffa44e8:	55 06 c0 0e 	rlwinm  r6,r8,24,0,7
fffa44ec:	7c c6 3b 78 	or      r6,r6,r7
fffa44f0:	55 25 c0 0e 	rlwinm  r5,r9,24,0,7
fffa44f4:	55 07 c2 3e 	rlwinm  r7,r8,24,8,31
fffa44f8:	7c a4 3b 78 	or      r4,r5,r7
fffa44fc:	55 05 f8 00 	rlwinm  r5,r8,31,0,0
fffa4500:	55 27 f8 7e 	rlwinm  r7,r9,31,1,31
fffa4504:	55 20 f8 00 	rlwinm  r0,r9,31,0,0
fffa4508:	7c a7 3b 78 	or      r7,r5,r7
fffa450c:	55 05 f8 7e 	rlwinm  r5,r8,31,1,31
fffa4510:	7c 05 2b 78 	or      r5,r0,r5
fffa4514:	7c 85 2a 78 	xor     r5,r4,r5
fffa4518:	90 a1 00 48 	stw     r5,72(r1)
fffa451c:	79 04 c9 c2 	rldicl  d4,d8,57,7
fffa4520:	18 81 00 20 	stvd    d4,32(r1)
fffa4524:	39 2a 00 0e 	addi    r9,r10,14
        s1 = W512[(j+14)&0x0f];
fffa4528:	7c a8 02 a6 	mflr    r5
fffa452c:	55 29 1e 78 	rlwinm  r9,r9,3,25,28
fffa4530:	7d 25 4a 14 	add     r9,r5,r9
fffa4534:	15 09 00 00 	lvd     d8,0(r9)
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
fffa4538:	7c c7 3a 78 	xor     r7,r6,r7
fffa453c:	90 e1 00 58 	stw     r7,88(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fffa4540:	55 26 1f 7e 	rlwinm  r6,r9,3,29,31
fffa4544:	55 07 18 38 	rlwinm  r7,r8,3,0,28
fffa4548:	7c c4 3b 78 	or      r4,r6,r7
fffa454c:	55 00 1f 7e 	rlwinm  r0,r8,3,29,31
fffa4550:	55 27 18 38 	rlwinm  r7,r9,3,0,28
fffa4554:	7c 06 3b 78 	or      r6,r0,r7
fffa4558:	55 00 68 24 	rlwinm  r0,r8,13,0,18
fffa455c:	55 27 6c fe 	rlwinm  r7,r9,13,19,31
fffa4560:	7c 07 3b 78 	or      r7,r0,r7
fffa4564:	55 05 6c fe 	rlwinm  r5,r8,13,19,31
fffa4568:	55 20 68 24 	rlwinm  r0,r9,13,0,18
fffa456c:	7c 05 2b 78 	or      r5,r0,r5
fffa4570:	7c c0 3a 78 	xor     r0,r6,r7
fffa4574:	79 06 d1 82 	rldicl  d6,d8,58,6

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fffa4578:	7d 08 02 a6 	mflr    r8
    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fffa457c:	18 c1 00 b0 	stvd    d6,176(r1)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fffa4580:	55 47 1e 78 	rlwinm  r7,r10,3,25,28
fffa4584:	7d 08 3a 14 	add     r8,r8,r7
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fffa4588:	7d 28 02 a6 	mflr    r9
fffa458c:	38 ea 00 09 	addi    r7,r10,9
fffa4590:	54 e7 1e 78 	rlwinm  r7,r7,3,25,28
fffa4594:	7c e9 3a 14 	add     r7,r9,r7
    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fffa4598:	7c 85 2a 78 	xor     r5,r4,r5
fffa459c:	90 a1 00 60 	stw     r5,96(r1)
fffa45a0:	14 87 00 00 	lvd     d4,0(r7)
fffa45a4:	14 c8 00 00 	lvd     d6,0(r8)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fffa45a8:	91 01 00 40 	stw     r8,64(r1)
fffa45ac:	7c e9 3b 78 	mr      r9,r7
fffa45b0:	7c c8 33 78 	mr      r8,r6
fffa45b4:	7c e9 28 14 	addc    r7,r9,r5
fffa45b8:	7c c8 21 14 	adde    r6,r8,r4
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
fffa45bc:	81 21 00 48 	lwz     r9,72(r1)
fffa45c0:	80 81 00 20 	lwz     r4,32(r1)
fffa45c4:	81 01 00 24 	lwz     r8,36(r1)
fffa45c8:	80 a1 00 58 	lwz     r5,88(r1)
fffa45cc:	7d 29 22 78 	xor     r9,r9,r4
fffa45d0:	7c a5 42 78 	xor     r5,r5,r8
fffa45d4:	90 a1 00 6c 	stw     r5,108(r1)
fffa45d8:	91 21 00 68 	stw     r9,104(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fffa45dc:	80 81 00 b0 	lwz     r4,176(r1)
fffa45e0:	15 01 00 68 	lvd     d8,104(r1)
fffa45e4:	80 a1 00 b4 	lwz     r5,180(r1)
fffa45e8:	7c e7 48 14 	addc    r7,r7,r9
fffa45ec:	7c c6 41 14 	adde    r6,r6,r8
fffa45f0:	81 21 00 60 	lwz     r9,96(r1)
fffa45f4:	7c 00 2a 78 	xor     r0,r0,r5
fffa45f8:	7d 29 22 78 	xor     r9,r9,r4
fffa45fc:	91 21 00 70 	stw     r9,112(r1)
fffa4600:	90 01 00 74 	stw     r0,116(r1)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fffa4604:	57 e0 90 1a 	rlwinm  r0,r31,18,0,13
fffa4608:	14 81 00 70 	lvd     d4,112(r1)
fffa460c:	55 4a 18 38 	rlwinm  r10,r10,3,0,28
fffa4610:	7d 27 28 14 	addc    r9,r7,r5
fffa4614:	7d 06 21 14 	adde    r8,r6,r4
fffa4618:	14 a1 00 28 	lvd     d5,40(r1)
fffa461c:	19 01 00 48 	stvd    d8,72(r1)
fffa4620:	7f 87 f0 38 	and     r7,r28,r30
fffa4624:	7c a8 f0 78 	andc    r8,r5,r30
fffa4628:	7c c9 f8 78 	andc    r9,r6,r31
fffa462c:	7d 07 3a 78 	xor     r7,r8,r7
fffa4630:	7f a8 f8 38 	and     r8,r29,r31
fffa4634:	90 e1 00 78 	stw     r7,120(r1)
fffa4638:	7d 28 42 78 	xor     r8,r9,r8
fffa463c:	57 e7 74 be 	rlwinm  r7,r31,14,18,31
fffa4640:	57 c9 70 22 	rlwinm  r9,r30,14,0,17
fffa4644:	91 01 00 7c 	stw     r8,124(r1)
fffa4648:	7d 27 3b 78 	or      r7,r9,r7
fffa464c:	57 e8 70 22 	rlwinm  r8,r31,14,0,17
fffa4650:	57 c9 74 be 	rlwinm  r9,r30,14,18,31
fffa4654:	7d 05 4b 78 	or      r5,r8,r9
fffa4658:	57 c6 93 be 	rlwinm  r6,r30,18,14,31
fffa465c:	57 e8 93 be 	rlwinm  r8,r31,18,14,31
fffa4660:	57 c9 90 1a 	rlwinm  r9,r30,18,0,13
fffa4664:	7c 00 33 78 	or      r0,r0,r6
fffa4668:	7d 29 43 78 	or      r9,r9,r8
fffa466c:	7c e9 4a 78 	xor     r9,r7,r9
fffa4670:	7c a8 02 78 	xor     r8,r5,r0
fffa4674:	57 c7 b8 10 	rlwinm  r7,r30,23,0,8
fffa4678:	57 e0 ba 7e 	rlwinm  r0,r31,23,9,31
fffa467c:	7c 00 3b 78 	or      r0,r0,r7
fffa4680:	57 c6 ba 7e 	rlwinm  r6,r30,23,9,31
fffa4684:	57 e7 b8 10 	rlwinm  r7,r31,23,0,8
fffa4688:	7c c6 3b 78 	or      r6,r6,r7
fffa468c:	7d 00 02 78 	xor     r0,r8,r0
fffa4690:	7d 26 32 78 	xor     r6,r9,r6
fffa4694:	90 01 00 80 	stw     r0,128(r1)
fffa4698:	90 c1 00 84 	stw     r6,132(r1)
fffa469c:	15 01 00 78 	lvd     d8,120(r1)
fffa46a0:	14 81 00 80 	lvd     d4,128(r1)
fffa46a4:	7c e9 28 14 	addc    r7,r9,r5
fffa46a8:	7c c8 21 14 	adde    r6,r8,r4
fffa46ac:	3c a0 ff fa 	lis     r5,-6
fffa46b0:	38 a5 73 20 	addi    r5,r5,29472
fffa46b4:	7d 45 52 14 	add     r10,r5,r10
fffa46b8:	18 c1 00 20 	stvd    d6,32(r1)
fffa46bc:	14 ca 00 00 	lvd     d6,0(r10)
fffa46c0:	14 81 00 20 	lvd     d4,32(r1)
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa46c4:	80 01 00 1c 	lwz     r0,28(r1)
fffa46c8:	7d 25 38 14 	addc    r9,r5,r7
fffa46cc:	7d 04 31 14 	adde    r8,r4,r6
fffa46d0:	14 a1 00 48 	lvd     d5,72(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fffa46d4:	80 e1 00 40 	lwz     r7,64(r1)
fffa46d8:	7d 29 30 14 	addc    r9,r9,r6
fffa46dc:	7d 08 29 14 	adde    r8,r8,r5
fffa46e0:	18 a7 00 00 	stvd    d5,0(r7)
fffa46e4:	14 c1 00 38 	lvd     d6,56(r1)
fffa46e8:	7c a9 38 14 	addc    r5,r9,r7
fffa46ec:	7c 88 31 14 	adde    r4,r8,r6
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa46f0:	80 e1 00 18 	lwz     r7,24(r1)
fffa46f4:	81 01 00 10 	lwz     r8,16(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fffa46f8:	18 81 00 38 	stvd    d4,56(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fffa46fc:	80 a1 00 08 	lwz     r5,8(r1)
fffa4700:	80 81 00 14 	lwz     r4,20(r1)
fffa4704:	80 c1 00 0c 	lwz     r6,12(r1)
fffa4708:	7c ea 42 78 	xor     r10,r7,r8
fffa470c:	7c 09 22 78 	xor     r9,r0,r4
fffa4710:	7d 4a 28 38 	and     r10,r10,r5
fffa4714:	7c e8 40 38 	and     r8,r7,r8
fffa4718:	7d 29 30 38 	and     r9,r9,r6
fffa471c:	7d 48 42 78 	xor     r8,r10,r8
fffa4720:	7c 0a 20 38 	and     r10,r0,r4
fffa4724:	7d 2a 52 78 	xor     r10,r9,r10
fffa4728:	91 41 00 8c 	stw     r10,140(r1)
fffa472c:	54 a9 f0 02 	rlwinm  r9,r5,30,0,1
fffa4730:	54 ca f0 be 	rlwinm  r10,r6,30,2,31
fffa4734:	7d 40 4b 78 	or      r0,r10,r9
fffa4738:	7c a4 2b 78 	mr      r4,r5
fffa473c:	54 a9 f0 be 	rlwinm  r9,r5,30,2,31
fffa4740:	54 ca f0 02 	rlwinm  r10,r6,30,0,1
fffa4744:	91 01 00 88 	stw     r8,136(r1)
fffa4748:	7d 28 53 78 	or      r8,r9,r10
fffa474c:	54 ca 27 3e 	rlwinm  r10,r6,4,28,31
fffa4750:	54 89 20 36 	rlwinm  r9,r4,4,0,27
fffa4754:	54 c4 20 36 	rlwinm  r4,r6,4,0,27
fffa4758:	14 c1 00 08 	lvd     d6,8(r1)
fffa475c:	54 c5 27 3e 	rlwinm  r5,r6,4,28,31
fffa4760:	7c 84 2b 78 	or      r4,r4,r5
fffa4764:	7d 29 53 78 	or      r9,r9,r10
fffa4768:	7d 09 4a 78 	xor     r9,r8,r9
fffa476c:	7c 0a 22 78 	xor     r10,r0,r4
fffa4770:	54 c8 c8 0c 	rlwinm  r8,r6,25,0,6
fffa4774:	54 e4 c9 fe 	rlwinm  r4,r7,25,7,31
fffa4778:	7c 84 43 78 	or      r4,r4,r8
fffa477c:	54 c5 c9 fe 	rlwinm  r5,r6,25,7,31
fffa4780:	54 e8 c8 0c 	rlwinm  r8,r7,25,0,6
fffa4784:	7c a5 43 78 	or      r5,r5,r8
fffa4788:	7d 44 22 78 	xor     r4,r10,r4
fffa478c:	7d 25 2a 78 	xor     r5,r9,r5
fffa4790:	18 81 00 90 	stvd    d4,144(r1)
fffa4794:	15 01 00 88 	lvd     d8,136(r1)
fffa4798:	14 81 00 90 	lvd     d4,144(r1)
fffa479c:	7c e9 28 14 	addc    r7,r9,r5
fffa47a0:	7c c8 21 14 	adde    r6,r8,r4
fffa47a4:	18 c1 00 20 	stvd    d6,32(r1)
        h = g;
        g = f;
        f = e;
        e = d + T1;
fffa47a8:	15 21 00 38 	lvd     d9,56(r1)
fffa47ac:	14 e1 00 30 	lvd     d7,48(r1)
fffa47b0:	7c c8 50 14 	addc    r6,r8,r10
fffa47b4:	7c a7 49 14 	adde    r5,r7,r9
fffa47b8:	18 a1 00 40 	stvd    d5,64(r1)
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fffa47bc:	14 c1 00 20 	lvd     d6,32(r1)
fffa47c0:	7c a7 50 14 	addc    r5,r7,r10
fffa47c4:	7c 86 49 14 	adde    r4,r6,r9
fffa47c8:	14 e1 00 18 	lvd     d7,24(r1)
fffa47cc:	18 81 00 20 	stvd    d4,32(r1)
fffa47d0:	18 e1 00 30 	stvd    d7,48(r1)
fffa47d4:	15 01 00 28 	lvd     d8,40(r1)
fffa47d8:	81 41 00 50 	lwz     r10,80(r1)
fffa47dc:	19 01 00 38 	stvd    d8,56(r1)
        a = T1 + T2;

        j++;
    } while (j < 16);

    do {
fffa47e0:	42 40 00 30 	bdz     fffa4810 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x5d8>
fffa47e4:	14 81 00 08 	lvd     d4,8(r1)
fffa47e8:	15 01 00 10 	lvd     d8,16(r1)
fffa47ec:	18 81 00 10 	stvd    d4,16(r1)
        f = e;
        e = d + T1;
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fffa47f0:	14 a1 00 20 	lvd     d5,32(r1)
fffa47f4:	1b 81 00 28 	stvd    d28,40(r1)
fffa47f8:	19 01 00 18 	stvd    d8,24(r1)
fffa47fc:	7f dc f3 78 	mr      r28,r30
fffa4800:	7f fd fb 78 	mr      r29,r31
fffa4804:	18 a1 00 08 	stvd    d5,8(r1)
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
        T2 = Sigma0_512(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + T1;
fffa4808:	17 c1 00 40 	lvd     d30,64(r1)
fffa480c:	4b ff fc c0 	b       fffa44cc <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x294>

        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
fffa4810:	14 c3 00 00 	lvd     d6,0(r3)
    context->state[6] += g;
    context->state[7] += h;

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fffa4814:	80 01 00 cc 	lwz     r0,204(r1)

        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
fffa4818:	7d 25 38 14 	addc    r9,r5,r7
fffa481c:	7d 04 31 14 	adde    r8,r4,r6
fffa4820:	19 03 00 00 	stvd    d8,0(r3)
    context->state[1] += b;
fffa4824:	14 81 00 08 	lvd     d4,8(r1)
fffa4828:	15 03 00 08 	lvd     d8,8(r3)
    context->state[6] += g;
    context->state[7] += h;

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fffa482c:	7c 08 03 a6 	mtlr    r0
        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
    context->state[1] += b;
fffa4830:	7d 29 28 14 	addc    r9,r9,r5
fffa4834:	7d 08 21 14 	adde    r8,r8,r4
fffa4838:	19 03 00 08 	stvd    d8,8(r3)
    context->state[2] += c;
fffa483c:	14 a1 00 10 	lvd     d5,16(r1)
fffa4840:	15 03 00 10 	lvd     d8,16(r3)
fffa4844:	7d 29 30 14 	addc    r9,r9,r6
fffa4848:	7d 08 29 14 	adde    r8,r8,r5
fffa484c:	19 03 00 10 	stvd    d8,16(r3)
    context->state[3] += d;
fffa4850:	14 c1 00 18 	lvd     d6,24(r1)
fffa4854:	15 03 00 18 	lvd     d8,24(r3)
fffa4858:	7d 29 38 14 	addc    r9,r9,r7
fffa485c:	7d 08 31 14 	adde    r8,r8,r6
fffa4860:	19 03 00 18 	stvd    d8,24(r3)
    context->state[4] += e;
fffa4864:	14 c1 00 40 	lvd     d6,64(r1)
fffa4868:	15 03 00 20 	lvd     d8,32(r3)
fffa486c:	7c a7 48 14 	addc    r5,r7,r9
fffa4870:	7c 86 41 14 	adde    r4,r6,r8
    context->state[5] += f;
fffa4874:	15 03 00 28 	lvd     d8,40(r3)
    /* Compute the current intermediate hash value */
    context->state[0] += a;
    context->state[1] += b;
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
fffa4878:	18 83 00 20 	stvd    d4,32(r3)
    context->state[5] += f;
fffa487c:	7d 29 f8 14 	addc    r9,r9,r31
fffa4880:	7d 08 f1 14 	adde    r8,r8,r30
fffa4884:	19 03 00 28 	stvd    d8,40(r3)
    context->state[6] += g;
fffa4888:	15 03 00 30 	lvd     d8,48(r3)
    context->state[7] += h;
fffa488c:	17 c1 00 28 	lvd     d30,40(r1)
    context->state[1] += b;
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
    context->state[5] += f;
    context->state[6] += g;
fffa4890:	7d 29 e8 14 	addc    r9,r9,r29
fffa4894:	7d 08 e1 14 	adde    r8,r8,r28
fffa4898:	19 03 00 30 	stvd    d8,48(r3)
    context->state[7] += h;
fffa489c:	15 03 00 38 	lvd     d8,56(r3)

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fffa48a0:	17 81 00 b8 	lvd     d28,184(r1)
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
    context->state[5] += f;
    context->state[6] += g;
    context->state[7] += h;
fffa48a4:	7d 29 f8 14 	addc    r9,r9,r31
fffa48a8:	7d 08 f1 14 	adde    r8,r8,r30
fffa48ac:	19 03 00 38 	stvd    d8,56(r3)

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fffa48b0:	17 c1 00 c0 	lvd     d30,192(r1)
fffa48b4:	38 21 00 c8 	addi    r1,r1,200
fffa48b8:	4e 80 00 20 	blr

fffa48bc <SHA512_Init>:
}

/*** SHA-512: *********************************************************/
asm(".globl .L.SHA512_Init");
void SHA512_Init(SHA512_CTX* context)
{
fffa48bc:	94 21 ff f0 	stwu    r1,-16(r1)
fffa48c0:	7c 08 02 a6 	mflr    r0
fffa48c4:	1b c1 00 08 	stvd    d30,8(r1)
fffa48c8:	90 01 00 14 	stw     r0,20(r1)
fffa48cc:	7c 7f 1b 78 	mr      r31,r3
    if (context == (SHA512_CTX*)0)
fffa48d0:	06 c3 00 1a 	bwz     r3,fffa4904 <SHA512_Init+0x48>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fffa48d4:	3c 80 ff fa 	lis     r4,-6
fffa48d8:	38 84 75 a0 	addi    r4,r4,30112
fffa48dc:	38 a0 00 40 	li      r5,64
fffa48e0:	48 00 11 95 	bl      fffa5a74 <memcpy>
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa48e4:	38 7f 00 50 	addi    r3,r31,80
fffa48e8:	38 80 00 00 	li      r4,0
fffa48ec:	38 a0 00 80 	li      r5,128
fffa48f0:	48 00 10 b1 	bl      fffa59a0 <memset>
                 "addi %0,%0,(sha512_initial_hash_value-0x8000)@l" : "=r" (sha512_initial_hash_value_p) );
#endif

    bcopy(sha512_initial_hash_value_p, context->state, SHA512_DIGEST_LENGTH);
    bzero(context->buffer, SHA512_BLOCK_LENGTH);
    context->bitcount[0] = context->bitcount[1] =  0;
fffa48f4:	39 00 00 00 	li      r8,0
fffa48f8:	39 20 00 00 	li      r9,0
fffa48fc:	19 1f 00 48 	stvd    d8,72(r31)
fffa4900:	19 1f 00 40 	stvd    d8,64(r31)
}
fffa4904:	80 01 00 14 	lwz     r0,20(r1)
fffa4908:	17 c1 00 08 	lvd     d30,8(r1)
fffa490c:	7c 08 03 a6 	mtlr    r0
fffa4910:	38 21 00 10 	addi    r1,r1,16
fffa4914:	4e 80 00 20 	blr

fffa4918 <SHA512_Update>:
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

asm(".globl .L.SHA512_Update");
void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len)
{
fffa4918:	94 21 ff e8 	stwu    r1,-24(r1)
fffa491c:	7c 08 02 a6 	mflr    r0
fffa4920:	1b c1 00 10 	stvd    d30,16(r1)
fffa4924:	90 01 00 1c 	stw     r0,28(r1)
fffa4928:	1b 81 00 08 	stvd    d28,8(r1)
fffa492c:	7c be 2b 78 	mr      r30,r5
    unsigned int freespace, usedspace;

    if (len == 0)
fffa4930:	06 c5 00 8a 	bwz     r5,fffa4a44 <SHA512_Update+0x12c>
    {
        /* Calling with no data is valid - we do nothing */
        return;
    }

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fffa4934:	15 03 00 40 	lvd     d8,64(r3)
fffa4938:	7c 7f 1b 78 	mr      r31,r3
fffa493c:	79 08 e8 c2 	rldicl  d8,d8,61,3
fffa4940:	55 23 06 7e 	clrlwi  r3,r9,25
fffa4944:	7c 9d 23 78 	mr      r29,r4
    if (usedspace > 0)
fffa4948:	06 c3 00 30 	bwz     r3,fffa49a8 <SHA512_Update+0x90>
    {
        /* Calculate how much free space is available in the buffer */
        freespace = SHA512_BLOCK_LENGTH - usedspace;
fffa494c:	23 83 00 80 	subfic  r28,r3,128
fffa4950:	38 63 00 50 	addi    r3,r3,80
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fffa4954:	7c 7f 1a 14 	add     r3,r31,r3
    if (usedspace > 0)
    {
        /* Calculate how much free space is available in the buffer */
        freespace = SHA512_BLOCK_LENGTH - usedspace;

        if (len >= freespace)
fffa4958:	05 85 e0 5c 	cmplwblt r5,r28,fffa4a10 <SHA512_Update+0xf8>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fffa495c:	7f 85 e3 78 	mr      r5,r28
fffa4960:	48 00 11 15 	bl      fffa5a74 <memcpy>

        if (len >= freespace)
        {
            /* Fill the buffer completely and process it */
            bcopy(data, &context->buffer[usedspace], freespace);
            ADDINC128(context->bitcount, freespace << 3);
fffa4964:	15 1f 00 40 	lvd     d8,64(r31)
fffa4968:	57 87 18 38 	rlwinm  r7,r28,3,0,28
fffa496c:	38 c0 00 00 	li      r6,0
fffa4970:	7d 29 38 14 	addc    r9,r9,r7
fffa4974:	7d 08 31 14 	adde    r8,r8,r6
fffa4978:	19 1f 00 40 	stvd    d8,64(r31)
fffa497c:	04 46 40 0c 	cmpwbne r6,r8,fffa4994 <SHA512_Update+0x7c>
fffa4980:	05 27 48 0a 	cmplwble r7,r9,fffa4994 <SHA512_Update+0x7c>
fffa4984:	15 1f 00 48 	lvd     d8,72(r31)
fffa4988:	31 29 00 01 	addic   r9,r9,1
fffa498c:	7d 08 01 94 	addze   r8,r8
fffa4990:	19 1f 00 48 	stvd    d8,72(r31)
            len -= freespace;
            data += freespace;
            SHA512_Transform(context, (uint64_t*)context->buffer);
fffa4994:	7f e3 fb 78 	mr      r3,r31
fffa4998:	38 9f 00 50 	addi    r4,r31,80
        if (len >= freespace)
        {
            /* Fill the buffer completely and process it */
            bcopy(data, &context->buffer[usedspace], freespace);
            ADDINC128(context->bitcount, freespace << 3);
            len -= freespace;
fffa499c:	7f dc f0 50 	subf    r30,r28,r30
            data += freespace;
fffa49a0:	7f bd e2 14 	add     r29,r29,r28
            SHA512_Transform(context, (uint64_t*)context->buffer);
fffa49a4:	4b ff f8 95 	bl      fffa4238 <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

asm(".globl .L.SHA512_Update");
void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len)
{
fffa49a8:	7f dc f3 78 	mr      r28,r30
            /* Clean up: */
            usedspace = freespace = 0;
            return;
        }
    }
    while (len >= SHA512_BLOCK_LENGTH)
fffa49ac:	28 1c 00 7f 	cmplwi  r28,127
fffa49b0:	7c 9c f0 50 	subf    r4,r28,r30
fffa49b4:	7c 9d 22 14 	add     r4,r29,r4
fffa49b8:	40 81 00 40 	ble     fffa49f8 <SHA512_Update+0xe0>
    {
        /* Process as many complete blocks as we can */
        SHA512_Transform(context, (const uint64_t*)data);
fffa49bc:	7f e3 fb 78 	mr      r3,r31
fffa49c0:	4b ff f8 79 	bl      fffa4238 <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
fffa49c4:	15 1f 00 40 	lvd     d8,64(r31)
fffa49c8:	31 29 04 00 	addic   r9,r9,1024
fffa49cc:	7d 08 01 94 	addze   r8,r8
fffa49d0:	19 1f 00 40 	stvd    d8,64(r31)
fffa49d4:	06 48 00 0e 	bwnz    r8,fffa49f0 <SHA512_Update+0xd8>
fffa49d8:	28 09 03 ff 	cmplwi  r9,1023
fffa49dc:	41 81 00 14 	bgt     fffa49f0 <SHA512_Update+0xd8>
fffa49e0:	15 1f 00 48 	lvd     d8,72(r31)
fffa49e4:	31 29 00 01 	addic   r9,r9,1
fffa49e8:	7d 08 01 94 	addze   r8,r8
fffa49ec:	19 1f 00 48 	stvd    d8,72(r31)
        len -= SHA512_BLOCK_LENGTH;
fffa49f0:	3b 9c ff 80 	addi    r28,r28,-128
fffa49f4:	4b ff ff b8 	b       fffa49ac <SHA512_Update+0x94>
fffa49f8:	57 c4 00 30 	rlwinm  r4,r30,0,0,24
fffa49fc:	57 de 06 7e 	clrlwi  r30,r30,25
fffa4a00:	7c 9d 22 14 	add     r4,r29,r4
        data += SHA512_BLOCK_LENGTH;
    }
    if (len > 0)
fffa4a04:	06 de 00 20 	bwz     r30,fffa4a44 <SHA512_Update+0x12c>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fffa4a08:	38 7f 00 50 	addi    r3,r31,80
fffa4a0c:	7f c5 f3 78 	mr      r5,r30
fffa4a10:	48 00 10 65 	bl      fffa5a74 <memcpy>
    }
    if (len > 0)
    {
        /* There's left-overs, so save 'em */
        bcopy(data, context->buffer, len);
        ADDINC128(context->bitcount, len << 3);
fffa4a14:	15 1f 00 40 	lvd     d8,64(r31)
fffa4a18:	57 c7 18 38 	rlwinm  r7,r30,3,0,28
fffa4a1c:	38 c0 00 00 	li      r6,0
fffa4a20:	7d 29 38 14 	addc    r9,r9,r7
fffa4a24:	7d 08 31 14 	adde    r8,r8,r6
fffa4a28:	19 1f 00 40 	stvd    d8,64(r31)
fffa4a2c:	04 46 40 0c 	cmpwbne r6,r8,fffa4a44 <SHA512_Update+0x12c>
fffa4a30:	05 27 48 0a 	cmplwble r7,r9,fffa4a44 <SHA512_Update+0x12c>
fffa4a34:	15 1f 00 48 	lvd     d8,72(r31)
fffa4a38:	31 29 00 01 	addic   r9,r9,1
fffa4a3c:	7d 08 01 94 	addze   r8,r8
fffa4a40:	19 1f 00 48 	stvd    d8,72(r31)
    }
    /* Clean up: */
    usedspace = freespace = 0;
}
fffa4a44:	80 01 00 1c 	lwz     r0,28(r1)
fffa4a48:	17 81 00 08 	lvd     d28,8(r1)
fffa4a4c:	7c 08 03 a6 	mtlr    r0
fffa4a50:	17 c1 00 10 	lvd     d30,16(r1)
fffa4a54:	38 21 00 18 	addi    r1,r1,24
fffa4a58:	4e 80 00 20 	blr

fffa4a5c <SHA512_Final>:
    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
}

asm(".globl .L.SHA512_Final");
void SHA512_Final(SHA512_CTX* context, SHA512_t *result) {
fffa4a5c:	94 21 ff e8 	stwu    r1,-24(r1)
fffa4a60:	7c 08 02 a6 	mflr    r0
fffa4a64:	1b c1 00 10 	stvd    d30,16(r1)
fffa4a68:	1b 81 00 08 	stvd    d28,8(r1)
fffa4a6c:	90 01 00 1c 	stw     r0,28(r1)
fffa4a70:	7c 7f 1b 78 	mr      r31,r3

static void SHA512_Last(SHA512_CTX* context)
{
    unsigned int usedspace;

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fffa4a74:	15 03 00 40 	lvd     d8,64(r3)
    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
}

asm(".globl .L.SHA512_Final");
void SHA512_Final(SHA512_CTX* context, SHA512_t *result) {
fffa4a78:	7c 9d 23 78 	mr      r29,r4

static void SHA512_Last(SHA512_CTX* context)
{
    unsigned int usedspace;

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fffa4a7c:	79 08 e8 c2 	rldicl  d8,d8,61,3
fffa4a80:	55 25 06 7e 	clrlwi  r5,r9,25
fffa4a84:	3b c3 00 50 	addi    r30,r3,80
    if (usedspace > 0)
fffa4a88:	06 c5 00 36 	bwz     r5,fffa4af4 <SHA512_Final+0x98>
    {
        /* Begin padding with a 1 bit: */
        context->buffer[usedspace++] = 0x80;
fffa4a8c:	39 25 00 01 	addi    r9,r5,1

            /* And set-up for the last transform: */
            bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
        }
#else
        if (usedspace < SHA512_SHORT_BLOCK_LENGTH)
fffa4a90:	28 09 00 6f 	cmplwi  r9,111

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
    if (usedspace > 0)
    {
        /* Begin padding with a 1 bit: */
        context->buffer[usedspace++] = 0x80;
fffa4a94:	7d 43 2a 14 	add     r10,r3,r5
fffa4a98:	39 00 ff 80 	li      r8,-128
fffa4a9c:	99 0a 00 50 	stb     r8,80(r10)

            /* And set-up for the last transform: */
            bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
        }
#else
        if (usedspace < SHA512_SHORT_BLOCK_LENGTH)
fffa4aa0:	41 a1 00 18 	bgt     fffa4ab8 <SHA512_Final+0x5c>
        {
            /* Set-up for the last transform: */
            bzero(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH
                  - usedspace);
fffa4aa4:	38 65 00 51 	addi    r3,r5,81
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4aa8:	7c 7f 1a 14 	add     r3,r31,r3
fffa4aac:	38 80 00 00 	li      r4,0
fffa4ab0:	20 a5 00 6f 	subfic  r5,r5,111
fffa4ab4:	48 00 00 38 	b       fffa4aec <SHA512_Final+0x90>
            bzero(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH
                  - usedspace);
        }
        else
        {
            if (usedspace < SHA512_BLOCK_LENGTH)
fffa4ab8:	28 09 00 80 	cmplwi  r9,128
fffa4abc:	41 a2 00 18 	beq     fffa4ad4 <SHA512_Final+0x78>
            {
                bzero(&context->buffer[usedspace], SHA512_BLOCK_LENGTH
                      - usedspace);
fffa4ac0:	38 65 00 51 	addi    r3,r5,81
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4ac4:	7c 7f 1a 14 	add     r3,r31,r3
fffa4ac8:	38 80 00 00 	li      r4,0
fffa4acc:	20 a5 00 7f 	subfic  r5,r5,127
fffa4ad0:	48 00 0e d1 	bl      fffa59a0 <memset>
            {
                bzero(&context->buffer[usedspace], SHA512_BLOCK_LENGTH
                      - usedspace);
            }
            /* Do second-to-last transform: */
            SHA512_Transform(context, (uint64_t*)context->buffer);
fffa4ad4:	7f e3 fb 78 	mr      r3,r31
fffa4ad8:	7f c4 f3 78 	mr      r4,r30
fffa4adc:	4b ff f7 5d 	bl      fffa4238 <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4ae0:	7f c3 f3 78 	mr      r3,r30
fffa4ae4:	38 80 00 00 	li      r4,0
fffa4ae8:	38 a0 00 7e 	li      r5,126
fffa4aec:	48 00 0e b5 	bl      fffa59a0 <memset>
fffa4af0:	48 00 00 1c 	b       fffa4b0c <SHA512_Final+0xb0>
fffa4af4:	7f c3 f3 78 	mr      r3,r30
fffa4af8:	38 80 00 00 	li      r4,0
fffa4afc:	38 a0 00 70 	li      r5,112
fffa4b00:	48 00 0e a1 	bl      fffa59a0 <memset>
    {
        /* Prepare for final transform: */
        bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);

        /* Begin padding with a 1 bit: */
        *context->buffer = 0x80;
fffa4b04:	39 20 ff 80 	li      r9,-128
fffa4b08:	99 3f 00 50 	stb     r9,80(r31)
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
fffa4b0c:	15 1f 00 48 	lvd     d8,72(r31)
    *p2 = context->bitcount[0];

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fffa4b10:	7f e3 fb 78 	mr      r3,r31
        *context->buffer = 0x80;
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
fffa4b14:	19 1f 00 c0 	stvd    d8,192(r31)
    *p2 = context->bitcount[0];
fffa4b18:	15 1f 00 40 	lvd     d8,64(r31)

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fffa4b1c:	7f c4 f3 78 	mr      r4,r30
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
    *p2 = context->bitcount[0];
fffa4b20:	19 1f 00 c8 	stvd    d8,200(r31)

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fffa4b24:	4b ff f7 15 	bl      fffa4238 <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fffa4b28:	7f e4 fb 78 	mr      r4,r31
fffa4b2c:	7f a3 eb 78 	mr      r3,r29
fffa4b30:	38 a0 00 40 	li      r5,64
fffa4b34:	48 00 0f 41 	bl      fffa5a74 <memcpy>
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fffa4b38:	80 01 00 1c 	lwz     r0,28(r1)
fffa4b3c:	17 81 00 08 	lvd     d28,8(r1)
fffa4b40:	7c 08 03 a6 	mtlr    r0
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4b44:	7f e3 fb 78 	mr      r3,r31
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fffa4b48:	17 c1 00 10 	lvd     d30,16(r1)
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4b4c:	38 80 00 00 	li      r4,0
fffa4b50:	38 a0 00 04 	li      r5,4
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fffa4b54:	38 21 00 18 	addi    r1,r1,24
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fffa4b58:	48 00 0e 48 	b       fffa59a0 <memset>

fffa4b5c <SHA512_Hash>:
    /* Zero out state data */
    bzero(context, sizeof(context));
}

asm(".globl .L.SHA512_Hash");
void SHA512_Hash(const sha2_byte* data, size_t len, SHA512_t *result) {
fffa4b5c:	94 21 ff 18 	stwu    r1,-232(r1)
fffa4b60:	7c 08 02 a6 	mflr    r0
fffa4b64:	1b 81 00 d8 	stvd    d28,216(r1)
fffa4b68:	1b c1 00 e0 	stvd    d30,224(r1)
fffa4b6c:	7c 7d 1b 78 	mr      r29,r3
fffa4b70:	7c 9e 23 78 	mr      r30,r4
    SHA512_CTX context;

    SHA512_Init(&context);
fffa4b74:	38 61 00 08 	addi    r3,r1,8
    /* Zero out state data */
    bzero(context, sizeof(context));
}

asm(".globl .L.SHA512_Hash");
void SHA512_Hash(const sha2_byte* data, size_t len, SHA512_t *result) {
fffa4b78:	90 01 00 ec 	stw     r0,236(r1)
fffa4b7c:	7c bf 2b 78 	mr      r31,r5
    SHA512_CTX context;

    SHA512_Init(&context);
fffa4b80:	4b ff fd 3d 	bl      fffa48bc <SHA512_Init>
    SHA512_Update(&context, data, len);
fffa4b84:	38 61 00 08 	addi    r3,r1,8
fffa4b88:	7f a4 eb 78 	mr      r4,r29
fffa4b8c:	7f c5 f3 78 	mr      r5,r30
fffa4b90:	4b ff fd 89 	bl      fffa4918 <SHA512_Update>
    SHA512_Final(&context, result);
fffa4b94:	38 61 00 08 	addi    r3,r1,8
fffa4b98:	7f e4 fb 78 	mr      r4,r31
fffa4b9c:	4b ff fe c1 	bl      fffa4a5c <SHA512_Final>
}
fffa4ba0:	80 01 00 ec 	lwz     r0,236(r1)
fffa4ba4:	17 81 00 d8 	lvd     d28,216(r1)
fffa4ba8:	7c 08 03 a6 	mtlr    r0
fffa4bac:	17 c1 00 e0 	lvd     d30,224(r1)
fffa4bb0:	38 21 00 e8 	addi    r1,r1,232
fffa4bb4:	4e 80 00 20 	blr

fffa4bb8 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>:
#include "sbemtrace.H"

static const size_t TPM_MAX_SPI_TRANSMIT_SIZE = 64;

fapi2::ReturnCode tpmReadSTSRegValid(SpiControlHandle &handle, tpm_sts_reg_t & o_stsReg)
{
fffa4bb8:	94 21 ff e8 	stwu    r1,-24(r1)
fffa4bbc:	7c 08 02 a6 	mflr    r0
fffa4bc0:	1b 81 00 08 	stvd    d28,8(r1)
fffa4bc4:	90 01 00 1c 	stw     r0,28(r1)
fffa4bc8:	1b c1 00 10 	stvd    d30,16(r1)
fffa4bcc:	7c 7c 1b 78 	mr      r28,r3
fffa4bd0:	7c 9e 23 78 	mr      r30,r4
    #define SBEM_FUNC " tpmReadSTSRegValid "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t polls = 0;
fffa4bd4:	3b a0 00 00 	li      r29,0
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&o_stsReg);
fffa4bd8:	7f 83 e3 78 	mr      r3,r28
fffa4bdc:	38 80 00 00 	li      r4,0
fffa4be0:	38 a0 00 18 	li      r5,24
fffa4be4:	38 c0 00 01 	li      r6,1
fffa4be8:	7f c7 f3 78 	mr      r7,r30
fffa4bec:	48 00 20 e5 	bl      fffa6cd0 <spi_tpm_read_secure>
fffa4bf0:	7c 7f 1b 78 	mr      r31,r3
        if(rc != fapi2::FAPI2_RC_SUCCESS)
fffa4bf4:	06 c3 00 12 	bwz     r3,fffa4c18 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x60>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading status with rc 0x%08X", rc);
fffa4bf8:	3c 60 80 46 	lis     r3,-32698
fffa4bfc:	60 63 00 01 	ori     r3,r3,1
fffa4c00:	7f e5 fb 78 	mr      r5,r31
fffa4c04:	38 c0 00 00 	li      r6,0
fffa4c08:	38 e0 00 00 	li      r7,0
fffa4c0c:	39 00 00 00 	li      r8,0
fffa4c10:	4b ff ef 41 	bl      fffa3b50 <pk_trace_big>
            break;
fffa4c14:	48 00 00 5c 	b       fffa4c70 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb8>
        }
        SBEM_INFO(SBEM_FUNC "TPM status register value is 0x%02X", o_stsReg.value);
fffa4c18:	88 7e 00 00 	lbz     r3,0(r30)
fffa4c1c:	64 63 2f b9 	oris    r3,r3,12217
fffa4c20:	4b ff ba a1 	bl      fffa06c0 <pk_trace_tiny>
        if((polls > MAX_STSVALID_POLLS) && !(o_stsReg.fields.stsValid))
fffa4c24:	28 1d c3 50 	cmplwi  r29,50000
fffa4c28:	89 3e 00 00 	lbz     r9,0(r30)
fffa4c2c:	40 81 00 1c 	ble     fffa4c48 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x90>
fffa4c30:	07 09 c0 0c 	bb1wi   r9,24,fffa4c48 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x90>
        {
            SBEM_INFO(SBEM_FUNC "TPM timeout waiting for stsValid");
fffa4c34:	3c 60 d8 0a 	lis     r3,-10230
            rc = fapi2::FAPI2_RC_FALSE;
fffa4c38:	3f e0 04 00 	lis     r31,1024
            break;
        }
        SBEM_INFO(SBEM_FUNC "TPM status register value is 0x%02X", o_stsReg.value);
        if((polls > MAX_STSVALID_POLLS) && !(o_stsReg.fields.stsValid))
        {
            SBEM_INFO(SBEM_FUNC "TPM timeout waiting for stsValid");
fffa4c3c:	4b ff ba 85 	bl      fffa06c0 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fffa4c40:	63 ff 00 06 	ori     r31,r31,6
            break;
fffa4c44:	48 00 00 2c 	b       fffa4c70 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb8>
        }
        else if(!o_stsReg.fields.stsValid)
fffa4c48:	07 09 c0 10 	bb1wi   r9,24,fffa4c68 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb0>
        {
            fapi2::delay(1000, 1000);
fffa4c4c:	38 60 00 00 	li      r3,0
fffa4c50:	38 80 03 e8 	li      r4,1000
fffa4c54:	38 a0 00 00 	li      r5,0
fffa4c58:	38 c0 03 e8 	li      r6,1000
fffa4c5c:	38 e0 00 00 	li      r7,0
fffa4c60:	48 00 0b c5 	bl      fffa5824 <_ZN5fapi25delayEyyb>
            polls++;
fffa4c64:	3b bd 00 01 	addi    r29,r29,1
        }
    }while(!o_stsReg.fields.stsValid);
fffa4c68:	89 3e 00 00 	lbz     r9,0(r30)
{
    #define SBEM_FUNC " tpmReadSTSRegValid "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t polls = 0;
    do
fffa4c6c:	07 89 c7 b6 	bb0wi   r9,24,fffa4bd8 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x20>
        }
    }while(!o_stsReg.fields.stsValid);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4c70:	80 01 00 1c 	lwz     r0,28(r1)
fffa4c74:	7f e3 fb 78 	mr      r3,r31
fffa4c78:	7c 08 03 a6 	mtlr    r0
fffa4c7c:	17 81 00 08 	lvd     d28,8(r1)
fffa4c80:	17 c1 00 10 	lvd     d30,16(r1)
fffa4c84:	38 21 00 18 	addi    r1,r1,24
fffa4c88:	4e 80 00 20 	blr

fffa4c8c <_Z14tpmIsExpectingR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fffa4c8c:	94 21 ff e0 	stwu    r1,-32(r1)
fffa4c90:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsExpecting "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isExpect = false;
fffa4c94:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fffa4c98:	1b c1 00 18 	stvd    d30,24(r1)
fffa4c9c:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsExpecting "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isExpect = false;
fffa4ca0:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fffa4ca4:	7c 7f 1b 78 	mr      r31,r3
    isExpect = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fffa4ca8:	3c 60 a4 d4 	lis     r3,-23340
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fffa4cac:	7c 9e 23 78 	mr      r30,r4
    isExpect = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fffa4cb0:	4b ff ba 11 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmReadSTSRegValid(handle, status);
fffa4cb4:	7f e3 fb 78 	mr      r3,r31
fffa4cb8:	38 81 00 08 	addi    r4,r1,8
fffa4cbc:	4b ff fe fd 	bl      fffa4bb8 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fffa4cc0:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa4cc4:	06 c3 00 12 	bwz     r3,fffa4ce8 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadSTSRegValid failed while reading TPM Status register with rc 0x%08X", rc);
fffa4cc8:	3c 60 49 8b 	lis     r3,18827
fffa4ccc:	60 63 00 01 	ori     r3,r3,1
fffa4cd0:	7f e5 fb 78 	mr      r5,r31
fffa4cd4:	38 c0 00 00 	li      r6,0
fffa4cd8:	38 e0 00 00 	li      r7,0
fffa4cdc:	39 00 00 00 	li      r8,0
fffa4ce0:	4b ff ee 71 	bl      fffa3b50 <pk_trace_big>
            break;
fffa4ce4:	48 00 00 20 	b       fffa4d04 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x78>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fffa4ce8:	88 61 00 08 	lbz     r3,8(r1)
fffa4cec:	64 63 22 42 	oris    r3,r3,8770
fffa4cf0:	4b ff b9 d1 	bl      fffa06c0 <pk_trace_tiny>
        if(status.fields.expect)
fffa4cf4:	89 21 00 08 	lbz     r9,8(r1)
fffa4cf8:	07 89 e0 06 	bb0wi   r9,28,fffa4d04 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x78>
        {
            isExpect = true;
fffa4cfc:	39 20 00 01 	li      r9,1
fffa4d00:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "isExpect is %d", isExpect);
fffa4d04:	88 7e 00 00 	lbz     r3,0(r30)
fffa4d08:	64 63 35 cb 	oris    r3,r3,13771
fffa4d0c:	4b ff b9 b5 	bl      fffa06c0 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4d10:	80 01 00 24 	lwz     r0,36(r1)
fffa4d14:	7f e3 fb 78 	mr      r3,r31
fffa4d18:	7c 08 03 a6 	mtlr    r0
fffa4d1c:	17 c1 00 18 	lvd     d30,24(r1)
fffa4d20:	38 21 00 20 	addi    r1,r1,32
fffa4d24:	4e 80 00 20 	blr

fffa4d28 <_Z14tpmIsDataAvailR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fffa4d28:	94 21 ff e0 	stwu    r1,-32(r1)
fffa4d2c:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsDataAvail "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    dataAvail = false;
fffa4d30:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fffa4d34:	1b c1 00 18 	stvd    d30,24(r1)
fffa4d38:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsDataAvail "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    dataAvail = false;
fffa4d3c:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fffa4d40:	7c 7f 1b 78 	mr      r31,r3
    dataAvail = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fffa4d44:	3c 60 9e 40 	lis     r3,-25024
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fffa4d48:	7c 9e 23 78 	mr      r30,r4
    dataAvail = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fffa4d4c:	4b ff b9 75 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmReadSTSRegValid(handle, status);
fffa4d50:	7f e3 fb 78 	mr      r3,r31
fffa4d54:	38 81 00 08 	addi    r4,r1,8
fffa4d58:	4b ff fe 61 	bl      fffa4bb8 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fffa4d5c:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa4d60:	06 c3 00 12 	bwz     r3,fffa4d84 <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadSTSRegValid failed while reading TPM Status register with rc 0x%08X", rc);
fffa4d64:	3c 60 a5 3b 	lis     r3,-23237
fffa4d68:	60 63 00 01 	ori     r3,r3,1
fffa4d6c:	7f e5 fb 78 	mr      r5,r31
fffa4d70:	38 c0 00 00 	li      r6,0
fffa4d74:	38 e0 00 00 	li      r7,0
fffa4d78:	39 00 00 00 	li      r8,0
fffa4d7c:	4b ff ed d5 	bl      fffa3b50 <pk_trace_big>
            break;
fffa4d80:	48 00 00 20 	b       fffa4da0 <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x78>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fffa4d84:	88 61 00 08 	lbz     r3,8(r1)
fffa4d88:	64 63 2e 67 	oris    r3,r3,11879
fffa4d8c:	4b ff b9 35 	bl      fffa06c0 <pk_trace_tiny>
        if(status.fields.dataAvail)
fffa4d90:	89 21 00 08 	lbz     r9,8(r1)
fffa4d94:	07 89 d8 06 	bb0wi   r9,27,fffa4da0 <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x78>
        {
            dataAvail = true;
fffa4d98:	39 20 00 01 	li      r9,1
fffa4d9c:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "dataAvail is %d", dataAvail);
fffa4da0:	88 7e 00 00 	lbz     r3,0(r30)
fffa4da4:	64 63 54 39 	oris    r3,r3,21561
fffa4da8:	4b ff b9 19 	bl      fffa06c0 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4dac:	80 01 00 24 	lwz     r0,36(r1)
fffa4db0:	7f e3 fb 78 	mr      r3,r31
fffa4db4:	7c 08 03 a6 	mtlr    r0
fffa4db8:	17 c1 00 18 	lvd     d30,24(r1)
fffa4dbc:	38 21 00 20 	addi    r1,r1,32
fffa4dc0:	4e 80 00 20 	blr

fffa4dc4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fffa4dc4:	94 21 ff e0 	stwu    r1,-32(r1)
fffa4dc8:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isCmdReady = false;
fffa4dcc:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fffa4dd0:	1b c1 00 18 	stvd    d30,24(r1)
fffa4dd4:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isCmdReady = false;
fffa4dd8:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fffa4ddc:	7c 9e 23 78 	mr      r30,r4
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;

        SBEM_DEBUG(SBEM_FUNC "Read TPM Status Register.");
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&status);
fffa4de0:	38 a0 00 18 	li      r5,24
fffa4de4:	38 80 00 00 	li      r4,0
fffa4de8:	38 c0 00 01 	li      r6,1
fffa4dec:	38 e1 00 08 	addi    r7,r1,8
fffa4df0:	48 00 1e e1 	bl      fffa6cd0 <spi_tpm_read_secure>
fffa4df4:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa4df8:	06 c3 00 12 	bwz     r3,fffa4e1c <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x58>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading TPM Status register with rc 0x%08X", rc);
fffa4dfc:	3c 60 26 44 	lis     r3,9796
fffa4e00:	60 63 00 01 	ori     r3,r3,1
fffa4e04:	7f e5 fb 78 	mr      r5,r31
fffa4e08:	38 c0 00 00 	li      r6,0
fffa4e0c:	38 e0 00 00 	li      r7,0
fffa4e10:	39 00 00 00 	li      r8,0
fffa4e14:	4b ff ed 3d 	bl      fffa3b50 <pk_trace_big>
            break;
fffa4e18:	48 00 00 20 	b       fffa4e38 <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x74>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fffa4e1c:	88 61 00 08 	lbz     r3,8(r1)
fffa4e20:	64 63 d9 26 	oris    r3,r3,55590
fffa4e24:	4b ff b8 9d 	bl      fffa06c0 <pk_trace_tiny>
        if(status.fields.isCommandReady)
fffa4e28:	89 21 00 08 	lbz     r9,8(r1)
fffa4e2c:	07 89 c8 06 	bb0wi   r9,25,fffa4e38 <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x74>
        {
            isCmdReady = true;
fffa4e30:	39 20 00 01 	li      r9,1
fffa4e34:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "TPM isCommand Ready is %d", isCmdReady);
fffa4e38:	88 7e 00 00 	lbz     r3,0(r30)
fffa4e3c:	64 63 74 c5 	oris    r3,r3,29893
fffa4e40:	4b ff b8 81 	bl      fffa06c0 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4e44:	80 01 00 24 	lwz     r0,36(r1)
fffa4e48:	7f e3 fb 78 	mr      r3,r31
fffa4e4c:	7c 08 03 a6 	mtlr    r0
fffa4e50:	17 c1 00 18 	lvd     d30,24(r1)
fffa4e54:	38 21 00 20 	addi    r1,r1,32
fffa4e58:	4e 80 00 20 	blr

fffa4e5c <_Z20tpmWriteCommandReadyR16SpiControlHandle>:

fapi2::ReturnCode tpmWriteCommandReady(SpiControlHandle &handle)
{
fffa4e5c:	94 21 ff e0 	stwu    r1,-32(r1)
fffa4e60:	7c 08 02 a6 	mflr    r0
    #define SBEM_FUNC " tpmWriteCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.isCommandReady = 1;
fffa4e64:	7c 27 0b 78 	mr      r7,r1
fffa4e68:	39 20 00 40 	li      r9,64
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmWriteCommandReady(SpiControlHandle &handle)
{
fffa4e6c:	1b c1 00 18 	stvd    d30,24(r1)
fffa4e70:	90 01 00 24 	stw     r0,36(r1)
    #define SBEM_FUNC " tpmWriteCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.isCommandReady = 1;
fffa4e74:	9d 27 00 08 	stbu    r9,8(r7)
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&stsReg);
fffa4e78:	38 80 00 00 	li      r4,0
fffa4e7c:	38 a0 00 18 	li      r5,24
fffa4e80:	38 c0 00 01 	li      r6,1
fffa4e84:	48 00 21 e1 	bl      fffa7064 <spi_tpm_write_with_wait>
fffa4e88:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa4e8c:	06 c3 00 10 	bwz     r3,fffa4eac <_Z20tpmWriteCommandReadyR16SpiControlHandle+0x50>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed while setting isCommandReady bit with rc 0x%08X", rc);
fffa4e90:	3c 60 8f c5 	lis     r3,-28731
fffa4e94:	60 63 00 01 	ori     r3,r3,1
fffa4e98:	7f e5 fb 78 	mr      r5,r31
fffa4e9c:	38 c0 00 00 	li      r6,0
fffa4ea0:	38 e0 00 00 	li      r7,0
fffa4ea4:	39 00 00 00 	li      r8,0
fffa4ea8:	4b ff ec a9 	bl      fffa3b50 <pk_trace_big>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4eac:	80 01 00 24 	lwz     r0,36(r1)
fffa4eb0:	7f e3 fb 78 	mr      r3,r31
fffa4eb4:	7c 08 03 a6 	mtlr    r0
fffa4eb8:	17 c1 00 18 	lvd     d30,24(r1)
fffa4ebc:	38 21 00 20 	addi    r1,r1,32
fffa4ec0:	4e 80 00 20 	blr

fffa4ec4 <_Z22tpmPollForCommandReadyR16SpiControlHandle>:

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fffa4ec4:	94 21 ff d0 	stwu    r1,-48(r1)
fffa4ec8:	7c 08 02 a6 	mflr    r0
fffa4ecc:	1b c1 00 28 	stvd    d30,40(r1)
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fffa4ed0:	39 20 00 00 	li      r9,0
fffa4ed4:	7c 3e 0b 78 	mr      r30,r1
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fffa4ed8:	1b 81 00 20 	stvd    d28,32(r1)
fffa4edc:	90 01 00 34 	stw     r0,52(r1)
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fffa4ee0:	3f 80 00 1e 	lis     r28,30
fffa4ee4:	9d 3e 00 08 	stbu    r9,8(r30)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fffa4ee8:	7c 7d 1b 78 	mr      r29,r3
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fffa4eec:	63 9c 84 80 	ori     r28,r28,33920
    do
    {
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
        {
            rc = tpmIsCommandReady(handle, isCommandReady);
fffa4ef0:	7f a3 eb 78 	mr      r3,r29
fffa4ef4:	7f c4 f3 78 	mr      r4,r30
fffa4ef8:	4b ff fe cd 	bl      fffa4dc4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fffa4efc:	7c 69 1b 78 	mr      r9,r3
fffa4f00:	7c 7f 1b 78 	mr      r31,r3
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
fffa4f04:	06 43 00 06 	bwnz    r3,fffa4f10 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x4c>
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (isCommandReady)) )
fffa4f08:	89 41 00 08 	lbz     r10,8(r1)
fffa4f0c:	06 ca 00 56 	bwz     r10,fffa4fb8 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xf4>
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady either failed while reading TPM Status register with rc 0x%08X or cmdReady %d",
                                     rc, status.fields.isCommandReady);
fffa4f10:	3c 60 8f 9b 	lis     r3,-28773
fffa4f14:	7d 25 4b 78 	mr      r5,r9
fffa4f18:	60 63 00 02 	ori     r3,r3,2
fffa4f1c:	38 c0 00 00 	li      r6,0
fffa4f20:	38 e0 00 00 	li      r7,0
fffa4f24:	39 00 00 00 	li      r8,0
fffa4f28:	91 21 00 18 	stw     r9,24(r1)
fffa4f2c:	4b ff ec 25 	bl      fffa3b50 <pk_trace_big>
                break;
            }
            fapi2::delay(1000, 1000);
        }

        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.isCommandReady))
fffa4f30:	81 21 00 18 	lwz     r9,24(r1)
fffa4f34:	06 49 00 5e 	bwnz    r9,fffa4ff0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
        {
            SBE_INFO(SBE_FUNC "isCommandReady Bit is not set. Set and poll");
fffa4f38:	3c 60 f0 6e 	lis     r3,-3986
fffa4f3c:	4b ff b7 85 	bl      fffa06c0 <pk_trace_tiny>
            // The first write to command ready may have just aborted
            // an outstanding command, we will write it again and poll once
            // more
            rc = tpmWriteCommandReady(handle);
fffa4f40:	7f a3 eb 78 	mr      r3,r29
fffa4f44:	4b ff ff 19 	bl      fffa4e5c <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fffa4f48:	3f 80 00 1e 	lis     r28,30
fffa4f4c:	7c 7f 1b 78 	mr      r31,r3
fffa4f50:	63 9c 84 80 	ori     r28,r28,33920
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa4f54:	06 c3 00 26 	bwz     r3,fffa4fa0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xdc>
            {
                SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
fffa4f58:	3c 60 a7 16 	lis     r3,-22762
fffa4f5c:	60 63 00 01 	ori     r3,r3,1
fffa4f60:	7f e5 fb 78 	mr      r5,r31
fffa4f64:	38 c0 00 00 	li      r6,0
fffa4f68:	38 e0 00 00 	li      r7,0
fffa4f6c:	39 00 00 00 	li      r8,0
fffa4f70:	4b ff eb e1 	bl      fffa3b50 <pk_trace_big>
                break;
fffa4f74:	48 00 00 7c 	b       fffa4ff0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
                // Operation TIMEOUT_B defined by TCG spec for command ready
                for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
                {
                    rc = tpmIsCommandReady(handle, isCommandReady);
                    if((rc != fapi2::FAPI2_RC_SUCCESS) ||
                       ((rc == fapi2::FAPI2_RC_SUCCESS) && (isCommandReady)))
fffa4f78:	89 21 00 08 	lbz     r9,8(r1)
fffa4f7c:	06 49 00 30 	bwnz    r9,fffa4fdc <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x118>
                    {
                        break;
                    }
                    fapi2::delay(1000, 1000);
fffa4f80:	38 60 00 00 	li      r3,0
fffa4f84:	38 80 03 e8 	li      r4,1000
fffa4f88:	38 a0 00 00 	li      r5,0
fffa4f8c:	38 c0 03 e8 	li      r6,1000
fffa4f90:	38 e0 00 00 	li      r7,0
fffa4f94:	48 00 08 91 	bl      fffa5824 <_ZN5fapi25delayEyyb>
            }
            else
            {
                // Ok, poll again
                // Operation TIMEOUT_B defined by TCG spec for command ready
                for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fffa4f98:	37 9c ff ff 	addic.  r28,r28,-1
fffa4f9c:	41 82 00 40 	beq     fffa4fdc <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x118>
                {
                    rc = tpmIsCommandReady(handle, isCommandReady);
fffa4fa0:	7f a3 eb 78 	mr      r3,r29
fffa4fa4:	7f c4 f3 78 	mr      r4,r30
fffa4fa8:	4b ff fe 1d 	bl      fffa4dc4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fffa4fac:	7c 7f 1b 78 	mr      r31,r3
                    if((rc != fapi2::FAPI2_RC_SUCCESS) ||
fffa4fb0:	06 c3 07 e4 	bwz     r3,fffa4f78 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xb4>
fffa4fb4:	48 00 00 3c 	b       fffa4ff0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady either failed while reading TPM Status register with rc 0x%08X or cmdReady %d",
                                     rc, status.fields.isCommandReady);
                break;
            }
            fapi2::delay(1000, 1000);
fffa4fb8:	38 60 00 00 	li      r3,0
fffa4fbc:	38 80 03 e8 	li      r4,1000
fffa4fc0:	38 a0 00 00 	li      r5,0
fffa4fc4:	38 c0 03 e8 	li      r6,1000
fffa4fc8:	38 e0 00 00 	li      r7,0
fffa4fcc:	48 00 08 59 	bl      fffa5824 <_ZN5fapi25delayEyyb>
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
    do
    {
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fffa4fd0:	37 9c ff ff 	addic.  r28,r28,-1
fffa4fd4:	40 82 ff 1c 	bne     fffa4ef0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x2c>
fffa4fd8:	4b ff ff 60 	b       fffa4f38 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x74>
                    }
                    fapi2::delay(1000, 1000);
                }
            }
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!isCommandReady))
fffa4fdc:	89 21 00 08 	lbz     r9,8(r1)
fffa4fe0:	3b e0 00 00 	li      r31,0
fffa4fe4:	06 49 00 06 	bwnz    r9,fffa4ff0 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
        {
            rc = fapi2::FAPI2_RC_FALSE;
fffa4fe8:	3f e0 04 00 	lis     r31,1024
fffa4fec:	63 ff 00 06 	ori     r31,r31,6

    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa4ff0:	80 01 00 34 	lwz     r0,52(r1)
fffa4ff4:	7f e3 fb 78 	mr      r3,r31
fffa4ff8:	7c 08 03 a6 	mtlr    r0
fffa4ffc:	17 81 00 20 	lvd     d28,32(r1)
fffa5000:	17 c1 00 28 	lvd     d30,40(r1)
fffa5004:	38 21 00 30 	addi    r1,r1,48
fffa5008:	4e 80 00 20 	blr

fffa500c <_Z17tpmReadBurstCountR16SpiControlHandleRt>:

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fffa500c:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5010:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
fffa5014:	7c 27 0b 78 	mr      r7,r1
fffa5018:	39 20 00 00 	li      r9,0
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fffa501c:	1b c1 00 18 	stvd    d30,24(r1)
fffa5020:	90 01 00 24 	stw     r0,36(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
fffa5024:	b5 27 00 08 	sthu    r9,8(r7)
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fffa5028:	7c 9e 23 78 	mr      r30,r4
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
        uint32_t readBytes = 2;
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&value);
fffa502c:	38 a0 00 19 	li      r5,25
fffa5030:	38 80 00 00 	li      r4,0
fffa5034:	38 c0 00 02 	li      r6,2
fffa5038:	48 00 1c 99 	bl      fffa6cd0 <spi_tpm_read_secure>
fffa503c:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5040:	06 c3 00 12 	bwz     r3,fffa5064 <_Z17tpmReadBurstCountR16SpiControlHandleRt+0x58>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading burst count with rc 0x%08X", rc);
fffa5044:	3c 60 b1 f6 	lis     r3,-19978
fffa5048:	60 63 00 01 	ori     r3,r3,1
fffa504c:	7f e5 fb 78 	mr      r5,r31
fffa5050:	38 c0 00 00 	li      r6,0
fffa5054:	38 e0 00 00 	li      r7,0
fffa5058:	39 00 00 00 	li      r8,0
fffa505c:	4b ff ea f5 	bl      fffa3b50 <pk_trace_big>
fffa5060:	48 00 00 18 	b       fffa5078 <_Z17tpmReadBurstCountR16SpiControlHandleRt+0x6c>
            break;
        }
        uint8_t lowByte = (value & 0x00FF);
fffa5064:	a1 21 00 08 	lhz     r9,8(r1)
        uint8_t highByte = (value & 0xFF00) >> 8;
        o_burstCount = (lowByte << 8) | highByte;
fffa5068:	55 2a 44 2e 	rlwinm  r10,r9,8,16,23
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading burst count with rc 0x%08X", rc);
            break;
        }
        uint8_t lowByte = (value & 0x00FF);
        uint8_t highByte = (value & 0xFF00) >> 8;
fffa506c:	55 29 c2 3e 	rlwinm  r9,r9,24,8,31
        o_burstCount = (lowByte << 8) | highByte;
fffa5070:	7d 49 4b 78 	or      r9,r10,r9
fffa5074:	b1 3e 00 00 	sth     r9,0(r30)
    }while(0);
    SBEM_DEBUG(SBEM_FUNC "Burst count is 0x%04X", o_burstCount);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa5078:	80 01 00 24 	lwz     r0,36(r1)
fffa507c:	7f e3 fb 78 	mr      r3,r31
fffa5080:	7c 08 03 a6 	mtlr    r0
fffa5084:	17 c1 00 18 	lvd     d30,24(r1)
fffa5088:	38 21 00 20 	addi    r1,r1,32
fffa508c:	4e 80 00 20 	blr

fffa5090 <_Z13tpmWriteTpmGoR16SpiControlHandle>:

fapi2::ReturnCode tpmWriteTpmGo(SpiControlHandle &handle)
{
fffa5090:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5094:	7c 08 02 a6 	mflr    r0
    #define SBEM_FUNC " tpmWriteTpmGo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.tpmGo = 1;
fffa5098:	7c 27 0b 78 	mr      r7,r1
fffa509c:	39 20 00 20 	li      r9,32
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmWriteTpmGo(SpiControlHandle &handle)
{
fffa50a0:	1b c1 00 18 	stvd    d30,24(r1)
fffa50a4:	90 01 00 24 	stw     r0,36(r1)
    #define SBEM_FUNC " tpmWriteTpmGo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.tpmGo = 1;
fffa50a8:	9d 27 00 08 	stbu    r9,8(r7)
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&stsReg);
fffa50ac:	38 80 00 00 	li      r4,0
fffa50b0:	38 a0 00 18 	li      r5,24
fffa50b4:	38 c0 00 01 	li      r6,1
fffa50b8:	48 00 1f ad 	bl      fffa7064 <spi_tpm_write_with_wait>
fffa50bc:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa50c0:	06 c3 00 10 	bwz     r3,fffa50e0 <_Z13tpmWriteTpmGoR16SpiControlHandle+0x50>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed while setting tpmGo bit with rc 0x%08X", rc);
fffa50c4:	3c 60 b2 5f 	lis     r3,-19873
fffa50c8:	60 63 00 01 	ori     r3,r3,1
fffa50cc:	7f e5 fb 78 	mr      r5,r31
fffa50d0:	38 c0 00 00 	li      r6,0
fffa50d4:	38 e0 00 00 	li      r7,0
fffa50d8:	39 00 00 00 	li      r8,0
fffa50dc:	4b ff ea 75 	bl      fffa3b50 <pk_trace_big>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa50e0:	80 01 00 24 	lwz     r0,36(r1)
fffa50e4:	7f e3 fb 78 	mr      r3,r31
fffa50e8:	7c 08 03 a6 	mtlr    r0
fffa50ec:	17 c1 00 18 	lvd     d30,24(r1)
fffa50f0:	38 21 00 20 	addi    r1,r1,32
fffa50f4:	4e 80 00 20 	blr

fffa50f8 <_Z19tpmPollForDataAvailR16SpiControlHandle>:

fapi2::ReturnCode tpmPollForDataAvail(SpiControlHandle &handle)
{
fffa50f8:	94 21 ff d8 	stwu    r1,-40(r1)
fffa50fc:	7c 08 02 a6 	mflr    r0
fffa5100:	1b 81 00 18 	stvd    d28,24(r1)
fffa5104:	90 01 00 2c 	stw     r0,44(r1)
fffa5108:	3f a0 00 1e 	lis     r29,30
fffa510c:	1b c1 00 20 	stvd    d30,32(r1)
fffa5110:	7c 7c 1b 78 	mr      r28,r3
fffa5114:	63 bd 84 80 	ori     r29,r29,33920
    {
        // Use the longer timeout B here since some of the TPM commands may take
        // more than timeout A to complete
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
        {
            rc = tpmReadSTSRegValid(handle, status);
fffa5118:	7f 83 e3 78 	mr      r3,r28
fffa511c:	38 81 00 08 	addi    r4,r1,8
fffa5120:	4b ff fa 99 	bl      fffa4bb8 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fffa5124:	7c 7f 1b 78 	mr      r31,r3
fffa5128:	7c 7e 1b 78 	mr      r30,r3
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
fffa512c:	06 43 00 26 	bwnz    r3,fffa5178 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x80>
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (status.fields.dataAvail)))
fffa5130:	89 21 00 08 	lbz     r9,8(r1)
fffa5134:	07 09 d8 22 	bb1wi   r9,27,fffa5178 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x80>
            if((rc == fapi2::FAPI2_RC_FALSE))
            {
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
fffa5138:	38 60 00 00 	li      r3,0
fffa513c:	38 80 03 e8 	li      r4,1000
fffa5140:	38 a0 00 00 	li      r5,0
fffa5144:	38 c0 03 e8 	li      r6,1000
fffa5148:	38 e0 00 00 	li      r7,0
fffa514c:	48 00 06 d9 	bl      fffa5824 <_ZN5fapi25delayEyyb>
    tpm_sts_reg_t status;
    do
    {
        // Use the longer timeout B here since some of the TPM commands may take
        // more than timeout A to complete
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fffa5150:	37 bd ff ff 	addic.  r29,r29,-1
fffa5154:	40 82 ff c4 	bne     fffa5118 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x20>
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
fffa5158:	89 21 00 08 	lbz     r9,8(r1)
fffa515c:	3b c0 00 00 	li      r30,0
fffa5160:	07 09 d8 1e 	bb1wi   r9,27,fffa519c <_Z19tpmPollForDataAvailR16SpiControlHandle+0xa4>
        {
            SBEM_ERROR(SBEM_FUNC "Timeout polling for dataAvail!");
fffa5164:	3c 60 fd 9a 	lis     r3,-614
            rc = fapi2::FAPI2_RC_FALSE;
fffa5168:	3f c0 04 00 	lis     r30,1024
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
        {
            SBEM_ERROR(SBEM_FUNC "Timeout polling for dataAvail!");
fffa516c:	4b ff b5 55 	bl      fffa06c0 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fffa5170:	63 de 00 06 	ori     r30,r30,6
fffa5174:	48 00 00 28 	b       fffa519c <_Z19tpmPollForDataAvailR16SpiControlHandle+0xa4>
        {
            rc = tpmReadSTSRegValid(handle, status);
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (status.fields.dataAvail)))
            {
                SBEM_ERROR(SBEM_FUNC "Either tpmReadSTSRegValid failed while with rc 0x%08X or data is available %d", rc, status.fields.dataAvail);
fffa5178:	80 c1 00 08 	lwz     r6,8(r1)
fffa517c:	3c 60 ef b0 	lis     r3,-4176
fffa5180:	60 63 00 02 	ori     r3,r3,2
fffa5184:	7f e5 fb 78 	mr      r5,r31
fffa5188:	54 c6 27 fe 	rlwinm  r6,r6,4,31,31
fffa518c:	38 e0 00 00 	li      r7,0
fffa5190:	39 00 00 00 	li      r8,0
fffa5194:	4b ff e9 bd 	bl      fffa3b50 <pk_trace_big>
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
fffa5198:	06 df 07 e0 	bwz     r31,fffa5158 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x60>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa519c:	80 01 00 2c 	lwz     r0,44(r1)
fffa51a0:	7f c3 f3 78 	mr      r3,r30
fffa51a4:	7c 08 03 a6 	mtlr    r0
fffa51a8:	17 81 00 18 	lvd     d28,24(r1)
fffa51ac:	17 c1 00 20 	lvd     d30,32(r1)
fffa51b0:	38 21 00 28 	addi    r1,r1,40
fffa51b4:	4e 80 00 20 	blr

fffa51b8 <_Z11tpmReadFifoR16SpiControlHandlePvRm>:

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fffa51b8:	94 21 ff c0 	stwu    r1,-64(r1)
fffa51bc:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fffa51c0:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fffa51c4:	1b 81 00 30 	stvd    d28,48(r1)
fffa51c8:	90 01 00 44 	stw     r0,68(r1)
fffa51cc:	1b c1 00 38 	stvd    d30,56(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fffa51d0:	b1 21 00 08 	sth     r9,8(r1)
    bool dataAvail = false;
fffa51d4:	99 21 00 0a 	stb     r9,10(r1)
    bool firstRead = true;
fffa51d8:	39 40 00 01 	li      r10,1
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
fffa51dc:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fffa51e0:	90 61 00 1c 	stw     r3,28(r1)
fffa51e4:	90 81 00 2c 	stw     r4,44(r1)
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
fffa51e8:	83 a5 00 00 	lwz     r29,0(r5)
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
fffa51ec:	91 21 00 18 	stw     r9,24(r1)
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
fffa51f0:	19 21 00 20 	stvd    d9,32(r1)
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fffa51f4:	7c bc 2b 78 	mr      r28,r5
    #define SBEM_FUNC " tpmReadFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
fffa51f8:	3b c0 00 00 	li      r30,0
        // all command responses are at least 10 bytes of data
        // 2 byte tag + 4 byte response size + 4 byte response code
        const uint32_t MIN_COMMAND_RESPONSE_SIZE = 10;

        // Verify the TPM has data waiting for us
        rc = tpmPollForDataAvail(handle);
fffa51fc:	80 61 00 1c 	lwz     r3,28(r1)
fffa5200:	4b ff fe f9 	bl      fffa50f8 <_Z19tpmPollForDataAvailR16SpiControlHandle>
fffa5204:	7c 7f 1b 78 	mr      r31,r3
        if(rc != fapi2::FAPI2_RC_SUCCESS)
fffa5208:	06 c3 00 06 	bwz     r3,fffa5214 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmPollForDataAvail failed with rc 0x%08X", rc);
fffa520c:	3c 60 be 2a 	lis     r3,-16854
fffa5210:	48 00 00 d4 	b       fffa52e4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x12c>
            break;
        }

        // Read burst count.
        rc = tpmReadBurstCount(handle, burstCount);
fffa5214:	80 61 00 1c 	lwz     r3,28(r1)
fffa5218:	38 81 00 08 	addi    r4,r1,8
fffa521c:	4b ff fd f1 	bl      fffa500c <_Z17tpmReadBurstCountR16SpiControlHandleRt>
        if(rc != fapi2::FAPI2_RC_SUCCESS )
fffa5220:	06 c3 00 08 	bwz     r3,fffa5230 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x78>
fffa5224:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
fffa5228:	3c 60 06 7a 	lis     r3,1658
fffa522c:	48 00 00 b8 	b       fffa52e4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x12c>
            break;
        }
        else if(burstCount == 0)
fffa5230:	a3 e1 00 08 	lhz     r31,8(r1)
fffa5234:	06 5f 00 20 	bwnz    r31,fffa5274 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xbc>
        {
            fapi2::delay(1000, 1000);
fffa5238:	38 60 00 00 	li      r3,0
fffa523c:	38 80 03 e8 	li      r4,1000
fffa5240:	38 a0 00 00 	li      r5,0
fffa5244:	38 c0 03 e8 	li      r6,1000
fffa5248:	38 e0 00 00 	li      r7,0
fffa524c:	48 00 05 d9 	bl      fffa5824 <_ZN5fapi25delayEyyb>
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
    do
fffa5250:	3d 20 00 0b 	lis     r9,11
            break;
        }
        else if(burstCount == 0)
        {
            fapi2::delay(1000, 1000);
            delay ++;
fffa5254:	3b de 00 01 	addi    r30,r30,1
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
    do
fffa5258:	61 29 71 af 	ori     r9,r9,29103
fffa525c:	05 3e 4f d0 	cmplwble r30,r9,fffa51fc <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x44>
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
        {
            SBEM_INFO(SBEM_FUNC "tpmReadFifo: timeout");
fffa5260:	3c 60 14 b0 	lis     r3,5296
            rc = fapi2::FAPI2_RC_FALSE;
fffa5264:	3f e0 04 00 	lis     r31,1024
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
        {
            SBEM_INFO(SBEM_FUNC "tpmReadFifo: timeout");
fffa5268:	4b ff b4 59 	bl      fffa06c0 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fffa526c:	63 ff 00 06 	ori     r31,r31,6
            break;
fffa5270:	48 00 01 a8 	b       fffa5418 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
            fapi2::delay(1000, 1000);
            delay ++;
            continue;
        }
        // Read some data.
        if (firstRead)
fffa5274:	81 41 00 24 	lwz     r10,36(r1)
fffa5278:	06 4a 00 08 	bwnz    r10,fffa5288 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd0>
        {
            dataLen = MIN_COMMAND_RESPONSE_SIZE;
        }
        else if (burstCount < dataLeft)
fffa527c:	05 9f e8 08 	cmplwblt r31,r29,fffa528c <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd4>
        {
            dataLen = burstCount;
        }
        else
        {
            dataLen = dataLeft;
fffa5280:	57 bf 04 3e 	clrlwi  r31,r29,16
fffa5284:	48 00 00 08 	b       fffa528c <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd4>
            continue;
        }
        // Read some data.
        if (firstRead)
        {
            dataLen = MIN_COMMAND_RESPONSE_SIZE;
fffa5288:	3b e0 00 0a 	li      r31,10
        else
        {
            dataLen = dataLeft;
        }
        // Check for a buffer overflow
        if (curByte + dataLen > io_buflen)
fffa528c:	81 21 00 20 	lwz     r9,32(r1)
fffa5290:	81 5c 00 00 	lwz     r10,0(r28)
fffa5294:	7d 3f 4a 14 	add     r9,r31,r9
fffa5298:	91 21 00 28 	stw     r9,40(r1)
fffa529c:	05 29 50 08 	cmplwble r9,r10,fffa52ac <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xf4>
        {
            // TPM is expecting more data even though we think we are done
            SBEM_INFO(SBEM_FUNC "TPM is expecting more data even though we think we are done");
fffa52a0:	3c 60 68 9e 	lis     r3,26782
fffa52a4:	4b ff b4 1d 	bl      fffa06c0 <pk_trace_tiny>
fffa52a8:	48 00 01 1c 	b       fffa53c4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x20c>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }

        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fffa52ac:	81 41 00 2c 	lwz     r10,44(r1)
fffa52b0:	81 21 00 20 	lwz     r9,32(r1)
        SBEM_INFO(SBEM_FUNC " Read %d byte from FIFO", dataLen);
fffa52b4:	67 e3 74 49 	oris    r3,r31,29769
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }

        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fffa52b8:	7f ca 4a 14 	add     r30,r10,r9
        SBEM_INFO(SBEM_FUNC " Read %d byte from FIFO", dataLen);
fffa52bc:	4b ff b4 05 	bl      fffa06c0 <pk_trace_tiny>
        uint32_t tpmLocality = 0;               // TPM locality (0-4)
        uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, dataLen, curBytePtr);
fffa52c0:	80 61 00 1c 	lwz     r3,28(r1)
fffa52c4:	38 80 00 00 	li      r4,0
fffa52c8:	38 a0 00 24 	li      r5,36
fffa52cc:	57 e6 06 3e 	clrlwi  r6,r31,24
fffa52d0:	7f c7 f3 78 	mr      r7,r30
fffa52d4:	48 00 19 fd 	bl      fffa6cd0 <spi_tpm_read_secure>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa52d8:	06 c3 00 14 	bwz     r3,fffa5300 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x148>
fffa52dc:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading data from FIFO with rc 0x%08X", rc);
fffa52e0:	3c 60 09 94 	lis     r3,2452
fffa52e4:	60 63 00 01 	ori     r3,r3,1
fffa52e8:	7f e5 fb 78 	mr      r5,r31
fffa52ec:	38 c0 00 00 	li      r6,0
fffa52f0:	38 e0 00 00 	li      r7,0
fffa52f4:	39 00 00 00 	li      r8,0
fffa52f8:	4b ff e8 59 	bl      fffa3b50 <pk_trace_big>
            break;
fffa52fc:	48 00 00 d0 	b       fffa53cc <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x214>
        }
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
fffa5300:	67 e3 90 17 	oris    r3,r31,36887
fffa5304:	4b ff b3 bd 	bl      fffa06c0 <pk_trace_tiny>
        if (firstRead)
fffa5308:	81 41 00 24 	lwz     r10,36(r1)
fffa530c:	06 ca 00 3a 	bwz     r10,fffa5380 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x1c8>
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
fffa5310:	3d 20 ff fa 	lis     r9,-6
fffa5314:	80 a9 75 e0 	lwz     r5,30176(r9)
fffa5318:	3c 60 f2 c2 	lis     r3,-3390
fffa531c:	60 63 00 01 	ori     r3,r3,1
fffa5320:	38 c0 00 00 	li      r6,0
fffa5324:	38 e0 00 00 	li      r7,0
fffa5328:	39 00 00 00 	li      r8,0
fffa532c:	4b ff e8 25 	bl      fffa3b50 <pk_trace_big>
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fffa5330:	89 5e 00 02 	lbz     r10,2(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fffa5334:	3c 60 f2 c2 	lis     r3,-3390
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fffa5338:	55 48 c0 0e 	rlwinm  r8,r10,24,0,7
fffa533c:	89 5e 00 03 	lbz     r10,3(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fffa5340:	60 63 00 02 	ori     r3,r3,2
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fffa5344:	55 4a 80 1e 	rlwinm  r10,r10,16,0,15
fffa5348:	7d 0a 53 78 	or      r10,r8,r10
fffa534c:	89 1e 00 05 	lbz     r8,5(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fffa5350:	38 e0 00 00 	li      r7,0
fffa5354:	7d 4a 43 78 	or      r10,r10,r8
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fffa5358:	89 1e 00 04 	lbz     r8,4(r30)
fffa535c:	55 08 40 2e 	rlwinm  r8,r8,8,0,23
fffa5360:	7d 48 43 78 	or      r8,r10,r8
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fffa5364:	3d 40 ff fa 	lis     r10,-6
fffa5368:	80 aa 75 e4 	lwz     r5,30180(r10)
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fffa536c:	91 01 00 18 	stw     r8,24(r1)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fffa5370:	7d 06 43 78 	mr      r6,r8
fffa5374:	39 00 00 00 	li      r8,0
fffa5378:	4b ff e7 d9 	bl      fffa3b50 <pk_trace_big>
            dataLeft = responseSize;
fffa537c:	83 a1 00 18 	lwz     r29,24(r1)
            firstRead = false;
        }
        curByte += dataLen;
        dataLeft -= dataLen;

        rc = tpmIsDataAvail(handle, dataAvail);
fffa5380:	80 61 00 1c 	lwz     r3,28(r1)
fffa5384:	38 81 00 0a 	addi    r4,r1,10
fffa5388:	4b ff f9 a1 	bl      fffa4d28 <_Z14tpmIsDataAvailR16SpiControlHandleRb>
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
            dataLeft = responseSize;
            firstRead = false;
        }
        curByte += dataLen;
        dataLeft -= dataLen;
fffa538c:	7f bf e8 50 	subf    r29,r31,r29
fffa5390:	88 c1 00 0a 	lbz     r6,10(r1)

        rc = tpmIsDataAvail(handle, dataAvail);
fffa5394:	7c 7f 1b 78 	mr      r31,r3
        if((rc != fapi2::FAPI2_RC_SUCCESS) || ((rc == fapi2::FAPI2_RC_SUCCESS) && (!dataAvail)) )
fffa5398:	06 43 00 20 	bwnz    r3,fffa53d8 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x220>
fffa539c:	54 ca 06 3e 	clrlwi  r10,r6,24
fffa53a0:	06 ca 00 1c 	bwz     r10,fffa53d8 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x220>
        {
            SBEM_ERROR(SBEM_FUNC "Either tpmIsDataAvail failed with rc 0x%08X or dataAvail is %d", rc, dataAvail);
            break;
        }
        if ((dataLeft == 0) && dataAvail)
fffa53a4:	06 5d 00 30 	bwnz    r29,fffa5404 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x24c>
        {
            // Either the available STS is wrong or
            // responseSize in firstRead response was wrong
            SBEM_INFO(SBEM_FUNC "data should not be available anymore"
fffa53a8:	3c 60 14 81 	lis     r3,5249
fffa53ac:	80 a1 00 18 	lwz     r5,24(r1)
fffa53b0:	60 63 00 01 	ori     r3,r3,1
fffa53b4:	38 c0 00 00 	li      r6,0
fffa53b8:	38 e0 00 00 	li      r7,0
fffa53bc:	39 00 00 00 	li      r8,0
fffa53c0:	4b ff e7 91 	bl      fffa3b50 <pk_trace_big>
                                " (response size in response: 0x%04X)", responseSize);
            rc = fapi2::FAPI2_RC_FALSE;
fffa53c4:	3f e0 04 00 	lis     r31,1024
fffa53c8:	63 ff 00 06 	ori     r31,r31,6
            // We read it properly tell the caller the result length
            io_buflen = curByte;
        }
        else
        {
            io_buflen = 0;
fffa53cc:	39 40 00 00 	li      r10,0
fffa53d0:	91 5c 00 00 	stw     r10,0(r28)
fffa53d4:	48 00 00 44 	b       fffa5418 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
        dataLeft -= dataLen;

        rc = tpmIsDataAvail(handle, dataAvail);
        if((rc != fapi2::FAPI2_RC_SUCCESS) || ((rc == fapi2::FAPI2_RC_SUCCESS) && (!dataAvail)) )
        {
            SBEM_ERROR(SBEM_FUNC "Either tpmIsDataAvail failed with rc 0x%08X or dataAvail is %d", rc, dataAvail);
fffa53d8:	3c 60 9d 05 	lis     r3,-25339
fffa53dc:	60 63 00 02 	ori     r3,r3,2
fffa53e0:	7f e5 fb 78 	mr      r5,r31
fffa53e4:	54 c6 06 3e 	clrlwi  r6,r6,24
fffa53e8:	38 e0 00 00 	li      r7,0
fffa53ec:	39 00 00 00 	li      r8,0
fffa53f0:	4b ff e7 61 	bl      fffa3b50 <pk_trace_big>
            break;
        }
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
fffa53f4:	06 5f 07 ec 	bwnz    r31,fffa53cc <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x214>
            break;
        }
        if (rc == fapi2::FAPI2_RC_SUCCESS)
        {
            // We read it properly tell the caller the result length
            io_buflen = curByte;
fffa53f8:	81 21 00 28 	lwz     r9,40(r1)
fffa53fc:	91 3c 00 00 	stw     r9,0(r28)
fffa5400:	48 00 00 18 	b       fffa5418 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
fffa5404:	81 41 00 28 	lwz     r10,40(r1)
fffa5408:	39 20 00 00 	li      r9,0
fffa540c:	91 41 00 20 	stw     r10,32(r1)
fffa5410:	91 21 00 24 	stw     r9,36(r1)
fffa5414:	4b ff fd e4 	b       fffa51f8 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x40>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa5418:	80 01 00 44 	lwz     r0,68(r1)
fffa541c:	7f e3 fb 78 	mr      r3,r31
fffa5420:	7c 08 03 a6 	mtlr    r0
fffa5424:	17 81 00 30 	lvd     d28,48(r1)
fffa5428:	17 c1 00 38 	lvd     d30,56(r1)
fffa542c:	38 21 00 40 	addi    r1,r1,64
fffa5430:	4e 80 00 20 	blr

fffa5434 <_Z12tpmWriteFifoR16SpiControlHandlePvm>:

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fffa5434:	94 21 ff d0 	stwu    r1,-48(r1)
fffa5438:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fffa543c:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fffa5440:	90 01 00 34 	stw     r0,52(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fffa5444:	b1 21 00 08 	sth     r9,8(r1)
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
fffa5448:	99 21 00 0a 	stb     r9,10(r1)
}

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fffa544c:	1b 81 00 20 	stvd    d28,32(r1)
fffa5450:	1b c1 00 28 	stvd    d30,40(r1)
fffa5454:	7c 7d 1b 78 	mr      r29,r3
fffa5458:	7c 9f 23 78 	mr      r31,r4
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
fffa545c:	3b 85 ff ff 	addi    r28,r5,-1
{
    #define SBEM_FUNC " tpmWriteFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
fffa5460:	3b c0 00 00 	li      r30,0
                               uint32_t i_buflen)
{
    #define SBEM_FUNC " tpmWriteFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
fffa5464:	39 20 00 00 	li      r9,0
    uint32_t tx_len = 0;
    bool expect = false;
    do
    {
        // Read burst count.
        rc = tpmReadBurstCount(handle, burstCount);
fffa5468:	7f a3 eb 78 	mr      r3,r29
fffa546c:	38 81 00 08 	addi    r4,r1,8
fffa5470:	91 21 00 1c 	stw     r9,28(r1)
fffa5474:	4b ff fb 99 	bl      fffa500c <_Z17tpmReadBurstCountR16SpiControlHandleRt>
        if(rc != fapi2::FAPI2_RC_SUCCESS )
fffa5478:	81 21 00 1c 	lwz     r9,28(r1)
fffa547c:	06 43 00 a6 	bwnz    r3,fffa55c8 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x194>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
            break;
        }
        else if(burstCount == 0)
fffa5480:	a1 41 00 08 	lhz     r10,8(r1)
fffa5484:	06 4a 00 1c 	bwnz    r10,fffa54bc <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x88>
        {
            fapi2::delay(1000, 1000);
fffa5488:	38 60 00 00 	li      r3,0
fffa548c:	38 80 03 e8 	li      r4,1000
fffa5490:	38 a0 00 00 	li      r5,0
fffa5494:	38 c0 03 e8 	li      r6,1000
fffa5498:	38 e0 00 00 	li      r7,0
fffa549c:	91 21 00 1c 	stw     r9,28(r1)
fffa54a0:	48 00 03 85 	bl      fffa5824 <_ZN5fapi25delayEyyb>
            delay ++;
fffa54a4:	81 21 00 1c 	lwz     r9,28(r1)
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
    do
fffa54a8:	3d 40 00 0b 	lis     r10,11
            break;
        }
        else if(burstCount == 0)
        {
            fapi2::delay(1000, 1000);
            delay ++;
fffa54ac:	39 29 00 01 	addi    r9,r9,1
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
    do
fffa54b0:	61 4a 71 af 	ori     r10,r10,29103
fffa54b4:	05 29 57 da 	cmplwble r9,r10,fffa5468 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x34>
fffa54b8:	48 00 01 bc 	b       fffa5674 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x240>
            delay ++;
            continue;
        }

        // Single operations are limited to TPM SPI transmit size
        if (burstCount > TPM_MAX_SPI_TRANSMIT_SIZE)
fffa54bc:	28 0a 00 40 	cmplwi  r10,64
fffa54c0:	40 81 00 0c 	ble     fffa54cc <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x98>
        {
            burstCount = TPM_MAX_SPI_TRANSMIT_SIZE;
fffa54c4:	39 20 00 40 	li      r9,64
fffa54c8:	b1 21 00 08 	sth     r9,8(r1)
        }

        // Limit TPM writes to 2 bytes and write information in chunks if
        // necessary
        if(burstCount > 2)
fffa54cc:	a1 21 00 08 	lhz     r9,8(r1)
fffa54d0:	28 09 00 02 	cmplwi  r9,2
fffa54d4:	40 81 00 0c 	ble     fffa54e0 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0xac>
        {
            burstCount = 2;
fffa54d8:	39 20 00 02 	li      r9,2
fffa54dc:	b1 21 00 08 	sth     r9,8(r1)
        }

        //Send in some data
        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
        tx_len = (curByte + burstCount > length ?
fffa54e0:	a1 21 00 08 	lhz     r9,8(r1)
            burstCount = 2;
        }

        //Send in some data
        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fffa54e4:	7d 5f f2 14 	add     r10,r31,r30
        tx_len = (curByte + burstCount > length ?
fffa54e8:	7d 1e 4a 14 	add     r8,r30,r9
                  (length - curByte) :
                  burstCount);
fffa54ec:	05 28 e0 04 	cmplwble r8,r28,fffa54f4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0xc0>
fffa54f0:	7d 3e e0 50 	subf    r9,r30,r28
        SBEM_INFO(SBEM_FUNC "tpmWriteFifo: send some data %d tx_len", tx_len);
fffa54f4:	3c 60 c4 95 	lis     r3,-15211
fffa54f8:	7d 25 4b 78 	mr      r5,r9
fffa54fc:	60 63 00 01 	ori     r3,r3,1
fffa5500:	38 c0 00 00 	li      r6,0
fffa5504:	38 e0 00 00 	li      r7,0
fffa5508:	39 00 00 00 	li      r8,0
fffa550c:	91 21 00 1c 	stw     r9,28(r1)
fffa5510:	91 41 00 18 	stw     r10,24(r1)
fffa5514:	4b ff e6 3d 	bl      fffa3b50 <pk_trace_big>
        uint32_t tpmLocality = 0;               // TPM locality (0-4)
        uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
fffa5518:	81 21 00 1c 	lwz     r9,28(r1)
fffa551c:	81 41 00 18 	lwz     r10,24(r1)
fffa5520:	55 26 06 3e 	clrlwi  r6,r9,24
fffa5524:	7f a3 eb 78 	mr      r3,r29
fffa5528:	38 80 00 00 	li      r4,0
fffa552c:	38 a0 00 24 	li      r5,36
fffa5530:	7d 47 53 78 	mr      r7,r10
fffa5534:	48 00 1b 31 	bl      fffa7064 <spi_tpm_write_with_wait>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5538:	81 21 00 1c 	lwz     r9,28(r1)
fffa553c:	06 c3 00 14 	bwz     r3,fffa5564 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x130>
fffa5540:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed with rc 0x%08X", rc);
fffa5544:	3c 60 4c bc 	lis     r3,19644
fffa5548:	60 63 00 01 	ori     r3,r3,1
fffa554c:	7f e5 fb 78 	mr      r5,r31
fffa5550:	38 c0 00 00 	li      r6,0
fffa5554:	38 e0 00 00 	li      r7,0
fffa5558:	39 00 00 00 	li      r8,0
fffa555c:	4b ff e5 f5 	bl      fffa3b50 <pk_trace_big>
            break;
fffa5560:	48 00 01 44 	b       fffa56a4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x270>
        }
        curByte += tx_len;

        // TPM should be expecting more data from the command
        SBEM_INFO(SBEM_FUNC "TPM should be expecting more data from the command");
fffa5564:	3c 60 bd ac 	lis     r3,-16980
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed with rc 0x%08X", rc);
            break;
        }
        curByte += tx_len;
fffa5568:	7f de 4a 14 	add     r30,r30,r9

        // TPM should be expecting more data from the command
        SBEM_INFO(SBEM_FUNC "TPM should be expecting more data from the command");
fffa556c:	4b ff b1 55 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmIsExpecting(handle, expect);
fffa5570:	7f a3 eb 78 	mr      r3,r29
fffa5574:	38 81 00 0a 	addi    r4,r1,10
fffa5578:	4b ff f7 15 	bl      fffa4c8c <_Z14tpmIsExpectingR16SpiControlHandleRb>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa557c:	06 c3 00 08 	bwz     r3,fffa558c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x158>
fffa5580:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsExpecting failed with rc 0x%08X", rc);
fffa5584:	3c 60 7f d2 	lis     r3,32722
fffa5588:	4b ff ff c0 	b       fffa5548 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x114>
            break;
        }
        if(( rc == fapi2::FAPI2_RC_SUCCESS) && (!expect))
fffa558c:	89 21 00 0a 	lbz     r9,10(r1)
fffa5590:	06 49 00 06 	bwnz    r9,fffa559c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x168>
        {
            SBEM_ERROR(SBEM_FUNC "TPM is not expecting any further data, expect is %d", expect);
fffa5594:	3c 60 53 9a 	lis     r3,21402
fffa5598:	48 00 00 e0 	b       fffa5678 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x244>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }
        // Everything but the last byte sent?
        SBEM_INFO(SBEM_FUNC "Everything but the last byte sent");
fffa559c:	3c 60 11 8f 	lis     r3,4495
fffa55a0:	4b ff b1 21 	bl      fffa06c0 <pk_trace_tiny>
        if (curByte >= length)
fffa55a4:	05 9e e7 60 	cmplwblt r30,r28,fffa5464 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x30>

    if((rc ==fapi2::FAPI2_RC_SUCCESS) && (delay < TPM_TIMEOUT_D))
    {
        delay = 0;
        // Send the final byte.
        SBEM_INFO(SBEM_FUNC "Send the final byte");
fffa55a8:	3c 60 a2 2c 	lis     r3,-24020
fffa55ac:	3f 80 00 0b 	lis     r28,11
fffa55b0:	4b ff b1 11 	bl      fffa06c0 <pk_trace_tiny>
fffa55b4:	63 9c 71 b0 	ori     r28,r28,29104
        do
        {
            // Read burst count.
            rc = tpmReadBurstCount(handle, burstCount);
fffa55b8:	7f a3 eb 78 	mr      r3,r29
fffa55bc:	38 81 00 08 	addi    r4,r1,8
fffa55c0:	4b ff fa 4d 	bl      fffa500c <_Z17tpmReadBurstCountR16SpiControlHandleRt>
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa55c4:	06 c3 00 08 	bwz     r3,fffa55d4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x1a0>
fffa55c8:	7c 7f 1b 78 	mr      r31,r3
            {
                SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
fffa55cc:	3c 60 1c 87 	lis     r3,7303
fffa55d0:	4b ff ff 78 	b       fffa5548 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x114>
                break;
            }
            else if(burstCount == 0)
fffa55d4:	a1 21 00 08 	lhz     r9,8(r1)
fffa55d8:	06 49 00 18 	bwnz    r9,fffa5608 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x1d4>
            {
                fapi2::delay(1000, 1000);
fffa55dc:	38 60 00 00 	li      r3,0
fffa55e0:	38 80 03 e8 	li      r4,1000
fffa55e4:	38 a0 00 00 	li      r5,0
fffa55e8:	38 c0 03 e8 	li      r6,1000
fffa55ec:	38 e0 00 00 	li      r7,0
fffa55f0:	48 00 02 35 	bl      fffa5824 <_ZN5fapi25delayEyyb>
    if((rc ==fapi2::FAPI2_RC_SUCCESS) && (delay < TPM_TIMEOUT_D))
    {
        delay = 0;
        // Send the final byte.
        SBEM_INFO(SBEM_FUNC "Send the final byte");
        do
fffa55f4:	37 9c ff ff 	addic.  r28,r28,-1
fffa55f8:	40 82 ff c0 	bne     fffa55b8 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x184>
fffa55fc:	3d 20 00 0b 	lis     r9,11
fffa5600:	61 29 71 b0 	ori     r9,r9,29104
fffa5604:	48 00 00 38 	b       fffa563c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x208>
                continue;
            }
            // Send in final byte
            delay = 0;
            curBytePtr = &(bytePtr[curByte]);
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
fffa5608:	7c 7f f0 ae 	lbzx    r3,r31,r30
                delay += 1;
                continue;
            }
            // Send in final byte
            delay = 0;
            curBytePtr = &(bytePtr[curByte]);
fffa560c:	7f 9f f2 14 	add     r28,r31,r30
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
fffa5610:	64 63 38 30 	oris    r3,r3,14384
fffa5614:	4b ff b0 ad 	bl      fffa06c0 <pk_trace_tiny>
            uint32_t tpmLocality = 0;               // TPM locality (0-4)
            uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
            tx_len = 1;
            rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
fffa5618:	7f a3 eb 78 	mr      r3,r29
fffa561c:	38 80 00 00 	li      r4,0
fffa5620:	38 a0 00 24 	li      r5,36
fffa5624:	38 c0 00 01 	li      r6,1
fffa5628:	7f 87 e3 78 	mr      r7,r28
fffa562c:	48 00 1a 39 	bl      fffa7064 <spi_tpm_write_with_wait>
fffa5630:	7c 7f 1b 78 	mr      r31,r3
                fapi2::delay(1000, 1000);
                delay += 1;
                continue;
            }
            // Send in final byte
            delay = 0;
fffa5634:	39 20 00 00 	li      r9,0
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
            uint32_t tpmLocality = 0;               // TPM locality (0-4)
            uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
            tx_len = 1;
            rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5638:	06 43 07 86 	bwnz    r3,fffa5544 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x110>
            break;
        }while(delay < TPM_TIMEOUT_D);
    }
    do
    {
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (delay >= TPM_TIMEOUT_D))
fffa563c:	3d 40 00 0b 	lis     r10,11
fffa5640:	61 4a 71 af 	ori     r10,r10,29103
fffa5644:	05 a9 50 18 	cmplwbgt r9,r10,fffa5674 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x240>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }
        if(rc == fapi2::FAPI2_RC_SUCCESS)
        {
            SBEM_INFO(SBEM_FUNC "Check if TPM is expecting more data.");
fffa5648:	3c 60 8c 4f 	lis     r3,-29617
fffa564c:	4b ff b0 75 	bl      fffa06c0 <pk_trace_tiny>
            rc = tpmIsExpecting(handle, expect);
fffa5650:	7f a3 eb 78 	mr      r3,r29
fffa5654:	38 81 00 0a 	addi    r4,r1,10
fffa5658:	4b ff f6 35 	bl      fffa4c8c <_Z14tpmIsExpectingR16SpiControlHandleRb>
fffa565c:	7c 7f 1b 78 	mr      r31,r3
fffa5660:	88 c1 00 0a 	lbz     r6,10(r1)
            if(( rc != fapi2::FAPI2_RC_SUCCESS) || (expect))
fffa5664:	06 43 00 0e 	bwnz    r3,fffa5680 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x24c>
fffa5668:	54 c9 06 3e 	clrlwi  r9,r6,24
fffa566c:	06 49 00 0a 	bwnz    r9,fffa5680 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x24c>
fffa5670:	48 00 00 34 	b       fffa56a4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x270>
    }
    do
    {
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (delay >= TPM_TIMEOUT_D))
        {
            SBE_ERROR(SBE_FUNC "TPM has timed out");
fffa5674:	3c 60 a9 3a 	lis     r3,-22214
fffa5678:	4b ff b0 49 	bl      fffa06c0 <pk_trace_tiny>
fffa567c:	48 00 00 20 	b       fffa569c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x268>
        {
            SBEM_INFO(SBEM_FUNC "Check if TPM is expecting more data.");
            rc = tpmIsExpecting(handle, expect);
            if(( rc != fapi2::FAPI2_RC_SUCCESS) || (expect))
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsExpecting failed or expecting more data with rc 0x%08X %d", rc, expect);
fffa5680:	3c 60 e5 85 	lis     r3,-6779
fffa5684:	60 63 00 02 	ori     r3,r3,2
fffa5688:	7f e5 fb 78 	mr      r5,r31
fffa568c:	54 c6 06 3e 	clrlwi  r6,r6,24
fffa5690:	38 e0 00 00 	li      r7,0
fffa5694:	39 00 00 00 	li      r8,0
fffa5698:	4b ff e4 b9 	bl      fffa3b50 <pk_trace_big>
                rc = fapi2::FAPI2_RC_FALSE;
fffa569c:	3f e0 04 00 	lis     r31,1024
fffa56a0:	63 ff 00 06 	ori     r31,r31,6
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa56a4:	80 01 00 34 	lwz     r0,52(r1)
fffa56a8:	7f e3 fb 78 	mr      r3,r31
fffa56ac:	7c 08 03 a6 	mtlr    r0
fffa56b0:	17 81 00 20 	lvd     d28,32(r1)
fffa56b4:	17 c1 00 28 	lvd     d30,40(r1)
fffa56b8:	38 21 00 30 	addi    r1,r1,48
fffa56bc:	4e 80 00 20 	blr

fffa56c0 <_Z11tpmTransmitR16SpiControlHandlePvRmm>:

fapi2::ReturnCode tpmTransmit( SpiControlHandle &handle,
                         void * io_buffer,
                         uint32_t & io_buflen,
                         uint32_t i_commandlen)
{
fffa56c0:	94 21 ff d0 	stwu    r1,-48(r1)
fffa56c4:	7c 08 02 a6 	mflr    r0
fffa56c8:	1b 81 00 20 	stvd    d28,32(r1)
fffa56cc:	1b c1 00 28 	stvd    d30,40(r1)
fffa56d0:	90 01 00 34 	stw     r0,52(r1)
fffa56d4:	7c 7f 1b 78 	mr      r31,r3
fffa56d8:	7c be 2b 78 	mr      r30,r5
    #define SBEM_FUNC " tpmTransmit "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    SBEM_INFO(SBEM_FUNC "TPM TRANSMIT START buflen 0x%08X and cmdlen 0x%08X",
                         io_buflen, i_commandlen);
fffa56dc:	3c 60 09 23 	lis     r3,2339
fffa56e0:	80 a5 00 00 	lwz     r5,0(r5)
fffa56e4:	60 63 00 02 	ori     r3,r3,2
fffa56e8:	38 e0 00 00 	li      r7,0
fffa56ec:	39 00 00 00 	li      r8,0

fapi2::ReturnCode tpmTransmit( SpiControlHandle &handle,
                         void * io_buffer,
                         uint32_t & io_buflen,
                         uint32_t i_commandlen)
{
fffa56f0:	7c 9d 23 78 	mr      r29,r4
fffa56f4:	90 c1 00 18 	stw     r6,24(r1)
    #define SBEM_FUNC " tpmTransmit "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    SBEM_INFO(SBEM_FUNC "TPM TRANSMIT START buflen 0x%08X and cmdlen 0x%08X",
                         io_buflen, i_commandlen);
fffa56f8:	4b ff e4 59 	bl      fffa3b50 <pk_trace_big>
    do
    {
        // Verify the TPM is ready to receive our command.
        bool isCmdReady = false;
fffa56fc:	7c 24 0b 78 	mr      r4,r1
fffa5700:	39 20 00 00 	li      r9,0
fffa5704:	9d 24 00 08 	stbu    r9,8(r4)
        rc = tpmIsCommandReady(handle, isCmdReady );
fffa5708:	7f e3 fb 78 	mr      r3,r31
fffa570c:	4b ff f6 b9 	bl      fffa4dc4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fffa5710:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady failed with rc 0x%08X", rc);
fffa5714:	3c 60 f2 f1 	lis     r3,-3343
    do
    {
        // Verify the TPM is ready to receive our command.
        bool isCmdReady = false;
        rc = tpmIsCommandReady(handle, isCmdReady );
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5718:	06 5c 00 6c 	bwnz    r28,fffa57f0 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady failed with rc 0x%08X", rc);
            break;
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is %d", isCmdReady);
fffa571c:	88 61 00 08 	lbz     r3,8(r1)
fffa5720:	64 63 d3 e5 	oris    r3,r3,54245
fffa5724:	4b ff af 9d 	bl      fffa06c0 <pk_trace_tiny>
        if(!isCmdReady)
fffa5728:	89 21 00 08 	lbz     r9,8(r1)
fffa572c:	06 49 00 14 	bwnz    r9,fffa5754 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x94>
        {
            // set TPM into command ready state
            rc = tpmWriteCommandReady(handle);
fffa5730:	7f e3 fb 78 	mr      r3,r31
fffa5734:	4b ff f7 29 	bl      fffa4e5c <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fffa5738:	7c 7c 1b 78 	mr      r28,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa573c:	06 43 00 58 	bwnz    r3,fffa57ec <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x12c>
                SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
                break;
            }

            // Verify the TPM is now ready to receive our command
            rc = tpmPollForCommandReady(handle);
fffa5740:	7f e3 fb 78 	mr      r3,r31
fffa5744:	4b ff f7 81 	bl      fffa4ec4 <_Z22tpmPollForCommandReadyR16SpiControlHandle>
fffa5748:	7c 7c 1b 78 	mr      r28,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
            {
                SBEM_ERROR(SBEM_FUNC "tpmPollForCommandReady failed with rc 0x%08X", rc);
fffa574c:	3c 60 a7 4d 	lis     r3,-22707
                break;
            }

            // Verify the TPM is now ready to receive our command
            rc = tpmPollForCommandReady(handle);
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5750:	06 5c 00 50 	bwnz    r28,fffa57f0 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
            {
                SBEM_ERROR(SBEM_FUNC "tpmPollForCommandReady failed with rc 0x%08X", rc);
                break;
            }
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is set. Go write the command to FIFO.");
fffa5754:	3c 60 e5 ca 	lis     r3,-6710
fffa5758:	4b ff af 69 	bl      fffa06c0 <pk_trace_tiny>

        // Write the command into the TPM FIFO
        rc = tpmWriteFifo(handle, io_buffer, i_commandlen);
fffa575c:	80 a1 00 18 	lwz     r5,24(r1)
fffa5760:	7f e3 fb 78 	mr      r3,r31
fffa5764:	7f a4 eb 78 	mr      r4,r29
fffa5768:	4b ff fc cd 	bl      fffa5434 <_Z12tpmWriteFifoR16SpiControlHandlePvm>
fffa576c:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteFifo failed with rc 0x%08X", rc);
fffa5770:	3c 60 da a6 	lis     r3,-9562
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is set. Go write the command to FIFO.");

        // Write the command into the TPM FIFO
        rc = tpmWriteFifo(handle, io_buffer, i_commandlen);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5774:	06 5c 00 3e 	bwnz    r28,fffa57f0 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
             SBEM_ERROR(SBEM_FUNC "tpmWriteFifo failed with rc 0x%08X", rc);
             break;
        }

        // Set the tpmGo bit
        SBEM_INFO(SBEM_FUNC "Set the tpmGo bit");
fffa5778:	3c 60 fc e6 	lis     r3,-794
fffa577c:	4b ff af 45 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmWriteTpmGo(handle);
fffa5780:	7f e3 fb 78 	mr      r3,r31
fffa5784:	4b ff f9 0d 	bl      fffa5090 <_Z13tpmWriteTpmGoR16SpiControlHandle>
fffa5788:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteTpmGo failed with rc 0x%08X", rc);
fffa578c:	3c 60 80 db 	lis     r3,-32549
        }

        // Set the tpmGo bit
        SBEM_INFO(SBEM_FUNC "Set the tpmGo bit");
        rc = tpmWriteTpmGo(handle);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa5790:	06 5c 00 30 	bwnz    r28,fffa57f0 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
             SBEM_ERROR(SBEM_FUNC "tpmWriteTpmGo failed with rc 0x%08X", rc);
             break;
        }

        // Read the response from the TPM FIFO
        SBEM_INFO(SBEM_FUNC "Read the response from TPM FIFO");
fffa5794:	3c 60 cd 3d 	lis     r3,-12995
fffa5798:	4b ff af 29 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmReadFifo(handle, io_buffer, io_buflen);
fffa579c:	7f e3 fb 78 	mr      r3,r31
fffa57a0:	7f a4 eb 78 	mr      r4,r29
fffa57a4:	7f c5 f3 78 	mr      r5,r30
fffa57a8:	4b ff fa 11 	bl      fffa51b8 <_Z11tpmReadFifoR16SpiControlHandlePvRm>
fffa57ac:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmReadFifo failed with rc 0x%08X", rc);
fffa57b0:	3c 60 3c 7a 	lis     r3,15482
        }

        // Read the response from the TPM FIFO
        SBEM_INFO(SBEM_FUNC "Read the response from TPM FIFO");
        rc = tpmReadFifo(handle, io_buffer, io_buflen);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa57b4:	06 5c 00 1e 	bwnz    r28,fffa57f0 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
        {
             SBEM_ERROR(SBEM_FUNC "tpmReadFifo failed with rc 0x%08X", rc);
             break;
        }
        SBEM_INFO(SBEM_FUNC "Buffer length after response is 0x%08X", io_buflen);
fffa57b8:	80 be 00 00 	lwz     r5,0(r30)
fffa57bc:	3c 60 e0 2d 	lis     r3,-8147
fffa57c0:	38 c0 00 00 	li      r6,0
fffa57c4:	38 e0 00 00 	li      r7,0
fffa57c8:	39 00 00 00 	li      r8,0
fffa57cc:	60 63 00 01 	ori     r3,r3,1
fffa57d0:	4b ff e3 81 	bl      fffa3b50 <pk_trace_big>

        // Set write command ready.
        SBEM_INFO(SBEM_FUNC "Set write command ready");
fffa57d4:	3c 60 60 c7 	lis     r3,24775
fffa57d8:	4b ff ae e9 	bl      fffa06c0 <pk_trace_tiny>
        rc = tpmWriteCommandReady(handle);
fffa57dc:	7f e3 fb 78 	mr      r3,r31
fffa57e0:	4b ff f6 7d 	bl      fffa4e5c <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fffa57e4:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fffa57e8:	06 c3 00 10 	bwz     r3,fffa5808 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x148>
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
fffa57ec:	3c 60 71 a0 	lis     r3,29088
fffa57f0:	60 63 00 01 	ori     r3,r3,1
fffa57f4:	7f 85 e3 78 	mr      r5,r28
fffa57f8:	38 c0 00 00 	li      r6,0
fffa57fc:	38 e0 00 00 	li      r7,0
fffa5800:	39 00 00 00 	li      r8,0
fffa5804:	4b ff e3 4d 	bl      fffa3b50 <pk_trace_big>
    }while(0);
    
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fffa5808:	80 01 00 34 	lwz     r0,52(r1)
fffa580c:	7f 83 e3 78 	mr      r3,r28
fffa5810:	7c 08 03 a6 	mtlr    r0
fffa5814:	17 81 00 20 	lvd     d28,32(r1)
fffa5818:	17 c1 00 28 	lvd     d30,40(r1)
fffa581c:	38 21 00 30 	addi    r1,r1,48
fffa5820:	4e 80 00 20 	blr

fffa5824 <_ZN5fapi25delayEyyb>:
        PkTimebase  target_time;
        PkTimebase  current_time;


        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
fffa5824:	7c 69 23 78 	or      r9,r3,r4
fffa5828:	06 c9 00 52 	bwz     r9,fffa58cc <_ZN5fapi25delayEyyb+0xa8>
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
    }
    /// @brief Delay this thread.
    ///
    ReturnCode delay(uint64_t i_nanoSeconds, uint64_t i_simCycles, bool i_fixed /* = false*/)
    {
fffa582c:	94 21 ff e8 	stwu    r1,-24(r1)
fffa5830:	7c 08 02 a6 	mflr    r0
fffa5834:	1b 81 00 08 	stvd    d28,8(r1)
fffa5838:	90 01 00 1c 	stw     r0,28(r1)
fffa583c:	1b c1 00 10 	stvd    d30,16(r1)
fffa5840:	7c 9d 23 78 	mr      r29,r4
fffa5844:	7c 7c 1b 78 	mr      r28,r3

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fffa5848:	4b ff b0 d9 	bl      fffa0920 <pk_timebase_get>
fffa584c:	7c 9f 23 78 	mr      r31,r4
#elif __SBEVFW_VERIFICATION__
        uint32_t sbeFrequency = g_sbevfreqency;
#else
        uint32_t sbeFrequency = SBE_GLOBAL->sbefreq;
#endif
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
fffa5850:	38 a0 00 00 	li      r5,0
fffa5854:	38 c0 03 e8 	li      r6,1000

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fffa5858:	7c 7e 1b 78 	mr      r30,r3
#elif __SBEVFW_VERIFICATION__
        uint32_t sbeFrequency = g_sbevfreqency;
#else
        uint32_t sbeFrequency = SBE_GLOBAL->sbefreq;
#endif
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
fffa585c:	7f a4 eb 78 	mr      r4,r29
fffa5860:	7f 83 e3 78 	mr      r3,r28
fffa5864:	48 00 00 d9 	bl      fffa593c <__udivdi3>
fffa5868:	7c 9d 23 78 	mr      r29,r4
fffa586c:	7c 7c 1b 78 	mr      r28,r3
fffa5870:	3c 80 00 0f 	lis     r4,15
fffa5874:	80 6d 13 90 	lwz     r3,5008(r13)
fffa5878:	60 84 42 40 	ori     r4,r4,16960
fffa587c:	48 00 00 ad 	bl      fffa5928 <__udivsi3>
fffa5880:	7c 66 1b 78 	mr      r6,r3
fffa5884:	7f a4 eb 78 	mr      r4,r29
fffa5888:	7f 83 e3 78 	mr      r3,r28
fffa588c:	38 a0 00 00 	li      r5,0
fffa5890:	48 00 00 d9 	bl      fffa5968 <__muldi3>

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fffa5894:	7f ff 20 14 	addc    r31,r31,r4
fffa5898:	7f de 19 14 	adde    r30,r30,r3
            current_time = pk_timebase_get();
fffa589c:	4b ff b0 85 	bl      fffa0920 <pk_timebase_get>

            do
            {
                current_time = pk_timebase_get();
fffa58a0:	4b ff b0 81 	bl      fffa0920 <pk_timebase_get>
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
            current_time = pk_timebase_get();

            do
fffa58a4:	05 83 f7 fe 	cmplwblt r3,r30,fffa58a0 <_ZN5fapi25delayEyyb+0x7c>
fffa58a8:	04 43 f0 04 	cmpwbne r3,r30,fffa58b0 <_ZN5fapi25delayEyyb+0x8c>
fffa58ac:	05 84 ff fa 	cmplwblt r4,r31,fffa58a0 <_ZN5fapi25delayEyyb+0x7c>

#endif

        // replace with platform specific implementation
        return FAPI2_RC_SUCCESS;
    }
fffa58b0:	80 01 00 1c 	lwz     r0,28(r1)
fffa58b4:	17 81 00 08 	lvd     d28,8(r1)
fffa58b8:	7c 08 03 a6 	mtlr    r0
fffa58bc:	17 c1 00 10 	lvd     d30,16(r1)
fffa58c0:	38 60 00 00 	li      r3,0
fffa58c4:	38 21 00 18 	addi    r1,r1,24
fffa58c8:	4e 80 00 20 	blr
fffa58cc:	38 60 00 00 	li      r3,0
fffa58d0:	4e 80 00 20 	blr
	...

fffa58e0 <udivmodsi4_loop>:
fffa58e0:	05 04 18 0e 	cmplwbge r4,r3,fffa58fc <udivmodsi4_loop+0x1c>
fffa58e4:	42 40 00 14 	bdz     fffa58f8 <udivmodsi4_loop+0x18>
fffa58e8:	06 84 00 0a 	bwltz   r4,fffa58fc <udivmodsi4_loop+0x1c>
fffa58ec:	54 84 08 3c 	rlwinm  r4,r4,1,0,30
fffa58f0:	55 29 08 3c 	rlwinm  r9,r9,1,0,30
fffa58f4:	4b ff ff ec 	b       fffa58e0 <udivmodsi4_loop>
fffa58f8:	39 20 00 00 	li      r9,0
fffa58fc:	39 40 00 00 	li      r10,0
fffa5900:	06 c9 00 0e 	bwz     r9,fffa591c <udivmodsi4_loop+0x3c>
fffa5904:	05 83 20 06 	cmplwblt r3,r4,fffa5910 <udivmodsi4_loop+0x30>
fffa5908:	7c 64 18 50 	subf    r3,r4,r3
fffa590c:	7d 4a 4b 78 	or      r10,r10,r9
fffa5910:	55 29 f8 7e 	rlwinm  r9,r9,31,1,31
fffa5914:	54 84 f8 7e 	rlwinm  r4,r4,31,1,31
fffa5918:	4b ff ff e8 	b       fffa5900 <udivmodsi4_loop+0x20>
fffa591c:	06 45 00 04 	bwnz    r5,fffa5924 <udivmodsi4_loop+0x44>
fffa5920:	7d 43 53 78 	mr      r3,r10
fffa5924:	4e 80 00 20 	blr

fffa5928 <__udivsi3>:
fffa5928:	38 a0 00 00 	li      r5,0
fffa592c:	39 40 00 21 	li      r10,33
fffa5930:	7d 49 03 a6 	mtctr   r10
fffa5934:	39 20 00 01 	li      r9,1
fffa5938:	4b ff ff a8 	b       fffa58e0 <udivmodsi4_loop>

fffa593c <__udivdi3>:
// quotient is 1 and the remainder is 0.
//

uint64_t
__udivdi3(uint64_t u, uint64_t v)
{
fffa593c:	94 21 ff e8 	stwu    r1,-24(r1)
fffa5940:	7c 08 02 a6 	mflr    r0
    uint64_t quotient, remainder;

    __ppe42_udiv64(u, v, &quotient, &remainder);
fffa5944:	38 e1 00 10 	addi    r7,r1,16
fffa5948:	39 01 00 08 	addi    r8,r1,8
// quotient is 1 and the remainder is 0.
//

uint64_t
__udivdi3(uint64_t u, uint64_t v)
{
fffa594c:	90 01 00 1c 	stw     r0,28(r1)
    uint64_t quotient, remainder;

    __ppe42_udiv64(u, v, &quotient, &remainder);
fffa5950:	48 00 01 f5 	bl      fffa5b44 <__ppe42_udiv64>
    return quotient;
}
fffa5954:	80 01 00 1c 	lwz     r0,28(r1)
fffa5958:	14 61 00 10 	lvd     d3,16(r1)
fffa595c:	7c 08 03 a6 	mtlr    r0
fffa5960:	38 21 00 18 	addi    r1,r1,24
fffa5964:	4e 80 00 20 	blr

fffa5968 <__muldi3>:

#endif //__PPE42A__

// 64 bit signed multiply
unsigned long long __muldi3(unsigned long long _a, unsigned long long _b)
{
fffa5968:	7c 89 23 78 	mr      r9,r4
fffa596c:	7c 68 1b 78 	mr      r8,r3
    unsigned long long sum = 0;
fffa5970:	38 80 00 00 	li      r4,0
fffa5974:	38 60 00 00 	li      r3,0

    while(_a)
fffa5978:	7d 0a 4b 78 	or      r10,r8,r9
fffa597c:	06 ca 00 10 	bwz     r10,fffa599c <__muldi3+0x34>
    {
        if(_a & 1)
fffa5980:	55 2a 07 fe 	clrlwi  r10,r9,31
fffa5984:	06 ca 00 06 	bwz     r10,fffa5990 <__muldi3+0x28>
        {
            sum += _b;
fffa5988:	7c 84 30 14 	addc    r4,r4,r6
fffa598c:	7c 63 29 14 	adde    r3,r3,r5
        }

        _a >>= 1;
fffa5990:	79 08 f8 42 	rldicl  d8,d8,63,1
        _b <<= 1;
fffa5994:	78 a5 0f a4 	rldicr  d5,d5,1,62
fffa5998:	4b ff ff e0 	b       fffa5978 <__muldi3+0x10>
    }

    return sum;
}
fffa599c:	4e 80 00 20 	blr

fffa59a0 <memset>:
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
    uint32_t addr = (uint32_t)vdest;
fffa59a0:	39 45 00 01 	addi    r10,r5,1
#ifdef __cplusplus
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
fffa59a4:	94 21 ff e8 	stwu    r1,-24(r1)
    uint32_t addr = (uint32_t)vdest;
fffa59a8:	7d 49 03 a6 	mtctr   r10
#ifdef __cplusplus
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
fffa59ac:	1b 81 00 08 	stvd    d28,8(r1)
fffa59b0:	1b c1 00 10 	stvd    d30,16(r1)
    uint32_t addr = (uint32_t)vdest;
fffa59b4:	7c 69 1b 78 	mr      r9,r3
fffa59b8:	42 40 00 28 	bdz     fffa59e0 <memset+0x40>

    while(len && (addr & 0x7)) // not 8 byte aligned
fffa59bc:	55 2a 07 7e 	clrlwi  r10,r9,29
fffa59c0:	06 ca 00 0a 	bwz     r10,fffa59d4 <memset+0x34>
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
fffa59c4:	98 89 00 00 	stb     r4,0(r9)
        ++addr;
        --len;
fffa59c8:	38 a5 ff ff 	addi    r5,r5,-1

    while(len && (addr & 0x7)) // not 8 byte aligned
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
        ++addr;
fffa59cc:	39 29 00 01 	addi    r9,r9,1
fffa59d0:	4b ff ff e8 	b       fffa59b8 <memset+0x18>
        --len;
    }

    if(len >= sizeof(uint64_t))
fffa59d4:	28 05 00 07 	cmplwi  r5,7
fffa59d8:	7c aa 2b 78 	mr      r10,r5
fffa59dc:	41 a1 00 14 	bgt     fffa59f0 <memset+0x50>
fffa59e0:	38 a5 00 01 	addi    r5,r5,1
fffa59e4:	39 40 00 00 	li      r10,0
fffa59e8:	7c a9 03 a6 	mtctr   r5
fffa59ec:	48 00 00 68 	b       fffa5a54 <memset+0xb4>
fffa59f0:	39 05 ff f8 	addi    r8,r5,-8
    {
        uint64_t lch = ch & 0xff;
fffa59f4:	54 9f 06 3e 	clrlwi  r31,r4,24
fffa59f8:	3b c0 00 00 	li      r30,0
fffa59fc:	55 08 e8 fe 	rlwinm  r8,r8,29,3,31
        lch |= lch << 8;
fffa5a00:	7b dc 45 e4 	rldicr  d28,d30,8,55
fffa5a04:	39 08 00 01 	addi    r8,r8,1
fffa5a08:	7f a7 fb 78 	or      r7,r29,r31
fffa5a0c:	7f 86 e3 78 	mr      r6,r28
fffa5a10:	7d 09 03 a6 	mtctr   r8
        lch |= lch << 16;
fffa5a14:	78 de 83 e4 	rldicr  d30,d6,16,47
fffa5a18:	7f e0 3b 78 	or      r0,r31,r7
fffa5a1c:	7f c6 33 78 	or      r6,r30,r6
        lch |= lch << 32;
fffa5a20:	7c 06 33 78 	or      r6,r0,r6
fffa5a24:	38 e9 ff f8 	addi    r7,r9,-8
fffa5a28:	39 07 00 08 	addi    r8,r7,8

        while(len >= sizeof(uint64_t))
        {
            uint64_t* p = (uint64_t*)addr;
            *p = lch;
fffa5a2c:	90 c7 00 08 	stw     r6,8(r7)
fffa5a30:	90 07 00 0c 	stw     r0,12(r7)
fffa5a34:	7d 07 43 78 	mr      r7,r8
        uint64_t lch = ch & 0xff;
        lch |= lch << 8;
        lch |= lch << 16;
        lch |= lch << 32;

        while(len >= sizeof(uint64_t))
fffa5a38:	42 00 ff f0 	bdnz    fffa5a28 <memset+0x88>
fffa5a3c:	39 4a ff f8 	addi    r10,r10,-8
fffa5a40:	39 29 00 08 	addi    r9,r9,8
fffa5a44:	55 4a 00 38 	rlwinm  r10,r10,0,0,28
fffa5a48:	54 a5 07 7e 	clrlwi  r5,r5,29
fffa5a4c:	7d 29 52 14 	add     r9,r9,r10
fffa5a50:	4b ff ff 90 	b       fffa59e0 <memset+0x40>
            len -= sizeof(uint64_t);
            addr += sizeof(uint64_t);
        }
    }

    while(len)
fffa5a54:	42 40 00 10 	bdz     fffa5a64 <memset+0xc4>
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
fffa5a58:	7c 8a 49 ae 	stbx    r4,r10,r9
fffa5a5c:	39 4a 00 01 	addi    r10,r10,1
fffa5a60:	4b ff ff f4 	b       fffa5a54 <memset+0xb4>
        ++addr;
        --len;
    }

    return vdest;
}
fffa5a64:	17 81 00 08 	lvd     d28,8(r1)
fffa5a68:	17 c1 00 10 	lvd     d30,16(r1)
fffa5a6c:	38 21 00 18 	addi    r1,r1,24
fffa5a70:	4e 80 00 20 	blr

fffa5a74 <memcpy>:

    // Loop, copying 4 bytes
    long* ldest = (long*)vdest;
    const long* lsrc = (const long*)vsrc;

    while (len >= sizeof(long))
fffa5a74:	54 a9 f0 be 	rlwinm  r9,r5,30,2,31
fffa5a78:	39 29 00 01 	addi    r9,r9,1
fffa5a7c:	7d 29 03 a6 	mtctr   r9
fffa5a80:	39 40 00 00 	li      r10,0
fffa5a84:	42 40 00 14 	bdz     fffa5a98 <memcpy+0x24>
    {
        *ldest++ = *lsrc++;
fffa5a88:	7d 24 50 2e 	lwzx    r9,r4,r10
fffa5a8c:	7d 23 51 2e 	stwx    r9,r3,r10
fffa5a90:	39 4a 00 04 	addi    r10,r10,4
fffa5a94:	4b ff ff f0 	b       fffa5a84 <memcpy+0x10>
fffa5a98:	54 a9 07 be 	clrlwi  r9,r5,30
    }

    // Loop, copying 1 byte
    char* cdest = (char*)ldest;
    const char* csrc = (const char*)lsrc;
    size_t i = 0;
fffa5a9c:	39 29 00 01 	addi    r9,r9,1
fffa5aa0:	7d 29 03 a6 	mtctr   r9
fffa5aa4:	54 a5 00 3a 	rlwinm  r5,r5,0,0,29
fffa5aa8:	7d 03 2a 14 	add     r8,r3,r5
fffa5aac:	39 40 00 00 	li      r10,0
fffa5ab0:	7c a4 2a 14 	add     r5,r4,r5

    for (; i < len; ++i)
fffa5ab4:	42 40 00 14 	bdz     fffa5ac8 <memcpy+0x54>
    {
        cdest[i] = csrc[i];
fffa5ab8:	7d 25 50 ae 	lbzx    r9,r5,r10
fffa5abc:	7d 28 51 ae 	stbx    r9,r8,r10
    // Loop, copying 1 byte
    char* cdest = (char*)ldest;
    const char* csrc = (const char*)lsrc;
    size_t i = 0;

    for (; i < len; ++i)
fffa5ac0:	39 4a 00 01 	addi    r10,r10,1
fffa5ac4:	4b ff ff f0 	b       fffa5ab4 <memcpy+0x40>
    {
        cdest[i] = csrc[i];
    }

    return vdest;
}
fffa5ac8:	4e 80 00 20 	blr

fffa5acc <memmove>:

void* memmove(void* vdest, const void* vsrc, size_t len)
{
fffa5acc:	38 e5 00 01 	addi    r7,r5,1
fffa5ad0:	7c 6a 1b 78 	mr      r10,r3
fffa5ad4:	7c 88 23 78 	mr      r8,r4
fffa5ad8:	7c a9 2b 78 	mr      r9,r5
fffa5adc:	7c e9 03 a6 	mtctr   r7
    // Copy first-to-last
    if (vdest <= vsrc)
fffa5ae0:	05 a3 20 04 	cmplwbgt r3,r4,fffa5ae8 <memmove+0x1c>
    {
        return memcpy(vdest, vsrc, len);
fffa5ae4:	4b ff ff 90 	b       fffa5a74 <memcpy>
fffa5ae8:	42 40 00 14 	bdz     fffa5afc <memmove+0x30>
    const char* src = (const char*)(vsrc);
    size_t i = len;

    for (; i > 0;)
    {
        --i;
fffa5aec:	39 29 ff ff 	addi    r9,r9,-1
        dest[i] = src[i];
fffa5af0:	7c e8 48 ae 	lbzx    r7,r8,r9
fffa5af4:	7c ea 49 ae 	stbx    r7,r10,r9
fffa5af8:	4b ff ff f0 	b       fffa5ae8 <memmove+0x1c>
    }

    return vdest;
}
fffa5afc:	7d 43 53 78 	mr      r3,r10
fffa5b00:	4e 80 00 20 	blr

fffa5b04 <memcmp>:
int memcmp(const void* p1, const void* p2, size_t len)
{
    const char* c1 = (const char*)(p1);
    const char* c2 = (const char*)(p2);

    size_t i = 0;
fffa5b04:	38 a5 00 01 	addi    r5,r5,1
fffa5b08:	7c a9 03 a6 	mtctr   r5
fffa5b0c:	39 40 00 00 	li      r10,0

    for (; i < len; ++i)
fffa5b10:	42 40 00 24 	bdz     fffa5b34 <memcmp+0x30>
    {
        long n = (long)(c1[i]) - (long)(c2[i]);
fffa5b14:	7d 23 50 ae 	lbzx    r9,r3,r10
fffa5b18:	7d 04 50 ae 	lbzx    r8,r4,r10
fffa5b1c:	7d 29 07 74 	extsb   r9,r9
fffa5b20:	7d 08 07 74 	extsb   r8,r8
fffa5b24:	7d 28 48 50 	subf    r9,r8,r9

        if (n != 0)
fffa5b28:	06 49 00 0a 	bwnz    r9,fffa5b3c <memcmp+0x38>
    const char* c1 = (const char*)(p1);
    const char* c2 = (const char*)(p2);

    size_t i = 0;

    for (; i < len; ++i)
fffa5b2c:	39 4a 00 01 	addi    r10,r10,1
fffa5b30:	4b ff ff e0 	b       fffa5b10 <memcmp+0xc>
        {
            return n;
        }
    }

    return 0;
fffa5b34:	38 60 00 00 	li      r3,0
fffa5b38:	4e 80 00 20 	blr
fffa5b3c:	7d 23 4b 78 	mr      r3,r9
}
fffa5b40:	4e 80 00 20 	blr

fffa5b44 <__ppe42_udiv64>:
fffa5b44:	94 21 ff f0 	stwu    r1,-16(r1)
fffa5b48:	1b c1 00 08 	stvd    d30,8(r1)
fffa5b4c:	61 1f 00 00 	ori     r31,r8,0
fffa5b50:	60 fe 00 00 	ori     r30,r7,0
fffa5b54:	2c 03 00 00 	cmpwi   r3,0
fffa5b58:	7c 60 00 34 	cntlzw  r0,r3
fffa5b5c:	7c 89 00 34 	cntlzw  r9,r4
fffa5b60:	40 82 00 08 	bne     fffa5b68 <lab1>
fffa5b64:	38 09 00 20 	addi    r0,r9,32

fffa5b68 <lab1>:
fffa5b68:	2c 05 00 00 	cmpwi   r5,0
fffa5b6c:	7c a9 00 34 	cntlzw  r9,r5
fffa5b70:	7c ca 00 34 	cntlzw  r10,r6
fffa5b74:	40 82 00 10 	bne     fffa5b84 <lab2>
fffa5b78:	2c 06 00 00 	cmpwi   r6,0
fffa5b7c:	41 82 00 e8 	beq     fffa5c64 <lab10>
fffa5b80:	39 2a 00 20 	addi    r9,r10,32

fffa5b84 <lab2>:
fffa5b84:	7c 00 48 00 	cmpw    r0,r9
fffa5b88:	21 40 00 40 	subfic  r10,r0,64
fffa5b8c:	41 81 00 c0 	bgt     fffa5c4c <lab9>
fffa5b90:	39 29 00 01 	addi    r9,r9,1
fffa5b94:	21 29 00 40 	subfic  r9,r9,64
fffa5b98:	7c 00 4a 14 	add     r0,r0,r9
fffa5b9c:	7d 29 50 50 	subf    r9,r9,r10
fffa5ba0:	7d 29 03 a6 	mtctr   r9
fffa5ba4:	2c 09 00 20 	cmpwi   r9,32
fffa5ba8:	38 e9 ff e0 	addi    r7,r9,-32
fffa5bac:	41 80 00 10 	blt     fffa5bbc <lab3>
fffa5bb0:	7c 68 3c 30 	srw     r8,r3,r7
fffa5bb4:	38 e0 00 00 	li      r7,0
fffa5bb8:	48 00 00 18 	b       fffa5bd0 <lab4>

fffa5bbc <lab3>:
fffa5bbc:	7c 88 4c 30 	srw     r8,r4,r9
fffa5bc0:	20 e9 00 20 	subfic  r7,r9,32
fffa5bc4:	7c 67 38 30 	slw     r7,r3,r7
fffa5bc8:	7d 08 3b 78 	or      r8,r8,r7
fffa5bcc:	7c 67 4c 30 	srw     r7,r3,r9

fffa5bd0 <lab4>:
fffa5bd0:	2c 00 00 20 	cmpwi   r0,32
fffa5bd4:	31 20 ff e0 	addic   r9,r0,-32
fffa5bd8:	41 80 00 10 	blt     fffa5be8 <lab5>
fffa5bdc:	7c 83 48 30 	slw     r3,r4,r9
fffa5be0:	38 80 00 00 	li      r4,0
fffa5be4:	48 00 00 18 	b       fffa5bfc <lab6>

fffa5be8 <lab5>:
fffa5be8:	7c 63 00 30 	slw     r3,r3,r0
fffa5bec:	21 20 00 20 	subfic  r9,r0,32
fffa5bf0:	7c 89 4c 30 	srw     r9,r4,r9
fffa5bf4:	7c 63 4b 78 	or      r3,r3,r9
fffa5bf8:	7c 84 00 30 	slw     r4,r4,r0

fffa5bfc <lab6>:
fffa5bfc:	39 40 ff ff 	li      r10,-1
fffa5c00:	30 e7 00 00 	addic   r7,r7,0

fffa5c04 <lab7>:
fffa5c04:	7c 84 21 14 	adde    r4,r4,r4
fffa5c08:	7c 63 19 14 	adde    r3,r3,r3
fffa5c0c:	7d 08 41 14 	adde    r8,r8,r8
fffa5c10:	7c e7 39 14 	adde    r7,r7,r7
fffa5c14:	7c 06 40 10 	subfc   r0,r6,r8
fffa5c18:	7d 25 39 11 	subfe.  r9,r5,r7
fffa5c1c:	41 80 00 10 	blt     fffa5c2c <lab8>
fffa5c20:	7c 08 03 78 	mr      r8,r0
fffa5c24:	7d 27 4b 78 	mr      r7,r9
fffa5c28:	30 0a 00 01 	addic   r0,r10,1

fffa5c2c <lab8>:
fffa5c2c:	42 00 ff d8 	bdnz    fffa5c04 <lab7>
fffa5c30:	7c 84 21 14 	adde    r4,r4,r4
fffa5c34:	7c 63 19 14 	adde    r3,r3,r3
fffa5c38:	90 9e 00 04 	stw     r4,4(r30)
fffa5c3c:	90 7e 00 00 	stw     r3,0(r30)
fffa5c40:	91 1f 00 04 	stw     r8,4(r31)
fffa5c44:	90 ff 00 00 	stw     r7,0(r31)
fffa5c48:	48 00 00 30 	b       fffa5c78 <lab11>

fffa5c4c <lab9>:
fffa5c4c:	38 00 00 00 	li      r0,0
fffa5c50:	90 7f 00 00 	stw     r3,0(r31)
fffa5c54:	90 9f 00 04 	stw     r4,4(r31)
fffa5c58:	90 1e 00 00 	stw     r0,0(r30)
fffa5c5c:	90 1e 00 04 	stw     r0,4(r30)
fffa5c60:	48 00 00 18 	b       fffa5c78 <lab11>

fffa5c64 <lab10>:
fffa5c64:	38 00 ff ff 	li      r0,-1
fffa5c68:	90 1f 00 00 	stw     r0,0(r31)
fffa5c6c:	90 1f 00 04 	stw     r0,4(r31)
fffa5c70:	90 1e 00 00 	stw     r0,0(r30)
fffa5c74:	90 1e 00 04 	stw     r0,4(r30)

fffa5c78 <lab11>:
fffa5c78:	17 c1 00 08 	lvd     d30,8(r1)
fffa5c7c:	80 21 00 00 	lwz     r1,0(r1)
fffa5c80:	4e 80 00 20 	blr

fffa5c84 <_ZL15spi_set_ecc_offR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_off(SpiControlHandle& i_handle)
{
fffa5c84:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5c88:	7c 08 02 a6 	mflr    r0
fffa5c8c:	1b c1 00 18 	stvd    d30,24(r1)
fffa5c90:	90 01 00 24 	stw     r0,36(r1)
fffa5c94:	7c 25 0b 78 	mr      r5,r1
fffa5c98:	39 00 00 00 	li      r8,0
fffa5c9c:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5ca0:	80 83 00 08 	lwz     r4,8(r3)
fffa5ca4:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa5ca8:	38 84 00 03 	addi    r4,r4,3
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_off(SpiControlHandle& i_handle)
{
fffa5cac:	7c 7f 1b 78 	mr      r31,r3
fffa5cb0:	4b ff d9 11 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5cb4:	90 6d 46 f0 	stw     r3,18160(r13)
fffa5cb8:	06 43 00 14 	bwnz    r3,fffa5ce0 <_ZL15spi_set_ecc_offR16SpiControlHandle+0x5c>
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            // This would be a candidate for a fast_mask (see variable_buffer) but
            // we'd need tables for all the integral types which maybe we need to
            // do ...
            iv_data |= (T(~0) >> (TT::bits_per_unit() - C)) << (TT::bits_per_unit() - B -
fffa5cbc:	80 a1 00 08 	lwz     r5,8(r1)

    l_data.setBit<30>();

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5cc0:	80 9f 00 08 	lwz     r4,8(r31)
fffa5cc4:	80 c1 00 0c 	lwz     r6,12(r1)
fffa5cc8:	60 a5 00 02 	ori     r5,r5,2
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa5ccc:	7f e3 fb 78 	mr      r3,r31
fffa5cd0:	38 84 00 03 	addi    r4,r4,3
fffa5cd4:	90 a1 00 08 	stw     r5,8(r1)
fffa5cd8:	4b ff d9 3d 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa5cdc:	90 6d 46 f0 	stw     r3,18160(r13)

fapi_try_exit:
    return fapi2::current_err;
}
fffa5ce0:	80 01 00 24 	lwz     r0,36(r1)
fffa5ce4:	17 c1 00 18 	lvd     d30,24(r1)
fffa5ce8:	7c 08 03 a6 	mtlr    r0
fffa5cec:	80 6d 46 f0 	lwz     r3,18160(r13)
fffa5cf0:	38 21 00 20 	addi    r1,r1,32
fffa5cf4:	4e 80 00 20 	blr

fffa5cf8 <_ZL14spi_set_ecc_onR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_on(SpiControlHandle& i_handle)
{
fffa5cf8:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5cfc:	7c 08 02 a6 	mflr    r0
fffa5d00:	1b c1 00 18 	stvd    d30,24(r1)
fffa5d04:	90 01 00 24 	stw     r0,36(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa5d08:	7c 25 0b 78 	mr      r5,r1
fffa5d0c:	39 00 00 00 	li      r8,0
fffa5d10:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5d14:	80 83 00 08 	lwz     r4,8(r3)
fffa5d18:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa5d1c:	38 84 00 03 	addi    r4,r4,3
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_on(SpiControlHandle& i_handle)
{
fffa5d20:	7c 7f 1b 78 	mr      r31,r3
fffa5d24:	4b ff d8 9d 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5d28:	90 6d 46 f0 	stw     r3,18160(r13)
fffa5d2c:	06 43 00 14 	bwnz    r3,fffa5d54 <_ZL14spi_set_ecc_onR16SpiControlHandle+0x5c>
        inline buffer & clearBit(void)
        {
            static_assert((B >= 0) &&
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            iv_data &= buffer<T>().template setBit<B, C>().invert();
fffa5d30:	80 a1 00 08 	lwz     r5,8(r1)

    l_data.clearBit<30>();

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5d34:	80 9f 00 08 	lwz     r4,8(r31)
fffa5d38:	80 c1 00 0c 	lwz     r6,12(r1)
fffa5d3c:	54 a5 07 fa 	rlwinm  r5,r5,0,31,29
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa5d40:	7f e3 fb 78 	mr      r3,r31
fffa5d44:	38 84 00 03 	addi    r4,r4,3
fffa5d48:	90 a1 00 08 	stw     r5,8(r1)
fffa5d4c:	4b ff d8 c9 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa5d50:	90 6d 46 f0 	stw     r3,18160(r13)

fapi_try_exit:
    return fapi2::current_err;
}
fffa5d54:	80 01 00 24 	lwz     r0,36(r1)
fffa5d58:	17 c1 00 18 	lvd     d30,24(r1)
fffa5d5c:	7c 08 03 a6 	mtlr    r0
fffa5d60:	80 6d 46 f0 	lwz     r3,18160(r13)
fffa5d64:	38 21 00 20 	addi    r1,r1,32
fffa5d68:	4e 80 00 20 	blr

fffa5d6c <_ZL9is_ecc_onR16SpiControlHandleRb>:

// ECC methods for SPI slave status reads
#ifndef BOOTLOADER
static fapi2::ReturnCode
is_ecc_on(SpiControlHandle& i_handle, bool& o_ecc)
{
fffa5d6c:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5d70:	7c 08 02 a6 	mflr    r0
fffa5d74:	1b c1 00 18 	stvd    d30,24(r1)
fffa5d78:	90 01 00 24 	stw     r0,36(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa5d7c:	7c 25 0b 78 	mr      r5,r1
fffa5d80:	39 00 00 00 	li      r8,0
fffa5d84:	39 20 00 00 	li      r9,0
fffa5d88:	7c 9f 23 78 	mr      r31,r4
    fapi2::buffer<uint64_t> l_data = 0;
    uint32_t l_ecc_cntl = 0;

    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fffa5d8c:	80 83 00 08 	lwz     r4,8(r3)
fffa5d90:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa5d94:	38 84 00 03 	addi    r4,r4,3
fffa5d98:	4b ff d8 29 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa5d9c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa5da0:	06 43 00 12 	bwnz    r3,fffa5dc4 <_ZL9is_ecc_onR16SpiControlHandleRb+0x58>
                source <<= shift;
            }
            else
            {
                shift = target_start - source_start;
                source >>= shift;
fffa5da4:	15 01 00 08 	lvd     d8,8(r1)
fffa5da8:	79 08 f8 60 	rldicl  d8,d8,31,33

    l_data.extractToRight(l_ecc_cntl, 29, 2);

    if( l_ecc_cntl % 2 == 0)
fffa5dac:	55 29 07 fe 	clrlwi  r9,r9,31
fffa5db0:	06 49 00 08 	bwnz    r9,fffa5dc0 <_ZL9is_ecc_onR16SpiControlHandleRb+0x54>
    {
        o_ecc = true;
fffa5db4:	39 20 00 01 	li      r9,1
fffa5db8:	99 3f 00 00 	stb     r9,0(r31)
fffa5dbc:	48 00 00 08 	b       fffa5dc4 <_ZL9is_ecc_onR16SpiControlHandleRb+0x58>
    }
    else
    {
        o_ecc = false;
fffa5dc0:	98 7f 00 00 	stb     r3,0(r31)
    }

fapi_try_exit:
    return fapi2::current_err;
}
fffa5dc4:	80 01 00 24 	lwz     r0,36(r1)
fffa5dc8:	17 c1 00 18 	lvd     d30,24(r1)
fffa5dcc:	7c 08 03 a6 	mtlr    r0
fffa5dd0:	80 6d 46 f0 	lwz     r3,18160(r13)
fffa5dd4:	38 21 00 20 	addi    r1,r1,32
fffa5dd8:	4e 80 00 20 	blr

fffa5ddc <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>:
};

// convert platform target handle to a uint64_t
template<fapi2::TargetType T, fapi2::MulticastType M>
inline uint64_t convertType( const fapi2::Target<T, M>& i_value)
fffa5ddc:	94 21 ff e0 	stwu    r1,-32(r1)
fffa5de0:	7c 08 02 a6 	mflr    r0
fffa5de4:	1b c1 00 18 	stvd    d30,24(r1)
fffa5de8:	90 01 00 24 	stw     r0,36(r1)
fffa5dec:	7c 7f 1b 78 	mr      r31,r3
        /// @brief Get the handle.
        /// @return V The target's handle, or value
        ///
        V get(void) const
        {
            return iv_handle;
fffa5df0:	81 23 00 00 	lwz     r9,0(r3)
    // send the target type and instance as ffdc they will be used
    // to instantiate a target before logging the ffdc data
    // 0:47     = Target Type
    // 48:63    = instance

    uint64_t ret_value = static_cast<uint64_t>(i_value.get().getFapiTargetType());
fffa5df4:	7c 23 0b 78 	mr      r3,r1
fffa5df8:	95 23 00 08 	stwu    r9,8(r3)
fffa5dfc:	4b ff d8 71 	bl      fffa366c <_ZNK5fapi218plat_target_handle17getFapiTargetTypeEv>
fffa5e00:	89 5f 00 00 	lbz     r10,0(r31)

    //Add the target instance value.
    ret_value = ret_value | (i_value.get().getTargetInstance() & 0xFFFF);

    return ret_value;
};
fffa5e04:	80 01 00 24 	lwz     r0,36(r1)
    //TODO: Check if sending the multicast bit is actually required. I do not
    //see any HWP attempting to callect the FFDC on the multicasted target. HWSV
    //is not even expecting the multicast bit to be present.

    //setting multicast bit at MSB of target type
    ret_value = (ret_value | static_cast<uint64_t>(i_value.get().fields.is_multicast) << 47);
fffa5e08:	55 49 d7 fe 	rlwinm  r9,r10,26,31,31
fffa5e0c:	39 00 00 00 	li      r8,0

    //Add the target instance value.
    ret_value = ret_value | (i_value.get().getTargetInstance() & 0xFFFF);

    return ret_value;
};
fffa5e10:	7c 08 03 a6 	mtlr    r0
    //TODO: Check if sending the multicast bit is actually required. I do not
    //see any HWP attempting to callect the FFDC on the multicasted target. HWSV
    //is not even expecting the multicast bit to be present.

    //setting multicast bit at MSB of target type
    ret_value = (ret_value | static_cast<uint64_t>(i_value.get().fields.is_multicast) << 47);
fffa5e14:	79 06 7c 06 	rldicr  d6,d8,47,16
fffa5e18:	7c 68 33 78 	or      r8,r3,r6
fffa5e1c:	7c 89 23 78 	mr      r9,r4

    ret_value = ret_value << 16;

    //Add the target instance value.
    ret_value = ret_value | (i_value.get().getTargetInstance() & 0xFFFF);
fffa5e20:	88 9f 00 01 	lbz     r4,1(r31)
    //is not even expecting the multicast bit to be present.

    //setting multicast bit at MSB of target type
    ret_value = (ret_value | static_cast<uint64_t>(i_value.get().fields.is_multicast) << 47);

    ret_value = ret_value << 16;
fffa5e24:	79 08 83 e4 	rldicr  d8,d8,16,47

    //Add the target instance value.
    ret_value = ret_value | (i_value.get().getTargetInstance() & 0xFFFF);

    return ret_value;
};
fffa5e28:	17 c1 00 18 	lvd     d30,24(r1)
fffa5e2c:	7d 03 43 78 	mr      r3,r8
fffa5e30:	7c 84 4b 78 	or      r4,r4,r9
fffa5e34:	38 21 00 20 	addi    r1,r1,32
fffa5e38:	4e 80 00 20 	blr

fffa5e3c <spi_precheck>:
#endif // #ifndef BOOTLOADER

//Check the h/w is in the expected state
fapi2::ReturnCode
spi_precheck(SpiControlHandle& i_handle)
{
fffa5e3c:	94 21 ff d0 	stwu    r1,-48(r1)
fffa5e40:	7c 08 02 a6 	mflr    r0
fffa5e44:	1b 81 00 20 	stvd    d28,32(r1)
fffa5e48:	1b c1 00 28 	stvd    d30,40(r1)
fffa5e4c:	90 01 00 34 	stw     r0,52(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa5e50:	7c 25 0b 78 	mr      r5,r1
fffa5e54:	39 00 00 00 	li      r8,0
fffa5e58:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> status_reg = 0;
    uint64_t temp, flags;

    FAPI_TRY(getScom(i_handle.target_chip,
fffa5e5c:	80 83 00 08 	lwz     r4,8(r3)
fffa5e60:	59 05 00 08 	stvdu   d8,8(r5)
fffa5e64:	38 84 00 08 	addi    r4,r4,8
#endif // #ifndef BOOTLOADER

//Check the h/w is in the expected state
fapi2::ReturnCode
spi_precheck(SpiControlHandle& i_handle)
{
fffa5e68:	7c 7d 1b 78 	mr      r29,r3
fffa5e6c:	4b ff d7 55 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa5e70:	7c 7e 1b 78 	mr      r30,r3
    fapi2::buffer<uint64_t> status_reg = 0;
    uint64_t temp, flags;

    FAPI_TRY(getScom(i_handle.target_chip,
fffa5e74:	90 6d 46 f0 	stw     r3,18160(r13)
fffa5e78:	06 43 00 58 	bwnz    r3,fffa5f28 <spi_precheck+0xec>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fffa5e7c:	83 81 00 08 	lwz     r28,8(r1)
fffa5e80:	81 01 00 0c 	lwz     r8,12(r1)
    flags = SPI_RDR_FULL | SPI_RDR_OVERRUN |
            SPI_RDR_UNDERRUN | SPI_TDR_FULL |
            SPI_TDR_OVERRUN /*| SPI_TDR_UNDERRUN*/;

    // Check the h/w is in the expected state
    FAPI_ASSERT( !(temp & flags),
fffa5e84:	77 89 ec 00 	andis.  r9,r28,60416
fffa5e88:	06 c9 00 50 	bwz     r9,fffa5f28 <spi_precheck+0xec>
    {

    }
    SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE()
    {
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fffa5e8c:	3d 40 00 e1 	lis     r10,225
fffa5e90:	61 4a 64 fb 	ori     r10,r10,25851
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("The SPI status register state bits check validation failed.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fffa5e94:	3d 20 ff fb 	lis     r9,-5
fffa5e98:	3b e9 bb e8 	addi    r31,r9,-17432
fffa5e9c:	91 49 bb e8 	stw     r10,-17432(r9)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5ea0:	7f a3 eb 78 	mr      r3,r29
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("The SPI status register state bits check validation failed.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
        fapi2::g_FfdcData.ffdcLength = 5 * sizeof(sbeFfdc_t);
fffa5ea4:	39 20 00 3c 	li      r9,60
fffa5ea8:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE()
    {
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fffa5eac:	91 4d 46 f0 	stw     r10,18160(r13)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5eb0:	91 01 00 18 	stw     r8,24(r1)
fffa5eb4:	4b ff ff 29 	bl      fffa5ddc <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5eb8:	39 20 00 00 	li      r9,0
fffa5ebc:	61 29 ff fe 	ori     r9,r9,65534
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5ec0:	90 7f 00 0c 	stw     r3,12(r31)
fffa5ec4:	90 9f 00 10 	stw     r4,16(r31)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5ec8:	91 3f 00 08 	stw     r9,8(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa5ecc:	3c c0 ec 00 	lis     r6,-5120
template<typename T>
inline uint64_t convertType( T& i_value )
{
    // for simplicity sake, all FFDC chunks from the SBE
    // are going to be sent as a uint64_t
    return static_cast<uint64_t>(i_value);
fffa5ed0:	89 3d 00 04 	lbz     r9,4(r29)
fffa5ed4:	93 df 00 18 	stw     r30,24(r31)
fffa5ed8:	91 3f 00 1c 	stw     r9,28(r31)

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5edc:	39 20 00 01 	li      r9,1
fffa5ee0:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa5ee4:	38 e0 00 00 	li      r7,0
fffa5ee8:	81 3d 00 08 	lwz     r9,8(r29)
fffa5eec:	93 df 00 24 	stw     r30,36(r31)
fffa5ef0:	39 29 00 08 	addi    r9,r9,8
fffa5ef4:	91 3f 00 28 	stw     r9,40(r31)
  public:
    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5ef8:	39 20 00 04 	li      r9,4
fffa5efc:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa5f00:	93 9f 00 30 	stw     r28,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f04:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa5f08:	81 01 00 18 	lwz     r8,24(r1)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f0c:	91 3f 00 2c 	stw     r9,44(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa5f10:	91 1f 00 34 	stw     r8,52(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa5f14:	90 df 00 3c 	stw     r6,60(r31)
fffa5f18:	90 ff 00 40 	stw     r7,64(r31)
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f1c:	91 3f 00 38 	stw     r9,56(r31)
fffa5f20:	3c 60 7c 91 	lis     r3,31889
fffa5f24:	4b ff a7 9d 	bl      fffa06c0 <pk_trace_tiny>
#else
                 RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE);
#endif
fapi_try_exit:
    return fapi2::current_err;
}
fffa5f28:	80 01 00 34 	lwz     r0,52(r1)
fffa5f2c:	17 81 00 20 	lvd     d28,32(r1)
fffa5f30:	7c 08 03 a6 	mtlr    r0
fffa5f34:	17 c1 00 28 	lvd     d30,40(r1)
fffa5f38:	80 6d 46 f0 	lwz     r3,18160(r13)
fffa5f3c:	38 21 00 30 	addi    r1,r1,48
fffa5f40:	4e 80 00 20 	blr

fffa5f44 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>:
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
fffa5f44:	94 21 ff f0 	stwu    r1,-16(r1)
fffa5f48:	7c 08 02 a6 	mflr    r0
fffa5f4c:	1b c1 00 08 	stvd    d30,8(r1)
fffa5f50:	7c 7f 1b 78 	mr      r31,r3
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5f54:	7c 83 23 78 	mr      r3,r4
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
fffa5f58:	90 01 00 14 	stw     r0,20(r1)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5f5c:	4b ff fe 81 	bl      fffa5ddc <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
fffa5f60:	3d 20 ff fb 	lis     r9,-5
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f64:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5f68:	39 29 bb e8 	addi    r9,r9,-17432
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f6c:	61 4a ff fe 	ori     r10,r10,65534
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5f70:	90 69 00 0c 	stw     r3,12(r9)
fffa5f74:	90 89 00 10 	stw     r4,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5f78:	91 49 00 08 	stw     r10,8(r9)
        return *this;
    };
fffa5f7c:	7f e3 fb 78 	mr      r3,r31
fffa5f80:	80 01 00 14 	lwz     r0,20(r1)
fffa5f84:	17 c1 00 08 	lvd     d30,8(r1)
fffa5f88:	7c 08 03 a6 	mtlr    r0
fffa5f8c:	38 21 00 10 	addi    r1,r1,16
fffa5f90:	4e 80 00 20 	blr

fffa5f94 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>:
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
fffa5f94:	94 21 ff f0 	stwu    r1,-16(r1)
fffa5f98:	7c 08 02 a6 	mflr    r0
fffa5f9c:	1b c1 00 08 	stvd    d30,8(r1)
fffa5fa0:	7c 7f 1b 78 	mr      r31,r3
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5fa4:	7c 83 23 78 	mr      r3,r4
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
fffa5fa8:	90 01 00 14 	stw     r0,20(r1)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5fac:	4b ff fe 31 	bl      fffa5ddc <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
fffa5fb0:	3d 20 ff fb 	lis     r9,-5
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5fb4:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5fb8:	39 29 bb e8 	addi    r9,r9,-17432
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5fbc:	61 4a ff fe 	ori     r10,r10,65534
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fffa5fc0:	90 69 00 0c 	stw     r3,12(r9)
fffa5fc4:	90 89 00 10 	stw     r4,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa5fc8:	91 49 00 08 	stw     r10,8(r9)
        return *this;
    };
fffa5fcc:	7f e3 fb 78 	mr      r3,r31
fffa5fd0:	80 01 00 14 	lwz     r0,20(r1)
fffa5fd4:	17 c1 00 08 	lvd     d30,8(r1)
fffa5fd8:	7c 08 03 a6 	mtlr    r0
fffa5fdc:	38 21 00 10 	addi    r1,r1,16
fffa5fe0:	4e 80 00 20 	blr

fffa5fe4 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

//waits for transmit-data-register empty
static fapi2::ReturnCode
spi_wait_for_tdr_empty(SpiControlHandle& i_handle)
{
fffa5fe4:	94 21 ff d0 	stwu    r1,-48(r1)
fffa5fe8:	7c 08 02 a6 	mflr    r0
fffa5fec:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa5ff0:	39 00 00 00 	li      r8,0
fffa5ff4:	7c 3f 0b 78 	mr      r31,r1
fffa5ff8:	39 20 00 00 	li      r9,0
fffa5ffc:	1b 81 00 20 	stvd    d28,32(r1)
fffa6000:	90 01 00 34 	stw     r0,52(r1)
fffa6004:	59 1f 00 08 	stvdu   d8,8(r31)
fffa6008:	7c 7e 1b 78 	mr      r30,r3
fffa600c:	3b 80 00 00 	li      r28,0
fffa6010:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fffa6014:	80 9e 00 08 	lwz     r4,8(r30)
fffa6018:	7f c3 f3 78 	mr      r3,r30
fffa601c:	38 84 00 08 	addi    r4,r4,8
fffa6020:	7f e5 fb 78 	mr      r5,r31
fffa6024:	4b ff d5 9d 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa6028:	7c 69 1b 78 	mr      r9,r3
fffa602c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6030:	06 43 00 94 	bwnz    r3,fffa6158 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x174>
                          i_handle.base_addr + SPIM_STATUSREG, data64));

        //checking for multiplexing error
        FAPI_ASSERT( (data64.getBit<50>() == 0),
fffa6034:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa6038:	81 41 00 08 	lwz     r10,8(r1)
fffa603c:	07 88 90 3e 	bb0wi   r8,18,fffa60b8 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0xd4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6040:	3d 00 00 cd 	lis     r8,205
fffa6044:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6048:	3d 40 ff fb 	lis     r10,-5
fffa604c:	3b ea bb e8 	addi    r31,r10,-17432
fffa6050:	91 0a bb e8 	stw     r8,-17432(r10)
fffa6054:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fffa6058:	39 40 00 30 	li      r10,48
fffa605c:	7f c4 f3 78 	mr      r4,r30
fffa6060:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6064:	91 0d 46 f0 	stw     r8,18160(r13)
fffa6068:	91 21 00 18 	stw     r9,24(r1)
fffa606c:	4b ff fe d9 	bl      fffa5f44 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa6070:	89 5e 00 04 	lbz     r10,4(r30)
fffa6074:	3c 60 46 80 	lis     r3,18048
fffa6078:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa607c:	39 40 00 01 	li      r10,1
fffa6080:	81 21 00 18 	lwz     r9,24(r1)
fffa6084:	91 5f 00 14 	stw     r10,20(r31)
fffa6088:	91 3f 00 18 	stw     r9,24(r31)
fffa608c:	81 5e 00 08 	lwz     r10,8(r30)
fffa6090:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6094:	39 20 00 04 	li      r9,4
fffa6098:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa609c:	15 01 00 08 	lvd     d8,8(r1)
fffa60a0:	39 4a 00 08 	addi    r10,r10,8
fffa60a4:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa60a8:	39 20 00 08 	li      r9,8
fffa60ac:	91 5f 00 28 	stw     r10,40(r31)
fffa60b0:	91 3f 00 2c 	stw     r9,44(r31)
fffa60b4:	48 00 00 a0 	b       fffa6154 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x170>
                     "Port multiplexer setting error set in spi_wait_for_tdr_empty");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(!(data64.getBit<4>()))
fffa60b8:	07 8a 20 50 	bb0wi   r10,4,fffa6158 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x174>
fffa60bc:	33 bd ff ff 	addic   r29,r29,-1
fffa60c0:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> data64 = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fffa60c4:	7f 89 eb 78 	or      r9,r28,r29
fffa60c8:	06 49 07 a6 	bwnz    r9,fffa6014 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa60cc:	3d 00 00 1e 	lis     r8,30
fffa60d0:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fffa60d4:	3d 40 ff fb 	lis     r10,-5
fffa60d8:	3b ea bb e8 	addi    r31,r10,-17432
fffa60dc:	91 0a bb e8 	stw     r8,-17432(r10)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fffa60e0:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 5 * sizeof(sbeFfdc_t);
fffa60e4:	39 40 00 3c 	li      r10,60
fffa60e8:	7f c4 f3 78 	mr      r4,r30
fffa60ec:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa60f0:	91 0d 46 f0 	stw     r8,18160(r13)
fffa60f4:	91 21 00 18 	stw     r9,24(r1)
fffa60f8:	4b ff fe 9d 	bl      fffa5f94 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa60fc:	89 5e 00 04 	lbz     r10,4(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6100:	38 c0 00 00 	li      r6,0
fffa6104:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6108:	39 40 00 01 	li      r10,1
fffa610c:	81 21 00 18 	lwz     r9,24(r1)
fffa6110:	91 5f 00 14 	stw     r10,20(r31)
fffa6114:	91 3f 00 18 	stw     r9,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6118:	38 e0 27 10 	li      r7,10000
fffa611c:	81 5e 00 08 	lwz     r10,8(r30)
fffa6120:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6124:	39 20 00 04 	li      r9,4
fffa6128:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa612c:	15 01 00 08 	lvd     d8,8(r1)
fffa6130:	39 4a 00 08 	addi    r10,r10,8
fffa6134:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6138:	39 20 00 08 	li      r9,8
fffa613c:	91 5f 00 28 	stw     r10,40(r31)
fffa6140:	91 3f 00 2c 	stw     r9,44(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6144:	90 df 00 3c 	stw     r6,60(r31)
fffa6148:	90 ff 00 40 	stw     r7,64(r31)
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa614c:	91 3f 00 38 	stw     r9,56(r31)
fffa6150:	3c 60 3f 0b 	lis     r3,16139
fffa6154:	4b ff a5 6d 	bl      fffa06c0 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fffa6158:	80 01 00 34 	lwz     r0,52(r1)
fffa615c:	17 81 00 20 	lvd     d28,32(r1)
fffa6160:	7c 08 03 a6 	mtlr    r0
fffa6164:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fffa6168:	80 6d 46 f0 	lwz     r3,18160(r13)
}
fffa616c:	38 21 00 30 	addi    r1,r1,48
fffa6170:	4e 80 00 20 	blr

fffa6174 <_ZL17spi_wait_for_idleR16SpiControlHandle>:
}

//waits for the fsm of the spi-master to be idle
static fapi2::ReturnCode
spi_wait_for_idle(SpiControlHandle& i_handle)
{
fffa6174:	94 21 ff d0 	stwu    r1,-48(r1)
fffa6178:	7c 08 02 a6 	mflr    r0
fffa617c:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa6180:	39 00 00 00 	li      r8,0
fffa6184:	7c 3f 0b 78 	mr      r31,r1
fffa6188:	39 20 00 00 	li      r9,0
fffa618c:	1b 81 00 20 	stvd    d28,32(r1)
fffa6190:	90 01 00 34 	stw     r0,52(r1)
fffa6194:	59 1f 00 08 	stvdu   d8,8(r31)
fffa6198:	7c 7e 1b 78 	mr      r30,r3
fffa619c:	3b 80 00 00 	li      r28,0
fffa61a0:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fffa61a4:	80 9e 00 08 	lwz     r4,8(r30)
fffa61a8:	7f c3 f3 78 	mr      r3,r30
fffa61ac:	38 84 00 08 	addi    r4,r4,8
fffa61b0:	7f e5 fb 78 	mr      r5,r31
fffa61b4:	4b ff d4 0d 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa61b8:	7c 69 1b 78 	mr      r9,r3
fffa61bc:	90 6d 46 f0 	stw     r3,18160(r13)
fffa61c0:	06 43 00 94 	bwnz    r3,fffa62e8 <_ZL17spi_wait_for_idleR16SpiControlHandle+0x174>
                          i_handle.base_addr + SPIM_STATUSREG, data64));

        //checking for multiplexing error
        FAPI_ASSERT( (data64.getBit<50>() == 0),
fffa61c4:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa61c8:	81 41 00 08 	lwz     r10,8(r1)
fffa61cc:	07 88 90 3e 	bb0wi   r8,18,fffa6248 <_ZL17spi_wait_for_idleR16SpiControlHandle+0xd4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa61d0:	3d 00 00 cd 	lis     r8,205
fffa61d4:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa61d8:	3d 40 ff fb 	lis     r10,-5
fffa61dc:	3b ea bb e8 	addi    r31,r10,-17432
fffa61e0:	91 0a bb e8 	stw     r8,-17432(r10)
fffa61e4:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fffa61e8:	39 40 00 30 	li      r10,48
fffa61ec:	7f c4 f3 78 	mr      r4,r30
fffa61f0:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa61f4:	91 0d 46 f0 	stw     r8,18160(r13)
fffa61f8:	91 21 00 18 	stw     r9,24(r1)
fffa61fc:	4b ff fd 49 	bl      fffa5f44 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa6200:	89 5e 00 04 	lbz     r10,4(r30)
fffa6204:	3c 60 4b 06 	lis     r3,19206
fffa6208:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa620c:	39 40 00 01 	li      r10,1
fffa6210:	81 21 00 18 	lwz     r9,24(r1)
fffa6214:	91 5f 00 14 	stw     r10,20(r31)
fffa6218:	91 3f 00 18 	stw     r9,24(r31)
fffa621c:	81 5e 00 08 	lwz     r10,8(r30)
fffa6220:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6224:	39 20 00 04 	li      r9,4
fffa6228:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa622c:	15 01 00 08 	lvd     d8,8(r1)
fffa6230:	39 4a 00 08 	addi    r10,r10,8
fffa6234:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6238:	39 20 00 08 	li      r9,8
fffa623c:	91 5f 00 28 	stw     r10,40(r31)
fffa6240:	91 3f 00 2c 	stw     r9,44(r31)
fffa6244:	48 00 00 a0 	b       fffa62e4 <_ZL17spi_wait_for_idleR16SpiControlHandle+0x170>
                     "Port multiplexer setting error set in spi_wait_for_idle");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(data64.getBit<15>())  //seq fsm Idle
fffa6248:	07 0a 78 50 	bb1wi   r10,15,fffa62e8 <_ZL17spi_wait_for_idleR16SpiControlHandle+0x174>
fffa624c:	33 bd ff ff 	addic   r29,r29,-1
fffa6250:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> data64 = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fffa6254:	7f 89 eb 78 	or      r9,r28,r29
fffa6258:	06 49 07 a6 	bwnz    r9,fffa61a4 <_ZL17spi_wait_for_idleR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa625c:	3d 00 00 1e 	lis     r8,30
fffa6260:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fffa6264:	3d 40 ff fb 	lis     r10,-5
fffa6268:	3b ea bb e8 	addi    r31,r10,-17432
fffa626c:	91 0a bb e8 	stw     r8,-17432(r10)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fffa6270:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 5 * sizeof(sbeFfdc_t);
fffa6274:	39 40 00 3c 	li      r10,60
fffa6278:	7f c4 f3 78 	mr      r4,r30
fffa627c:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa6280:	91 0d 46 f0 	stw     r8,18160(r13)
fffa6284:	91 21 00 18 	stw     r9,24(r1)
fffa6288:	4b ff fd 0d 	bl      fffa5f94 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa628c:	89 5e 00 04 	lbz     r10,4(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6290:	38 c0 00 00 	li      r6,0
fffa6294:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6298:	39 40 00 01 	li      r10,1
fffa629c:	81 21 00 18 	lwz     r9,24(r1)
fffa62a0:	91 5f 00 14 	stw     r10,20(r31)
fffa62a4:	91 3f 00 18 	stw     r9,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa62a8:	38 e0 27 10 	li      r7,10000
fffa62ac:	81 5e 00 08 	lwz     r10,8(r30)
fffa62b0:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa62b4:	39 20 00 04 	li      r9,4
fffa62b8:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa62bc:	15 01 00 08 	lvd     d8,8(r1)
fffa62c0:	39 4a 00 08 	addi    r10,r10,8
fffa62c4:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa62c8:	39 20 00 08 	li      r9,8
fffa62cc:	91 5f 00 28 	stw     r10,40(r31)
fffa62d0:	91 3f 00 2c 	stw     r9,44(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa62d4:	90 df 00 3c 	stw     r6,60(r31)
fffa62d8:	90 ff 00 40 	stw     r7,64(r31)
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa62dc:	91 3f 00 38 	stw     r9,56(r31)
fffa62e0:	3c 60 02 03 	lis     r3,515
fffa62e4:	4b ff a3 dd 	bl      fffa06c0 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fffa62e8:	80 01 00 34 	lwz     r0,52(r1)
fffa62ec:	17 81 00 20 	lvd     d28,32(r1)
fffa62f0:	7c 08 03 a6 	mtlr    r0
fffa62f4:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fffa62f8:	80 6d 46 f0 	lwz     r3,18160(r13)
}
fffa62fc:	38 21 00 30 	addi    r1,r1,48
fffa6300:	4e 80 00 20 	blr

fffa6304 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>:
}

//waits for receive-data-register full
static fapi2::ReturnCode
spi_wait_for_rdr_full(SpiControlHandle& i_handle)
{
fffa6304:	94 21 ff d0 	stwu    r1,-48(r1)
fffa6308:	7c 08 02 a6 	mflr    r0
fffa630c:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa6310:	39 00 00 00 	li      r8,0
fffa6314:	7c 3f 0b 78 	mr      r31,r1
fffa6318:	39 20 00 00 	li      r9,0
fffa631c:	1b 81 00 20 	stvd    d28,32(r1)
fffa6320:	90 01 00 34 	stw     r0,52(r1)
fffa6324:	59 1f 00 08 	stvdu   d8,8(r31)
fffa6328:	7c 7e 1b 78 	mr      r30,r3
fffa632c:	3b 80 00 00 	li      r28,0
fffa6330:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fffa6334:	80 9e 00 08 	lwz     r4,8(r30)
fffa6338:	7f c3 f3 78 	mr      r3,r30
fffa633c:	38 84 00 08 	addi    r4,r4,8
fffa6340:	7f e5 fb 78 	mr      r5,r31
fffa6344:	4b ff d2 7d 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa6348:	7c 69 1b 78 	mr      r9,r3
fffa634c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6350:	06 43 00 94 	bwnz    r3,fffa6478 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x174>
                          i_handle.base_addr + SPIM_STATUSREG, status_reg));

        //checking for multiplexing error
        FAPI_ASSERT( (status_reg.getBit<50>() == 0),
fffa6354:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa6358:	81 41 00 08 	lwz     r10,8(r1)
fffa635c:	07 88 90 3e 	bb0wi   r8,18,fffa63d8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0xd4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6360:	3d 00 00 cd 	lis     r8,205
fffa6364:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6368:	3d 40 ff fb 	lis     r10,-5
fffa636c:	3b ea bb e8 	addi    r31,r10,-17432
fffa6370:	91 0a bb e8 	stw     r8,-17432(r10)
fffa6374:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fffa6378:	39 40 00 30 	li      r10,48
fffa637c:	7f c4 f3 78 	mr      r4,r30
fffa6380:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6384:	91 0d 46 f0 	stw     r8,18160(r13)
fffa6388:	91 21 00 18 	stw     r9,24(r1)
fffa638c:	4b ff fb b9 	bl      fffa5f44 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa6390:	89 5e 00 04 	lbz     r10,4(r30)
fffa6394:	3c 60 92 f0 	lis     r3,-27920
fffa6398:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa639c:	39 40 00 01 	li      r10,1
fffa63a0:	81 21 00 18 	lwz     r9,24(r1)
fffa63a4:	91 5f 00 14 	stw     r10,20(r31)
fffa63a8:	91 3f 00 18 	stw     r9,24(r31)
fffa63ac:	81 5e 00 08 	lwz     r10,8(r30)
fffa63b0:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa63b4:	39 20 00 04 	li      r9,4
fffa63b8:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa63bc:	15 01 00 08 	lvd     d8,8(r1)
fffa63c0:	39 4a 00 08 	addi    r10,r10,8
fffa63c4:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa63c8:	39 20 00 08 	li      r9,8
fffa63cc:	91 5f 00 28 	stw     r10,40(r31)
fffa63d0:	91 3f 00 2c 	stw     r9,44(r31)
fffa63d4:	48 00 00 a0 	b       fffa6474 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x170>
                     "Port multiplexer setting error set in spi_wait_for_rdr_full");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(status_reg.getBit<0>()) //Wait until RX Buffer is full
fffa63d8:	06 8a 00 50 	bwltz   r10,fffa6478 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x174>
fffa63dc:	33 bd ff ff 	addic   r29,r29,-1
fffa63e0:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fffa63e4:	7f 89 eb 78 	or      r9,r28,r29
fffa63e8:	06 49 07 a6 	bwnz    r9,fffa6334 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa63ec:	3d 00 00 1e 	lis     r8,30
fffa63f0:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fffa63f4:	3d 40 ff fb 	lis     r10,-5
fffa63f8:	3b ea bb e8 	addi    r31,r10,-17432
fffa63fc:	91 0a bb e8 	stw     r8,-17432(r10)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fffa6400:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 5 * sizeof(sbeFfdc_t);
fffa6404:	39 40 00 3c 	li      r10,60
fffa6408:	7f c4 f3 78 	mr      r4,r30
fffa640c:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa6410:	91 0d 46 f0 	stw     r8,18160(r13)
fffa6414:	91 21 00 18 	stw     r9,24(r1)
fffa6418:	4b ff fb 7d 	bl      fffa5f94 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa641c:	89 5e 00 04 	lbz     r10,4(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6420:	38 c0 00 00 	li      r6,0
fffa6424:	91 5f 00 1c 	stw     r10,28(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6428:	39 40 00 01 	li      r10,1
fffa642c:	81 21 00 18 	lwz     r9,24(r1)
fffa6430:	91 5f 00 14 	stw     r10,20(r31)
fffa6434:	91 3f 00 18 	stw     r9,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6438:	38 e0 27 10 	li      r7,10000
fffa643c:	81 5e 00 08 	lwz     r10,8(r30)
fffa6440:	91 3f 00 24 	stw     r9,36(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6444:	39 20 00 04 	li      r9,4
fffa6448:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa644c:	15 01 00 08 	lvd     d8,8(r1)
fffa6450:	39 4a 00 08 	addi    r10,r10,8
fffa6454:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6458:	39 20 00 08 	li      r9,8
fffa645c:	91 5f 00 28 	stw     r10,40(r31)
fffa6460:	91 3f 00 2c 	stw     r9,44(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa6464:	90 df 00 3c 	stw     r6,60(r31)
fffa6468:	90 ff 00 40 	stw     r7,64(r31)
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa646c:	91 3f 00 38 	stw     r9,56(r31)
fffa6470:	3c 60 14 43 	lis     r3,5187
fffa6474:	4b ff a2 4d 	bl      fffa06c0 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fffa6478:	80 01 00 34 	lwz     r0,52(r1)
fffa647c:	17 81 00 20 	lvd     d28,32(r1)
fffa6480:	7c 08 03 a6 	mtlr    r0
fffa6484:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fffa6488:	80 6d 46 f0 	lwz     r3,18160(r13)
}
fffa648c:	38 21 00 30 	addi    r1,r1,48
fffa6490:	4e 80 00 20 	blr

fffa6494 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>:
    uint64_t CNT = 0;
    uint64_t TDR;
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    int number_rdr = i_length / 8;

    if ((i_length > MAX_LENGTH_TRNS) || (i_length % 8))
fffa6494:	28 05 00 08 	cmplwi  r5,8
 */
#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_read_secure(SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
                uint8_t* o_buffer, SPI_ECC_CONTROL_STATUS i_eccStatus)
{
fffa6498:	94 21 ff c8 	stwu    r1,-56(r1)
fffa649c:	7c 08 02 a6 	mflr    r0
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa64a0:	39 00 00 00 	li      r8,0
fffa64a4:	39 20 00 00 	li      r9,0
fffa64a8:	1b 81 00 28 	stvd    d28,40(r1)
fffa64ac:	90 01 00 3c 	stw     r0,60(r1)
fffa64b0:	1b c1 00 30 	stvd    d30,48(r1)
fffa64b4:	7c bd 2b 78 	mr      r29,r5
fffa64b8:	90 c1 00 18 	stw     r6,24(r1)
fffa64bc:	19 01 00 08 	stvd    d8,8(r1)
    uint64_t CNT = 0;
    uint64_t TDR;
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    int number_rdr = i_length / 8;

    if ((i_length > MAX_LENGTH_TRNS) || (i_length % 8))
fffa64c0:	41 81 00 0c 	bgt     fffa64cc <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x38>
fffa64c4:	54 a9 07 7e 	clrlwi  r9,r5,29
fffa64c8:	06 c9 00 08 	bwz     r9,fffa64d8 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x44>
    {
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
fffa64cc:	3c 60 04 00 	lis     r3,1024
fffa64d0:	60 63 00 04 	ori     r3,r3,4
fffa64d4:	48 00 01 7c 	b       fffa6650 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1bc>
fffa64d8:	7c 7f 1b 78 	mr      r31,r3
fffa64dc:	7c 9e 23 78 	mr      r30,r4
    }


    if((i_eccStatus == STANDARD_ECC_ACCESS) ||
fffa64e0:	07 47 f0 18 	clrbwibnz r7,30,fffa6510 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x7c>
       (i_eccStatus == DISCARD_ECC_ACCESS)   )
    {
        if (i_address % 8) //Address should be aligned for ecc
fffa64e4:	54 89 07 7e 	clrlwi  r9,r4,29
fffa64e8:	06 49 07 f2 	bwnz    r9,fffa64cc <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x38>
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        if (i_length <= 8)
        {
            SEQ = 0x1034491000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); // slave0, TX4, RX9, loop
fffa64ec:	a1 23 00 06 	lhz     r9,6(r3)
fffa64f0:	39 00 00 00 	li      r8,0
fffa64f4:	79 08 c1 c6 	rldicr  d8,d8,56,7
fffa64f8:	65 05 10 34 	oris    r5,r8,4148
            FAPI_ERR( "spi_read_secure: (ecc) Read length is greater than 40 bytes, which cannot be"
                      " done in a secure read. i_length = %d", i_length);
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        i_address = i_address * 9 / 8;
fffa64fc:	1f c4 00 09 	mulli   r30,r4,9
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        if (i_length <= 8)
        {
            SEQ = 0x1034491000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); // slave0, TX4, RX9, loop
fffa6500:	60 a5 49 10 	ori     r5,r5,18704
fffa6504:	7d 26 4b 78 	mr      r6,r9
            FAPI_ERR( "spi_read_secure: (ecc) Read length is greater than 40 bytes, which cannot be"
                      " done in a secure read. i_length = %d", i_length);
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        i_address = i_address * 9 / 8;
fffa6508:	57 de e8 fe 	rlwinm  r30,r30,29,3,31
fffa650c:	48 00 00 1c 	b       fffa6528 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x94>
    }
    else
    {
        if (i_length <= 8)
        {
            SEQ = 0x1034481000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); //slave0, TX4, RX8, loop
fffa6510:	a1 23 00 06 	lhz     r9,6(r3)
fffa6514:	39 00 00 00 	li      r8,0
fffa6518:	79 08 c1 c6 	rldicr  d8,d8,56,7
fffa651c:	65 05 10 34 	oris    r5,r8,4148
fffa6520:	60 a5 48 10 	ori     r5,r5,18448
fffa6524:	7d 26 4b 78 	mr      r6,r9
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }
    }

    //Check the state of the h/w
    rc = spi_precheck(i_handle);
fffa6528:	7f e3 fb 78 	mr      r3,r31
fffa652c:	90 a1 00 1c 	stw     r5,28(r1)
fffa6530:	90 c1 00 20 	stw     r6,32(r1)
fffa6534:	4b ff f9 09 	bl      fffa5e3c <spi_precheck>
fffa6538:	7c 7c 1b 78 	mr      r28,r3

    if (rc != fapi2::FAPI2_RC_SUCCESS)
fffa653c:	80 a1 00 1c 	lwz     r5,28(r1)
fffa6540:	80 c1 00 20 	lwz     r6,32(r1)
fffa6544:	06 5c 00 86 	bwnz    r28,fffa6650 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1bc>
    }

    /*Read command (0x3)|| address in TDR to be sent to the slave*/
    TDR = SPI_SLAVE_RD_CMD | ((uint64_t)i_address << 32);

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fffa6548:	80 9f 00 08 	lwz     r4,8(r31)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa654c:	7f e3 fb 78 	mr      r3,r31
fffa6550:	38 84 00 07 	addi    r4,r4,7
fffa6554:	4b ff d0 c1 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6558:	90 6d 46 f0 	stw     r3,18160(r13)
fffa655c:	06 43 00 78 	bwnz    r3,fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fffa6560:	80 9f 00 08 	lwz     r4,8(r31)
fffa6564:	7f e3 fb 78 	mr      r3,r31
fffa6568:	38 84 00 01 	addi    r4,r4,1
fffa656c:	38 a0 00 00 	li      r5,0
fffa6570:	38 c0 00 00 	li      r6,0
fffa6574:	4b ff d0 a1 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6578:	90 6d 46 f0 	stw     r3,18160(r13)
fffa657c:	06 43 00 68 	bwnz    r3,fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, TDR));
fffa6580:	80 9f 00 08 	lwz     r4,8(r31)
fffa6584:	67 c5 03 00 	oris    r5,r30,768
fffa6588:	7f e3 fb 78 	mr      r3,r31
fffa658c:	38 84 00 05 	addi    r4,r4,5
fffa6590:	38 c0 00 00 	li      r6,0
fffa6594:	4b ff d0 81 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6598:	90 6d 46 f0 	stw     r3,18160(r13)
fffa659c:	3b c0 00 00 	li      r30,0
fffa65a0:	06 43 00 56 	bwnz    r3,fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
    {
        rc = spi_wait_for_rdr_full(i_handle);
fffa65a4:	7f e3 fb 78 	mr      r3,r31
        }

        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
fffa65a8:	05 1e e8 24 	cmplwbge r30,r29,fffa65f0 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x15c>
    {
        rc = spi_wait_for_rdr_full(i_handle);
fffa65ac:	4b ff fd 59 	bl      fffa6304 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fffa65b0:	7c 7c 1b 78 	mr      r28,r3

        if (rc)
fffa65b4:	06 c3 00 06 	bwz     r3,fffa65c0 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x12c>
        {
            FAPI_ERR("Error in spi_wait_for_rdr_full");
fffa65b8:	3c 60 c9 6f 	lis     r3,-13969
fffa65bc:	48 00 00 44 	b       fffa6600 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x16c>
            fapi2::current_err = rc;
            goto fapi_try_exit;
        }

        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fffa65c0:	80 9f 00 08 	lwz     r4,8(r31)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa65c4:	7f e3 fb 78 	mr      r3,r31
fffa65c8:	38 84 00 06 	addi    r4,r4,6
fffa65cc:	38 a1 00 08 	addi    r5,r1,8
fffa65d0:	4b ff cf f1 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa65d4:	90 6d 46 f0 	stw     r3,18160(r13)
fffa65d8:	06 43 00 3a 	bwnz    r3,fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fffa65dc:	15 01 00 08 	lvd     d8,8(r1)
        data64.extract<0, 64>(temp);
#ifndef _BIG_ENDIAN
        fapi2::endian_swap(temp);
#endif
        ((uint64_t*)o_buffer)[i / 8] = temp;
fffa65e0:	81 41 00 18 	lwz     r10,24(r1)
        }

        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
fffa65e4:	3b de 00 08 	addi    r30,r30,8
        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
        data64.extract<0, 64>(temp);
#ifndef _BIG_ENDIAN
        fapi2::endian_swap(temp);
#endif
        ((uint64_t*)o_buffer)[i / 8] = temp;
fffa65e8:	19 0a 00 00 	stvd    d8,0(r10)
fffa65ec:	4b ff ff b8 	b       fffa65a4 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x110>
    }

    rc = spi_wait_for_idle(i_handle);
fffa65f0:	4b ff fb 85 	bl      fffa6174 <_ZL17spi_wait_for_idleR16SpiControlHandle>
fffa65f4:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fffa65f8:	06 c3 00 0a 	bwz     r3,fffa660c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x178>
    {
        FAPI_ERR("Multiplexing Error in spi_wait_for_idle ");
fffa65fc:	3c 60 03 7d 	lis     r3,893
fffa6600:	4b ff a0 c1 	bl      fffa06c0 <pk_trace_tiny>
        fapi2::current_err = rc;
fffa6604:	93 8d 46 f0 	stw     r28,18160(r13)
        goto fapi_try_exit;
fffa6608:	48 00 00 44 	b       fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    }

    /*Restore the default counter and seq used by the side band path*/
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, 0x0ULL));
fffa660c:	80 9f 00 08 	lwz     r4,8(r31)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa6610:	7f e3 fb 78 	mr      r3,r31
fffa6614:	38 84 00 01 	addi    r4,r4,1
fffa6618:	38 a0 00 00 	li      r5,0
fffa661c:	38 c0 00 00 	li      r6,0
fffa6620:	4b ff cf f5 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6624:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6628:	06 43 00 12 	bwnz    r3,fffa664c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip,
fffa662c:	80 9f 00 08 	lwz     r4,8(r31)
fffa6630:	3c a0 11 34 	lis     r5,4404
fffa6634:	7f e3 fb 78 	mr      r3,r31
fffa6638:	38 84 00 07 	addi    r4,r4,7
fffa663c:	60 a5 49 10 	ori     r5,r5,18704
fffa6640:	38 c0 00 00 	li      r6,0
fffa6644:	4b ff cf d1 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6648:	90 6d 46 f0 	stw     r3,18160(r13)
                     i_handle.base_addr + SPIM_SEQREG, SPI_DEFAULT_SEQ));

fapi_try_exit:
    return fapi2::current_err;
fffa664c:	80 6d 46 f0 	lwz     r3,18160(r13)
}
fffa6650:	80 01 00 3c 	lwz     r0,60(r1)
fffa6654:	17 81 00 28 	lvd     d28,40(r1)
fffa6658:	7c 08 03 a6 	mtlr    r0
fffa665c:	17 c1 00 30 	lvd     d30,48(r1)
fffa6660:	38 21 00 38 	addi    r1,r1,56
fffa6664:	4e 80 00 20 	blr

fffa6668 <spi_read>:

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fffa6668:	94 21 ff c8 	stwu    r1,-56(r1)
fffa666c:	7c 08 02 a6 	mflr    r0
fffa6670:	1b 81 00 28 	stvd    d28,40(r1)
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fffa6674:	39 20 00 00 	li      r9,0

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fffa6678:	7c 9c 23 78 	mr      r28,r4
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fffa667c:	7c 24 0b 78 	mr      r4,r1

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fffa6680:	1b c1 00 30 	stvd    d30,48(r1)
fffa6684:	90 01 00 3c 	stw     r0,60(r1)
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fffa6688:	9d 24 00 08 	stbu    r9,8(r4)

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fffa668c:	7c 7f 1b 78 	mr      r31,r3
fffa6690:	7c be 2b 78 	mr      r30,r5
fffa6694:	90 c1 00 18 	stw     r6,24(r1)
fffa6698:	7c fd 3b 78 	mr      r29,r7
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
    is_ecc_on(i_handle, l_ecc);
fffa669c:	4b ff f6 d1 	bl      fffa5d6c <_ZL9is_ecc_onR16SpiControlHandleRb>

    if ((i_eccStatus == RAW_BYTE_ACCESS) && (l_ecc))
fffa66a0:	81 21 00 18 	lwz     r9,24(r1)
fffa66a4:	06 49 08 0a 	cmpwibne r9,1,fffa66b8 <spi_read+0x50>
fffa66a8:	89 21 00 08 	lbz     r9,8(r1)
fffa66ac:	06 c9 00 06 	bwz     r9,fffa66b8 <spi_read+0x50>
    {
        spi_set_ecc_off(i_handle);
fffa66b0:	7f e3 fb 78 	mr      r3,r31
fffa66b4:	4b ff f5 d1 	bl      fffa5c84 <_ZL15spi_set_ecc_offR16SpiControlHandle>
    }

    do
    {

        if (i_length <= MAX_LENGTH_TRNS)
fffa66b8:	28 1e 00 08 	cmplwi  r30,8
fffa66bc:	39 00 00 00 	li      r8,0
fffa66c0:	41 a1 00 68 	bgt     fffa6728 <spi_read+0xc0>
        {
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
fffa66c4:	80 e1 00 18 	lwz     r7,24(r1)
fffa66c8:	7f e3 fb 78 	mr      r3,r31
fffa66cc:	7f 84 e3 78 	mr      r4,r28
fffa66d0:	7f c5 f3 78 	mr      r5,r30
fffa66d4:	7f a6 eb 78 	mr      r6,r29
fffa66d8:	4b ff fd bd 	bl      fffa6494 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>
fffa66dc:	7c 6a 1b 78 	mr      r10,r3
            break;
fffa66e0:	48 00 00 60 	b       fffa6740 <spi_read+0xd8>
        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
        {
            readlen = (i_length - i) < MAX_LENGTH_TRNS ?
                      (i_length - i) : MAX_LENGTH_TRNS;

            if (readlen == 0)
fffa66e4:	06 c9 00 2c 	bwz     r9,fffa673c <spi_read+0xd4>
            {
                break;
            }

            rc = spi_read_secure( i_handle, i_address,
                                  readlen, o_buffer, i_eccStatus );
fffa66e8:	80 e1 00 18 	lwz     r7,24(r1)
fffa66ec:	7d 25 4b 78 	mr      r5,r9
fffa66f0:	7f e3 fb 78 	mr      r3,r31
fffa66f4:	7f 84 e3 78 	mr      r4,r28
fffa66f8:	7f a6 eb 78 	mr      r6,r29
fffa66fc:	91 01 00 20 	stw     r8,32(r1)
fffa6700:	91 21 00 1c 	stw     r9,28(r1)
fffa6704:	4b ff fd 91 	bl      fffa6494 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>
fffa6708:	7c 6a 1b 78 	mr      r10,r3

            if (rc != fapi2::FAPI2_RC_SUCCESS)
fffa670c:	81 01 00 20 	lwz     r8,32(r1)
fffa6710:	81 21 00 1c 	lwz     r9,28(r1)
fffa6714:	06 43 00 16 	bwnz    r3,fffa6740 <spi_read+0xd8>
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
            break;
        }

        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
fffa6718:	39 08 00 08 	addi    r8,r8,8
            if (rc != fapi2::FAPI2_RC_SUCCESS)
            {
                break;
            }

            i_address += readlen;
fffa671c:	7f 9c 4a 14 	add     r28,r28,r9
            o_buffer = (uint8_t*)(reinterpret_cast<uint64_t>(o_buffer) + readlen);
fffa6720:	7f bd 4a 14 	add     r29,r29,r9
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
            break;
        }

        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
fffa6724:	05 08 f0 0e 	cmplwbge r8,r30,fffa6740 <spi_read+0xd8>
fffa6728:	7d 28 f0 50 	subf    r9,r8,r30
        {
            readlen = (i_length - i) < MAX_LENGTH_TRNS ?
                      (i_length - i) : MAX_LENGTH_TRNS;
fffa672c:	28 09 00 08 	cmplwi  r9,8
fffa6730:	40 a1 ff b4 	ble     fffa66e4 <spi_read+0x7c>
fffa6734:	39 20 00 08 	li      r9,8
fffa6738:	4b ff ff b0 	b       fffa66e8 <spi_read+0x80>
fffa673c:	39 40 00 00 	li      r10,0

    }
    while(0);

    // Restore ECC setting, if necessary
    if ((i_eccStatus == RAW_BYTE_ACCESS) && (l_ecc))
fffa6740:	81 21 00 18 	lwz     r9,24(r1)
fffa6744:	06 49 08 0e 	cmpwibne r9,1,fffa6760 <spi_read+0xf8>
fffa6748:	89 21 00 08 	lbz     r9,8(r1)
fffa674c:	06 c9 00 0a 	bwz     r9,fffa6760 <spi_read+0xf8>
    {
        spi_set_ecc_on(i_handle);
fffa6750:	7f e3 fb 78 	mr      r3,r31
fffa6754:	91 41 00 1c 	stw     r10,28(r1)
fffa6758:	4b ff f5 a1 	bl      fffa5cf8 <_ZL14spi_set_ecc_onR16SpiControlHandle>
fffa675c:	81 41 00 1c 	lwz     r10,28(r1)
    }

    return rc;
}
fffa6760:	80 01 00 3c 	lwz     r0,60(r1)
fffa6764:	17 81 00 28 	lvd     d28,40(r1)
fffa6768:	7c 08 03 a6 	mtlr    r0
fffa676c:	17 c1 00 30 	lvd     d30,48(r1)
fffa6770:	7d 43 53 78 	mr      r3,r10
fffa6774:	38 21 00 38 	addi    r1,r1,56
fffa6778:	4e 80 00 20 	blr

fffa677c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31>:
 * @param[in]  i_handle - handle for SPI operations
 * @param[in]  i_index - SEQ index to check has executed
 * @return     Error RC if timeout or multiplexing error detected
 */
static fapi2::ReturnCode
spi_wait_for_seq_index_pass(SpiControlHandle& i_handle, const uint32_t i_index)
fffa677c:	94 21 ff d0 	stwu    r1,-48(r1)
fffa6780:	7c 08 02 a6 	mflr    r0
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa6784:	7c 28 0b 78 	mr      r8,r1
fffa6788:	38 c0 00 00 	li      r6,0
fffa678c:	38 e0 00 00 	li      r7,0
fffa6790:	1b c1 00 28 	stvd    d30,40(r1)
fffa6794:	1b 81 00 20 	stvd    d28,32(r1)
fffa6798:	90 01 00 34 	stw     r0,52(r1)
fffa679c:	58 c8 00 08 	stvdu   d6,8(r8)
fffa67a0:	7c 7d 1b 78 	mr      r29,r3
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;
fffa67a4:	3b c0 00 00 	li      r30,0
fffa67a8:	3b e0 27 10 	li      r31,10000

    while(timeout--)
fffa67ac:	33 ff ff ff 	addic   r31,r31,-1
fffa67b0:	7f de 01 d4 	addme   r30,r30
fffa67b4:	2c 1e ff ff 	cmpwi   r30,-1
fffa67b8:	41 82 00 c4 	beq     fffa687c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x100>
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fffa67bc:	80 9d 00 08 	lwz     r4,8(r29)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa67c0:	7d 05 43 78 	mr      r5,r8
fffa67c4:	7f a3 eb 78 	mr      r3,r29
fffa67c8:	38 84 00 08 	addi    r4,r4,8
fffa67cc:	91 01 00 18 	stw     r8,24(r1)
fffa67d0:	4b ff cd f1 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa67d4:	7c 7c 1b 78 	mr      r28,r3
fffa67d8:	90 6d 46 f0 	stw     r3,18160(r13)
fffa67dc:	81 01 00 18 	lwz     r8,24(r1)
fffa67e0:	06 43 00 a4 	bwnz    r3,fffa6928 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x1ac>
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fffa67e4:	15 21 00 08 	lvd     d9,8(r1)
fffa67e8:	55 4a 04 a4 	rlwinm  r10,r10,0,18,18
                          i_handle.base_addr + SPIM_STATUSREG, status_reg));

        //checking for multiplexing error
        FAPI_ASSERT( (status_reg.getBit<50>() == 0),
fffa67ec:	06 ca 00 3c 	bwz     r10,fffa6864 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0xe8>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa67f0:	3d 40 00 cd 	lis     r10,205
fffa67f4:	61 4a af 48 	ori     r10,r10,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa67f8:	3d 20 ff fb 	lis     r9,-5
fffa67fc:	3b e9 bb e8 	addi    r31,r9,-17432
fffa6800:	91 49 bb e8 	stw     r10,-17432(r9)
fffa6804:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fffa6808:	39 20 00 30 	li      r9,48
fffa680c:	7f a4 eb 78 	mr      r4,r29
fffa6810:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fffa6814:	91 4d 46 f0 	stw     r10,18160(r13)
fffa6818:	4b ff f7 2d 	bl      fffa5f44 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa681c:	89 3d 00 04 	lbz     r9,4(r29)
fffa6820:	93 9f 00 18 	stw     r28,24(r31)
fffa6824:	91 3f 00 1c 	stw     r9,28(r31)

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6828:	39 20 00 01 	li      r9,1
fffa682c:	91 3f 00 14 	stw     r9,20(r31)
fffa6830:	3c 60 03 ff 	lis     r3,1023
fffa6834:	81 3d 00 08 	lwz     r9,8(r29)
fffa6838:	93 9f 00 24 	stw     r28,36(r31)
fffa683c:	39 29 00 08 	addi    r9,r9,8
fffa6840:	91 3f 00 28 	stw     r9,40(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6844:	39 20 00 04 	li      r9,4
fffa6848:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa684c:	15 01 00 08 	lvd     d8,8(r1)
fffa6850:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6854:	39 20 00 08 	li      r9,8
fffa6858:	91 3f 00 2c 	stw     r9,44(r31)
fffa685c:	4b ff 9e 65 	bl      fffa06c0 <pk_trace_tiny>
fffa6860:	48 00 00 c8 	b       fffa6928 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x1ac>
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        // 28 to 31 Sequencer index - Sequence index currently being executed
        status_reg = (status_reg >> 32) & 0x000000000000000FULL;
fffa6864:	55 29 07 3e 	clrlwi  r9,r9,28

        if(status_reg > i_index)
fffa6868:	28 09 00 03 	cmplwi  r9,3
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        // 28 to 31 Sequencer index - Sequence index currently being executed
        status_reg = (status_reg >> 32) & 0x000000000000000FULL;
fffa686c:	91 41 00 08 	stw     r10,8(r1)
fffa6870:	91 21 00 0c 	stw     r9,12(r1)

        if(status_reg > i_index)
fffa6874:	40 81 ff 38 	ble     fffa67ac <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x30>
fffa6878:	48 00 00 10 	b       fffa6888 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x10c>
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout--)
fffa687c:	2c 1f ff ff 	cmpwi   r31,-1
fffa6880:	40 82 ff 3c 	bne     fffa67bc <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x40>
fffa6884:	48 00 00 a4 	b       fffa6928 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x1ac>
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
    }

    FAPI_DBG("wait_for_seq_index_pass(%d) timeout %lld msec", i_index, timeout);
    FAPI_ASSERT( timeout != 0,
fffa6888:	7f de fb 78 	or      r30,r30,r31
fffa688c:	06 5e 00 4e 	bwnz    r30,fffa6928 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31+0x1ac>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa6890:	3d 40 00 1e 	lis     r10,30
fffa6894:	61 4a da 3a 	ori     r10,r10,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fffa6898:	3d 20 ff fb 	lis     r9,-5
fffa689c:	3b e9 bb e8 	addi    r31,r9,-17432
fffa68a0:	91 49 bb e8 	stw     r10,-17432(r9)
fffa68a4:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 5 * sizeof(sbeFfdc_t);
fffa68a8:	39 20 00 3c 	li      r9,60
fffa68ac:	7f a4 eb 78 	mr      r4,r29
fffa68b0:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fffa68b4:	91 4d 46 f0 	stw     r10,18160(r13)
fffa68b8:	4b ff f6 dd 	bl      fffa5f94 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fffa68bc:	89 3d 00 04 	lbz     r9,4(r29)
fffa68c0:	93 df 00 18 	stw     r30,24(r31)
fffa68c4:	91 3f 00 1c 	stw     r9,28(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_SPI_ENGINE(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa68c8:	39 20 00 01 	li      r9,1
fffa68cc:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa68d0:	38 c0 00 00 	li      r6,0
fffa68d4:	81 3d 00 08 	lwz     r9,8(r29)
fffa68d8:	38 e0 27 10 	li      r7,10000
fffa68dc:	39 29 00 08 	addi    r9,r9,8
fffa68e0:	91 3f 00 28 	stw     r9,40(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa68e4:	39 20 00 04 	li      r9,4
fffa68e8:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa68ec:	15 01 00 08 	lvd     d8,8(r1)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa68f0:	90 df 00 3c 	stw     r6,60(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fffa68f4:	19 1f 00 30 	stvd    d8,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa68f8:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
fffa68fc:	90 ff 00 40 	stw     r7,64(r31)
fffa6900:	3c 60 66 d3 	lis     r3,26323
fffa6904:	93 df 00 24 	stw     r30,36(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa6908:	91 3f 00 2c 	stw     r9,44(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[4].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[4].size = fapi2::getErrorInfoFfdcSize(i_value);
fffa690c:	91 3f 00 38 	stw     r9,56(r31)
fffa6910:	60 63 00 01 	ori     r3,r3,1
fffa6914:	38 a0 00 03 	li      r5,3
fffa6918:	38 c0 00 00 	li      r6,0
fffa691c:	38 e0 00 00 	li      r7,0
fffa6920:	39 00 00 00 	li      r8,0
fffa6924:	4b ff d2 2d 	bl      fffa3b50 <pk_trace_big>
                 RC_SBE_SPI_HANG_TIMEOUT);
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fffa6928:	80 01 00 34 	lwz     r0,52(r1)
fffa692c:	17 81 00 20 	lvd     d28,32(r1)
fffa6930:	7c 08 03 a6 	mtlr    r0
fffa6934:	17 c1 00 28 	lvd     d30,40(r1)
fffa6938:	80 6d 46 f0 	lwz     r3,18160(r13)
fffa693c:	38 21 00 30 	addi    r1,r1,48
fffa6940:	4e 80 00 20 	blr

fffa6944 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>:
  */
fapi2::ReturnCode spi_tpm_read_internal_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_address,
        uint8_t i_length,
        uint8_t* o_buffer )
{
fffa6944:	94 21 ff c8 	stwu    r1,-56(r1)
fffa6948:	7c 08 02 a6 	mflr    r0
    tpmSpiCmd_t startReadCmd = {0};

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fffa694c:	28 05 00 08 	cmplwi  r5,8
  */
fapi2::ReturnCode spi_tpm_read_internal_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_address,
        uint8_t i_length,
        uint8_t* o_buffer )
{
fffa6950:	1b 81 00 28 	stvd    d28,40(r1)
fffa6954:	1b c1 00 30 	stvd    d30,48(r1)
fffa6958:	90 01 00 3c 	stw     r0,60(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fffa695c:	39 00 00 00 	li      r8,0
fffa6960:	39 20 00 00 	li      r9,0
fffa6964:	7c 7d 1b 78 	mr      r29,r3
fffa6968:	7c bf 2b 78 	mr      r31,r5
fffa696c:	7c de 33 78 	mr      r30,r6
fffa6970:	19 01 00 10 	stvd    d8,16(r1)
    uint64_t SEQ;
    uint64_t CNT;
    fapi2::buffer<uint64_t> data64 = 0;
    uint64_t temp = 0;
fffa6974:	19 01 00 08 	stvd    d8,8(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpmSpiCmd_t startReadCmd = {0};
fffa6978:	3b 80 00 00 	li      r28,0
fffa697c:	a0 e3 00 06 	lhz     r7,6(r3)

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fffa6980:	41 81 00 38 	bgt     fffa69b8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x74>
        // Shift out 4 bytes of TDR (the read/write bit, the size, the address),
        // then switch to reading and if the next bytes is not 1, then go to
        // sequence opcode (2), and keep doing that until the data is 0x1.
        // (that covers the flow control), then start reading the actual # of
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fffa6984:	54 e9 04 3e 	clrlwi  r9,r7,16
fffa6988:	39 00 00 00 	li      r8,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa698c:	79 08 c1 c6 	rldicr  d8,d8,56,7
        // Shift out 4 bytes of TDR (the read/write bit, the size, the address),
        // then switch to reading and if the next bytes is not 1, then go to
        // sequence opcode (2), and keep doing that until the data is 0x1.
        // (that covers the flow control), then start reading the actual # of
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fffa6990:	7c a7 2b 78 	mr      r7,r5
fffa6994:	65 08 10 34 	oris    r8,r8,4148
fffa6998:	38 c0 00 00 	li      r6,0
fffa699c:	78 c6 c1 e4 	rldicr  d6,d6,24,39
fffa69a0:	61 08 41 62 	ori     r8,r8,16738
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69a4:	64 e9 40 10 	oris    r9,r7,16400
fffa69a8:	7d 05 33 78 	or      r5,r8,r6
        CNT = 0;
fffa69ac:	39 40 00 00 	li      r10,0
fffa69b0:	38 e0 00 00 	li      r7,0
fffa69b4:	48 00 00 58 	b       fffa6a0c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xc8>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69b8:	54 e9 04 3e 	clrlwi  r9,r7,16
fffa69bc:	39 00 00 00 	li      r8,0
fffa69c0:	79 08 c1 c6 	rldicr  d8,d8,56,7
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0;
    }
    else if((i_length % 8) == 0)
fffa69c4:	54 a5 07 7e 	clrlwi  r5,r5,29
fffa69c8:	57 ea e8 fe 	rlwinm  r10,r31,29,3,31
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69cc:	65 08 10 34 	oris    r8,r8,4148
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0;
    }
    else if((i_length % 8) == 0)
fffa69d0:	06 45 00 0a 	bwnz    r5,fffa69e4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xa0>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69d4:	3d 20 48 e4 	lis     r9,18660
fffa69d8:	61 05 41 62 	ori     r5,r8,16738
fffa69dc:	61 29 10 00 	ori     r9,r9,4096
fffa69e0:	48 00 00 24 	b       fffa6a04 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xc0>
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  40 = Shift_N2 - 0 bytes to receive
        //                    10 = select_slave 0 - deselect any slave
        //                      00 = STOP
        SEQ = 0x1034416248E44010ULL | (static_cast<uint64_t>((i_length) % 8) << 8)
              | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69e4:	7c a7 2b 78 	mr      r7,r5
fffa69e8:	38 c0 00 00 	li      r6,0
fffa69ec:	3d 20 48 e4 	lis     r9,18660
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  40 = Shift_N2 - 0 bytes to receive
        //                    10 = select_slave 0 - deselect any slave
        //                      00 = STOP
        SEQ = 0x1034416248E44010ULL | (static_cast<uint64_t>((i_length) % 8) << 8)
fffa69f0:	78 c6 45 e4 	rldicr  d6,d6,8,55
fffa69f4:	61 08 41 62 	ori     r8,r8,16738
              | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa69f8:	61 29 40 10 	ori     r9,r9,16400
fffa69fc:	7d 05 33 78 	or      r5,r8,r6
fffa6a00:	7d 29 3b 78 	or      r9,r9,r7
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x6F) << 8);
fffa6a04:	39 4a ff ff 	addi    r10,r10,-1
fffa6a08:	38 e0 6f 00 	li      r7,28416
    }

    // Initial TDR command
    startReadCmd.cmd_bits.readNotWrite = 1;
fffa6a0c:	38 c0 00 01 	li      r6,1
fffa6a10:	50 dc f8 00 	rlwimi  r28,r6,31,0,0
    startReadCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fffa6a14:	38 df ff ff 	addi    r6,r31,-1
fffa6a18:	50 dc c0 8e 	rlwimi  r28,r6,24,2,7
    startReadCmd.cmd_bits.addr = i_address;
fffa6a1c:	50 9c 02 3e 	rlwimi  r28,r4,0,8,31

    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fffa6a20:	80 9d 00 08 	lwz     r4,8(r29)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa6a24:	7f a3 eb 78 	mr      r3,r29
fffa6a28:	38 84 00 07 	addi    r4,r4,7
fffa6a2c:	7d 26 4b 78 	mr      r6,r9
fffa6a30:	90 e1 00 20 	stw     r7,32(r1)
fffa6a34:	91 41 00 1c 	stw     r10,28(r1)
fffa6a38:	4b ff cb dd 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6a3c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6a40:	80 e1 00 20 	lwz     r7,32(r1)
fffa6a44:	81 41 00 1c 	lwz     r10,28(r1)
fffa6a48:	06 c3 00 06 	bwz     r3,fffa6a54 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x110>
fffa6a4c:	3b 80 00 00 	li      r28,0
fffa6a50:	48 00 02 64 	b       fffa6cb4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x370>
    FAPI_DBG("Address: 0x%08X, MMSPIMREG: 0x%016X", i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg));
fffa6a54:	80 9d 00 08 	lwz     r4,8(r29)
fffa6a58:	3c c0 ff 01 	lis     r6,-255
fffa6a5c:	7f a3 eb 78 	mr      r3,r29
fffa6a60:	38 84 00 04 	addi    r4,r4,4
fffa6a64:	38 a0 00 00 	li      r5,0
fffa6a68:	60 c6 ff 00 	ori     r6,r6,65280
fffa6a6c:	90 e1 00 20 	stw     r7,32(r1)
fffa6a70:	91 41 00 1c 	stw     r10,28(r1)
fffa6a74:	4b ff cb a1 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6a78:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6a7c:	80 e1 00 20 	lwz     r7,32(r1)
fffa6a80:	81 41 00 1c 	lwz     r10,28(r1)
fffa6a84:	06 43 07 e4 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("Address: 0x%08X, COUNTERREG: 0x%016X", i_handle.base_addr + SPIM_COUNTERREG, CNT);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fffa6a88:	80 9d 00 08 	lwz     r4,8(r29)
fffa6a8c:	7f a3 eb 78 	mr      r3,r29
fffa6a90:	38 84 00 01 	addi    r4,r4,1
fffa6a94:	7d 45 53 78 	mr      r5,r10
fffa6a98:	7c e6 3b 78 	mr      r6,r7
fffa6a9c:	4b ff cb 79 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6aa0:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6aa4:	06 43 07 d4 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startReadCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startReadCmd.val));
fffa6aa8:	80 9d 00 08 	lwz     r4,8(r29)
fffa6aac:	7f a3 eb 78 	mr      r3,r29
fffa6ab0:	38 84 00 05 	addi    r4,r4,5
fffa6ab4:	7f 85 e3 78 	mr      r5,r28
fffa6ab8:	38 c0 00 00 	li      r6,0
fffa6abc:	4b ff cb 59 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6ac0:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6ac4:	06 43 07 c4 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("spi_wait_for_tdr_empty()");
    rc = spi_wait_for_tdr_empty(i_handle);
fffa6ac8:	7f a3 eb 78 	mr      r3,r29
fffa6acc:	4b ff f5 19 	bl      fffa5fe4 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>
fffa6ad0:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
    {
        FAPI_ERR("Error in spi_wait_for_tdr_empty");
fffa6ad4:	3c 60 07 35 	lis     r3,1845
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startReadCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startReadCmd.val));
    FAPI_DBG("spi_wait_for_tdr_empty()");
    rc = spi_wait_for_tdr_empty(i_handle);

    if (rc)
fffa6ad8:	06 5c 00 ea 	bwnz    r28,fffa6cac <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
        FAPI_ERR("Error in spi_wait_for_tdr_empty");
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    if (i_length > 8)
fffa6adc:	28 1f 00 08 	cmplwi  r31,8
fffa6ae0:	41 81 00 34 	bgt     fffa6b14 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1d0>
        FAPI_DBG("TDR 0 done");
    }

    // Wait until sequence index 3 has executed (TPM finished
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);
fffa6ae4:	7f a3 eb 78 	mr      r3,r29
fffa6ae8:	4b ff fc 95 	bl      fffa677c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31>
fffa6aec:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fffa6af0:	06 c3 00 24 	bwz     r3,fffa6b38 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1f4>
    {
        FAPI_ERR("Error in wait_for_seq_index_pass, rc: 0x%08X",
fffa6af4:	3c 60 29 d3 	lis     r3,10707
fffa6af8:	60 63 00 01 	ori     r3,r3,1
fffa6afc:	7f 85 e3 78 	mr      r5,r28
fffa6b00:	38 c0 00 00 	li      r6,0
fffa6b04:	38 e0 00 00 	li      r7,0
fffa6b08:	39 00 00 00 	li      r8,0
fffa6b0c:	4b ff d0 45 	bl      fffa3b50 <pk_trace_big>
fffa6b10:	48 00 01 a0 	b       fffa6cb0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x36c>
    }

    if (i_length > 8)
    {
        FAPI_DBG("spi_wait_for_tdr_empty() done, TDR 0");
        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
fffa6b14:	80 9d 00 08 	lwz     r4,8(r29)
fffa6b18:	7f a3 eb 78 	mr      r3,r29
fffa6b1c:	38 84 00 05 	addi    r4,r4,5
fffa6b20:	38 a0 00 00 	li      r5,0
fffa6b24:	38 c0 00 00 	li      r6,0
fffa6b28:	4b ff ca ed 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6b2c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6b30:	06 c3 07 da 	bwz     r3,fffa6ae4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1a0>
fffa6b34:	4b ff ff 18 	b       fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    //receive data
    if(i_length <= 8)
fffa6b38:	28 1f 00 08 	cmplwi  r31,8
#endif
    }
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
fffa6b3c:	39 3f ff f9 	addi    r9,r31,-7
fffa6b40:	3b 80 00 00 	li      r28,0
fffa6b44:	91 21 00 18 	stw     r9,24(r1)
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    //receive data
    if(i_length <= 8)
fffa6b48:	41 a1 00 a4 	bgt     fffa6bec <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2a8>
    {
        rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fffa6b4c:	7f a3 eb 78 	mr      r3,r29
fffa6b50:	4b ff f7 b5 	bl      fffa6304 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fffa6b54:	7c 7c 1b 78 	mr      r28,r3

        if (rc)
fffa6b58:	06 43 00 74 	bwnz    r3,fffa6c40 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2fc>
            FAPI_ERR("Error in spi_wait_for_rdr_full");
            fapi2::current_err = rc;
            goto fapi_try_exit;
        }

        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fffa6b5c:	80 9d 00 08 	lwz     r4,8(r29)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fffa6b60:	7f a3 eb 78 	mr      r3,r29
fffa6b64:	38 84 00 06 	addi    r4,r4,6
fffa6b68:	38 a1 00 10 	addi    r5,r1,16
fffa6b6c:	4b ff ca 55 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa6b70:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6b74:	06 43 07 6c 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>

        FAPI_DBG("spi_wait_for_rdr_full finished, data read from rdr: 0x%016X", temp);

        // The value read from this RDR register is right-aligned.
        // Only copy the requested bytes of data
        temp = temp << ((8 - i_length) * 8);
fffa6b78:	21 1f 00 08 	subfic  r8,r31,8
fffa6b7c:	55 0a 18 38 	rlwinm  r10,r8,3,0,28
fffa6b80:	15 01 00 10 	lvd     d8,16(r1)
fffa6b84:	7d 08 50 76 	slvd    d8,d8,r10
fffa6b88:	19 01 00 08 	stvd    d8,8(r1)
#ifndef __PPE__
        memcpy(o_buffer, &temp, i_length);
#else
        uint8_t* tempPtr = (uint8_t*)&temp;

        for(uint32_t i = 0; i < i_length; i++)
fffa6b8c:	39 40 00 00 	li      r10,0
fffa6b90:	39 3f 00 01 	addi    r9,r31,1
fffa6b94:	06 5f 00 04 	bwnz    r31,fffa6b9c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x258>
fffa6b98:	39 20 00 01 	li      r9,1
fffa6b9c:	35 29 ff ff 	addic.  r9,r9,-1
fffa6ba0:	41 82 00 5c 	beq     fffa6bfc <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2b8>
        {
            *(o_buffer + i) = *(tempPtr + i);
fffa6ba4:	39 01 00 08 	addi    r8,r1,8
fffa6ba8:	7d 0a 40 ae 	lbzx    r8,r10,r8
fffa6bac:	7d 1e 51 ae 	stbx    r8,r30,r10
#ifndef __PPE__
        memcpy(o_buffer, &temp, i_length);
#else
        uint8_t* tempPtr = (uint8_t*)&temp;

        for(uint32_t i = 0; i < i_length; i++)
fffa6bb0:	39 4a 00 01 	addi    r10,r10,1
fffa6bb4:	4b ff ff e8 	b       fffa6b9c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x258>
                FAPI_ERR("Error in spi_wait_for_rdr_full");
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fffa6bb8:	80 9d 00 08 	lwz     r4,8(r29)
fffa6bbc:	7f a3 eb 78 	mr      r3,r29
fffa6bc0:	38 84 00 06 	addi    r4,r4,6
fffa6bc4:	38 a1 00 10 	addi    r5,r1,16
fffa6bc8:	4b ff c9 f9 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa6bcc:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6bd0:	06 43 07 3e 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fffa6bd4:	14 c1 00 10 	lvd     d6,16(r1)
            data64.extract<0, 64>(temp);
            FAPI_DBG("%d) spi_wait_for_rdr_full finished, data read from rdr: 0x%016X", i, temp);

            // add the full 8 bytes to buffer
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
fffa6bd8:	57 89 00 38 	rlwinm  r9,r28,0,0,28
fffa6bdc:	7d 3e 4a 14 	add     r9,r30,r9
            o_out = out;
fffa6be0:	18 c1 00 08 	stvd    d6,8(r1)
fffa6be4:	18 c9 00 00 	stvd    d6,0(r9)
#endif
    }
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
fffa6be8:	3b 9c 00 08 	addi    r28,r28,8
fffa6bec:	81 21 00 18 	lwz     r9,24(r1)
fffa6bf0:	05 9c 48 12 	cmplwblt r28,r9,fffa6c14 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2d0>

            // add the full 8 bytes to buffer
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
        }

        if ((i_length % 8 != 0) && (i_length > 8))
fffa6bf4:	57 e9 07 7e 	clrlwi  r9,r31,29
fffa6bf8:	06 49 00 18 	bwnz    r9,fffa6c28 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2e4>
#endif
        }
    }

    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle");
    rc = spi_wait_for_idle(i_handle);
fffa6bfc:	7f a3 eb 78 	mr      r3,r29
fffa6c00:	4b ff f5 75 	bl      fffa6174 <_ZL17spi_wait_for_idleR16SpiControlHandle>
fffa6c04:	7c 7c 1b 78 	mr      r28,r3
    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle done");

    if (rc)
fffa6c08:	06 c3 00 56 	bwz     r3,fffa6cb4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x370>
    {
        FAPI_ERR("Multiplexing error in spi_wait_for_idle");
fffa6c0c:	3c 60 d8 b1 	lis     r3,-10063
fffa6c10:	48 00 00 9c 	b       fffa6cac <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
        {
            rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fffa6c14:	7f a3 eb 78 	mr      r3,r29
fffa6c18:	4b ff f6 ed 	bl      fffa6304 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>

            if (rc)
fffa6c1c:	06 c3 07 ce 	bwz     r3,fffa6bb8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x274>
fffa6c20:	7c 7c 1b 78 	mr      r28,r3
fffa6c24:	48 00 00 1c 	b       fffa6c40 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2fc>
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
        }

        if ((i_length % 8 != 0) && (i_length > 8))
        {
            rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fffa6c28:	7f a3 eb 78 	mr      r3,r29
fffa6c2c:	91 21 00 1c 	stw     r9,28(r1)
fffa6c30:	4b ff f6 d5 	bl      fffa6304 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fffa6c34:	7c 7c 1b 78 	mr      r28,r3

            if (rc)
fffa6c38:	81 21 00 1c 	lwz     r9,28(r1)
fffa6c3c:	06 c3 00 06 	bwz     r3,fffa6c48 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x304>
            {
                FAPI_ERR("Error in spi_wait_for_rdr_full");
fffa6c40:	3c 60 c9 6f 	lis     r3,-13969
fffa6c44:	48 00 00 68 	b       fffa6cac <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fffa6c48:	80 9d 00 08 	lwz     r4,8(r29)
fffa6c4c:	7f a3 eb 78 	mr      r3,r29
fffa6c50:	38 84 00 06 	addi    r4,r4,6
fffa6c54:	38 a1 00 10 	addi    r5,r1,16
fffa6c58:	91 21 00 1c 	stw     r9,28(r1)
fffa6c5c:	4b ff c9 65 	bl      fffa35c0 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fffa6c60:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6c64:	81 21 00 1c 	lwz     r9,28(r1)
fffa6c68:	06 43 06 f2 	bwnz    r3,fffa6a4c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fffa6c6c:	20 c9 00 08 	subfic  r6,r9,8
fffa6c70:	54 ca 18 38 	rlwinm  r10,r6,3,0,28
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fffa6c74:	39 29 00 01 	addi    r9,r9,1
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fffa6c78:	14 c1 00 10 	lvd     d6,16(r1)
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fffa6c7c:	7d 29 03 a6 	mtctr   r9
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fffa6c80:	7c c6 50 76 	slvd    d6,d6,r10
fffa6c84:	18 c1 00 08 	stvd    d6,8(r1)
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fffa6c88:	39 40 00 00 	li      r10,0
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fffa6c8c:	57 ff 00 38 	rlwinm  r31,r31,0,0,28
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fffa6c90:	42 40 ff 6c 	bdz     fffa6bfc <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2b8>
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fffa6c94:	39 01 00 08 	addi    r8,r1,8
fffa6c98:	7d 0a 40 ae 	lbzx    r8,r10,r8
fffa6c9c:	7d 3e 52 14 	add     r9,r30,r10
fffa6ca0:	7d 09 f9 ae 	stbx    r8,r9,r31
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fffa6ca4:	39 4a 00 01 	addi    r10,r10,1
fffa6ca8:	4b ff ff e8 	b       fffa6c90 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x34c>
    rc = spi_wait_for_idle(i_handle);
    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle done");

    if (rc)
    {
        FAPI_ERR("Multiplexing error in spi_wait_for_idle");
fffa6cac:	4b ff 9a 15 	bl      fffa06c0 <pk_trace_tiny>
        fapi2::current_err = rc;
fffa6cb0:	93 8d 46 f0 	stw     r28,18160(r13)
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_read_with_wait() exit. RC: 0x%02X", static_cast<int>(rc));
    return rc;
}
fffa6cb4:	80 01 00 3c 	lwz     r0,60(r1)
fffa6cb8:	7f 83 e3 78 	mr      r3,r28
fffa6cbc:	7c 08 03 a6 	mtlr    r0
fffa6cc0:	17 81 00 28 	lvd     d28,40(r1)
fffa6cc4:	17 c1 00 30 	lvd     d30,48(r1)
fffa6cc8:	38 21 00 38 	addi    r1,r1,56
fffa6ccc:	4e 80 00 20 	blr

fffa6cd0 <spi_tpm_read_secure>:

    // 0xEX Op code is not allowed in secure mode so need to split
    // read into multiple transactions of TPM_SECURE_DATA_LEN max size
    do
    {
        if (i_length <= TPM_SECURE_DATA_LEN)
fffa6cd0:	28 06 00 08 	cmplwi  r6,8
fapi2::ReturnCode spi_tpm_read_secure( SpiControlHandle& i_handle,
                                       const uint32_t i_locality,
                                       const uint32_t i_address,
                                       const uint8_t i_length,
                                       uint8_t* o_buffer )
{
fffa6cd4:	94 21 ff e0 	stwu    r1,-32(r1)
fffa6cd8:	7c 08 02 a6 	mflr    r0
    uint8_t readlen = i_length;  // try to read full length if possible

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fffa6cdc:	54 a5 05 3e 	clrlwi  r5,r5,20
fffa6ce0:	3c a5 00 d4 	addis   r5,r5,212
fffa6ce4:	54 84 60 26 	rlwinm  r4,r4,12,0,19
fapi2::ReturnCode spi_tpm_read_secure( SpiControlHandle& i_handle,
                                       const uint32_t i_locality,
                                       const uint32_t i_address,
                                       const uint8_t i_length,
                                       uint8_t* o_buffer )
{
fffa6ce8:	1b 81 00 10 	stvd    d28,16(r1)
fffa6cec:	1b c1 00 18 	stvd    d30,24(r1)
fffa6cf0:	90 01 00 24 	stw     r0,36(r1)
fffa6cf4:	7c dd 33 78 	mr      r29,r6
    uint8_t readlen = i_length;  // try to read full length if possible

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fffa6cf8:	7f 85 22 14 	add     r28,r5,r4
fffa6cfc:	7c 6a 1b 78 	mr      r10,r3

    // 0xEX Op code is not allowed in secure mode so need to split
    // read into multiple transactions of TPM_SECURE_DATA_LEN max size
    do
    {
        if (i_length <= TPM_SECURE_DATA_LEN)
fffa6d00:	3b e0 00 00 	li      r31,0
fffa6d04:	41 a1 00 30 	bgt     fffa6d34 <spi_tpm_read_secure+0x64>
        {
            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
fffa6d08:	7c c5 33 78 	mr      r5,r6
fffa6d0c:	7f 84 e3 78 	mr      r4,r28
fffa6d10:	7c e6 3b 78 	mr      r6,r7
fffa6d14:	4b ff fc 31 	bl      fffa6944 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>
fffa6d18:	7c 69 1b 78 	mr      r9,r3
            break;
fffa6d1c:	48 00 00 88 	b       fffa6da4 <spi_tpm_read_secure+0xd4>
        }

        for(uint8_t i = 0; i < i_length; i += TPM_SECURE_DATA_LEN)
fffa6d20:	3b ff 00 08 	addi    r31,r31,8
fffa6d24:	57 de 06 3e 	clrlwi  r30,r30,24
fffa6d28:	57 ff 06 3e 	clrlwi  r31,r31,24
                          "Failed address 0x%04X read at %d bytes out of %d total",
                          l_address, i, i_length);
                break;
            }

            o_buffer += readlen;
fffa6d2c:	7c e7 f2 14 	add     r7,r7,r30
        {
            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
            break;
        }

        for(uint8_t i = 0; i < i_length; i += TPM_SECURE_DATA_LEN)
fffa6d30:	05 1f e8 3a 	cmplwbge r31,r29,fffa6da4 <spi_tpm_read_secure+0xd4>
        {
            readlen = (i_length - i) < TPM_SECURE_DATA_LEN ?
fffa6d34:	7f df e8 50 	subf    r30,r31,r29
                      (i_length - i) : TPM_SECURE_DATA_LEN;
fffa6d38:	06 3e 40 08 	cmpwible r30,8,fffa6d48 <spi_tpm_read_secure+0x78>
fffa6d3c:	3b c0 00 08 	li      r30,8
fffa6d40:	38 a0 00 08 	li      r5,8
fffa6d44:	48 00 00 0c 	b       fffa6d50 <spi_tpm_read_secure+0x80>
fffa6d48:	57 c5 06 3e 	clrlwi  r5,r30,24

            if (readlen == 0)
fffa6d4c:	06 c5 00 2a 	bwz     r5,fffa6da0 <spi_tpm_read_secure+0xd0>
            {
                break;
            }

            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
fffa6d50:	7d 43 53 78 	mr      r3,r10
fffa6d54:	7c e6 3b 78 	mr      r6,r7
fffa6d58:	7f 84 e3 78 	mr      r4,r28
fffa6d5c:	90 e1 00 0c 	stw     r7,12(r1)
fffa6d60:	91 41 00 08 	stw     r10,8(r1)
fffa6d64:	4b ff fb e1 	bl      fffa6944 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>
fffa6d68:	7c 69 1b 78 	mr      r9,r3

            if (rc != fapi2::FAPI2_RC_SUCCESS)
fffa6d6c:	80 e1 00 0c 	lwz     r7,12(r1)
fffa6d70:	81 41 00 08 	lwz     r10,8(r1)
fffa6d74:	06 c3 07 d6 	bwz     r3,fffa6d20 <spi_tpm_read_secure+0x50>
            {
                FAPI_ERR( "spi_tpm_read_secure: "
fffa6d78:	3c 60 f2 18 	lis     r3,-3560
fffa6d7c:	60 63 00 03 	ori     r3,r3,3
fffa6d80:	7f 85 e3 78 	mr      r5,r28
fffa6d84:	7f e6 fb 78 	mr      r6,r31
fffa6d88:	7f a7 eb 78 	mr      r7,r29
fffa6d8c:	39 00 00 00 	li      r8,0
fffa6d90:	91 21 00 08 	stw     r9,8(r1)
fffa6d94:	4b ff cd bd 	bl      fffa3b50 <pk_trace_big>
                          "Failed address 0x%04X read at %d bytes out of %d total",
                          l_address, i, i_length);
                break;
fffa6d98:	81 21 00 08 	lwz     r9,8(r1)
fffa6d9c:	48 00 00 08 	b       fffa6da4 <spi_tpm_read_secure+0xd4>
fffa6da0:	39 20 00 00 	li      r9,0
        }
    }
    while(0);

    return rc;
}
fffa6da4:	80 01 00 24 	lwz     r0,36(r1)
fffa6da8:	17 81 00 10 	lvd     d28,16(r1)
fffa6dac:	7c 08 03 a6 	mtlr    r0
fffa6db0:	17 c1 00 18 	lvd     d30,24(r1)
fffa6db4:	7d 23 4b 78 	mr      r3,r9
fffa6db8:	38 21 00 20 	addi    r1,r1,32
fffa6dbc:	4e 80 00 20 	blr

fffa6dc0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh>:
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa6dc0:	94 21 ff d0 	stwu    r1,-48(r1)
    tpmSpiCmd_t startWriteCmd = {0};

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fffa6dc4:	28 06 00 08 	cmplwi  r6,8
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa6dc8:	7c 08 02 a6 	mflr    r0
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fffa6dcc:	54 a5 05 3e 	clrlwi  r5,r5,20
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa6dd0:	1b c1 00 28 	stvd    d30,40(r1)
fffa6dd4:	3c a5 00 d4 	addis   r5,r5,212
fffa6dd8:	7c 7e 1b 78 	mr      r30,r3
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fffa6ddc:	54 84 60 26 	rlwinm  r4,r4,12,0,19
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa6de0:	1b 81 00 20 	stvd    d28,32(r1)
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fffa6de4:	7c 65 22 14 	add     r3,r5,r4
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa6de8:	90 01 00 34 	stw     r0,52(r1)
fffa6dec:	7c df 33 78 	mr      r31,r6
fffa6df0:	90 e1 00 14 	stw     r7,20(r1)
    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpmSpiCmd_t startWriteCmd = {0};
fffa6df4:	3b a0 00 00 	li      r29,0
fffa6df8:	a0 be 00 06 	lhz     r5,6(r30)

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fffa6dfc:	41 81 00 38 	bgt     fffa6e34 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x74>
        //          41 = Shift_N2 - M = 1 byte to receive
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fffa6e00:	54 a9 04 3e 	clrlwi  r9,r5,16
fffa6e04:	39 00 00 00 	li      r8,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e08:	79 08 c1 c6 	rldicr  d8,d8,56,7
        //          41 = Shift_N2 - M = 1 byte to receive
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fffa6e0c:	7c c7 33 78 	mr      r7,r6
fffa6e10:	65 08 10 34 	oris    r8,r8,4148
fffa6e14:	38 c0 00 00 	li      r6,0
fffa6e18:	78 c6 c1 e4 	rldicr  d6,d6,24,39
fffa6e1c:	61 08 41 62 	ori     r8,r8,16738
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e20:	7d 08 33 78 	or      r8,r8,r6
        CNT = 0x0;
fffa6e24:	3b 80 00 00 	li      r28,0
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e28:	64 e6 30 10 	oris    r6,r7,12304
        CNT = 0x0;
fffa6e2c:	38 e0 00 00 	li      r7,0
fffa6e30:	48 00 00 54 	b       fffa6e84 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xc4>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e34:	54 a9 04 3e 	clrlwi  r9,r5,16
fffa6e38:	39 00 00 00 	li      r8,0
fffa6e3c:	79 08 c1 c6 	rldicr  d8,d8,56,7
fffa6e40:	65 08 10 34 	oris    r8,r8,4148
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0x0;
    }
    else if((i_length % 8) == 0)
fffa6e44:	54 c6 07 7e 	clrlwi  r6,r6,29
fffa6e48:	57 e7 e8 fe 	rlwinm  r7,r31,29,3,31
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e4c:	61 08 41 62 	ori     r8,r8,16738
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0x0;
    }
    else if((i_length % 8) == 0)
fffa6e50:	06 46 00 08 	bwnz    r6,fffa6e60 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xa0>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e54:	3c c0 38 e4 	lis     r6,14564
fffa6e58:	60 c6 10 00 	ori     r6,r6,4096
fffa6e5c:	48 00 00 20 	b       fffa6e7c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xbc>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to send
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  3M = Shift_N1 - M = i_length%8 of remaining data sent in TDR
        //                    10 = select_slave 0 - deselect any slave
        SEQ = 0x1034416238E43010ULL | (static_cast<uint64_t>((i_length) % 8) << 8) |
fffa6e60:	7c c5 33 78 	mr      r5,r6
fffa6e64:	38 80 00 00 	li      r4,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e68:	3c c0 38 e4 	lis     r6,14564
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to send
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  3M = Shift_N1 - M = i_length%8 of remaining data sent in TDR
        //                    10 = select_slave 0 - deselect any slave
        SEQ = 0x1034416238E43010ULL | (static_cast<uint64_t>((i_length) % 8) << 8) |
fffa6e6c:	78 84 45 e4 	rldicr  d4,d4,8,55
              (static_cast<uint64_t>(i_handle.slave) << 56);
fffa6e70:	60 c6 30 10 	ori     r6,r6,12304
fffa6e74:	7d 08 23 78 	or      r8,r8,r4
fffa6e78:	7c c6 2b 78 	or      r6,r6,r5
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
fffa6e7c:	38 e7 ff ff 	addi    r7,r7,-1
fffa6e80:	3b 80 65 00 	li      r28,25856
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fffa6e84:	39 3f ff ff 	addi    r9,r31,-1
    startWriteCmd.cmd_bits.addr = l_address;


    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fffa6e88:	80 9e 00 08 	lwz     r4,8(r30)
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fffa6e8c:	51 3d c0 8e 	rlwimi  r29,r9,24,2,7
    startWriteCmd.cmd_bits.addr = l_address;
fffa6e90:	50 7d 02 3e 	rlwimi  r29,r3,0,8,31
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fffa6e94:	38 84 00 07 	addi    r4,r4,7
fffa6e98:	7f c3 f3 78 	mr      r3,r30
fffa6e9c:	7d 05 43 78 	mr      r5,r8
fffa6ea0:	90 e1 00 18 	stw     r7,24(r1)
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fffa6ea4:	91 21 00 08 	stw     r9,8(r1)
fffa6ea8:	4b ff c7 6d 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
    startWriteCmd.cmd_bits.addr = l_address;


    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fffa6eac:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6eb0:	80 e1 00 18 	lwz     r7,24(r1)
fffa6eb4:	06 c3 00 06 	bwz     r3,fffa6ec0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x100>
fffa6eb8:	3b 80 00 00 	li      r28,0
fffa6ebc:	48 00 01 8c 	b       fffa7048 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
    FAPI_DBG("Address: 0x%08X, MEMORY_MAPPING_REG: 0x%016X", i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg));
fffa6ec0:	80 9e 00 08 	lwz     r4,8(r30)
fffa6ec4:	3c c0 ff 01 	lis     r6,-255
fffa6ec8:	7f c3 f3 78 	mr      r3,r30
fffa6ecc:	38 84 00 04 	addi    r4,r4,4
fffa6ed0:	38 a0 00 00 	li      r5,0
fffa6ed4:	60 c6 ff 00 	ori     r6,r6,65280
fffa6ed8:	90 e1 00 18 	stw     r7,24(r1)
fffa6edc:	4b ff c7 39 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6ee0:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6ee4:	80 e1 00 18 	lwz     r7,24(r1)
fffa6ee8:	06 43 07 e8 	bwnz    r3,fffa6eb8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
    FAPI_DBG("Address: 0x%08X, CNT: 0x%016X", i_handle.base_addr + SPIM_COUNTERREG, CNT);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fffa6eec:	80 9e 00 08 	lwz     r4,8(r30)
fffa6ef0:	7f c3 f3 78 	mr      r3,r30
fffa6ef4:	38 84 00 01 	addi    r4,r4,1
fffa6ef8:	7c e5 3b 78 	mr      r5,r7
fffa6efc:	7f 86 e3 78 	mr      r6,r28
fffa6f00:	4b ff c7 15 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6f04:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6f08:	06 43 07 d8 	bwnz    r3,fffa6eb8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startWriteCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startWriteCmd.val));
fffa6f0c:	80 9e 00 08 	lwz     r4,8(r30)
fffa6f10:	7f c3 f3 78 	mr      r3,r30
fffa6f14:	38 84 00 05 	addi    r4,r4,5
fffa6f18:	7f a5 eb 78 	mr      r5,r29
fffa6f1c:	38 c0 00 00 	li      r6,0
fffa6f20:	4b ff c6 f5 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa6f24:	90 6d 46 f0 	stw     r3,18160(r13)
fffa6f28:	06 43 07 c8 	bwnz    r3,fffa6eb8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>


    // Wait until sequence index 3 has executed (TPM finished
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);
fffa6f2c:	7f c3 f3 78 	mr      r3,r30
fffa6f30:	4b ff f8 4d 	bl      fffa677c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.31>
fffa6f34:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fffa6f38:	06 43 00 14 	bwnz    r3,fffa6f60 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1a0>
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
                 ((i == (i_length - 1)) && ((i_length % 8) != 0)) )
            {
                data64 = data64 << (8 * (8 - i_length % 8));
fffa6f3c:	57 ea 07 7e 	clrlwi  r10,r31,29
fffa6f40:	21 2a 00 08 	subfic  r9,r10,8
fffa6f44:	55 29 18 38 	rlwinm  r9,r9,3,0,28
fffa6f48:	91 21 00 10 	stw     r9,16(r1)
fffa6f4c:	91 41 00 0c 	stw     r10,12(r1)
fffa6f50:	39 00 00 00 	li      r8,0
fffa6f54:	39 20 00 00 	li      r9,0
fffa6f58:	3b a0 00 00 	li      r29,0
fffa6f5c:	48 00 00 4c 	b       fffa6fa8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1e8>
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);

    if (rc)
    {
        FAPI_ERR("Error in wait_for_seq_index_pass, rc: 0x%08X", static_cast<uint32_t>(rc));
fffa6f60:	3c 60 29 d3 	lis     r3,10707
fffa6f64:	60 63 00 01 	ori     r3,r3,1
fffa6f68:	7f 85 e3 78 	mr      r5,r28
fffa6f6c:	38 c0 00 00 	li      r6,0
fffa6f70:	38 e0 00 00 	li      r7,0
fffa6f74:	39 00 00 00 	li      r8,0
fffa6f78:	4b ff cb d9 	bl      fffa3b50 <pk_trace_big>
fffa6f7c:	48 00 00 b8 	b       fffa7034 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x274>
    data64 = 0;

    // break data up into 8-byte sections
    for(int i = 0; i < i_length; i++)
    {
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);
fffa6f80:	79 04 45 e4 	rldicr  d4,d8,8,55
fffa6f84:	81 21 00 14 	lwz     r9,20(r1)
fffa6f88:	7c 88 23 78 	mr      r8,r4
fffa6f8c:	7c c9 e8 ae 	lbzx    r6,r9,r29
fffa6f90:	7c c9 2b 78 	or      r9,r6,r5

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
fffa6f94:	57 a6 07 7e 	clrlwi  r6,r29,29
fffa6f98:	06 c6 38 0c 	cmpwibeq r6,7,fffa6fb0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1f0>
fffa6f9c:	81 41 00 08 	lwz     r10,8(r1)
fffa6fa0:	04 dd 50 4e 	cmpwbeq r29,r10,fffa703c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x27c>
    }

    data64 = 0;

    // break data up into 8-byte sections
    for(int i = 0; i < i_length; i++)
fffa6fa4:	3b bd 00 01 	addi    r29,r29,1
fffa6fa8:	04 9d ff ec 	cmpwblt r29,r31,fffa6f80 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1c0>
fffa6fac:	48 00 00 70 	b       fffa701c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x25c>
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
fffa6fb0:	28 1f 00 07 	cmplwi  r31,7
fffa6fb4:	40 81 00 14 	ble     fffa6fc8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x208>
fffa6fb8:	81 41 00 08 	lwz     r10,8(r1)
fffa6fbc:	04 5d 50 0a 	cmpwbne r29,r10,fffa6fd0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x210>
                 ((i == (i_length - 1)) && ((i_length % 8) != 0)) )
fffa6fc0:	81 41 00 0c 	lwz     r10,12(r1)
fffa6fc4:	06 ca 00 06 	bwz     r10,fffa6fd0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x210>
            {
                data64 = data64 << (8 * (8 - i_length % 8));
fffa6fc8:	81 41 00 10 	lwz     r10,16(r1)
fffa6fcc:	7d 08 50 76 	slvd    d8,d8,r10
            }

            rc = spi_wait_for_tdr_empty(i_handle);
fffa6fd0:	7f c3 f3 78 	mr      r3,r30
fffa6fd4:	19 01 00 18 	stvd    d8,24(r1)
fffa6fd8:	4b ff f0 0d 	bl      fffa5fe4 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>
fffa6fdc:	7c 7c 1b 78 	mr      r28,r3

            if (rc)
fffa6fe0:	15 01 00 18 	lvd     d8,24(r1)
fffa6fe4:	06 c3 00 06 	bwz     r3,fffa6ff0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x230>
            {
                FAPI_ERR("Error in spi_wait_for_tdr_empty ");
fffa6fe8:	3c 60 07 35 	lis     r3,1845
fffa6fec:	48 00 00 44 	b       fffa7030 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x270>
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_DBG("tpm_write() TDR: 0x%016X", data64);
            FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, data64));
fffa6ff0:	80 9e 00 08 	lwz     r4,8(r30)
fffa6ff4:	7d 05 43 78 	mr      r5,r8
fffa6ff8:	7d 26 4b 78 	mr      r6,r9
fffa6ffc:	7f c3 f3 78 	mr      r3,r30
fffa7000:	38 84 00 05 	addi    r4,r4,5
fffa7004:	19 01 00 18 	stvd    d8,24(r1)
fffa7008:	4b ff c6 0d 	bl      fffa3614 <_ZN5fapi216putscom_abs_wrapEPKvmy>
fffa700c:	90 6d 46 f0 	stw     r3,18160(r13)
fffa7010:	15 01 00 18 	lvd     d8,24(r1)
fffa7014:	06 c3 07 c8 	bwz     r3,fffa6fa4 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1e4>
fffa7018:	4b ff fe a0 	b       fffa6eb8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
        }
    }

    rc = spi_wait_for_idle(i_handle);
fffa701c:	7f c3 f3 78 	mr      r3,r30
fffa7020:	4b ff f1 55 	bl      fffa6174 <_ZL17spi_wait_for_idleR16SpiControlHandle>
fffa7024:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fffa7028:	06 c3 00 10 	bwz     r3,fffa7048 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
    {
        FAPI_ERR("Multiplexing error or timeout from spi_wait_for_idle ");
fffa702c:	3c 60 00 fa 	lis     r3,250
fffa7030:	4b ff 96 91 	bl      fffa06c0 <pk_trace_tiny>
        fapi2::current_err = rc;
fffa7034:	93 8d 46 f0 	stw     r28,18160(r13)
        goto fapi_try_exit;
fffa7038:	48 00 00 10 	b       fffa7048 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
fffa703c:	28 1f 00 07 	cmplwi  r31,7
fffa7040:	40 a1 ff 88 	ble     fffa6fc8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x208>
fffa7044:	4b ff ff 7c 	b       fffa6fc0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x200>
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_write_with_wait_internal() exit. RC: 0x%08X", static_cast<uint32_t>(rc));
    return rc;
}
fffa7048:	80 01 00 34 	lwz     r0,52(r1)
fffa704c:	7f 83 e3 78 	mr      r3,r28
fffa7050:	7c 08 03 a6 	mtlr    r0
fffa7054:	17 81 00 20 	lvd     d28,32(r1)
fffa7058:	17 c1 00 28 	lvd     d30,40(r1)
fffa705c:	38 21 00 30 	addi    r1,r1,48
fffa7060:	4e 80 00 20 	blr

fffa7064 <spi_tpm_write_with_wait>:
fapi2::ReturnCode spi_tpm_write_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fffa7064:	94 21 ff d8 	stwu    r1,-40(r1)
fffa7068:	7c 08 02 a6 	mflr    r0
fffa706c:	1b 81 00 18 	stvd    d28,24(r1)
fffa7070:	90 01 00 2c 	stw     r0,44(r1)
fffa7074:	1b c1 00 20 	stvd    d30,32(r1)
fffa7078:	7c 7d 1b 78 	mr      r29,r3
fffa707c:	7c 9c 23 78 	mr      r28,r4
fffa7080:	7c aa 2b 78 	mr      r10,r5
fffa7084:	7c de 33 78 	mr      r30,r6
fffa7088:	7c e8 3b 78 	mr      r8,r7

    // We're only allowing secure TPM writes, which are of length TPM_SECURE_DATA_LEN or less.
    // l_lengthTraversed will increase from 0 up to i_length in TPM_SECURE_DATA_LEN intervals or less.
    // l_lengthTraversed will be used to know from what offset in the buffer we're writing to the TPM.

    uint8_t l_lengthTraversed = 0;
fffa708c:	38 00 00 00 	li      r0,0

    while (l_lengthTraversed < i_length)
fffa7090:	05 00 f0 2e 	cmplwbge r0,r30,fffa70ec <spi_tpm_write_with_wait+0x88>
    {
        uint8_t l_minTravelLength = std::min(TPM_SECURE_DATA_LEN, (i_length - l_lengthTraversed));
fffa7094:	7d 20 f0 50 	subf    r9,r0,r30
fffa7098:	3b e0 00 08 	li      r31,8
     */
    template <class T>
    inline const T& 
    min(const T& a, const T& b)
    {
        if( b < a) return b;
fffa709c:	06 a9 38 08 	cmpwibgt r9,7,fffa70ac <spi_tpm_write_with_wait+0x48>
fffa70a0:	55 3f 06 3e 	clrlwi  r31,r9,24

        // TODO RTC: 268091 Current SPI issue when writing 3 bytes. Must be broken down into smaller write ops.
        if (l_minTravelLength == 3)
fffa70a4:	06 5f 18 04 	cmpwibne r31,3,fffa70ac <spi_tpm_write_with_wait+0x48>
        {
            l_minTravelLength = 2;
fffa70a8:	3b e0 00 02 	li      r31,2
        }

        rc = spi_tpm_write_with_wait_internal(i_handle, i_locality, i_address, l_minTravelLength,
                                              i_buffer + l_lengthTraversed);
fffa70ac:	7c e8 02 14 	add     r7,r8,r0
fffa70b0:	7d 45 53 78 	mr      r5,r10
fffa70b4:	7f a3 eb 78 	mr      r3,r29
fffa70b8:	7f 84 e3 78 	mr      r4,r28
fffa70bc:	7f e6 fb 78 	mr      r6,r31
fffa70c0:	90 01 00 08 	stw     r0,8(r1)
fffa70c4:	91 01 00 10 	stw     r8,16(r1)
fffa70c8:	91 41 00 0c 	stw     r10,12(r1)
fffa70cc:	4b ff fc f5 	bl      fffa6dc0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh>

        if (rc)
fffa70d0:	80 01 00 08 	lwz     r0,8(r1)
fffa70d4:	81 01 00 10 	lwz     r8,16(r1)
fffa70d8:	81 41 00 0c 	lwz     r10,12(r1)
fffa70dc:	06 43 00 0c 	bwnz    r3,fffa70f4 <spi_tpm_write_with_wait+0x90>
        {
            break;
        }

        l_lengthTraversed += l_minTravelLength;
fffa70e0:	7f ff 02 14 	add     r31,r31,r0
fffa70e4:	57 e0 06 3e 	clrlwi  r0,r31,24
fffa70e8:	4b ff ff a8 	b       fffa7090 <spi_tpm_write_with_wait+0x2c>
fffa70ec:	3b e0 00 00 	li      r31,0
fffa70f0:	48 00 00 14 	b       fffa7104 <spi_tpm_write_with_wait+0xa0>
fffa70f4:	7c 7f 1b 78 	mr      r31,r3
    }

    if (rc)
    {
        FAPI_ERR("spi_tpm_write_with_wait: Error doing secure write.");
fffa70f8:	3c 60 a6 4f 	lis     r3,-22961
fffa70fc:	4b ff 95 c5 	bl      fffa06c0 <pk_trace_tiny>
        fapi2::current_err = rc;
fffa7100:	93 ed 46 f0 	stw     r31,18160(r13)
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_write_with_wait() exit. RC: 0x%08X", static_cast<uint32_t>(rc));
    return rc;
}
fffa7104:	80 01 00 2c 	lwz     r0,44(r1)
fffa7108:	7f e3 fb 78 	mr      r3,r31
fffa710c:	7c 08 03 a6 	mtlr    r0
fffa7110:	17 81 00 18 	lvd     d28,24(r1)
fffa7114:	17 c1 00 20 	lvd     d30,32(r1)
fffa7118:	38 21 00 28 	addi    r1,r1,40
fffa711c:	4e 80 00 20 	blr
