
/tmp/power-jenkins.swg-devops/jenkins-slave/workspace/PSE-JET/EKB/Auto-Release-HW-Image/checkNewCommit-buildRelease/REPO_DEST_PROJ/PPE/label/rhel7/ppe/images/sbe_measurement_seeprom.out:     file format elf32-powerpc


Disassembly of section .loader_text:

ff880200 <__vectors>:
	...

ff880240 <__system_reset>:
ff880240:	48 00 00 04 	b       ff880244 <__l1Loader>

ff880244 <__l1Loader>:
ff880244:	3c a0 00 05 	lis     r5,5
ff880248:	60 a5 00 09 	ori     r5,r5,9
ff88024c:	14 05 00 00 	lvd     d0,0(r5)
ff880250:	54 00 00 36 	rlwinm  r0,r0,0,0,27
ff880254:	60 00 00 02 	ori     r0,r0,2
ff880258:	38 20 00 00 	li      r1,0
ff88025c:	18 05 00 00 	stvd    d0,0(r5)
ff880260:	3c c0 c0 00 	lis     r6,-16384
ff880264:	60 c6 20 40 	ori     r6,r6,8256
ff880268:	14 06 00 00 	lvd     d0,0(r6)
ff88026c:	07 00 70 04 	bb1wi   r0,14,ff880274 <skip_pibmem_repair_in_mpipl>
ff880270:	48 00 01 29 	bl      ff880398 <_pibmemRepair>

ff880274 <skip_pibmem_repair_in_mpipl>:
ff880274:	3c 60 ff 88 	lis     r3,-120
ff880278:	60 63 00 ac 	ori     r3,r3,172
ff88027c:	3c 80 ff f8 	lis     r4,-8
ff880280:	60 84 00 00 	ori     r4,r4,0
ff880284:	3d 20 ff 88 	lis     r9,-120
ff880288:	61 29 00 00 	ori     r9,r9,0
ff88028c:	80 a3 00 04 	lwz     r5,4(r3)
ff880290:	7c a5 1e 70 	srawi   r5,r5,3
ff880294:	7c a9 03 a6 	mtctr   r5
ff880298:	81 03 00 00 	lwz     r8,0(r3)
ff88029c:	7d 08 49 14 	adde    r8,r8,r9

ff8802a0 <copy_loop>:
ff8802a0:	17 88 00 00 	lvd     d28,0(r8)
ff8802a4:	1b 84 00 00 	stvd    d28,0(r4)
ff8802a8:	39 08 00 08 	addi    r8,r8,8
ff8802ac:	38 84 00 08 	addi    r4,r4,8
ff8802b0:	42 00 ff f0 	bdnz    ff8802a0 <copy_loop>
ff8802b4:	3c c0 c0 00 	lis     r6,-16384
ff8802b8:	60 c6 20 40 	ori     r6,r6,8256
ff8802bc:	14 06 00 00 	lvd     d0,0(r6)
ff8802c0:	07 00 70 04 	bb1wi   r0,14,ff8802c8 <skip_pibmem_init_memory_in_mpipl>
ff8802c4:	48 00 00 91 	bl      ff880354 <__zeroInitPibmemArea>

ff8802c8 <skip_pibmem_init_memory_in_mpipl>:
ff8802c8:	3c a0 00 05 	lis     r5,5
ff8802cc:	60 a5 00 09 	ori     r5,r5,9
ff8802d0:	14 05 00 00 	lvd     d0,0(r5)
ff8802d4:	54 00 00 36 	rlwinm  r0,r0,0,0,27
ff8802d8:	60 00 00 05 	ori     r0,r0,5
ff8802dc:	38 20 00 00 	li      r1,0
ff8802e0:	18 05 00 00 	stvd    d0,0(r5)
ff8802e4:	3c c0 00 01 	lis     r6,1
ff8802e8:	60 c6 00 06 	ori     r6,r6,6
ff8802ec:	3c 00 00 08 	lis     r0,8
ff8802f0:	60 00 00 00 	nop
ff8802f4:	38 20 00 00 	li      r1,0
ff8802f8:	18 06 00 00 	stvd    d0,0(r6)
ff8802fc:	3c c0 c0 00 	lis     r6,-16384
ff880300:	60 c6 20 30 	ori     r6,r6,8240
ff880304:	3c 00 80 00 	lis     r0,-32768
ff880308:	60 00 00 00 	nop
ff88030c:	38 20 00 00 	li      r1,0
ff880310:	18 06 00 00 	stvd    d0,0(r6)
ff880314:	3c a0 00 00 	lis     r5,0
ff880318:	60 a5 00 50 	ori     r5,r5,80
ff88031c:	7c a9 03 a6 	mtctr   r5

ff880320 <delay_loop>:
ff880320:	42 00 00 00 	bdnz    ff880320 <delay_loop>
ff880324:	18 06 00 08 	stvd    d0,8(r6)

ff880328 <jump_to_kernel>:
ff880328:	3d 00 ff f8 	lis     r8,-8
ff88032c:	61 08 00 00 	ori     r8,r8,0
ff880330:	39 20 00 00 	li      r9,0
ff880334:	3d 40 c0 00 	lis     r10,-16384
ff880338:	61 4a 01 60 	ori     r10,r10,352
ff88033c:	19 0a 00 00 	stvd    d8,0(r10)
ff880340:	3c 60 ff 88 	lis     r3,-120
ff880344:	60 63 00 1c 	ori     r3,r3,28
ff880348:	80 c3 00 00 	lwz     r6,0(r3)
ff88034c:	7c c8 03 a6 	mtlr    r6
ff880350:	4e 80 00 20 	blr

ff880354 <__zeroInitPibmemArea>:
ff880354:	3c 60 ff 88 	lis     r3,-120
ff880358:	60 63 00 ac 	ori     r3,r3,172
ff88035c:	3c 80 ff f8 	lis     r4,-8
ff880360:	60 84 00 00 	ori     r4,r4,0
ff880364:	80 a3 00 04 	lwz     r5,4(r3)
ff880368:	3c c0 00 07 	lis     r6,7
ff88036c:	60 c6 ff 80 	ori     r6,r6,65408
ff880370:	7c 84 2a 14 	add     r4,r4,r5
ff880374:	7c a5 30 50 	subf    r5,r5,r6
ff880378:	7c a5 1e 70 	srawi   r5,r5,3
ff88037c:	7c a9 03 a6 	mtctr   r5
ff880380:	3b 80 00 00 	li      r28,0
ff880384:	3b a0 00 00 	li      r29,0

ff880388 <copy_loop_init>:
ff880388:	1b 84 00 00 	stvd    d28,0(r4)
ff88038c:	38 84 00 08 	addi    r4,r4,8
ff880390:	42 00 ff f8 	bdnz    ff880388 <copy_loop_init>
ff880394:	4e 80 00 20 	blr

ff880398 <_pibmemRepair>:
ff880398:	3c 60 00 05 	lis     r3,5
ff88039c:	60 63 01 30 	ori     r3,r3,304
ff8803a0:	38 80 00 02 	li      r4,2
ff8803a4:	38 a0 00 00 	li      r5,0
ff8803a8:	18 83 00 00 	stvd    d4,0(r3)
ff8803ac:	3c 60 01 03 	lis     r3,259
ff8803b0:	60 63 00 01 	ori     r3,r3,1
ff8803b4:	3c 80 70 00 	lis     r4,28672
ff8803b8:	38 a0 00 20 	li      r5,32
ff8803bc:	18 83 00 00 	stvd    d4,0(r3)
ff8803c0:	3c a0 00 05 	lis     r5,5
ff8803c4:	60 a5 00 09 	ori     r5,r5,9
ff8803c8:	14 05 00 00 	lvd     d0,0(r5)
ff8803cc:	54 00 00 36 	rlwinm  r0,r0,0,0,27
ff8803d0:	60 00 00 03 	ori     r0,r0,3
ff8803d4:	38 20 00 00 	li      r1,0
ff8803d8:	18 05 00 00 	stvd    d0,0(r5)
ff8803dc:	7c 88 02 a6 	mflr    r4
ff8803e0:	3c 60 ff 88 	lis     r3,-120
ff8803e4:	60 63 00 88 	ori     r3,r3,136
ff8803e8:	3d 20 ff 88 	lis     r9,-120
ff8803ec:	61 29 00 00 	ori     r9,r9,0
ff8803f0:	81 03 00 00 	lwz     r8,0(r3)
ff8803f4:	28 08 00 00 	cmplwi  r8,0
ff8803f8:	41 82 00 34 	beq     ff88042c <skip_parse_row>
ff8803fc:	7d 08 49 14 	adde    r8,r8,r9

ff880400 <parse_row>:
ff880400:	14 08 00 00 	lvd     d0,0(r8)
ff880404:	54 03 46 3e 	rlwinm  r3,r0,8,24,31
ff880408:	39 08 00 08 	addi    r8,r8,8
ff88040c:	14 c8 00 00 	lvd     d6,0(r8)
ff880410:	06 c3 00 91 	bwzl    r3,ff880530 <__getscom_bootloader>
ff880414:	06 43 00 97 	bwnzl   r3,ff880540 <__putscom_bootloader>
ff880418:	39 08 00 08 	addi    r8,r8,8
ff88041c:	54 03 84 3e 	rlwinm  r3,r0,16,16,31
ff880420:	70 63 00 ff 	andi.   r3,r3,255
ff880424:	28 03 00 01 	cmplwi  r3,1
ff880428:	40 82 ff d8 	bne     ff880400 <parse_row>

ff88042c <skip_parse_row>:
ff88042c:	7c 88 03 a6 	mtlr    r4
ff880430:	3c a0 00 05 	lis     r5,5
ff880434:	60 a5 00 09 	ori     r5,r5,9
ff880438:	14 05 00 00 	lvd     d0,0(r5)
ff88043c:	54 00 00 36 	rlwinm  r0,r0,0,0,27
ff880440:	60 00 00 04 	ori     r0,r0,4
ff880444:	38 20 00 00 	li      r1,0
ff880448:	18 05 00 00 	stvd    d0,0(r5)
ff88044c:	3c 60 00 05 	lis     r3,5
ff880450:	60 63 01 2a 	ori     r3,r3,298
ff880454:	3c 80 80 00 	lis     r4,-32768
ff880458:	38 a0 00 00 	li      r5,0
ff88045c:	18 83 00 00 	stvd    d4,0(r3)
ff880460:	38 80 20 00 	li      r4,8192
ff880464:	18 83 00 10 	stvd    d4,16(r3)
ff880468:	3c 60 01 00 	lis     r3,256
ff88046c:	60 63 00 21 	ori     r3,r3,33
ff880470:	3c 80 02 00 	lis     r4,512
ff880474:	18 83 00 00 	stvd    d4,0(r3)
ff880478:	3c 80 20 00 	lis     r4,8192
ff88047c:	18 83 ff ef 	stvd    d4,-17(r3)
ff880480:	3c 60 01 03 	lis     r3,259
ff880484:	60 63 00 05 	ori     r3,r3,5
ff880488:	38 80 00 00 	li      r4,0
ff88048c:	18 83 00 00 	stvd    d4,0(r3)
ff880490:	3c 80 42 00 	lis     r4,16896
ff880494:	3c a0 00 01 	lis     r5,1
ff880498:	38 a5 e0 00 	addi    r5,r5,-8192
ff88049c:	18 83 00 01 	stvd    d4,1(r3)
ff8804a0:	3c 60 01 00 	lis     r3,256
ff8804a4:	60 63 01 00 	ori     r3,r3,256
ff8804a8:	3c 80 00 80 	lis     r4,128
ff8804ac:	38 a0 00 00 	li      r5,0
ff8804b0:	14 c3 00 00 	lvd     d6,0(r3)
ff8804b4:	74 c6 00 80 	andis.  r6,r6,128
ff8804b8:	04 44 30 48 	cmpwbne r4,r6,ff880548 <__PIB_OPCG_LOCK_FAIL>
ff8804bc:	3c 60 01 03 	lis     r3,259
ff8804c0:	60 63 00 08 	ori     r3,r3,8
ff8804c4:	3c 80 fa 00 	lis     r4,-1536
ff8804c8:	38 84 ff ff 	addi    r4,r4,-1
ff8804cc:	38 a0 ff ff 	li      r5,-1
ff8804d0:	14 c3 00 00 	lvd     d6,0(r3)
ff8804d4:	04 44 30 3e 	cmpwbne r4,r6,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804d8:	04 45 38 3c 	cmpwbne r5,r7,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804dc:	14 c3 00 01 	lvd     d6,1(r3)
ff8804e0:	04 44 30 38 	cmpwbne r4,r6,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804e4:	04 45 38 36 	cmpwbne r5,r7,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804e8:	14 c3 00 02 	lvd     d6,2(r3)
ff8804ec:	04 44 30 32 	cmpwbne r4,r6,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804f0:	04 45 38 30 	cmpwbne r5,r7,ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>
ff8804f4:	3c 60 01 03 	lis     r3,259
ff8804f8:	60 63 00 06 	ori     r3,r3,6
ff8804fc:	3c 80 00 00 	lis     r4,0
ff880500:	38 a0 00 00 	li      r5,0
ff880504:	18 83 00 00 	stvd    d4,0(r3)
ff880508:	3c 60 01 00 	lis     r3,256
ff88050c:	60 63 00 24 	ori     r3,r3,36
ff880510:	3c 80 02 00 	lis     r4,512
ff880514:	18 83 00 00 	stvd    d4,0(r3)
ff880518:	3c 60 00 05 	lis     r3,5
ff88051c:	60 63 01 21 	ori     r3,r3,289
ff880520:	38 80 02 00 	li      r4,512
ff880524:	38 a0 00 00 	li      r5,0
ff880528:	18 83 00 00 	stvd    d4,0(r3)
ff88052c:	4e 80 00 20 	blr

ff880530 <__getscom_bootloader>:
ff880530:	17 81 00 00 	lvd     d28,0(r1)
ff880534:	04 5c 30 12 	cmpwbne r28,r6,ff880558 <__PIBMEM_REPAIR_COMPARE_HDR_FAIL>
ff880538:	04 5d 38 10 	cmpwbne r29,r7,ff880558 <__PIBMEM_REPAIR_COMPARE_HDR_FAIL>
ff88053c:	4e 80 00 20 	blr

ff880540 <__putscom_bootloader>:
ff880540:	18 c1 00 00 	stvd    d6,0(r1)
ff880544:	4e 80 00 20 	blr

ff880548 <__PIB_OPCG_LOCK_FAIL>:
ff880548:	38 00 00 01 	li      r0,1
ff88054c:	48 00 00 14 	b       ff880560 <__compare_failed>

ff880550 <__PIB_CLOCK_RUNNING_STATUS_FAIL>:
ff880550:	38 00 00 02 	li      r0,2
ff880554:	48 00 00 0c 	b       ff880560 <__compare_failed>

ff880558 <__PIBMEM_REPAIR_COMPARE_HDR_FAIL>:
ff880558:	38 00 00 03 	li      r0,3
ff88055c:	48 00 00 04 	b       ff880560 <__compare_failed>

ff880560 <__compare_failed>:
ff880560:	7c 1d 0b a6 	mtspr   61,r0
ff880564:	7f e0 00 08 	trap

Disassembly of section .pkVectors:

fff80000 <__vectors>:
fff80000:	48 00 00 20 	b       fff80020 <__machine_check>
	...

fff80010 <__set_msr>:
fff80010:	7c 60 01 24 	mtmsr   r3
fff80014:	4e 80 00 20 	blr
	...

fff80020 <__machine_check>:
fff80020:	48 00 14 cc 	b       fff814ec <__sbe_machine_check_handler>
	...

fff80040 <__system_reset>:
fff80040:	48 00 07 7c 	b       fff807bc <__pk_boot>
	...

fff80060 <__data_storage>:
fff80060:	48 00 14 85 	bl      fff814e4 <__sbe_register_saveoff>
fff80064:	7f e0 10 08 	twu     r0,r2
	...

fff80080 <__instruction_storage>:
fff80080:	48 00 14 65 	bl      fff814e4 <__sbe_register_saveoff>
fff80084:	7f e0 18 08 	twu     r0,r3
	...

fff800a0 <__external_interrupt_vector>:
fff800a0:	f8 21 ff af 	stcxu   r1,-88(r1)
fff800a4:	3c 60 ff f8 	lis     r3,-8
fff800a8:	60 63 03 90 	ori     r3,r3,912
fff800ac:	7c 68 03 a6 	mtlr    r3
fff800b0:	7c 90 42 a6 	mfsprg  r4,0
fff800b4:	48 00 02 6c 	b       fff80320 <ctx_check_discard>
	...

fff800c0 <__alignment_exception>:
fff800c0:	48 00 14 25 	bl      fff814e4 <__sbe_register_saveoff>
fff800c4:	7f e0 20 08 	twu     r0,r4
	...

fff800e0 <__program_exception>:
fff800e0:	48 00 14 05 	bl      fff814e4 <__sbe_register_saveoff>
fff800e4:	7f e0 e0 08 	twu     r0,r28
	...

fff80100 <__dec_interrupt>:
fff80100:	f8 21 ff af 	stcxu   r1,-88(r1)
fff80104:	3c 60 ff f8 	lis     r3,-8
fff80108:	60 63 02 70 	ori     r3,r3,624
fff8010c:	7c 68 03 a6 	mtlr    r3
fff80110:	7c 90 42 a6 	mfsprg  r4,0
fff80114:	48 00 02 0c 	b       fff80320 <ctx_check_discard>
	...

fff80120 <__fit_interrupt>:
fff80120:	f8 21 ff af 	stcxu   r1,-88(r1)
fff80124:	3c 60 ff f8 	lis     r3,-8
fff80128:	60 63 02 b4 	ori     r3,r3,692
fff8012c:	7c 68 03 a6 	mtlr    r3
fff80130:	7c 90 42 a6 	mfsprg  r4,0
fff80134:	48 00 01 ec 	b       fff80320 <ctx_check_discard>
	...

fff80140 <__watchdog_interrupt>:
fff80140:	f8 21 ff af 	stcxu   r1,-88(r1)
fff80144:	3c 60 ff f8 	lis     r3,-8
fff80148:	60 63 02 e0 	ori     r3,r3,736
fff8014c:	7c 68 03 a6 	mtlr    r3
fff80150:	7c 90 42 a6 	mfsprg  r4,0
fff80154:	48 00 01 cc 	b       fff80320 <ctx_check_discard>
	...

fff80160 <__virtual_exception>:
fff80160:	7f e0 e8 08 	twu     r0,r29

Disassembly of section .base:

fff80164 <pk_trace_timer_callback>:
#if PK_TRACE_TIMER_OUTPUT
    // guarantee at least one trace before the lower 32bit timebase flips
    PK_TRACE("PERIODIC TIMESTAMPING TRACE");
#endif
    // restart the timer
    pk_timer_schedule(&g_pk_trace_timer,
fff80164:	3c c0 fc 46 	lis     r6,-954
fff80168:	38 6d 10 58 	addi    r3,r13,4184
fff8016c:	38 a0 00 00 	li      r5,0
fff80170:	60 c6 53 5f 	ori     r6,r6,21343
fff80174:	48 00 05 cc 	b       fff80740 <pk_timer_schedule>

fff80178 <pk_trace_tiny>:
// Creates an 8 byte entry in the trace buffer that includes a timestamp,
// a format string hash value and a 16 bit parameter.
//
// i_parm has the hash value combined with the 16 bit parameter
void pk_trace_tiny(uint32_t i_parm)
{
fff80178:	94 21 ff f0 	stwu    r1,-16(r1)
fff8017c:	7c 08 02 a6 	mflr    r0
fff80180:	1b c1 00 08 	stvd    d30,8(r1)
fff80184:	90 01 00 14 	stw     r0,20(r1)
fff80188:	7c 7f 1b 78 	mr      r31,r3
    uint64_t            tb64;
    PkMachineContext    ctx;

    //fill in the footer data
    footer.parms.word32 = i_parm;
    tb64 = pk_timebase_get();
fff8018c:	48 00 03 15 	bl      fff804a0 <pk_timebase_get>
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;

    footer.time_format.format = PK_TRACE_FORMAT_TINY;
fff80190:	39 20 00 01 	li      r9,1
fff80194:	51 24 07 be 	rlwimi  r4,r9,0,30,31

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff80198:	7d 00 00 a6 	mfmsr   r8

wrteei(0);
fff8019c:	7c 00 01 46 	wrteei  0
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fff801a0:	39 4d 00 20 	addi    r10,r13,32
fff801a4:	81 2a 00 34 	lwz     r9,52(r10)
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fff801a8:	90 6a 00 30 	stw     r3,48(r10)
    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];

    //calculate the offset for the next entry in the cb
    state.offset = g_pk_trace_buf.state.offset + sizeof(PkTraceTiny);
fff801ac:	38 e9 00 08 	addi    r7,r9,8
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fff801b0:	55 29 05 3e 	clrlwi  r9,r9,20
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fff801b4:	90 ea 00 34 	stw     r7,52(r10)
    //The following operations must be done atomically
    pk_critical_section_enter(&ctx);

    //load the current byte count and calculate the address for this
    //entry in the cb
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[g_pk_trace_buf.state.offset & PK_TRACE_CB_MASK];
fff801b8:	39 29 00 30 	addi    r9,r9,48
    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;

    //write the data to the circular buffer including the
    //timesamp, string hash, and 16bit parameter
    *ptr64 = footer.word64;
fff801bc:	39 4a 00 08 	addi    r10,r10,8
fff801c0:	7c ea 4a 14 	add     r7,r10,r9
fff801c4:	7f ea 49 2e 	stwx    r31,r10,r9
fff801c8:	90 87 00 04 	stw     r4,4(r7)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff801cc:	7d 00 01 24 	mtmsr   r8

    //exit the critical section
    pk_critical_section_exit(&ctx);
}
fff801d0:	80 01 00 14 	lwz     r0,20(r1)
fff801d4:	17 c1 00 08 	lvd     d30,8(r1)
fff801d8:	7c 08 03 a6 	mtlr    r0
fff801dc:	38 21 00 10 	addi    r1,r1,16
fff801e0:	4e 80 00 20 	blr

fff801e4 <pk_trace_set_timebase>:
// as the current timebase for tracing purposes.  It can also be used
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
fff801e4:	94 21 ff f0 	stwu    r1,-16(r1)
fff801e8:	7c 08 02 a6 	mflr    r0
fff801ec:	1b c1 00 08 	stvd    d30,8(r1)
fff801f0:	90 01 00 14 	stw     r0,20(r1)
fff801f4:	7c 9f 23 78 	mr      r31,r4
fff801f8:	7c 7e 1b 78 	mr      r30,r3
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fff801fc:	48 00 02 a5 	bl      fff804a0 <pk_timebase_get>
}
fff80200:	80 01 00 14 	lwz     r0,20(r1)
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fff80204:	7f e4 f8 10 	subfc   r31,r4,r31
fff80208:	7f c3 f1 10 	subfe   r30,r3,r30
}
fff8020c:	7c 08 03 a6 	mtlr    r0
// to set the current time to 0.  This function changes the timebase for
// all entries that are currently in the trace buffer.  Setting the current
// timebase to 0 will cause previous traces to have very large timestamps.
void pk_trace_set_timebase(PkTimebase timebase)
{
    g_pk_trace_buf.time_adj64 = timebase - pk_timebase_get();
fff80210:	39 2d 00 20 	addi    r9,r13,32
fff80214:	1b c9 00 28 	stvd    d30,40(r9)
}
fff80218:	17 c1 00 08 	lvd     d30,8(r1)
fff8021c:	38 21 00 10 	addi    r1,r1,16
fff80220:	4e 80 00 20 	blr

fff80224 <pk_trace_set_freq>:

void pk_trace_set_freq(uint32_t i_frequency)
{
    g_pk_trace_buf.hz = i_frequency;
fff80224:	39 2d 00 20 	addi    r9,r13,32
fff80228:	90 69 00 20 	stw     r3,32(r9)
fff8022c:	4e 80 00 20 	blr
	...

fff80240 <__pk_idle_thread>:
fff80240:	7c 70 42 a6 	mfsprg  r3,0
fff80244:	54 63 84 3e 	rlwinm  r3,r3,16,16,31
fff80248:	64 63 a0 80 	oris    r3,r3,41088
fff8024c:	7c 70 43 a6 	mtsprg  0,r3
fff80250:	80 2d 13 54 	lwz     r1,4948(r13)

fff80254 <__pk_idle_thread_from_bootloader>:
fff80254:	80 6d 13 38 	lwz     r3,4920(r13)
fff80258:	64 63 00 04 	oris    r3,r3,4
fff8025c:	4b ff fd b5 	bl      fff80010 <__set_msr>
fff80260:	48 00 00 00 	b       fff80260 <__pk_idle_thread_from_bootloader+0xc>

fff80264 <pk_halt>:
fff80264:	3f e0 30 00 	lis     r31,12288
fff80268:	7f f4 4b a6 	mtspr   308,r31
fff8026c:	00 00 00 00 	.long 0x0

fff80270 <dec_handler>:
fff80270:	38 80 00 58 	li      r4,88
fff80274:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fff80278:	64 63 40 00 	oris    r3,r3,16384
fff8027c:	7c 70 43 a6 	mtsprg  0,r3
fff80280:	3c 60 08 00 	lis     r3,2048
fff80284:	7c 70 53 a6 	mtspr   336,r3
fff80288:	48 00 04 91 	bl      fff80718 <__pk_timer_handler>
fff8028c:	48 00 01 5c 	b       fff803e8 <check_for_ext_interrupt>

fff80290 <__pk_next_thread_resume>:
fff80290:	80 6d 13 40 	lwz     r3,4928(r13)
fff80294:	90 6d 13 44 	stw     r3,4932(r13)
fff80298:	06 c3 07 d4 	bwz     r3,fff80240 <__pk_idle_thread>
fff8029c:	80 23 00 00 	lwz     r1,0(r3)

fff802a0 <restore_and_update_sprg0>:
fff802a0:	8b ed 13 3c 	lbz     r31,4924(r13)
fff802a4:	80 61 00 0c 	lwz     r3,12(r1)
fff802a8:	53 e3 c0 8e 	rlwimi  r3,r31,24,2,7
fff802ac:	7c 70 43 a6 	mtsprg  0,r3
fff802b0:	48 00 01 ac 	b       fff8045c <ctx_pop>

fff802b4 <fit_handler>:
fff802b4:	38 80 00 59 	li      r4,89
fff802b8:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fff802bc:	64 63 40 00 	oris    r3,r3,16384
fff802c0:	7c 70 43 a6 	mtsprg  0,r3
fff802c4:	80 6d 40 08 	lwz     r3,16392(r13)
fff802c8:	3c c0 04 00 	lis     r6,1024
fff802cc:	7c d0 53 a6 	mtspr   336,r6
fff802d0:	80 cd 40 14 	lwz     r6,16404(r13)
fff802d4:	7c c8 03 a6 	mtlr    r6
fff802d8:	4e 80 00 21 	blrl
fff802dc:	48 00 01 0c 	b       fff803e8 <check_for_ext_interrupt>

fff802e0 <watchdog_handler>:
fff802e0:	38 80 00 5a 	li      r4,90
fff802e4:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fff802e8:	64 63 40 00 	oris    r3,r3,16384
fff802ec:	7c 70 43 a6 	mtsprg  0,r3
fff802f0:	3c c0 40 00 	lis     r6,16384
fff802f4:	7c d0 53 a6 	mtspr   336,r6
fff802f8:	80 cd 40 10 	lwz     r6,16400(r13)
fff802fc:	7c c8 03 a6 	mtlr    r6
fff80300:	4e 80 00 21 	blrl
fff80304:	48 00 00 e4 	b       fff803e8 <check_for_ext_interrupt>
fff80308:	48 00 00 18 	b       fff80320 <ctx_check_discard>
fff8030c:	60 00 00 00 	nop
fff80310:	60 00 00 00 	nop
fff80314:	60 00 00 00 	nop
fff80318:	60 00 00 00 	nop
fff8031c:	60 00 00 00 	nop

fff80320 <ctx_check_discard>:
fff80320:	07 84 40 1a 	bb0wi   r4,8,fff80354 <ctx_interrupt_check>
fff80324:	38 21 00 58 	addi    r1,r1,88
fff80328:	4e 80 00 20 	blr

fff8032c <__ctx_switch>:
fff8032c:	7c 68 02 a6 	mflr    r3
fff80330:	7c 80 00 a6 	mfmsr   r4
fff80334:	7c 00 01 46 	wrteei  0
fff80338:	7c 7a 03 a6 	mtsrr0  r3
fff8033c:	7c 9b 03 a6 	mtsrr1  r4
fff80340:	7c 00 04 ac 	sync    
fff80344:	f8 21 ff af 	stcxu   r1,-88(r1)
fff80348:	3c a0 ff f8 	lis     r5,-8
fff8034c:	60 a5 02 90 	ori     r5,r5,656
fff80350:	7c a8 03 a6 	mtlr    r5

fff80354 <ctx_interrupt_check>:
fff80354:	7c 70 42 a6 	mfsprg  r3,0
fff80358:	07 03 08 14 	bb1wi   r3,1,fff80380 <kernel_stack_check>
fff8035c:	80 8d 13 44 	lwz     r4,4932(r13)
fff80360:	06 c4 00 0a 	bwz     r4,fff80374 <stack_good>
fff80364:	90 24 00 00 	stw     r1,0(r4)
fff80368:	80 e4 00 04 	lwz     r7,4(r4)
fff8036c:	05 87 08 04 	cmplwblt r7,r1,fff80374 <stack_good>
fff80370:	7f e3 28 08 	twu     r3,r5

fff80374 <stack_good>:
fff80374:	90 2d 13 58 	stw     r1,4952(r13)
fff80378:	80 2d 13 54 	lwz     r1,4948(r13)
fff8037c:	4e 80 00 20 	blr

fff80380 <kernel_stack_check>:
fff80380:	80 ed 13 50 	lwz     r7,4944(r13)
fff80384:	05 87 08 04 	cmplwblt r7,r1,fff8038c <ctx_push_complete>
fff80388:	7f e3 28 08 	twu     r3,r5

fff8038c <ctx_push_complete>:
fff8038c:	4e 80 00 20 	blr

fff80390 <__get_ext_irq>:
fff80390:	7c 70 42 a6 	mfsprg  r3,0
fff80394:	3c a0 00 82 	lis     r5,130
fff80398:	60 a5 18 00 	ori     r5,r5,6144
fff8039c:	7c a0 01 24 	mtmsr   r5
fff803a0:	7c 00 04 ac 	sync    
fff803a4:	3c a0 c0 00 	lis     r5,-16384
fff803a8:	14 a5 00 80 	lvd     d5,128(r5)
fff803ac:	7c a4 00 34 	cntlzw  r4,r5
fff803b0:	06 24 f8 06 	cmpwible r4,31,fff803bc <call_external_irq_handler>
fff803b4:	7c c4 00 34 	cntlzw  r4,r6
fff803b8:	38 84 00 20 	addi    r4,r4,32

fff803bc <call_external_irq_handler>:
fff803bc:	50 83 82 5e 	rlwimi  r3,r4,16,9,15
fff803c0:	64 63 40 00 	oris    r3,r3,16384
fff803c4:	7c 70 43 a6 	mtsprg  0,r3
fff803c8:	54 83 18 38 	rlwinm  r3,r4,3,0,28
fff803cc:	3c c0 ff f8 	lis     r6,-8
fff803d0:	60 c6 79 f8 	ori     r6,r6,31224
fff803d4:	7c a6 18 2e 	lwzx    r5,r6,r3
fff803d8:	38 63 00 04 	addi    r3,r3,4
fff803dc:	7c 66 18 2e 	lwzx    r3,r6,r3
fff803e0:	7c a8 03 a6 	mtlr    r5
fff803e4:	4e 80 00 21 	blrl

fff803e8 <check_for_ext_interrupt>:
fff803e8:	7f f0 42 a6 	mfsprg  r31,0
fff803ec:	67 ff 00 80 	oris    r31,r31,128
fff803f0:	7f f0 43 a6 	mtsprg  0,r31
fff803f4:	7c 00 81 46 	wrteei  1
fff803f8:	7c 00 01 46 	wrteei  0

fff803fc <check_interrupted_bh>:
fff803fc:	57 e4 46 be 	rlwinm  r4,r31,8,26,31
fff80400:	2c 04 00 21 	cmpwi   r4,33
fff80404:	41 82 00 50 	beq     fff80454 <ctx_pop_with_sprg0>

fff80408 <check_for_bh>:
fff80408:	80 8d 12 90 	lwz     r4,4752(r13)
fff8040c:	80 a4 00 00 	lwz     r5,0(r4)
fff80410:	05 c4 28 10 	cmplwbeq r4,r5,fff80430 <restore_interrupted_sp>

fff80414 <process_bottom_halves>:
fff80414:	57 e3 02 42 	rlwinm  r3,r31,0,9,1
fff80418:	64 63 21 00 	oris    r3,r3,8448
fff8041c:	7c 70 43 a6 	mtsprg  0,r3
fff80420:	7c 00 81 46 	wrteei  1
fff80424:	48 00 00 a1 	bl      fff804c4 <_pk_process_bh>
fff80428:	7c 00 01 46 	wrteei  0
fff8042c:	7f f0 43 a6 	mtsprg  0,r31

fff80430 <restore_interrupted_sp>:
fff80430:	80 2d 13 58 	lwz     r1,4952(r13)

fff80434 <check_thread_mode>:
fff80434:	07 9f 00 10 	bb0wi   r31,0,fff80454 <ctx_pop_with_sprg0>

fff80438 <check_for_ctx_switch>:
fff80438:	80 6d 13 48 	lwz     r3,4936(r13)
fff8043c:	06 c3 00 08 	bwz     r3,fff8044c <check_for_idle_thread>
fff80440:	38 60 00 00 	li      r3,0
fff80444:	90 6d 13 48 	stw     r3,4936(r13)
fff80448:	4b ff fe 48 	b       fff80290 <__pk_next_thread_resume>

fff8044c <check_for_idle_thread>:
fff8044c:	80 6d 13 44 	lwz     r3,4932(r13)
fff80450:	06 c3 06 f8 	bwz     r3,fff80240 <__pk_idle_thread>

fff80454 <ctx_pop_with_sprg0>:
fff80454:	80 01 00 0c 	lwz     r0,12(r1)
fff80458:	7c 10 43 a6 	mtsprg  0,r0

fff8045c <ctx_pop>:
fff8045c:	e8 21 00 5f 	lcxu    r1,88(r1)
fff80460:	4c 00 00 64 	rfi

fff80464 <__ppe42_default_irq_handler>:
/// by the application.  These interrupts should never fire.

void
__ppe42_default_irq_handler(void* arg, PkIrqId irq)
{
    PK_PANIC(PK_DEFAULT_IRQ_HANDLER);
fff80464:	7f e0 30 08 	twu     r0,r6
fff80468:	4e 80 00 20 	blr

fff8046c <__ppe42_phantom_irq_handler>:
/// 'glitch' occurred on the external interrupt input
/// to the PPE42 core.

void __ppe42_phantom_irq_handler(void* arg, PkIrqId irq)
{
    PK_PANIC(PPE42_PHANTOM_INTERRUPT);
fff8046c:	7f e0 40 08 	twu     r0,r8
fff80470:	4e 80 00 20 	blr
	...

fff80480 <pk_timebase32_get>:
fff80480:	14 8d 40 18 	lvd     d4,16408(r13)
fff80484:	80 6d 40 24 	lwz     r3,16420(r13)
fff80488:	7c 16 02 a6 	mfdec   r0
fff8048c:	80 cd 40 1c 	lwz     r6,16412(r13)
fff80490:	05 45 37 f8 	cmplwbne r5,r6,fff80480 <pk_timebase32_get>
fff80494:	7c a0 20 50 	subf    r5,r0,r4
fff80498:	7c 65 1a 14 	add     r3,r5,r3
fff8049c:	4e 80 00 20 	blr

fff804a0 <pk_timebase_get>:
fff804a0:	14 ad 40 18 	lvd     d5,16408(r13)
fff804a4:	14 6d 40 20 	lvd     d3,16416(r13)
fff804a8:	7c 16 02 a6 	mfdec   r0
fff804ac:	80 ed 40 1c 	lwz     r7,16412(r13)
fff804b0:	05 46 3f f8 	cmplwbne r6,r7,fff804a0 <pk_timebase_get>
fff804b4:	7c c0 28 50 	subf    r6,r0,r5
fff804b8:	7c 86 20 14 	addc    r4,r6,r4
fff804bc:	7c 63 01 94 	addze   r3,r3
fff804c0:	4e 80 00 20 	blr

fff804c4 <_pk_process_bh>:

/// Statically initialize the bottom half queue
PK_DEQUE_SENTINEL_STATIC_CREATE(_pk_bh_queue);

void _pk_process_bh(void)
{
fff804c4:	94 21 ff f0 	stwu    r1,-16(r1)
fff804c8:	7c 08 02 a6 	mflr    r0
fff804cc:	1b c1 00 08 	stvd    d30,8(r1)
fff804d0:	90 01 00 14 	stw     r0,20(r1)
/// \retval 1 The PkDeque is empty

static inline int
pk_deque_is_empty(PkDeque* deque)
{
    return (deque == deque->next);
fff804d4:	3b ed 12 90 	addi    r31,r13,4752
fff804d8:	81 2d 12 90 	lwz     r9,4752(r13)
static inline PkDeque*
pk_deque_pop_front(PkDeque* deque)
{
    PkDeque* head;

    if (pk_deque_is_empty(deque))
fff804dc:	04 c9 f8 16 	cmpwbeq r9,r31,fff80508 <_pk_process_bh+0x44>
        return 0;
    }
    else
    {
        head = (PkDeque*)(deque->next);
        deque->next = head->next;
fff804e0:	81 49 00 00 	lwz     r10,0(r9)
    PkBottomHalf* bh;

    while((bh = (PkBottomHalf*)pk_deque_pop_front(&_pk_bh_queue)) != 0)
    {
        bh->bh_handler(bh->arg);
fff804e4:	80 69 00 0c 	lwz     r3,12(r9)
        deque->next->previous = deque;
fff804e8:	93 ea 00 04 	stw     r31,4(r10)
        return 0;
    }
    else
    {
        head = (PkDeque*)(deque->next);
        deque->next = head->next;
fff804ec:	91 4d 12 90 	stw     r10,4752(r13)
        deque->next->previous = deque;
        head->next = 0;
fff804f0:	39 40 00 00 	li      r10,0
fff804f4:	91 49 00 00 	stw     r10,0(r9)
fff804f8:	81 49 00 08 	lwz     r10,8(r9)
fff804fc:	7d 49 03 a6 	mtctr   r10
fff80500:	4e 80 04 21 	bctrl
fff80504:	4b ff ff d4 	b       fff804d8 <_pk_process_bh+0x14>
    }

    return;
}
fff80508:	80 01 00 14 	lwz     r0,20(r1)
fff8050c:	17 c1 00 08 	lvd     d30,8(r1)
fff80510:	7c 08 03 a6 	mtlr    r0
fff80514:	38 21 00 10 	addi    r1,r1,16
fff80518:	4e 80 00 20 	blr

fff8051c <pk_deque_sentinel_create>:
int
pk_deque_sentinel_create(PkDeque* deque)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(deque == 0, PK_INVALID_DEQUE_SENTINEL);
fff8051c:	06 c3 00 0a 	bwz     r3,fff80530 <pk_deque_sentinel_create+0x14>
    }

    deque->next = deque->previous = deque;
fff80520:	90 63 00 04 	stw     r3,4(r3)
fff80524:	90 63 00 00 	stw     r3,0(r3)
    return 0;
fff80528:	38 60 00 00 	li      r3,0
fff8052c:	4e 80 00 20 	blr
int
pk_deque_sentinel_create(PkDeque* deque)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(deque == 0, PK_INVALID_DEQUE_SENTINEL);
fff80530:	38 60 fc e1 	li      r3,-799
    }

    deque->next = deque->previous = deque;
    return 0;
}
fff80534:	4e 80 00 20 	blr

fff80538 <pk_deque_element_create>:
int
pk_deque_element_create(PkDeque* element)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(element == 0, PK_INVALID_DEQUE_ELEMENT);
fff80538:	06 c3 00 0a 	bwz     r3,fff8054c <pk_deque_element_create+0x14>
    }

    element->next = 0;
fff8053c:	39 20 00 00 	li      r9,0
fff80540:	91 23 00 00 	stw     r9,0(r3)
    return 0;
fff80544:	38 60 00 00 	li      r3,0
fff80548:	4e 80 00 20 	blr
int
pk_deque_element_create(PkDeque* element)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(element == 0, PK_INVALID_DEQUE_ELEMENT);
fff8054c:	38 60 fc 00 	li      r3,-1024
    }

    element->next = 0;
    return 0;
}
fff80550:	4e 80 00 20 	blr

fff80554 <__pk_timer_bh_handler>:
// The main loop iterates on the PkDeque form of the time queue, casting each
// element back up to the PkTimer as it is processed.

static void
__pk_timer_bh_handler(void* arg)
{
fff80554:	94 21 ff e0 	stwu    r1,-32(r1)
fff80558:	7c 08 02 a6 	mflr    r0
fff8055c:	1b c1 00 18 	stvd    d30,24(r1)
fff80560:	90 01 00 24 	stw     r0,36(r1)
    tq = &__pk_time_queue;

    // Check if we entered the function while it was running in another context.
    if (PK_ERROR_CHECK_KERNEL)
    {
        if (tq->cursor != 0)
fff80564:	3b ed 12 98 	addi    r31,r13,4760
fff80568:	81 3f 00 10 	lwz     r9,16(r31)
// The main loop iterates on the PkDeque form of the time queue, casting each
// element back up to the PkTimer as it is processed.

static void
__pk_timer_bh_handler(void* arg)
{
fff8056c:	1b 81 00 10 	stvd    d28,16(r1)
    tq = &__pk_time_queue;

    // Check if we entered the function while it was running in another context.
    if (PK_ERROR_CHECK_KERNEL)
    {
        if (tq->cursor != 0)
fff80570:	06 c9 00 04 	bwz     r9,fff80578 <__pk_timer_bh_handler+0x24>
        {
            PK_PANIC(PK_TIMER_HANDLER_INVARIANT);
fff80574:	7f e4 30 08 	twu     r4,r6

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff80578:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fff8057c:	7c 00 01 46 	wrteei  0

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
    {
        tq->next_timeout = PK_TIMEBASE_MAX;
fff80580:	3b 80 ff ff 	li      r28,-1
fff80584:	3b a0 ff ff 	li      r29,-1
        }
    }

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
fff80588:	4b ff ff 19 	bl      fff804a0 <pk_timebase_get>
fff8058c:	81 2d 12 a0 	lwz     r9,4768(r13)
fff80590:	7c 68 1b 78 	mr      r8,r3
fff80594:	05 a9 40 62 	cmplwbgt r9,r8,fff80658 <__pk_timer_bh_handler+0x104>
fff80598:	04 c9 40 5a 	cmpwbeq r9,r8,fff8064c <__pk_timer_bh_handler+0xf8>
    {
        tq->next_timeout = PK_TIMEBASE_MAX;
fff8059c:	1b 8d 12 a0 	stvd    d28,4768(r13)
        timer_deque = ((PkDeque*)tq)->next;
fff805a0:	81 2d 12 98 	lwz     r9,4760(r13)

        // Iterate through the entire timer list, calling the callback of
        // timed-out elements and finding the timer that will timeout next,
        // which is stored in tq->next_timeout.
        while (timer_deque != (PkDeque*)tq)
fff805a4:	04 c9 ff f2 	cmpwbeq r9,r31,fff80588 <__pk_timer_bh_handler+0x34>

            timer = (PkTimer*)timer_deque;

            // Setting this to a non-zero value indicates we are in the middle
            // of processing the time queue.
            tq->cursor = timer_deque->next;
fff805a8:	80 e9 00 00 	lwz     r7,0(r9)
fff805ac:	39 4d 12 98 	addi    r10,r13,4760
fff805b0:	90 ea 00 10 	stw     r7,16(r10)

            if (timer->timeout <= now)
fff805b4:	81 49 00 08 	lwz     r10,8(r9)
fff805b8:	80 c9 00 0c 	lwz     r6,12(r9)
fff805bc:	80 e9 00 00 	lwz     r7,0(r9)
fff805c0:	05 aa 40 28 	cmplwbgt r10,r8,fff80610 <__pk_timer_bh_handler+0xbc>
fff805c4:	04 4a 40 04 	cmpwbne r10,r8,fff805cc <__pk_timer_bh_handler+0x78>
fff805c8:	05 a6 20 24 	cmplwbgt r6,r4,fff80610 <__pk_timer_bh_handler+0xbc>
/// enqueued, but the API does not check for this error.

static inline void
pk_deque_delete(PkDeque* element)
{
    element->previous->next = element->next;
fff805cc:	81 49 00 04 	lwz     r10,4(r9)
fff805d0:	90 ea 00 00 	stw     r7,0(r10)
    element->next->previous = element->previous;
fff805d4:	80 e9 00 00 	lwz     r7,0(r9)
fff805d8:	91 47 00 04 	stw     r10,4(r7)
    element->next = 0;
fff805dc:	39 40 00 00 	li      r10,0
fff805e0:	91 49 00 00 	stw     r10,0(r9)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff805e4:	7f c0 01 24 	mtmsr   r30

                pk_deque_delete(timer_deque);

                pk_critical_section_exit(&ctx);

                callback = timer->callback;
fff805e8:	81 49 00 10 	lwz     r10,16(r9)

                if (callback)
fff805ec:	06 ca 00 28 	bwz     r10,fff8063c <__pk_timer_bh_handler+0xe8>
                {
                    callback(timer->arg);
fff805f0:	80 69 00 14 	lwz     r3,20(r9)
fff805f4:	7d 49 03 a6 	mtctr   r10
fff805f8:	90 81 00 0c 	stw     r4,12(r1)
fff805fc:	91 01 00 08 	stw     r8,8(r1)
fff80600:	4e 80 04 21 	bctrl
fff80604:	80 81 00 0c 	lwz     r4,12(r1)
fff80608:	81 01 00 08 	lwz     r8,8(r1)
fff8060c:	48 00 00 30 	b       fff8063c <__pk_timer_bh_handler+0xe8>
            else
            {

                // This timer has not timed out.  Its timeout will simply
                // participate in the computation of the next timeout.
                tq->next_timeout = MIN(timer->timeout, tq->next_timeout);
fff80610:	81 2d 12 a0 	lwz     r9,4768(r13)
fff80614:	80 ff 00 0c 	lwz     r7,12(r31)
fff80618:	05 a9 50 06 	cmplwbgt r9,r10,fff80624 <__pk_timer_bh_handler+0xd0>
fff8061c:	04 49 50 08 	cmpwbne r9,r10,fff8062c <__pk_timer_bh_handler+0xd8>
fff80620:	05 27 30 06 	cmplwble r7,r6,fff8062c <__pk_timer_bh_handler+0xd8>
fff80624:	7d 49 53 78 	mr      r9,r10
fff80628:	7c c7 33 78 	mr      r7,r6
fff8062c:	91 2d 12 a0 	stw     r9,4768(r13)
fff80630:	39 2d 12 98 	addi    r9,r13,4760
fff80634:	90 e9 00 0c 	stw     r7,12(r9)
fff80638:	7f c0 01 24 	mtmsr   r30
                pk_critical_section_exit(&ctx);
            }

            timer_deque = tq->cursor;
fff8063c:	81 3f 00 10 	lwz     r9,16(r31)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff80640:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fff80644:	7c 00 01 46 	wrteei  0
fff80648:	4b ff ff 5c 	b       fff805a4 <__pk_timer_bh_handler+0x50>
        }
    }

    pk_critical_section_enter(&ctx);

    while ((now = pk_timebase_get()) >= tq->next_timeout)
fff8064c:	39 2d 12 98 	addi    r9,r13,4760
fff80650:	81 29 00 0c 	lwz     r9,12(r9)
fff80654:	05 29 27 a4 	cmplwble r9,r4,fff8059c <__pk_timer_bh_handler+0x48>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff80658:	7f c0 01 24 	mtmsr   r30
    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fff8065c:	80 01 00 24 	lwz     r0,36(r1)
    }

    pk_critical_section_exit(&ctx);

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;
fff80660:	39 20 00 00 	li      r9,0

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fff80664:	7c 08 03 a6 	mtlr    r0
    }

    pk_critical_section_exit(&ctx);

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;
fff80668:	91 3f 00 10 	stw     r9,16(r31)

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
}
fff8066c:	17 81 00 10 	lvd     d28,16(r1)
fff80670:	17 c1 00 18 	lvd     d30,24(r1)

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
fff80674:	14 6d 12 a0 	lvd     d3,4768(r13)
}
fff80678:	38 21 00 20 	addi    r1,r1,32

    // This marks that we are no longer processing the time queue
    tq->cursor = 0;

    // Finally, reschedule the next timeout
    __pk_schedule_hardware_timeout(tq->next_timeout);
fff8067c:	48 00 01 a8 	b       fff80824 <__pk_schedule_hardware_timeout>

fff80680 <__pk_timer_cancel>:
//  Note that cancelling a timer does not cause a re-evaluation of the next
//  timeout.  This will happen naturally when the current timeout expires.

int
__pk_timer_cancel(PkTimer* timer)
{
fff80680:	81 23 00 00 	lwz     r9,0(r3)
    int rc;
    PkDeque* timer_deque = (PkDeque*)timer;
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fff80684:	06 c9 00 1a 	bwz     r9,fff806b8 <__pk_timer_cancel+0x38>

    }
    else
    {

        if (timer_deque == tq->cursor)
fff80688:	39 4d 12 98 	addi    r10,r13,4760
fff8068c:	81 0a 00 10 	lwz     r8,16(r10)
fff80690:	04 43 40 04 	cmpwbne r3,r8,fff80698 <__pk_timer_cancel+0x18>
        {
            tq->cursor = tq->cursor->next;
fff80694:	91 2a 00 10 	stw     r9,16(r10)
/// enqueued, but the API does not check for this error.

static inline void
pk_deque_delete(PkDeque* element)
{
    element->previous->next = element->next;
fff80698:	81 43 00 04 	lwz     r10,4(r3)
fff8069c:	91 2a 00 00 	stw     r9,0(r10)
    element->next->previous = element->previous;
fff806a0:	81 23 00 00 	lwz     r9,0(r3)
fff806a4:	91 49 00 04 	stw     r10,4(r9)
    element->next = 0;
fff806a8:	39 20 00 00 	li      r9,0
fff806ac:	91 23 00 00 	stw     r9,0(r3)
        }

        pk_deque_delete(timer_deque);
        rc = 0;
fff806b0:	38 60 00 00 	li      r3,0
fff806b4:	4e 80 00 20 	blr
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
    {

        rc = -PK_TIMER_NOT_ACTIVE;
fff806b8:	38 60 fc f9 	li      r3,-775
        pk_deque_delete(timer_deque);
        rc = 0;
    }

    return rc;
}
fff806bc:	4e 80 00 20 	blr

fff806c0 <__pk_timer_schedule>:
void
__pk_timer_schedule(PkTimer* timer)
{
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fff806c0:	81 03 00 00 	lwz     r8,0(r3)
// we are in the midst of processing the time queue, and the end of time queue
// processing will schedule the next hardware timemout.

void
__pk_timer_schedule(PkTimer* timer)
{
fff806c4:	7c 69 1b 78 	mr      r9,r3
fff806c8:	39 4d 12 98 	addi    r10,r13,4760
    PkTimeQueue* tq = &__pk_time_queue;

    if (!timer_active(timer))
fff806cc:	06 48 00 0c 	bwnz    r8,fff806e4 <__pk_timer_schedule+0x24>
/// but the API does not check for this error.

static inline void
pk_deque_push_back(PkDeque* deque, PkDeque* element)
{
    deque->previous->next = element;
fff806d0:	81 0d 12 9c 	lwz     r8,4764(r13)
fff806d4:	90 68 00 00 	stw     r3,0(r8)
    element->previous = deque->previous;
fff806d8:	91 03 00 04 	stw     r8,4(r3)
    element->next = deque;
fff806dc:	91 43 00 00 	stw     r10,0(r3)
    deque->previous = element;
fff806e0:	90 6d 12 9c 	stw     r3,4764(r13)
    {
        pk_deque_push_back((PkDeque*)tq, (PkDeque*)timer);
    }

    if (timer->timeout < tq->next_timeout)
fff806e4:	14 69 00 08 	lvd     d3,8(r9)
fff806e8:	81 2d 12 a0 	lwz     r9,4768(r13)
fff806ec:	05 a9 18 0a 	cmplwbgt r9,r3,fff80700 <__pk_timer_schedule+0x40>
fff806f0:	04 49 18 12 	cmpwbne r9,r3,fff80714 <__pk_timer_schedule+0x54>
fff806f4:	39 2d 12 98 	addi    r9,r13,4760
fff806f8:	81 29 00 0c 	lwz     r9,12(r9)
fff806fc:	05 29 20 0c 	cmplwble r9,r4,fff80714 <__pk_timer_schedule+0x54>
    {
        tq->next_timeout = timer->timeout;

        if (tq->cursor == 0)
fff80700:	81 2a 00 10 	lwz     r9,16(r10)
        pk_deque_push_back((PkDeque*)tq, (PkDeque*)timer);
    }

    if (timer->timeout < tq->next_timeout)
    {
        tq->next_timeout = timer->timeout;
fff80704:	90 6d 12 a0 	stw     r3,4768(r13)
fff80708:	90 8a 00 0c 	stw     r4,12(r10)

        if (tq->cursor == 0)
fff8070c:	06 49 00 04 	bwnz    r9,fff80714 <__pk_timer_schedule+0x54>
        {
            __pk_schedule_hardware_timeout(tq->next_timeout);
fff80710:	48 00 01 14 	b       fff80824 <__pk_schedule_hardware_timeout>
fff80714:	4e 80 00 20 	blr

fff80718 <__pk_timer_handler>:
extern PkDeque _pk_bh_queue SECTION(".sdata.pk");

static inline void
pk_bh_schedule(PkBottomHalf* bottom_half)
{
    if(!pk_deque_is_queued((PkDeque*)bottom_half))
fff80718:	81 4d 13 5c 	lwz     r10,4956(r13)
fff8071c:	39 2d 13 5c 	addi    r9,r13,4956
fff80720:	06 4a 00 0e 	bwnz    r10,fff8073c <__pk_timer_handler+0x24>
/// but the API does not check for this error.

static inline void
pk_deque_push_back(PkDeque* deque, PkDeque* element)
{
    deque->previous->next = element;
fff80724:	81 4d 12 94 	lwz     r10,4756(r13)
fff80728:	91 2a 00 00 	stw     r9,0(r10)
    element->previous = deque->previous;
fff8072c:	91 4d 13 60 	stw     r10,4960(r13)
    element->next = deque;
fff80730:	39 4d 12 90 	addi    r10,r13,4752
fff80734:	91 4d 13 5c 	stw     r10,4956(r13)
    deque->previous = element;
fff80738:	91 2d 12 94 	stw     r9,4756(r13)
fff8073c:	4e 80 00 20 	blr

fff80740 <pk_timer_schedule>:
///

int
pk_timer_schedule(PkTimer*    timer,
                  PkInterval interval)
{
fff80740:	94 21 ff e8 	stwu    r1,-24(r1)
fff80744:	7c 08 02 a6 	mflr    r0
fff80748:	1b c1 00 10 	stvd    d30,16(r1)
fff8074c:	1b 81 00 08 	stvd    d28,8(r1)
fff80750:	7c df 33 78 	mr      r31,r6
fff80754:	7c be 2b 78 	mr      r30,r5
fff80758:	90 01 00 1c 	stw     r0,28(r1)
fff8075c:	7c 7d 1b 78 	mr      r29,r3
    PkMachineContext ctx;
    PkTimebase  timeout = pk_timebase_get() + PK_INTERVAL_SCALE(interval);
fff80760:	4b ff fd 41 	bl      fff804a0 <pk_timebase_get>
fff80764:	3d 20 ff f8 	lis     r9,-8
fff80768:	89 09 69 70 	lbz     r8,26992(r9)
fff8076c:	7f c8 44 76 	srvd    d8,d30,r8
fff80770:	7f ff 48 14 	addc    r31,r31,r9
fff80774:	7f de 41 14 	adde    r30,r30,r8
fff80778:	7f ff 20 14 	addc    r31,r31,r4
fff8077c:	7f de 19 14 	adde    r30,r30,r3

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff80780:	7f 80 00 a6 	mfmsr   r28

wrteei(0);
fff80784:	7c 00 01 46 	wrteei  0

    pk_critical_section_enter(&ctx);

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(timer == 0, PK_INVALID_TIMER_AT_SCHEDULE);
fff80788:	38 60 fd fd 	li      r3,-515
fff8078c:	06 dd 00 0c 	bwz     r29,fff807a4 <pk_timer_schedule+0x64>
    }

    timer->timeout = timeout;
fff80790:	1b dd 00 08 	stvd    d30,8(r29)
    __pk_timer_schedule(timer);
fff80794:	7f a3 eb 78 	mr      r3,r29
fff80798:	4b ff ff 29 	bl      fff806c0 <__pk_timer_schedule>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff8079c:	7f 80 01 24 	mtmsr   r28

    pk_critical_section_exit(&ctx);

    return PK_OK;
fff807a0:	38 60 00 00 	li      r3,0
}
fff807a4:	80 01 00 1c 	lwz     r0,28(r1)
fff807a8:	17 81 00 08 	lvd     d28,8(r1)
fff807ac:	7c 08 03 a6 	mtlr    r0
fff807b0:	17 c1 00 10 	lvd     d30,16(r1)
fff807b4:	38 21 00 18 	addi    r1,r1,24
fff807b8:	4e 80 00 20 	blr

fff807bc <__pk_boot>:
fff807bc:	38 60 00 00 	li      r3,0
fff807c0:	7c 74 53 a6 	mtspr   340,r3
fff807c4:	3c 40 ff f8 	lis     r2,-8
fff807c8:	60 42 66 48 	ori     r2,r2,26184
fff807cc:	3d a0 ff f8 	lis     r13,-8
fff807d0:	61 ad 69 70 	ori     r13,r13,26992
fff807d4:	3c 20 ff f8 	lis     r1,-8
fff807d8:	60 21 ad bf 	ori     r1,r1,44479
fff807dc:	54 21 00 38 	rlwinm  r1,r1,0,0,28
fff807e0:	94 61 ff f8 	stwu    r3,-8(r1)
fff807e4:	7c 70 43 a6 	mtsprg  0,r3
fff807e8:	3c 60 01 80 	lis     r3,384
fff807ec:	60 63 00 04 	ori     r3,r3,4
fff807f0:	7c 74 4b a6 	mtspr   308,r3
fff807f4:	38 60 00 00 	li      r3,0
fff807f8:	7c 7c 4b a6 	mtspr   316,r3
fff807fc:	3c 60 00 82 	lis     r3,130
fff80800:	60 63 18 00 	ori     r3,r3,6144
fff80804:	7c 60 01 24 	mtmsr   r3
fff80808:	7c 00 04 ac 	sync    
fff8080c:	48 00 00 c1 	bl      fff808cc <__ppe42_system_setup>
fff80810:	38 60 00 00 	li      r3,0
fff80814:	3c 80 00 00 	lis     r4,0
fff80818:	60 84 00 00 	ori     r4,r4,0
fff8081c:	48 00 02 ed 	bl      fff80b08 <__pk_main>
fff80820:	4b ff fa 34 	b       fff80254 <__pk_idle_thread_from_bootloader>

fff80824 <__pk_schedule_hardware_timeout>:
{
    PkTimebase       now;
    uint32_t         new_dec;
    uint32_t         dec;

    if (timeout != PK_TIMEBASE_MAX)
fff80824:	2c 03 ff ff 	cmpwi   r3,-1
// in the future in accordance with the PK specification.

#ifndef APPCFG_USE_EXT_TIMEBASE
void
__pk_schedule_hardware_timeout(PkTimebase timeout)
{
fff80828:	94 21 ff f0 	stwu    r1,-16(r1)
fff8082c:	7c 08 02 a6 	mflr    r0
fff80830:	1b c1 00 08 	stvd    d30,8(r1)
fff80834:	90 01 00 14 	stw     r0,20(r1)
fff80838:	7c 9f 23 78 	mr      r31,r4
fff8083c:	7c 7e 1b 78 	mr      r30,r3
    PkTimebase       now;
    uint32_t         new_dec;
    uint32_t         dec;

    if (timeout != PK_TIMEBASE_MAX)
fff80840:	40 a2 00 0c 	bne     fff8084c <__pk_schedule_hardware_timeout+0x28>
fff80844:	2c 04 ff ff 	cmpwi   r4,-1
fff80848:	41 82 00 70 	beq     fff808b8 <__pk_schedule_hardware_timeout+0x94>
    {

        now = pk_timebase_get();
fff8084c:	4b ff fc 55 	bl      fff804a0 <pk_timebase_get>

        if (timeout <= now)
fff80850:	05 be 18 06 	cmplwbgt r30,r3,fff8085c <__pk_schedule_hardware_timeout+0x38>
fff80854:	04 5e 18 12 	cmpwbne r30,r3,fff80878 <__pk_schedule_hardware_timeout+0x54>
fff80858:	05 3f 20 10 	cmplwble r31,r4,fff80878 <__pk_schedule_hardware_timeout+0x54>
        {
            new_dec = 1;
        }
        else if ((timeout - now) > 0xffff0000)
fff8085c:	7d 24 f8 10 	subfc   r9,r4,r31
fff80860:	7d 03 f1 10 	subfe   r8,r3,r30
fff80864:	06 48 00 0e 	bwnz    r8,fff80880 <__pk_schedule_hardware_timeout+0x5c>
fff80868:	3d 40 ff ff 	lis     r10,-1
fff8086c:	05 8a 48 0a 	cmplwblt r10,r9,fff80880 <__pk_schedule_hardware_timeout+0x5c>
        {
            new_dec = 0xffff0000;
        }
        else
        {
            new_dec = timeout - now;
fff80870:	7d 44 f8 50 	subf    r10,r4,r31
fff80874:	48 00 00 10 	b       fff80884 <__pk_schedule_hardware_timeout+0x60>

        now = pk_timebase_get();

        if (timeout <= now)
        {
            new_dec = 1;
fff80878:	39 40 00 01 	li      r10,1
fff8087c:	48 00 00 08 	b       fff80884 <__pk_schedule_hardware_timeout+0x60>
        }
        else if ((timeout - now) > 0xffff0000)
        {
            new_dec = 0xffff0000;
fff80880:	3d 40 ff ff 	lis     r10,-1
            new_dec = timeout - now;
        }

        //read and write the DEC back-to-back so that we lose as little time
        //as possible
        dec = mfspr(SPRN_DEC);
fff80884:	7c f6 02 a6 	mfdec   r7
        mtspr(SPRN_DEC, new_dec);
fff80888:	7d 56 03 a6 	mtdec   r10

        //update our 64bit accumulator with how much time has advanced since
        //we last changed it.
        ppe42_64bit_timebase += ppe42_tb_data.dec_start - dec;
fff8088c:	80 cd 40 18 	lwz     r6,16408(r13)
fff80890:	39 00 00 00 	li      r8,0
fff80894:	7d 27 30 50 	subf    r9,r7,r6
fff80898:	14 cd 40 20 	lvd     d6,16416(r13)

        //update our start time so we know how much time has advanced since
        //this update of the accumulator
        ppe42_tb_data.dec_start = new_dec;
fff8089c:	91 4d 40 18 	stw     r10,16408(r13)
        dec = mfspr(SPRN_DEC);
        mtspr(SPRN_DEC, new_dec);

        //update our 64bit accumulator with how much time has advanced since
        //we last changed it.
        ppe42_64bit_timebase += ppe42_tb_data.dec_start - dec;
fff808a0:	7d 29 38 14 	addc    r9,r9,r7
fff808a4:	7d 08 31 14 	adde    r8,r8,r6
fff808a8:	19 0d 40 20 	stvd    d8,16416(r13)

        //update our start time so we know how much time has advanced since
        //this update of the accumulator
        ppe42_tb_data.dec_start = new_dec;
        ppe42_tb_data.dec_change_tag++;
fff808ac:	81 2d 40 1c 	lwz     r9,16412(r13)
fff808b0:	39 29 00 01 	addi    r9,r9,1
fff808b4:	91 2d 40 1c 	stw     r9,16412(r13)
    }
}
fff808b8:	80 01 00 14 	lwz     r0,20(r1)
fff808bc:	17 c1 00 08 	lvd     d30,8(r1)
fff808c0:	7c 08 03 a6 	mtlr    r0
fff808c4:	38 21 00 10 	addi    r1,r1,16
fff808c8:	4e 80 00 20 	blr

fff808cc <__ppe42_system_setup>:
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
fff808cc:	39 00 00 40 	li      r8,64
fff808d0:	7d 09 03 a6 	mtctr   r8
fff808d4:	3d 20 ff f8 	lis     r9,-8
void __hwmacro_setup(void);


void
__ppe42_system_setup()
{
fff808d8:	39 40 00 00 	li      r10,0
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
fff808dc:	39 29 04 64 	addi    r9,r9,1124
fff808e0:	39 0d 10 88 	addi    r8,r13,4232
fff808e4:	7d 28 51 2e 	stwx    r9,r8,r10
fff808e8:	39 4a 00 08 	addi    r10,r10,8
    //Only do this if the application hasn't provided a static table definition
#ifndef STATIC_IRQ_TABLE
    PkIrqId irq;

    // Initialize the interrupt vectors.
    for (irq = 0; irq < EXTERNAL_IRQS; irq++)
fff808ec:	42 00 ff f4 	bdnz    fff808e0 <__ppe42_system_setup+0x14>
    {
        __ppe42_irq_handlers[irq].handler = __ppe42_default_irq_handler;
    }

    //NOTE: EXTERNAL_IRQS is the phantom interrupt assigned irq
    __ppe42_irq_handlers[irq].handler = __ppe42_phantom_irq_handler;
fff808f0:	3d 40 ff f8 	lis     r10,-8
fff808f4:	39 4a 04 6c 	addi    r10,r10,1132
fff808f8:	91 48 02 00 	stw     r10,512(r8)

#endif /*STATIC_IRQ_TABLE*/
    // Initialize special interrupt handlers

    __ppe42_fit_routine = __ppe42_default_irq_handler;
    __ppe42_fit_arg = 0;
fff808fc:	39 40 00 00 	li      r10,0
    __ppe42_irq_handlers[irq].handler = __ppe42_phantom_irq_handler;

#endif /*STATIC_IRQ_TABLE*/
    // Initialize special interrupt handlers

    __ppe42_fit_routine = __ppe42_default_irq_handler;
fff80900:	91 2d 40 14 	stw     r9,16404(r13)
    __ppe42_fit_arg = 0;
fff80904:	91 4d 40 08 	stw     r10,16392(r13)

    __ppe42_watchdog_routine = __ppe42_default_irq_handler;
fff80908:	91 2d 40 10 	stw     r9,16400(r13)
    __ppe42_watchdog_arg = 0;
fff8090c:	91 4d 40 0c 	stw     r10,16396(r13)

    //Clear all status bits in the TSR
    mtspr(SPRN_TSR, TSR_ENW | TSR_WIS | TSR_DIS | TSR_FIS);
fff80910:	3d 20 cc 00 	lis     r9,-13312
fff80914:	7d 30 53 a6 	mtspr   336,r9
#ifdef APPCFG_USE_EXT_TIMEBASE
    //Enable the DEC interrupt and configure it to use the external dec_timer signal
    mtspr(SPRN_TCR, TCR_DIE | TCR_DS);
#else
    //Enable the DEC interrupt and configure it to use the internal clock signal
    mtspr(SPRN_TCR, TCR_DIE);
fff80918:	3d 20 04 00 	lis     r9,1024
fff8091c:	7d 34 53 a6 	mtspr   340,r9

#if PK_TIMER_SUPPORT
#if PK_TRACE_SUPPORT
    extern PkTraceBuffer g_pk_trace_buf;
    //set the ppe instance id
    g_pk_trace_buf.instance_id = (uint16_t)(mfspr(SPRN_PIR) & PIR_PPE_INSTANCE_MASK);
fff80920:	7d 3e 42 a6 	mfspr   r9,286
fff80924:	39 4d 00 20 	addi    r10,r13,32
fff80928:	55 29 06 fe 	clrlwi  r9,r9,27
fff8092c:	b1 2a 00 14 	sth     r9,20(r10)
#endif  /* PK_TRACE_SUPPORT */
#endif  /* PK_TIMER_SUPPORT */

    //call macro-specific setup
    __hwmacro_setup();
fff80930:	48 00 00 04 	b       fff80934 <__hwmacro_setup>

fff80934 <__hwmacro_setup>:

void
__hwmacro_setup(void)
{
    //mask all interrupts to prevent spurious pulse to PPE
    out64(STD_LCL_EIMR, 0xffffffffffffffffull);
fff80934:	3d 40 c0 00 	lis     r10,-16384
fff80938:	39 00 ff ff 	li      r8,-1
fff8093c:	39 20 ff ff 	li      r9,-1
fff80940:	61 4a 00 20 	ori     r10,r10,32
fff80944:	19 0a 00 00 	stvd    d8,0(r10)

    //set up the configured polarity
    out64(STD_LCL_EIPR, g_ext_irqs_polarity);
fff80948:	15 0d 10 70 	lvd     d8,4208(r13)
fff8094c:	39 4a 00 20 	addi    r10,r10,32
fff80950:	19 0a 00 00 	stvd    d8,0(r10)

    //set up the configured type
    out64(STD_LCL_EITR, g_ext_irqs_type);
fff80954:	15 0d 10 78 	lvd     d8,4216(r13)
fff80958:	39 4a 00 20 	addi    r10,r10,32
fff8095c:	19 0a 00 00 	stvd    d8,0(r10)

    //clear the status of all edge interrupts
    out64(STD_LCL_EISR_CLR, g_ext_irqs_type);
fff80960:	15 0d 10 78 	lvd     d8,4216(r13)
fff80964:	39 4a ff b8 	addi    r10,r10,-72
fff80968:	19 0a 00 00 	stvd    d8,0(r10)

    //unmask the interrupts that are to be enabled by default
    out64(STD_LCL_EIMR_CLR, g_ext_irqs_enable);
fff8096c:	15 0d 10 80 	lvd     d8,4224(r13)
fff80970:	19 0a 00 20 	stvd    d8,32(r10)

    //wait for the last operation to complete
    sync();
fff80974:	7c 00 04 ac 	sync    
fff80978:	4e 80 00 20 	blr

fff8097c <pk_set_timebase_rshift>:
uint8_t  __pk_timebase_rshift = 32;

void pk_set_timebase_rshift(uint32_t timebase_freq_hz)
{
    //Use 1.0 scale if less than or equal to 1.0625 * base frequency
    if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 4)))
fff8097c:	3d 40 19 54 	lis     r10,6484
fff80980:	61 4a fc 40 	ori     r10,r10,64576
fff80984:	3d 20 ff f8 	lis     r9,-8
fff80988:	05 a3 50 06 	cmplwbgt r3,r10,fff80994 <pk_set_timebase_rshift+0x18>
    {
        __pk_timebase_rshift = 32;
fff8098c:	39 40 00 20 	li      r10,32
fff80990:	48 00 00 44 	b       fff809d4 <pk_set_timebase_rshift+0x58>
    }

    //use 1.125 scale if between 1.0625 and 1.1875 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 4) + (PK_BASE_FREQ_HZ >> 3)))
fff80994:	3d 40 1c 4f 	lis     r10,7247
fff80998:	61 4a ec c0 	ori     r10,r10,60608
fff8099c:	05 a3 50 06 	cmplwbgt r3,r10,fff809a8 <pk_set_timebase_rshift+0x2c>
    {
        __pk_timebase_rshift = 3;
fff809a0:	39 40 00 03 	li      r10,3
fff809a4:	48 00 00 30 	b       fff809d4 <pk_set_timebase_rshift+0x58>
    }

    //use 1.25 scale if between 1,1875 and 1.375 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 3) + (PK_BASE_FREQ_HZ >> 2)))
fff809a8:	3d 40 20 c8 	lis     r10,8392
fff809ac:	61 4a 55 80 	ori     r10,r10,21888
fff809b0:	05 a3 50 06 	cmplwbgt r3,r10,fff809bc <pk_set_timebase_rshift+0x40>
    {
        __pk_timebase_rshift = 2;
fff809b4:	39 40 00 02 	li      r10,2
fff809b8:	48 00 00 1c 	b       fff809d4 <pk_set_timebase_rshift+0x58>
    }
    //use 1.5 scale if between 1.375 and 1.75 * base frequency
    else if(timebase_freq_hz <= (PK_BASE_FREQ_HZ + (PK_BASE_FREQ_HZ >> 2) + (PK_BASE_FREQ_HZ >> 1)))
fff809bc:	3d 40 29 b9 	lis     r10,10681
fff809c0:	61 4a 27 00 	ori     r10,r10,9984
fff809c4:	05 a3 50 06 	cmplwbgt r3,r10,fff809d0 <pk_set_timebase_rshift+0x54>
    {
        __pk_timebase_rshift = 1;
fff809c8:	39 40 00 01 	li      r10,1
fff809cc:	48 00 00 08 	b       fff809d4 <pk_set_timebase_rshift+0x58>
    }
    //use 2.0 scale if greater than 1.75 * base frequency
    else
    {
        __pk_timebase_rshift = 0;
fff809d0:	39 40 00 00 	li      r10,0
fff809d4:	99 49 69 70 	stb     r10,26992(r9)
fff809d8:	4e 80 00 20 	blr

fff809dc <pk_initialize>:
int
pk_initialize(PkAddress     kernel_stack,
              size_t       kernel_stack_size,
              PkTimebase   initial_timebase,
              uint32_t     timebase_frequency_hz)
{
fff809dc:	94 21 ff d8 	stwu    r1,-40(r1)
fff809e0:	7c 08 02 a6 	mflr    r0
fff809e4:	1b 81 00 18 	stvd    d28,24(r1)
fff809e8:	90 01 00 2c 	stw     r0,44(r1)
fff809ec:	1b c1 00 20 	stvd    d30,32(r1)
fff809f0:	18 61 00 08 	stvd    d3,8(r1)
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((kernel_stack == 0) ||
fff809f4:	06 c3 00 7c 	bwz     r3,fff80aec <pk_initialize+0x110>
fff809f8:	38 60 fd e2 	li      r3,-542
fff809fc:	06 c4 00 7a 	bwz     r4,fff80af0 <pk_initialize+0x114>
                    (kernel_stack_size == 0),
                    PK_INVALID_ARGUMENT_INIT);
    }

    __pk_timebase_frequency_hz = timebase_frequency_hz;
fff80a00:	3d 20 ff f8 	lis     r9,-8
fff80a04:	90 e9 69 74 	stw     r7,26996(r9)

    __pk_thread_machine_context_default = PK_THREAD_MACHINE_CONTEXT_DEFAULT;
fff80a08:	3d 20 00 83 	lis     r9,131
fff80a0c:	61 29 98 00 	ori     r9,r9,38912

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);
fff80a10:	7c e3 3b 78 	mr      r3,r7
fff80a14:	7c ff 3b 78 	mr      r31,r7
fff80a18:	7c de 33 78 	mr      r30,r6
fff80a1c:	7c bd 2b 78 	mr      r29,r5
                    PK_INVALID_ARGUMENT_INIT);
    }

    __pk_timebase_frequency_hz = timebase_frequency_hz;

    __pk_thread_machine_context_default = PK_THREAD_MACHINE_CONTEXT_DEFAULT;
fff80a20:	91 2d 13 38 	stw     r9,4920(r13)

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);
fff80a24:	4b ff ff 59 	bl      fff8097c <pk_set_timebase_rshift>

    __pk_kernel_stack_limit = kernel_stack;
fff80a28:	81 21 00 08 	lwz     r9,8(r1)

    rc = __pk_stack_init(&kernel_stack, &kernel_stack_size);
fff80a2c:	38 61 00 08 	addi    r3,r1,8
fff80a30:	38 81 00 0c 	addi    r4,r1,12

    //set the shift adjustment to get us closer to the true
    //timebase frequency (versus what was hardcoded)
    pk_set_timebase_rshift(timebase_frequency_hz);

    __pk_kernel_stack_limit = kernel_stack;
fff80a34:	91 2d 13 50 	stw     r9,4944(r13)

    rc = __pk_stack_init(&kernel_stack, &kernel_stack_size);
fff80a38:	48 00 00 d5 	bl      fff80b0c <__pk_stack_init>
fff80a3c:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fff80a40:	06 5c 00 58 	bwnz    r28,fff80af0 <pk_initialize+0x114>
    {
        return rc;
    }

    __pk_kernel_stack = kernel_stack;
fff80a44:	81 21 00 08 	lwz     r9,8(r1)
fff80a48:	91 2d 13 54 	stw     r9,4948(r13)
    __pk_kernel_stack_size = kernel_stack_size;
fff80a4c:	81 21 00 0c 	lwz     r9,12(r1)
fff80a50:	91 2d 13 34 	stw     r9,4916(r13)
#if PK_TIMER_SUPPORT

    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
fff80a54:	39 2d 12 98 	addi    r9,r13,4760
fff80a58:	7d 23 4b 78 	mr      r3,r9
fff80a5c:	91 21 00 10 	stw     r9,16(r1)
fff80a60:	4b ff fa bd 	bl      fff8051c <pk_deque_sentinel_create>
    __pk_time_queue.cursor = 0;
fff80a64:	81 21 00 10 	lwz     r9,16(r1)
    __pk_time_queue.next_timeout = PK_TIMEBASE_MAX;
fff80a68:	39 00 ff ff 	li      r8,-1

    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
    __pk_time_queue.cursor = 0;
fff80a6c:	93 89 00 10 	stw     r28,16(r9)

#endif  /* PK_TIMER_SUPPORT (timed callback)*/

#if PK_TRACE_SUPPORT
    //set the trace timebase HZ
    pk_trace_set_freq(timebase_frequency_hz);
fff80a70:	7f e3 fb 78 	mr      r3,r31
    // Initialize the time queue sentinel as a circular queue, set the next
    // timeout and clear the cursor.

    pk_deque_sentinel_create((PkDeque*)&__pk_time_queue);
    __pk_time_queue.cursor = 0;
    __pk_time_queue.next_timeout = PK_TIMEBASE_MAX;
fff80a74:	39 20 ff ff 	li      r9,-1
fff80a78:	19 0d 12 a0 	stvd    d8,4768(r13)

#endif  /* PK_TIMER_SUPPORT (timed callback)*/

#if PK_TRACE_SUPPORT
    //set the trace timebase HZ
    pk_trace_set_freq(timebase_frequency_hz);
fff80a7c:	4b ff f7 a9 	bl      fff80224 <pk_trace_set_freq>

    if(initial_timebase != PK_TIMEBASE_CONTINUES)
fff80a80:	2c 1d ff ff 	cmpwi   r29,-1
fff80a84:	40 82 00 0c 	bne     fff80a90 <pk_initialize+0xb4>
fff80a88:	2c 1e ff ff 	cmpwi   r30,-1
fff80a8c:	41 82 00 10 	beq     fff80a9c <pk_initialize+0xc0>
    {
        //set the timebase ajdustment for trace synchronization
        pk_trace_set_timebase(initial_timebase);
fff80a90:	7f a3 eb 78 	mr      r3,r29
fff80a94:	7f c4 f3 78 	mr      r4,r30
fff80a98:	4b ff f7 4d 	bl      fff801e4 <pk_trace_set_timebase>
    }

    // Schedule the timer that puts a 64bit timestamp in the trace buffer
    // periodically.  This allows us to use 32bit timestamps.
    pk_timer_schedule(&g_pk_trace_timer,
fff80a9c:	3c c0 fc 46 	lis     r6,-954
fff80aa0:	38 6d 10 58 	addi    r3,r13,4184
fff80aa4:	38 a0 00 00 	li      r5,0
fff80aa8:	60 c6 53 5f 	ori     r6,r6,21343
fff80aac:	4b ff fc 95 	bl      fff80740 <pk_timer_schedule>

    int i;

    for (i = 0; i <= PK_THREADS; i++)
    {
        __pk_priority_map[i] = 0;
fff80ab0:	39 20 00 21 	li      r9,33
fff80ab4:	7d 29 03 a6 	mtctr   r9
        pk_trace_set_timebase(initial_timebase);
    }

    // Schedule the timer that puts a 64bit timestamp in the trace buffer
    // periodically.  This allows us to use 32bit timestamps.
    pk_timer_schedule(&g_pk_trace_timer,
fff80ab8:	39 40 00 00 	li      r10,0

    int i;

    for (i = 0; i <= PK_THREADS; i++)
    {
        __pk_priority_map[i] = 0;
fff80abc:	38 e0 00 00 	li      r7,0
fff80ac0:	39 0d 12 b0 	addi    r8,r13,4784
fff80ac4:	7c e8 51 2e 	stwx    r7,r8,r10
fff80ac8:	39 20 00 00 	li      r9,0
fff80acc:	39 4a 00 04 	addi    r10,r10,4
    // Clear the priority map. The final entry [PK_THREADS] is for the idle
    // thread.

    int i;

    for (i = 0; i <= PK_THREADS; i++)
fff80ad0:	42 00 ff f0 	bdnz    fff80ac0 <pk_initialize+0xe4>
// cntlzw().

static inline void
__pk_thread_queue_clear(volatile PkThreadQueue* queue)
{
*queue = 0;
fff80ad4:	91 2d 13 4c 	stw     r9,4940(r13)
    }

    // Initialize the thread scheduler

    __pk_thread_queue_clear(&__pk_run_queue);
    __pk_current_thread = 0;
fff80ad8:	91 2d 13 44 	stw     r9,4932(r13)
    __pk_next_thread    = 0;
fff80adc:	91 2d 13 40 	stw     r9,4928(r13)
    __pk_delayed_switch = 0;
fff80ae0:	91 2d 13 48 	stw     r9,4936(r13)

#endif  /* PK_THREAD_SUPPORT */

    return PK_OK;
fff80ae4:	38 60 00 00 	li      r3,0
fff80ae8:	48 00 00 08 	b       fff80af0 <pk_initialize+0x114>
{
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((kernel_stack == 0) ||
fff80aec:	38 60 fd e2 	li      r3,-542
    __pk_delayed_switch = 0;

#endif  /* PK_THREAD_SUPPORT */

    return PK_OK;
}
fff80af0:	80 01 00 2c 	lwz     r0,44(r1)
fff80af4:	17 81 00 18 	lvd     d28,24(r1)
fff80af8:	7c 08 03 a6 	mtlr    r0
fff80afc:	17 c1 00 20 	lvd     d30,32(r1)
fff80b00:	38 21 00 28 	addi    r1,r1,40
fff80b04:	4e 80 00 20 	blr

fff80b08 <__pk_main>:
__pk_main(int argc, char** argv)
{
    PK_MAIN_HOOK;

    int main(int argc, char** argv);
    main(argc, argv);
fff80b08:	48 00 06 14 	b       fff8111c <main>

fff80b0c <__pk_stack_init>:
        // stacks, otherwise the initial address is first brought into range
        // before alignment.  The stack is aligned downward, then the size is
        // adjusted to a multiple of the stack type.  Stacks are optionally
        // prepatterned. Alignment is assumed to be a power of 2.

        *stack += *size;
fff80b0c:	81 24 00 00 	lwz     r9,0(r4)
fff80b10:	81 43 00 00 	lwz     r10,0(r3)

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fff80b14:	3c e0 03 ab 	lis     r7,939
        // stacks, otherwise the initial address is first brought into range
        // before alignment.  The stack is aligned downward, then the size is
        // adjusted to a multiple of the stack type.  Stacks are optionally
        // prepatterned. Alignment is assumed to be a power of 2.

        *stack += *size;
fff80b18:	7d 49 52 14 	add     r10,r9,r10
            *stack -= sizeof(PK_STACK_TYPE);
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
fff80b1c:	55 48 07 7e 	clrlwi  r8,r10,29
        *stack -= excess;
        *size -= excess;
fff80b20:	7d 28 48 50 	subf    r9,r8,r9
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
        *stack -= excess;
fff80b24:	7d 48 50 50 	subf    r10,r8,r10
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);
fff80b28:	55 29 00 3a 	rlwinm  r9,r9,0,0,29
            *size -= sizeof(PK_STACK_TYPE);
        }

        mask = PK_STACK_ALIGNMENT - 1;
        excess = *stack & mask;
        *stack -= excess;
fff80b2c:	91 43 00 00 	stw     r10,0(r3)
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);
fff80b30:	91 24 00 00 	stw     r9,0(r4)

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fff80b34:	55 29 f0 be 	rlwinm  r9,r9,30,2,31
fff80b38:	39 29 00 01 	addi    r9,r9,1
fff80b3c:	7d 29 03 a6 	mtctr   r9
        *size -= excess;
        *size = (*size / sizeof(PK_STACK_TYPE)) * sizeof(PK_STACK_TYPE);

        if (PK_STACK_CHECK)
        {
            p = (PK_STACK_TYPE*)(*stack);
fff80b40:	7d 48 53 78 	mr      r8,r10

            for (i = 0; i < count; i++)
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fff80b44:	60 e7 cd ef 	ori     r7,r7,52719
        if (PK_STACK_CHECK)
        {
            p = (PK_STACK_TYPE*)(*stack);
            count = *size / sizeof(PK_STACK_TYPE);

            for (i = 0; i < count; i++)
fff80b48:	42 40 00 0c 	bdz     fff80b54 <__pk_stack_init+0x48>
            {
                if (PK_STACK_PRE_DECREMENT)
                {
                    *(--p) = PK_STACK_PATTERN;
fff80b4c:	94 e8 ff fc 	stwu    r7,-4(r8)
fff80b50:	4b ff ff f8 	b       fff80b48 <__pk_stack_init+0x3c>
/// behind the SP are for the initial subroutine's LR.

static inline void
__pk_stack_create_initial_frame(PkAddress* stack, size_t* size)
{
*stack -= 8;
fff80b54:	39 2a ff f8 	addi    r9,r10,-8
fff80b58:	91 23 00 00 	stw     r9,0(r3)
* size -= 8;
fff80b5c:	81 24 00 00 	lwz     r9,0(r4)

        PK_PANIC(PK_UNIMPLEMENTED);
    }

    return PK_OK;
}
fff80b60:	38 60 00 00 	li      r3,0
fff80b64:	39 29 ff f8 	addi    r9,r9,-8
fff80b68:	91 24 00 00 	stw     r9,0(r4)
* ((PK_STACK_TYPE*)(*stack)) = 0;
fff80b6c:	39 20 00 00 	li      r9,0
fff80b70:	91 2a ff f8 	stw     r9,-8(r10)
fff80b74:	4e 80 00 20 	blr

fff80b78 <_ZN13sbe_local_LFRC1Ev>:
        spi_clock_divider = 0;
        sec_boot_seeprom = 0;
        sec_meas_seeprom = 0;
        mpipl = 0;
        ipl_reset = 0;
        runtime_reset = 0;
fff80b78:	a1 23 00 02 	lhz     r9,2(r3)
    uint32_t bitsreserved : 12;           //Bit 36-47 Reserved
    uint32_t pau_freq_in_mhz : 16;        //Bit 48-63 PAU system frequency in MHz

    sbe_local_LFR()
    {
        spi_clock_divider = 0;
fff80b7c:	39 40 00 00 	li      r10,0
        ipl_reset = 0;
        runtime_reset = 0;
        hreset_done = 0;
        mpipl_reset_done = 0;
        round_trip_delay = 0;
        secure_mode = 0;
fff80b80:	71 29 10 ff 	andi.   r9,r9,4351
        pau_freq_in_mhz = 0;
fff80b84:	b1 43 00 06 	sth     r10,6(r3)
        ipl_reset = 0;
        runtime_reset = 0;
        hreset_done = 0;
        mpipl_reset_done = 0;
        round_trip_delay = 0;
        secure_mode = 0;
fff80b88:	51 49 64 e6 	rlwimi  r9,r10,12,19,19
fff80b8c:	91 23 00 00 	stw     r9,0(r3)
        pau_freq_in_mhz = 0;
        tpm_spi_clock_freq_Mhz = 0;
fff80b90:	39 20 00 00 	li      r9,0
fff80b94:	99 23 00 03 	stb     r9,3(r3)
        tpm_spi_clock_delay = 0;
fff80b98:	81 23 00 04 	lwz     r9,4(r3)
        // This is required else these gets initialised with dummy data
        bitsreserved = 0;
fff80b9c:	55 29 01 3e 	clrlwi  r9,r9,4
fff80ba0:	51 49 81 1e 	rlwimi  r9,r10,16,4,15
fff80ba4:	91 23 00 04 	stw     r9,4(r3)
fff80ba8:	4e 80 00 20 	blr

fff80bac <__eabi>:
void __eabi()
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
fff80bac:	39 2d 13 78 	addi    r9,r13,4984
        while ( startAddr != &_sbss_end )
fff80bb0:	39 4d 40 50 	addi    r10,r13,16464
        {
            *startAddr = 0;
fff80bb4:	38 c0 00 00 	li      r6,0
fff80bb8:	38 e0 00 00 	li      r7,0
{
    do
    {
        // Initialise sbss section
        uint64_t *startAddr = &_sbss_start;
        while ( startAddr != &_sbss_end )
fff80bbc:	04 c9 50 08 	cmpwbeq r9,r10,fff80bcc <__eabi+0x20>
        {
            *startAddr = 0;
fff80bc0:	18 c9 00 00 	stvd    d6,0(r9)
            startAddr++;
fff80bc4:	39 29 00 08 	addi    r9,r9,8
fff80bc8:	4b ff ff f4 	b       fff80bbc <__eabi+0x10>
// or linker script to zero init sbss section. This way we will be future
// garded if pk  boot uses some static/global data  initialised to
// false in future.

void __eabi()
{
fff80bcc:	94 21 ff f0 	stwu    r1,-16(r1)
fff80bd0:	7c 08 02 a6 	mflr    r0
fff80bd4:	1b c1 00 08 	stvd    d30,8(r1)
fff80bd8:	90 01 00 14 	stw     r0,20(r1)
fff80bdc:	3f e0 ff f8 	lis     r31,-8
            *startAddr = 0;
            startAddr++;
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
fff80be0:	3f c0 ff f8 	lis     r30,-8
fff80be4:	3b ff 66 48 	addi    r31,r31,26184
fff80be8:	3b de 66 54 	addi    r30,r30,26196
fff80bec:	04 df f0 0c 	cmpwbeq r31,r30,fff80c04 <__eabi+0x58>
        {
            (*ctors)();
fff80bf0:	81 3f 00 00 	lwz     r9,0(r31)
            ctors++;
fff80bf4:	3b ff 00 04 	addi    r31,r31,4
        }
        // Call global constructors
        void(**ctors)() = &ctor_start_address;
        while( ctors != &ctor_end_address)
        {
            (*ctors)();
fff80bf8:	7d 29 03 a6 	mtctr   r9
fff80bfc:	4e 80 04 21 	bctrl
fff80c00:	4b ff ff ec 	b       fff80bec <__eabi+0x40>
            ctors++;
        }
    } while (false);
}
fff80c04:	80 01 00 14 	lwz     r0,20(r1)
fff80c08:	17 c1 00 08 	lvd     d30,8(r1)
fff80c0c:	7c 08 03 a6 	mtlr    r0
fff80c10:	38 21 00 10 	addi    r1,r1,16
fff80c14:	4e 80 00 20 	blr

fff80c18 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities>:
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
fff80c18:	94 21 ff f0 	stwu    r1,-16(r1)
fff80c1c:	7c 08 02 a6 	mflr    r0
    rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
fff80c20:	55 08 06 3e 	clrlwi  r8,r8,24
                                PkThreadRoutine   i_thread_routine,
                                void             *io_pArg,
                                PkAddress         i_stack,
                                size_t            i_stack_size,
                                sbeThreadPriorities  i_priority)
{
fff80c24:	1b c1 00 08 	stvd    d30,8(r1)
fff80c28:	90 01 00 14 	stw     r0,20(r1)
fff80c2c:	7c 7e 1b 78 	mr      r30,r3
    rc =  pk_thread_create(io_pThread,
                             i_thread_routine,
                             io_pArg,
                             i_stack,
                             i_stack_size,
                             (PkThreadPriority)i_priority);
fff80c30:	48 00 23 0d 	bl      fff82f3c <pk_thread_create>
fff80c34:	7c 7f 1b 78 	mr      r31,r3
    if(rc == PK_OK)
fff80c38:	06 43 00 0a 	bwnz    r3,fff80c4c <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities+0x34>
    {
        // resume the thread once created
        rc = pk_thread_resume(io_pThread);
fff80c3c:	7f c3 f3 78 	mr      r3,r30
fff80c40:	48 00 22 31 	bl      fff82e70 <pk_thread_resume>
fff80c44:	7c 7f 1b 78 	mr      r31,r3
    }

    // Check for errors creating or resuming the thread
    if(rc != PK_OK)
fff80c48:	06 c3 00 10 	bwz     r3,fff80c68 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities+0x50>
    {
        SBE_ERROR ("Failure creating/resuming thread, rc=[%d]", rc);
fff80c4c:	3c 60 bf 45 	lis     r3,-16571
fff80c50:	60 63 00 01 	ori     r3,r3,1
fff80c54:	7f e5 fb 78 	mr      r5,r31
fff80c58:	38 c0 00 00 	li      r6,0
fff80c5c:	38 e0 00 00 	li      r7,0
fff80c60:	39 00 00 00 	li      r8,0
fff80c64:	48 00 24 01 	bl      fff83064 <pk_trace_big>
    }

    return rc;
}
fff80c68:	80 01 00 14 	lwz     r0,20(r1)
fff80c6c:	7f e3 fb 78 	mr      r3,r31
fff80c70:	7c 08 03 a6 	mtlr    r0
fff80c74:	17 c1 00 08 	lvd     d30,8(r1)
fff80c78:	38 21 00 10 	addi    r1,r1,16
fff80c7c:	4e 80 00 20 	blr

fff80c80 <_Z36setupSpiClockDividerAndLFRPerPAUDPLLmh>:

// Setup the SPI Clock Divider per the new clock and update LFR
void setupSpiClockDividerAndLFRPerPAUDPLL(uint32_t i_tpm_spi_clock_divider, uint8_t i_tpm_spi_clock_delay)
{
fff80c80:	94 21 ff d0 	stwu    r1,-48(r1)
fff80c84:	7c 08 02 a6 	mflr    r0
fff80c88:	7c 66 1b 78 	mr      r6,r3
    sbe_local_LFR lfrReg;
fff80c8c:	38 61 00 08 	addi    r3,r1,8
    return rc;
}

// Setup the SPI Clock Divider per the new clock and update LFR
void setupSpiClockDividerAndLFRPerPAUDPLL(uint32_t i_tpm_spi_clock_divider, uint8_t i_tpm_spi_clock_delay)
{
fff80c90:	90 01 00 34 	stw     r0,52(r1)
fff80c94:	1b 81 00 20 	stvd    d28,32(r1)
fff80c98:	1b c1 00 28 	stvd    d30,40(r1)
    sbe_local_LFR lfrReg;
fff80c9c:	90 81 00 1c 	stw     r4,28(r1)
fff80ca0:	90 c1 00 18 	stw     r6,24(r1)
fff80ca4:	4b ff fe d5 	bl      fff80b78 <_ZN13sbe_local_LFRC1Ev>
    uint64_t loadData = 0;
    uint32_t spiAddr = 0;

    PPE_LVD(0xc0002040, lfrReg);
fff80ca8:	3d 00 c0 00 	lis     r8,-16384
fff80cac:	61 08 20 40 	ori     r8,r8,8256
fff80cb0:	15 08 00 00 	lvd     d8,0(r8)
fff80cb4:	19 01 00 08 	stvd    d8,8(r1)
    //  There is a tpm spi clock dial to control clock divider and clock delay from user
    //  Passed here as Parameters from Scratch 13, instead of Hard-coding
    uint32_t spiSeepromClockDivider = 48;
    //uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
fff80cb8:	39 20 00 04 	li      r9,4
fff80cbc:	7d 29 03 a6 	mtctr   r9
fff80cc0:	3c e0 00 0c 	lis     r7,12
fff80cc4:	80 c1 00 18 	lwz     r6,24(r1)
fff80cc8:	80 81 00 1c 	lwz     r4,28(r1)
fff80ccc:	60 e7 00 03 	ori     r7,r7,3
    {
        PPE_LVD(spiAddr, loadData);
        loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                ((uint64_t)spiSeepromClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
fff80cd0:	3b 80 00 00 	li      r28,0
fff80cd4:	3b a0 00 80 	li      r29,128
    uint32_t spiSeepromClockDivider = 48;
    //uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
    {
        PPE_LVD(spiAddr, loadData);
fff80cd8:	15 27 00 00 	lvd     d9,0(r7)
        loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                ((uint64_t)spiSeepromClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
fff80cdc:	81 01 00 08 	lwz     r8,8(r1)
    //uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
    {
        PPE_LVD(spiAddr, loadData);
        loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
fff80ce0:	55 25 05 3e 	clrlwi  r5,r9,20
                ((uint64_t)spiSeepromClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
fff80ce4:	55 08 c7 3e 	rlwinm  r8,r8,24,28,31
fff80ce8:	21 08 00 2c 	subfic  r8,r8,44
fff80cec:	7f 88 40 76 	slvd    d8,d28,r8
fff80cf0:	65 08 03 00 	oris    r8,r8,768
fff80cf4:	7d 1e 2b 78 	or      r30,r8,r5
fff80cf8:	7d 3f 53 78 	or      r31,r9,r10
        PPE_STVD(spiAddr, loadData);
fff80cfc:	1b c7 00 00 	stvd    d30,0(r7)
    //  There is a tpm spi clock dial to control clock divider and clock delay from user
    //  Passed here as Parameters from Scratch 13, instead of Hard-coding
    uint32_t spiSeepromClockDivider = 48;
    //uint32_t spiTpmClockDivider = 10;

    for(spiAddr = 0xc0003; spiAddr<=0xc0063; spiAddr += 0x20)
fff80d00:	38 e7 00 20 	addi    r7,r7,32
fff80d04:	42 00 ff d4 	bdnz    fff80cd8 <_Z36setupSpiClockDividerAndLFRPerPAUDPLLmh+0x58>
                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.round_trip_delay)) );
        PPE_STVD(spiAddr, loadData);
    }
    // Update TPM SPI Clock Divider, use the clock dial
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
fff80d08:	17 c7 00 00 	lvd     d30,0(r7)
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)i_tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - i_tpm_spi_clock_delay)) |
fff80d0c:	3b 80 00 00 	li      r28,0
    }
    // Update TPM SPI Clock Divider, use the clock dial
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)i_tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
fff80d10:	7c c9 33 78 	mr      r9,r6
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - i_tpm_spi_clock_delay)) |
fff80d14:	3b a0 00 80 	li      r29,128
    }
    // Update TPM SPI Clock Divider, use the clock dial
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)i_tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
fff80d18:	39 00 00 00 	li      r8,0
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - i_tpm_spi_clock_delay)) |
fff80d1c:	20 84 00 2c 	subfic  r4,r4,44
    }
    // Update TPM SPI Clock Divider, use the clock dial
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
            ((uint64_t)i_tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
fff80d20:	79 08 a2 c6 	rldicr  d8,d8,52,11
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - i_tpm_spi_clock_delay)) |
fff80d24:	7f 84 20 76 	slvd    d4,d28,r4
fff80d28:	7d 0a 23 78 	or      r10,r8,r4
        PPE_STVD(spiAddr, loadData);
    }
    // Update TPM SPI Clock Divider, use the clock dial
    spiAddr = 0xc0083;
    PPE_LVD(spiAddr, loadData);
    loadData = ( (loadData & SPI_CLOCK_DIVIDER_DELAY_MASK) |
fff80d2c:	57 c3 05 3e 	clrlwi  r3,r30,20
fff80d30:	61 4a 00 0a 	ori     r10,r10,10
            ((uint64_t)i_tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - i_tpm_spi_clock_delay)) |
            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
fff80d34:	7d 48 1b 78 	or      r8,r10,r3
fff80d38:	7c a9 fb 78 	or      r9,r5,r31
    PPE_STVD(spiAddr, loadData);
fff80d3c:	19 07 00 00 	stvd    d8,0(r7)

    // Update the LFR Clock divider and Hard-coded PAU Freq
    lfrReg.spi_clock_divider = spiSeepromClockDivider;
fff80d40:	81 21 00 08 	lwz     r9,8(r1)
fff80d44:	39 40 00 30 	li      r10,48
fff80d48:	51 49 a0 16 	rlwimi  r9,r10,20,0,11
fff80d4c:	91 21 00 08 	stw     r9,8(r1)
    lfrReg.pau_freq_in_mhz = 0x7B0; // This is hard-coded when we run out of PAU DPLL
fff80d50:	39 20 07 b0 	li      r9,1968
fff80d54:	b1 21 00 0e 	sth     r9,14(r1)
    PPE_STVD(0xc0002040, lfrReg); // New Divider and system freq updated into LFR
fff80d58:	3d 40 c0 00 	lis     r10,-16384
fff80d5c:	15 01 00 08 	lvd     d8,8(r1)
fff80d60:	61 4a 20 40 	ori     r10,r10,8256
fff80d64:	19 0a 00 00 	stvd    d8,0(r10)
    //////////////////# SPI Clock Setting per the new Frequency - End /////////////////
}
fff80d68:	80 01 00 34 	lwz     r0,52(r1)
fff80d6c:	17 81 00 20 	lvd     d28,32(r1)
fff80d70:	7c 08 03 a6 	mtlr    r0
fff80d74:	17 c1 00 28 	lvd     d30,40(r1)
fff80d78:	38 21 00 30 	addi    r1,r1,48
fff80d7c:	4e 80 00 20 	blr

fff80d80 <_Z26scanInitDD2PauDpllTimeRingv>:
///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD2 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD2PauDpllTimeRing()
{
fff80d80:	94 21 ff f8 	stwu    r1,-8(r1)
fff80d84:	7c 08 02 a6 	mflr    r0
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
fff80d88:	3d 40 01 03 	lis     r10,259
}
///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD2 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD2PauDpllTimeRing()
{
fff80d8c:	90 01 00 0c 	stw     r0,12(r1)
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
fff80d90:	61 4a 00 05 	ori     r10,r10,5
fff80d94:	3d 00 00 0c 	lis     r8,12
fff80d98:	39 20 01 00 	li      r9,256
fff80d9c:	19 0a 00 00 	stvd    d8,0(r10)
    //# insert header
    //# SCOMIN 0103F040 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
fff80da0:	3d 20 01 03 	lis     r9,259
fff80da4:	3c c0 a5 a5 	lis     r6,-23131
fff80da8:	3c e0 a5 a5 	lis     r7,-23131
fff80dac:	61 29 f0 40 	ori     r9,r9,61504
fff80db0:	60 c6 a5 a5 	ori     r6,r6,42405
fff80db4:	60 e7 a5 a5 	ori     r7,r7,42405
fff80db8:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0004 8001
    loadData = 0x0000000000048001ULL;
    PPE_STVD(0x0103F040, loadData);
fff80dbc:	3c e0 00 04 	lis     r7,4
fff80dc0:	38 c0 00 00 	li      r6,0
fff80dc4:	60 e7 80 01 	ori     r7,r7,32769
fff80dc8:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 4310 1554 0000 1248
    loadData = 0x4310155400001248ULL;
    PPE_STVD(0x0103F040, loadData);
fff80dcc:	3c c0 43 10 	lis     r6,17168
fff80dd0:	60 c6 15 54 	ori     r6,r6,5460
fff80dd4:	38 e0 12 48 	li      r7,4680
fff80dd8:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0020 0000 0000
    loadData = 0x8000000200000000ULL;
    PPE_STVD(0x0103F040, loadData);
fff80ddc:	3c c0 80 00 	lis     r6,-32768
fff80de0:	60 c6 00 02 	ori     r6,r6,2
fff80de4:	38 e0 00 00 	li      r7,0
fff80de8:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 9000 2862 02AA
    loadData = 0x00009000286202AAULL;
    PPE_STVD(0x0103F040, loadData);
fff80dec:	38 c0 00 00 	li      r6,0
fff80df0:	3c e0 28 62 	lis     r7,10338
fff80df4:	60 c6 90 00 	ori     r6,r6,36864
fff80df8:	60 e7 02 aa 	ori     r7,r7,682
fff80dfc:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 8000 0249 1000 0000
    loadData = 0x8000024910000000ULL;
    PPE_STVD(0x0103F040, loadData);
fff80e00:	3c c0 80 00 	lis     r6,-32768
fff80e04:	60 c6 02 49 	ori     r6,r6,585
fff80e08:	3c e0 10 00 	lis     r7,4096
fff80e0c:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 16bits
    //# SCOMIN 0103F010 4000 0000 0000 0000
    loadData = 0x4000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
fff80e10:	3c e0 01 03 	lis     r7,259
fff80e14:	3d 00 40 00 	lis     r8,16384
fff80e18:	39 20 00 00 	li      r9,0
fff80e1c:	60 e7 f0 10 	ori     r7,r7,61456
fff80e20:	19 07 00 00 	stvd    d8,0(r7)
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5A5A5A5A5A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
fff80e24:	3d 00 01 03 	lis     r8,259
fff80e28:	61 08 f0 00 	ori     r8,r8,61440
fff80e2c:	15 08 00 00 	lvd     d8,0(r8)
    if(fetchData != loadData)
fff80e30:	3c e0 a5 a5 	lis     r7,-23131
fff80e34:	60 e7 a5 a5 	ori     r7,r7,42405
fff80e38:	04 47 40 04 	cmpwbne r7,r8,fff80e40 <_Z26scanInitDD2PauDpllTimeRingv+0xc0>
fff80e3c:	04 c9 40 06 	cmpwbeq r9,r8,fff80e48 <_Z26scanInitDD2PauDpllTimeRingv+0xc8>
    {
        // asm("li %r0, PAU_DPLL_SCAN_HDR_COMPARE_FAIL\n"); -> wanting to use this,
        // but because of compile failure hard-coding the values from sbe_link.H
        // PAU_DPLL_SCAN_HDR_COMPARE_FAIL 0x04
        asm("li %r1, 4\n");
fff80e40:	38 20 00 04 	li      r1,4
        pk_halt();
fff80e44:	4b ff f4 21 	bl      fff80264 <pk_halt>
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
fff80e48:	39 00 00 00 	li      r8,0
fff80e4c:	39 20 00 00 	li      r9,0
fff80e50:	19 0a 00 00 	stvd    d8,0(r10)
}
fff80e54:	80 01 00 0c 	lwz     r0,12(r1)
fff80e58:	7c 08 03 a6 	mtlr    r0
fff80e5c:	38 21 00 08 	addi    r1,r1,8
fff80e60:	4e 80 00 20 	blr

fff80e64 <_Z26scanInitDD1PauDpllTimeRingv>:

///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD1 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD1PauDpllTimeRing()
{
fff80e64:	94 21 ff f8 	stwu    r1,-8(r1)
fff80e68:	7c 08 02 a6 	mflr    r0
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
fff80e6c:	3d 40 01 03 	lis     r10,259

///////////////////////////////////////////////////////////////////////////////////////
//SCAN Init sequence for DD1 PAU_DPLL_RING
///////////////////////////////////////////////////////////////////////////////////////
void scanInitDD1PauDpllTimeRing()
{
fff80e70:	90 01 00 0c 	stw     r0,12(r1)
    uint64_t loadData = 0;
    uint64_t fetchData = 0;
    //# Scan region & type
    //# SCOMIN 01030005 000C000000000100
    loadData = 0x000C000000000100ULL;
    PPE_STVD(0x01030005, loadData);
fff80e74:	61 4a 00 05 	ori     r10,r10,5
fff80e78:	3d 00 00 0c 	lis     r8,12
fff80e7c:	39 20 01 00 	li      r9,256
fff80e80:	19 0a 00 00 	stvd    d8,0(r10)
    //# insert header
    //# SCOMIN 0103F040 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_STVD(0x0103F040, loadData);
fff80e84:	3d 20 01 03 	lis     r9,259
fff80e88:	3c c0 a5 a5 	lis     r6,-23131
fff80e8c:	3c e0 a5 a5 	lis     r7,-23131
fff80e90:	61 29 f0 40 	ori     r9,r9,61504
fff80e94:	60 c6 a5 a5 	ori     r6,r6,42405
fff80e98:	60 e7 a5 a5 	ori     r7,r7,42405
fff80e9c:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0000 0048 0014
    loadData = 0x0000000000480014ULL;
    PPE_STVD(0x0103F040, loadData);
fff80ea0:	3c e0 00 48 	lis     r7,72
fff80ea4:	38 c0 00 00 	li      r6,0
fff80ea8:	60 e7 00 14 	ori     r7,r7,20
fff80eac:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 3101 5540 0001 2488
    loadData = 0x3101554000012488;
    PPE_STVD(0x0103F040, loadData);
fff80eb0:	3c c0 31 01 	lis     r6,12545
fff80eb4:	3c e0 00 01 	lis     r7,1
fff80eb8:	60 c6 55 40 	ori     r6,r6,21824
fff80ebc:	60 e7 24 88 	ori     r7,r7,9352
fff80ec0:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 0020 0000 0000
    loadData = 0x0000002000000000ULL;
    PPE_STVD(0x0103F040, loadData);
fff80ec4:	38 c0 00 20 	li      r6,32
fff80ec8:	38 e0 00 00 	li      r7,0
fff80ecc:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0009 0002 8620 2AA8
    loadData = 0x0009000286202AA8ULL;
    PPE_STVD(0x0103F040, loadData);
fff80ed0:	3c c0 00 09 	lis     r6,9
fff80ed4:	3c e0 86 20 	lis     r7,-31200
fff80ed8:	60 c6 00 02 	ori     r6,r6,2
fff80edc:	60 e7 2a a8 	ori     r7,r7,10920
fff80ee0:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 64bits
    //# SCOMIN 0103F040 0000 2491 0000 0004
    loadData = 0x0000249100000004ULL;
    PPE_STVD(0x0103F040, loadData);
fff80ee4:	38 c0 24 91 	li      r6,9361
fff80ee8:	38 e0 00 04 	li      r7,4
fff80eec:	18 c9 00 00 	stvd    d6,0(r9)
    //# insert scan data 16bits
    //# SCOMIN 0103F010 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x0103F010, loadData);
fff80ef0:	39 00 00 00 	li      r8,0
fff80ef4:	39 20 00 00 	li      r9,0
fff80ef8:	3c a0 01 03 	lis     r5,259
fff80efc:	7d 06 43 78 	mr      r6,r8
fff80f00:	7d 27 4b 78 	mr      r7,r9
fff80f04:	60 a5 f0 10 	ori     r5,r5,61456
fff80f08:	18 c5 00 00 	stvd    d6,0(r5)
    //# extract/read the header out and compare
    //# SCOMOUT 0103F000 A5A5 A5A5 A5A5 A5A5
    loadData = 0xA5A5A5A5A5A5A5A5ULL;
    PPE_LVD(0x0103F000, fetchData);
fff80f0c:	3c c0 01 03 	lis     r6,259
fff80f10:	60 c6 f0 00 	ori     r6,r6,61440
fff80f14:	14 c6 00 00 	lvd     d6,0(r6)
    if(fetchData != loadData)
fff80f18:	3c a0 a5 a5 	lis     r5,-23131
fff80f1c:	60 a5 a5 a5 	ori     r5,r5,42405
fff80f20:	04 45 30 04 	cmpwbne r5,r6,fff80f28 <_Z26scanInitDD1PauDpllTimeRingv+0xc4>
fff80f24:	04 c7 30 06 	cmpwbeq r7,r6,fff80f30 <_Z26scanInitDD1PauDpllTimeRingv+0xcc>
    {
        // asm("li %r0, PAU_DPLL_SCAN_HDR_COMPARE_FAIL\n"); -> wanting to use this,
        // but because of compile failure hard-coding the values from sbe_link.H
        // PAU_DPLL_SCAN_HDR_COMPARE_FAIL 0x04
        asm("li %r1, 4\n");
fff80f28:	38 20 00 04 	li      r1,4
        pk_halt();
fff80f2c:	4b ff f3 39 	bl      fff80264 <pk_halt>
    }
    //# clear scan region & type
    //# SCOMIN 01030005 0000 0000 0000 0000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
fff80f30:	19 0a 00 00 	stvd    d8,0(r10)
}
fff80f34:	80 01 00 0c 	lwz     r0,12(r1)
fff80f38:	7c 08 03 a6 	mtlr    r0
fff80f3c:	38 21 00 08 	addi    r1,r1,8
fff80f40:	4e 80 00 20 	blr

fff80f44 <_Z11lockPauDpllmh>:

// This function is to lock on the PAU DPLL from Ref clock
void lockPauDpll(uint32_t i_tpm_spi_clock_divider, uint8_t i_tpm_spi_clock_delay)
{
fff80f44:	94 21 ff f0 	stwu    r1,-16(r1)
fff80f48:	7c 08 02 a6 	mflr    r0
    /////////////////////////# Putring Start for perv_dpll_time/////////////////////////
    /////////////////SCOM in the SCAN Inits for the PERV_DPLL_TIME Ring/////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    // Check if you are DD1/DD2, CBS Environment Status Register bit 24-27, should be
    // 0001 -> DD1, 0002 -> DD2
    PPE_LVD(0x50004, fetchData);
fff80f4c:	3d 00 00 05 	lis     r8,5
    PPE_STVD(0x01030005, loadData);
}

// This function is to lock on the PAU DPLL from Ref clock
void lockPauDpll(uint32_t i_tpm_spi_clock_divider, uint8_t i_tpm_spi_clock_delay)
{
fff80f50:	1b c1 00 08 	stvd    d30,8(r1)
fff80f54:	90 01 00 14 	stw     r0,20(r1)
fff80f58:	7c 7f 1b 78 	mr      r31,r3
fff80f5c:	7c 9e 23 78 	mr      r30,r4
    /////////////////////////# Putring Start for perv_dpll_time/////////////////////////
    /////////////////SCOM in the SCAN Inits for the PERV_DPLL_TIME Ring/////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    // Check if you are DD1/DD2, CBS Environment Status Register bit 24-27, should be
    // 0001 -> DD1, 0002 -> DD2
    PPE_LVD(0x50004, fetchData);
fff80f60:	61 08 00 04 	ori     r8,r8,4
fff80f64:	15 08 00 00 	lvd     d8,0(r8)
    if((fetchData >> EC_MAJOR_VERSION_BIT_SHIFT) & DD1)
fff80f68:	07 88 d8 0a 	bb0wi   r8,27,fff80f7c <_Z11lockPauDpllmh+0x38>
    {
        SBE_INFO("Scanning PAU DPLL on DD1");
fff80f6c:	3c 60 05 47 	lis     r3,1351
fff80f70:	4b ff f2 09 	bl      fff80178 <pk_trace_tiny>
        scanInitDD1PauDpllTimeRing();
fff80f74:	4b ff fe f1 	bl      fff80e64 <_Z26scanInitDD1PauDpllTimeRingv>
fff80f78:	48 00 00 10 	b       fff80f88 <_Z11lockPauDpllmh+0x44>
    }
    else // DD2
    {
        SBE_INFO("Scanning PAU DPLL on DD2");
fff80f7c:	3c 60 95 de 	lis     r3,-27170
fff80f80:	4b ff f1 f9 	bl      fff80178 <pk_trace_tiny>
        scanInitDD2PauDpllTimeRing();
fff80f84:	4b ff fd fd 	bl      fff80d80 <_Z26scanInitDD2PauDpllTimeRingv>
    }
    //////////////////////////# Putring End for perv_dpll_time/////////////////////////

    // SPI Clock Setting per the new Frequency Start
    setupSpiClockDividerAndLFRPerPAUDPLL(i_tpm_spi_clock_divider, i_tpm_spi_clock_delay);
fff80f88:	7f e3 fb 78 	mr      r3,r31
fff80f8c:	7f c4 f3 78 	mr      r4,r30
fff80f90:	4b ff fc f1 	bl      fff80c80 <_Z36setupSpiClockDividerAndLFRPerPAUDPLLmh>

    ///////////////////////////////////////////////////////////////////////////////////
    //# PAU DPLL: Initialize to mode1
    //# SCOMIN 01060052 A000000000000000
    loadData = 0xA000000000000000ULL;
    PPE_STVD(0x01060052, loadData);
fff80f94:	3d 40 01 06 	lis     r10,262
fff80f98:	3d 00 a0 00 	lis     r8,-24576
fff80f9c:	39 20 00 00 	li      r9,0
fff80fa0:	61 4a 00 52 	ori     r10,r10,82
fff80fa4:	19 0a 00 00 	stvd    d8,0(r10)
    //# PAU DPLL: Write frequency settings
    //# frquency_calculated = ((7B0 + 1) * 2)/25 = 0x9D
    // SCOMIN 01060051 09D009D009D00000
    loadData = 0x09D009D009D00000ULL;
    PPE_STVD(0x01060051, loadData);
fff80fa8:	3d 00 09 d0 	lis     r8,2512
fff80fac:	3d 40 01 06 	lis     r10,262
fff80fb0:	61 08 09 d0 	ori     r8,r8,2512
fff80fb4:	3d 20 09 d0 	lis     r9,2512
fff80fb8:	61 4a 00 51 	ori     r10,r10,81
fff80fbc:	19 0a 00 00 	stvd    d8,0(r10)
    //# PAU DPLL: Switch to internal clocks (Bit 27)
    //# SCOMIN 00050133 0000001000000000
    loadData = 0x0000001000000000ULL;
    PPE_STVD(0x00050133, loadData);
fff80fc0:	3d 40 00 05 	lis     r10,5
fff80fc4:	61 4a 01 33 	ori     r10,r10,307
fff80fc8:	39 00 00 10 	li      r8,16
fff80fcc:	39 20 00 00 	li      r9,0
fff80fd0:	19 0a 00 00 	stvd    d8,0(r10)
    //# PAU DPLL : Release reset (Bit 24)
    //# SCOMIN 00050133 0000008000000000
    loadData = 0x0000008000000000;
    PPE_STVD(0x00050133, loadData);
fff80fd4:	39 00 00 80 	li      r8,128
fff80fd8:	39 20 00 00 	li      r9,0
fff80fdc:	19 0a 00 00 	stvd    d8,0(r10)
    //////////////////////////////////START CLOCKS/////////////////////////////////////
    //# Startclocks for PAU DPLL regions
    //# Exit flush (set flushmode inhibit) (set bit 2)
    //# SCOMIN 01000010 2000000000000000
    loadData = 0x2000000000000000ULL;
    PPE_STVD(0x01000010, loadData);
fff80fe0:	3d 40 01 00 	lis     r10,256
fff80fe4:	3d 00 20 00 	lis     r8,8192
fff80fe8:	39 20 00 00 	li      r9,0
fff80fec:	61 4a 00 10 	ori     r10,r10,16
fff80ff0:	19 0a 00 00 	stvd    d8,0(r10)
    //# Clear Scan region type register
    //# SCOMIN 01030005 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030005, loadData);
fff80ff4:	3d 40 01 03 	lis     r10,259
fff80ff8:	39 00 00 00 	li      r8,0
fff80ffc:	39 20 00 00 	li      r9,0
fff81000:	61 4a 00 05 	ori     r10,r10,5
fff81004:	19 0a 00 00 	stvd    d8,0(r10)
    //# Setup all Clock Domains and Clock Types
    //# SCOMIN  01030006 400800000000E000
    loadData = 0x400800000000E000ULL;
    PPE_STVD(0x01030006, loadData);
fff81008:	39 20 00 00 	li      r9,0
fff8100c:	3d 40 01 03 	lis     r10,259
fff81010:	3d 00 40 08 	lis     r8,16392
fff81014:	61 29 e0 00 	ori     r9,r9,57344
fff81018:	61 4a 00 06 	ori     r10,r10,6
fff8101c:	19 0a 00 00 	stvd    d8,0(r10)
    //# Poll OPCG done bit to check for completeness
    //# SCOMOUT 01000100 00C0000000000000, see if bit8 is set
    for(uint32_t cnt=0; cnt<0x100; cnt++)
    {
        PPE_LVD(0x01000100, fetchData);
fff81020:	39 40 01 00 	li      r10,256
fff81024:	7d 49 03 a6 	mtctr   r10
fff81028:	3d 20 01 00 	lis     r9,256
fff8102c:	61 29 01 00 	ori     r9,r9,256
fff81030:	14 c9 00 00 	lvd     d6,0(r9)
        if(fetchData & 0x0080000000000000ULL)
fff81034:	07 06 40 08 	bb1wi   r6,8,fff81044 <_Z11lockPauDpllmh+0x100>
fff81038:	42 00 ff f8 	bdnz    fff81030 <_Z11lockPauDpllmh+0xec>
    }
    if(opcg_done == 0)
    {
        //asm("li %r0, PAU_DPLL_START_CLOCK_OPCG_FAIL\n");
        //PAU_DPLL_START_CLOCK_OPCG_FAIL 0x5
        asm("li %r1, 5\n");
fff8103c:	38 20 00 05 	li      r1,5
fff81040:	48 00 00 9c 	b       fff810dc <_Z11lockPauDpllmh+0x198>
    //# CLOCK RUNNING STATUS
    //# OPGC Done, check clock status SL, NSL, ARY

    //# Check for clocks running SL
    //# SCOMOUT  01030008 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030008, fetchData);
fff81044:	3d 00 01 03 	lis     r8,259
fff81048:	61 08 00 08 	ori     r8,r8,8
fff8104c:	15 08 00 00 	lvd     d8,0(r8)
    if(((fetchData >> 32) & 0x00800000) == 0)
fff81050:	07 88 40 12 	bb0wi   r8,8,fff81074 <_Z11lockPauDpllmh+0x130>
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running NSL
    //# SCOMOUT  01030009 F9F7FFFFFFFFFFFF
    PPE_LVD(0x01030009, fetchData);
fff81054:	3d 00 01 03 	lis     r8,259
fff81058:	61 08 00 09 	ori     r8,r8,9
fff8105c:	15 08 00 00 	lvd     d8,0(r8)
    if(((fetchData >> 32) & 0x00800000) == 0)
fff81060:	07 88 40 0a 	bb0wi   r8,8,fff81074 <_Z11lockPauDpllmh+0x130>
        asm("li %r1, 6\n");
        pk_halt();
    }
    //# Check for clocks running ARY
    //# SCOMOUT  0103000A F9F7FFFFFFFFFFFF
    PPE_LVD(0x0103000A, fetchData);
fff81064:	3d 00 01 03 	lis     r8,259
fff81068:	61 08 00 0a 	ori     r8,r8,10
fff8106c:	15 08 00 00 	lvd     d8,0(r8)
    if(((fetchData >> 32) & 0x00800000) == 0)
fff81070:	07 08 40 06 	bb1wi   r8,8,fff8107c <_Z11lockPauDpllmh+0x138>
    {
        //asm("li %r0, PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL\n");
        // PAU_DPLL_CLOCK_RUNNING_STATUS_FAIL 0x6
        asm("li %r1, 6\n");
fff81074:	38 20 00 06 	li      r1,6
fff81078:	48 00 00 64 	b       fff810dc <_Z11lockPauDpllmh+0x198>
        pk_halt();
    }
    //# Clear clock region
    //# SCOMIN   01030006 0000000000000000
    loadData = 0x0000000000000000ULL;
    PPE_STVD(0x01030006, loadData);
fff8107c:	3d 40 01 03 	lis     r10,259
fff81080:	39 00 00 00 	li      r8,0
fff81084:	39 20 00 00 	li      r9,0
fff81088:	61 4a 00 06 	ori     r10,r10,6
fff8108c:	19 0a 00 00 	stvd    d8,0(r10)
    //# Enter flush (clear flushmode inhibit)
    //# SCOMIN   01000024 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000024, loadData);
fff81090:	3d 00 00 08 	lis     r8,8
fff81094:	39 20 00 00 	li      r9,0
fff81098:	3d 40 01 00 	lis     r10,256
fff8109c:	7d 06 43 78 	mr      r6,r8
fff810a0:	7d 27 4b 78 	mr      r7,r9
fff810a4:	61 4a 00 24 	ori     r10,r10,36
fff810a8:	18 ca 00 00 	stvd    d6,0(r10)

    //# Drop clock region fences for PAU DPLL
    //# SCOMIN   01000021 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000021, loadData);
fff810ac:	3d 40 01 00 	lis     r10,256
fff810b0:	61 4a 00 21 	ori     r10,r10,33
fff810b4:	19 0a 00 00 	stvd    d8,0(r10)
    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
    //# Check for PAU DPLL lock, check if bit 63 is set
    //# SCOMOUT  01060055 09D0000000000009
    for(uint32_t cnt=0; cnt<0x2750; cnt++)
    {
        PPE_LVD(0x01060055, fetchData);
fff810b8:	39 40 27 50 	li      r10,10064
fff810bc:	7d 49 03 a6 	mtctr   r10
fff810c0:	3d 20 01 06 	lis     r9,262
fff810c4:	61 29 00 55 	ori     r9,r9,85
fff810c8:	14 c9 00 00 	lvd     d6,0(r9)
        if(fetchData & 0x1)
fff810cc:	54 ea 07 fe 	clrlwi  r10,r7,31
fff810d0:	06 4a 00 08 	bwnz    r10,fff810e0 <_Z11lockPauDpllmh+0x19c>
fff810d4:	42 00 ff f4 	bdnz    fff810c8 <_Z11lockPauDpllmh+0x184>
    }
    if(pau_lock == 0)
    {
        //asm("li %r0, PAU_DPLL_LOCK_FAIL\n");
        //PAU_DPLL_LOCK_FAIL 0x07
        asm("li %r1, 7\n");
fff810d8:	38 20 00 07 	li      r1,7
        pk_halt();
fff810dc:	4b ff f1 89 	bl      fff80264 <pk_halt>
    }

    //# PAU DPLL: Release test_enable and bypass
    //# SCOMIN 00050133 0000006000000000
    loadData = 0x0000006000000000ULL;
    PPE_STVD(0x00050133, loadData);
fff810e0:	3d 40 00 05 	lis     r10,5
fff810e4:	39 00 00 60 	li      r8,96
fff810e8:	39 20 00 00 	li      r9,0
fff810ec:	61 4a 01 33 	ori     r10,r10,307
fff810f0:	19 0a 00 00 	stvd    d8,0(r10)
    //# Raise clock region fences for PAU DPLL
    //# SCOMIN 01000011 0008000000000000
    loadData = 0x0008000000000000ULL;
    PPE_STVD(0x01000011, loadData);
fff810f4:	3d 40 01 00 	lis     r10,256
fff810f8:	3d 00 00 08 	lis     r8,8
fff810fc:	39 20 00 00 	li      r9,0
fff81100:	61 4a 00 11 	ori     r10,r10,17
fff81104:	19 0a 00 00 	stvd    d8,0(r10)

    //////////////////////////////////PAU DPLL LOCK////////////////////////////////////
}
fff81108:	80 01 00 14 	lwz     r0,20(r1)
fff8110c:	17 c1 00 08 	lvd     d30,8(r1)
fff81110:	7c 08 03 a6 	mtlr    r0
fff81114:	38 21 00 10 	addi    r1,r1,16
fff81118:	4e 80 00 20 	blr

fff8111c <main>:

////////////////////////////////////////////////////////////////
// @brief - main : Measurement Application main
////////////////////////////////////////////////////////////////
int  main(int argc, char **argv)
{
fff8111c:	94 21 ff d8 	stwu    r1,-40(r1)
fff81120:	7c 08 02 a6 	mflr    r0
fff81124:	1b 81 00 18 	stvd    d28,24(r1)
fff81128:	90 01 00 2c 	stw     r0,44(r1)
fff8112c:	1b c1 00 20 	stvd    d30,32(r1)
fff81130:	4b ff fa 7d 	bl      fff80bac <__eabi>
    SBEM_ENTER(SBEM_FUNC);

    int rc = 0;
    uint64_t loadData = 0;
    uint64_t scratchMsgReg = 0;
    sbe_local_LFR lfrReg;
fff81134:	38 61 00 08 	addi    r3,r1,8
fff81138:	4b ff fa 41 	bl      fff80b78 <_ZN13sbe_local_LFRC1Ev>

    do
    {
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PIBMEM_START_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);
fff8113c:	3d 40 00 05 	lis     r10,5
fff81140:	39 00 00 06 	li      r8,6
fff81144:	39 20 00 00 	li      r9,0
fff81148:	61 4a 00 09 	ori     r10,r10,9
fff8114c:	19 0a 00 00 	stvd    d8,0(r10)

        //Fetch the default clock divider from LFR, whatever is updated by OTPROM
        PPE_LVD(0xc0002040, lfrReg);
fff81150:	3d 00 c0 00 	lis     r8,-16384
fff81154:	61 08 20 40 	ori     r8,r8,8256
fff81158:	15 08 00 00 	lvd     d8,0(r8)
        //
        // Reset the TPM SPI Engine, c0002010 bit 12 OR_Register/ c0002018 bit 12 And_Register
        // This is an externel reset, it will clear the spi lock and any status/config register
        // to default.
        loadData = 0x0008000000000000ULL;
        PPE_STVD(0xc0002010, loadData);
fff8115c:	3d 40 c0 00 	lis     r10,-16384
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PIBMEM_START_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);

        //Fetch the default clock divider from LFR, whatever is updated by OTPROM
        PPE_LVD(0xc0002040, lfrReg);
fff81160:	19 01 00 08 	stvd    d8,8(r1)
        //
        // Reset the TPM SPI Engine, c0002010 bit 12 OR_Register/ c0002018 bit 12 And_Register
        // This is an externel reset, it will clear the spi lock and any status/config register
        // to default.
        loadData = 0x0008000000000000ULL;
        PPE_STVD(0xc0002010, loadData);
fff81164:	61 4a 20 10 	ori     r10,r10,8208
fff81168:	3d 00 00 08 	lis     r8,8
fff8116c:	39 20 00 00 	li      r9,0
fff81170:	19 0a 00 00 	stvd    d8,0(r10)
        PPE_STVD(0xc0002018, loadData);
fff81174:	39 4a 00 08 	addi    r10,r10,8
fff81178:	19 0a 00 00 	stvd    d8,0(r10)
        // In this path, we make sure we have updated all SPI Clock Registers and updated LFR
        // all fields, nothing is missing, so that subsequent flow can depend on LFR
        if(!(lfrReg.mpipl)) // IPL Path
fff8117c:	83 c1 00 08 	lwz     r30,8(r1)
fff81180:	07 1e 70 c8 	bb1wi   r30,14,fff81310 <main+0x1f4>
        {
            // Fetch scratch reg8 to validate other scratch registers
            PPE_LVD(0x5003F, scratchReg8);
fff81184:	3c c0 00 05 	lis     r6,5
fff81188:	60 c6 00 3f 	ori     r6,r6,63
fff8118c:	14 c6 00 00 	lvd     d6,0(r6)
            // Fetch scratch register8 bit 13, to check if scratch 13 is valid to pick the TPM
            // clock divder and clock delay settings
            if((scratchReg8 >> BIT12_SHIFT) & BIT0_MASK) // Scratch Reg13 is Valid
fff81190:	54 ca 03 18 	rlwinm  r10,r6,0,12,12
            else // Not valid Scratch Reg13
            {
                // Hard-code the TPM SPI clock settings to default values in case User Dial is not there
                // Use 133Mhz PAU Ref clock, Filling it up here since it will be used everywhere. At this point
                // LFR can be used to derive TPM SPI Clock divider, Assuming Ref clock at this point.
                scratchReg13.tpm_spi_clock_delay = lfrReg.round_trip_delay; //Default to SPI Seeprom
fff81194:	57 df c7 3e 	rlwinm  r31,r30,24,28,31
fff81198:	81 21 00 0c 	lwz     r9,12(r1)
                scratchReg13.tpm_spi_clock_divider = lfrReg.spi_clock_divider; // Default to SPI Seeprom
fff8119c:	57 de 65 3e 	rlwinm  r30,r30,12,20,31
        {
            // Fetch scratch reg8 to validate other scratch registers
            PPE_LVD(0x5003F, scratchReg8);
            // Fetch scratch register8 bit 13, to check if scratch 13 is valid to pick the TPM
            // clock divder and clock delay settings
            if((scratchReg8 >> BIT12_SHIFT) & BIT0_MASK) // Scratch Reg13 is Valid
fff811a0:	06 ca 00 0c 	bwz     r10,fff811b8 <main+0x9c>
            {
                // Pick up the TPM SPI clock divider and clock delay basis
                PPE_LVD(0x50184, scratchReg13);
fff811a4:	3f e0 00 05 	lis     r31,5
fff811a8:	63 ff 01 84 	ori     r31,r31,388
fff811ac:	14 9f 00 00 	lvd     d4,0(r31)
fff811b0:	54 9e 65 3e 	rlwinm  r30,r4,12,20,31
fff811b4:	54 9f 87 3e 	rlwinm  r31,r4,16,28,31
                // Hard-code the TPM SPI clock settings to default values in case User Dial is not there
                // Use 133Mhz PAU Ref clock, Filling it up here since it will be used everywhere. At this point
                // LFR can be used to derive TPM SPI Clock divider, Assuming Ref clock at this point.
                scratchReg13.tpm_spi_clock_delay = lfrReg.round_trip_delay; //Default to SPI Seeprom
                scratchReg13.tpm_spi_clock_divider = lfrReg.spi_clock_divider; // Default to SPI Seeprom
                lfrReg.tpm_spi_clock_delay =  scratchReg13.tpm_spi_clock_delay;
fff811b8:	53 e9 e0 06 	rlwimi  r9,r31,28,0,3
fff811bc:	91 21 00 0c 	stw     r9,12(r1)
            }
            PPE_STVD(0xc0002040, lfrReg);
fff811c0:	3f a0 c0 00 	lis     r29,-16384
fff811c4:	63 bd 20 40 	ori     r29,r29,8256
fff811c8:	15 01 00 08 	lvd     d8,8(r1)
fff811cc:	19 1d 00 00 	stvd    d8,0(r29)
fff811d0:	19 01 00 08 	stvd    d8,8(r1)

            // Fetch scratch register8 bit 5, to check if scratch reg 6 bit15 is unset to boot
            // using the PAU DPLL
            PPE_LVD(0x5003D, scratchReg6);
fff811d4:	3d 00 00 05 	lis     r8,5
fff811d8:	61 08 00 3d 	ori     r8,r8,61
fff811dc:	15 08 00 00 	lvd     d8,0(r8)
            if((!((scratchReg6 >> BIT15_SHIFT) & BIT0_MASK)) && ((scratchReg8 >> BIT5_SHIFT) & BIT0_MASK)) //PAU Path
fff811e0:	07 08 78 54 	bb1wi   r8,15,fff81288 <main+0x16c>
fff811e4:	07 86 28 52 	bb0wi   r6,5,fff81288 <main+0x16c>
            {
                // Update the Code Flow status in messaging register 50009
                uint64_t scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PAU_DPLL_LOCK_MSG)<<32;
                PPE_STVD(0x50009, scratchMsgReg);
fff811e8:	3c e0 00 05 	lis     r7,5
fff811ec:	39 00 00 07 	li      r8,7
fff811f0:	39 20 00 00 	li      r9,0
fff811f4:	60 e7 00 09 	ori     r7,r7,9
fff811f8:	19 07 00 00 	stvd    d8,0(r7)
                if( !((scratchReg8 >> BIT12_SHIFT) & BIT0_MASK) ) // If Scratch 13 is not valid
fff811fc:	06 4a 00 06 	bwnz    r10,fff81208 <main+0xec>
                {
                    scratchReg13.tpm_spi_clock_divider = 0x15; // Hard-code to 12Mhz in case of Scratch Reg13 is not valid
                    scratchReg13.tpm_spi_clock_delay = 0x7; // Hard code to 7 cycle delay
fff81200:	3b e0 00 07 	li      r31,7
                // Update the Code Flow status in messaging register 50009
                uint64_t scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_PAU_DPLL_LOCK_MSG)<<32;
                PPE_STVD(0x50009, scratchMsgReg);
                if( !((scratchReg8 >> BIT12_SHIFT) & BIT0_MASK) ) // If Scratch 13 is not valid
                {
                    scratchReg13.tpm_spi_clock_divider = 0x15; // Hard-code to 12Mhz in case of Scratch Reg13 is not valid
fff81204:	3b c0 00 15 	li      r30,21
fff81208:	3f a0 1d 53 	lis     r29,7507
                    scratchReg13.tpm_spi_clock_delay = 0x7; // Hard code to 7 cycle delay
                }
                if(!SBE::isSimicsRunning())
fff8120c:	48 00 14 91 	bl      fff8269c <_ZN3SBE15isSimicsRunningEv>
fff81210:	63 bd 53 00 	ori     r29,r29,21248
fff81214:	06 43 00 0e 	bwnz    r3,fff81230 <main+0x114>
                {
                    // Pass in the TPM Spi Clock divider and Clock delay
                    lockPauDpll(scratchReg13.tpm_spi_clock_divider, scratchReg13.tpm_spi_clock_delay);
fff81218:	7f c3 f3 78 	mr      r3,r30
fff8121c:	7f e4 fb 78 	mr      r4,r31
fff81220:	4b ff fd 25 	bl      fff80f44 <_Z11lockPauDpllmh>
                    // The above function is going to return success, if not then pk_halt
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
fff81224:	93 ad 13 70 	stw     r29,4976(r13)
                    SBEM_INFO(SBEM_FUNC "HW Path of setting PAU DPLL");
fff81228:	3c 60 75 1b 	lis     r3,29979
fff8122c:	48 00 00 18 	b       fff81244 <main+0x128>
                }
                else
                {
                    //In Simics Path, Simply set the SPI Clock and LFR with new clock dividers
                    // SPI Clock Setting per the new Frequency Start
                    setupSpiClockDividerAndLFRPerPAUDPLL(scratchReg13.tpm_spi_clock_divider, scratchReg13.tpm_spi_clock_delay);
fff81230:	7f c3 f3 78 	mr      r3,r30
fff81234:	7f e4 fb 78 	mr      r4,r31
fff81238:	4b ff fa 49 	bl      fff80c80 <_Z36setupSpiClockDividerAndLFRPerPAUDPLLmh>
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
fff8123c:	93 ad 13 70 	stw     r29,4976(r13)
                    SBEM_INFO(SBEM_FUNC "Simics Path of Skipping PAU DPLL");
fff81240:	3c 60 65 2f 	lis     r3,25903
                }
                // Read LFR again since it is going to change in the PAU DPLL function
                PPE_LVD(0xc0002040, lfrReg);
fff81244:	3f 80 c0 00 	lis     r28,-16384
                {
                    //In Simics Path, Simply set the SPI Clock and LFR with new clock dividers
                    // SPI Clock Setting per the new Frequency Start
                    setupSpiClockDividerAndLFRPerPAUDPLL(scratchReg13.tpm_spi_clock_divider, scratchReg13.tpm_spi_clock_delay);
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                    SBEM_INFO(SBEM_FUNC "Simics Path of Skipping PAU DPLL");
fff81248:	4b ff ef 31 	bl      fff80178 <pk_trace_tiny>
                }
                // Read LFR again since it is going to change in the PAU DPLL function
                PPE_LVD(0xc0002040, lfrReg);
fff8124c:	63 9c 20 40 	ori     r28,r28,8256
fff81250:	15 1c 00 00 	lvd     d8,0(r28)
                lfrReg.tpm_spi_clock_freq_Mhz = 1968/(8*(scratchReg13.tpm_spi_clock_divider + 1));
fff81254:	38 9e 00 01 	addi    r4,r30,1
                    setupSpiClockDividerAndLFRPerPAUDPLL(scratchReg13.tpm_spi_clock_divider, scratchReg13.tpm_spi_clock_delay);
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                    SBEM_INFO(SBEM_FUNC "Simics Path of Skipping PAU DPLL");
                }
                // Read LFR again since it is going to change in the PAU DPLL function
                PPE_LVD(0xc0002040, lfrReg);
fff81258:	7d 3d 4b 78 	mr      r29,r9
                lfrReg.tpm_spi_clock_freq_Mhz = 1968/(8*(scratchReg13.tpm_spi_clock_divider + 1));
fff8125c:	54 84 18 38 	rlwinm  r4,r4,3,0,28
fff81260:	38 60 07 b0 	li      r3,1968
                    setupSpiClockDividerAndLFRPerPAUDPLL(scratchReg13.tpm_spi_clock_divider, scratchReg13.tpm_spi_clock_delay);
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                    SBEM_INFO(SBEM_FUNC "Simics Path of Skipping PAU DPLL");
                }
                // Read LFR again since it is going to change in the PAU DPLL function
                PPE_LVD(0xc0002040, lfrReg);
fff81264:	19 01 00 08 	stvd    d8,8(r1)
                lfrReg.tpm_spi_clock_freq_Mhz = 1968/(8*(scratchReg13.tpm_spi_clock_divider + 1));
fff81268:	48 00 16 e1 	bl      fff82948 <__divsi3>
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
fff8126c:	7f a9 eb 78 	mr      r9,r29
fff81270:	53 e9 e0 06 	rlwimi  r9,r31,28,0,3
                    g_sbemfreqency = SBE_PAU_DPLL_BASE_FREQ_HZ; // this is required for pk init
                    SBEM_INFO(SBEM_FUNC "Simics Path of Skipping PAU DPLL");
                }
                // Read LFR again since it is going to change in the PAU DPLL function
                PPE_LVD(0xc0002040, lfrReg);
                lfrReg.tpm_spi_clock_freq_Mhz = 1968/(8*(scratchReg13.tpm_spi_clock_divider + 1));
fff81274:	98 61 00 0b 	stb     r3,11(r1)
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
fff81278:	91 21 00 0c 	stw     r9,12(r1)
                PPE_STVD(0xc0002040, lfrReg);
fff8127c:	15 01 00 08 	lvd     d8,8(r1)
fff81280:	19 1c 00 00 	stvd    d8,0(r28)
fff81284:	48 00 00 84 	b       fff81308 <main+0x1ec>
            }
            else // Ref clock Path
            {
                // Read LFR again since it is going to change
                PPE_LVD(0xc0002040, lfrReg);
fff81288:	15 1d 00 00 	lvd     d8,0(r29)
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                // and clock delay setting to what we have stored in the scratch13 above, we are expected
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
fff8128c:	38 9e 00 01 	addi    r4,r30,1
                PPE_STVD(0xc0002040, lfrReg);
            }
            else // Ref clock Path
            {
                // Read LFR again since it is going to change
                PPE_LVD(0xc0002040, lfrReg);
fff81290:	19 01 00 08 	stvd    d8,8(r1)
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                // and clock delay setting to what we have stored in the scratch13 above, we are expected
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
fff81294:	54 84 18 38 	rlwinm  r4,r4,3,0,28
                // We can assume all other SPIs are configured here in Otprom with
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                // and clock delay setting to what we have stored in the scratch13 above, we are expected
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
fff81298:	53 e9 e0 06 	rlwimi  r9,r31,28,0,3
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
fff8129c:	38 60 00 85 	li      r3,133
                // We can assume all other SPIs are configured here in Otprom with
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                // and clock delay setting to what we have stored in the scratch13 above, we are expected
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
fff812a0:	91 21 00 0c 	stw     r9,12(r1)
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
fff812a4:	48 00 16 a5 	bl      fff82948 <__divsi3>
                PPE_LVD(0xc0083, spiClockReg);
fff812a8:	3d 40 00 0c 	lis     r10,12
                // 133Mhz and 4 respectively, We just need to set the TPM SPI Clock Register
                // and clock delay setting to what we have stored in the scratch13 above, we are expected
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
fff812ac:	98 61 00 0b 	stb     r3,11(r1)
                PPE_LVD(0xc0083, spiClockReg);
fff812b0:	61 4a 00 83 	ori     r10,r10,131
fff812b4:	14 ca 00 00 	lvd     d6,0(r10)
                spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                                ((uint64_t)scratchReg13.tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
fff812b8:	39 00 00 00 	li      r8,0
fff812bc:	7f c9 f3 78 	mr      r9,r30
fff812c0:	79 08 a2 c6 	rldicr  d8,d8,52,11
                                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - scratchReg13.tpm_spi_clock_delay)) |
fff812c4:	20 9f 00 2c 	subfic  r4,r31,44
fff812c8:	3b c0 00 00 	li      r30,0
fff812cc:	3b e0 00 80 	li      r31,128
fff812d0:	7f c4 20 76 	slvd    d4,d30,r4
fff812d4:	61 08 00 0a 	ori     r8,r8,10
                // to fail with this configuration, but that is ok, since if TPM communication fails,
                // we will do the deconfig of the TPM.
                lfrReg.tpm_spi_clock_delay = scratchReg13.tpm_spi_clock_delay;
                lfrReg.tpm_spi_clock_freq_Mhz = (133/(8*(scratchReg13.tpm_spi_clock_divider + 1)));
                PPE_LVD(0xc0083, spiClockReg);
                spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
fff812d8:	54 c6 05 3e 	clrlwi  r6,r6,20
fff812dc:	7d 08 23 78 	or      r8,r8,r4
                                ((uint64_t)scratchReg13.tpm_spi_clock_divider << SPI_CLOCK_DIVIDER_SHIFT) |
                                ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - scratchReg13.tpm_spi_clock_delay)) |
                                ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                                ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
fff812e0:	7d 1e 33 78 	or      r30,r8,r6
fff812e4:	7c bf 3b 78 	or      r31,r5,r7
                PPE_STVD(0xc0083, spiClockReg);
fff812e8:	1b ca 00 00 	stvd    d30,0(r10)
                g_sbemfreqency = SBE_REF_BASE_FREQ_HZ; // this is required for pk init
fff812ec:	3d 20 01 fb 	lis     r9,507
fff812f0:	61 29 5a d0 	ori     r9,r9,23248
fff812f4:	91 2d 13 70 	stw     r9,4976(r13)
                // Let's update the Ref clock frequency into LFR, this is the first time we got
                // a chance to do that since otprom change is not allowed.
                lfrReg.pau_freq_in_mhz = 133; // 133MHz Ref clock
fff812f8:	39 20 00 85 	li      r9,133
fff812fc:	b1 21 00 0e 	sth     r9,14(r1)
                PPE_STVD(0xc0002040, lfrReg);
fff81300:	15 01 00 08 	lvd     d8,8(r1)
fff81304:	19 1d 00 00 	stvd    d8,0(r29)
fff81308:	19 01 00 08 	stvd    d8,8(r1)
fff8130c:	48 00 00 8c 	b       fff81398 <main+0x27c>
            // calculate TPM SPI Clock divider.
            // Re-calculate from TPM SPI Clock divider from Frequency we have stored in LFR
            //uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            // divider = (PAU/24MHz*8) - 1
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/(lfrReg.tpm_spi_clock_freq_Mhz * 8)) - 1);
            PPE_LVD(0xc0083, spiClockReg);
fff81310:	3f a0 00 0c 	lis     r29,12
fff81314:	63 bd 00 83 	ori     r29,r29,131
fff81318:	17 dd 00 00 	lvd     d30,0(r29)
            // in case they are modified. We have the PAU system frequency in LFR, fetch that and
            // calculate TPM SPI Clock divider.
            // Re-calculate from TPM SPI Clock divider from Frequency we have stored in LFR
            //uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            // divider = (PAU/24MHz*8) - 1
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/(lfrReg.tpm_spi_clock_freq_Mhz * 8)) - 1);
fff8131c:	88 81 00 0b 	lbz     r4,11(r1)
fff81320:	a0 61 00 0e 	lhz     r3,14(r1)
fff81324:	54 84 18 38 	rlwinm  r4,r4,3,0,28
fff81328:	48 00 16 21 	bl      fff82948 <__divsi3>
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.tpm_spi_clock_delay)) |
fff8132c:	81 21 00 0c 	lwz     r9,12(r1)
fff81330:	38 80 00 00 	li      r4,0
fff81334:	55 29 27 3e 	rlwinm  r9,r9,4,28,31
fff81338:	21 29 00 2c 	subfic  r9,r9,44
fff8133c:	38 a0 00 80 	li      r5,128
fff81340:	7c 84 48 76 	slvd    d4,d4,r9
            //uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            // divider = (PAU/24MHz*8) - 1
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/(lfrReg.tpm_spi_clock_freq_Mhz * 8)) - 1);
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
fff81344:	38 e3 ff ff 	addi    r7,r3,-1
fff81348:	38 c0 00 00 	li      r6,0
fff8134c:	78 c8 a2 c6 	rldicr  d8,d6,52,11
fff81350:	60 8a 00 0a 	ori     r10,r4,10
            // Re-calculate from TPM SPI Clock divider from Frequency we have stored in LFR
            //uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/192) - 1); // 24MHz = ((PAU/4)/2(N+1))
            // divider = (PAU/24MHz*8) - 1
            uint32_t tpmSpiClockDivider = ((lfrReg.pau_freq_in_mhz/(lfrReg.tpm_spi_clock_freq_Mhz * 8)) - 1);
            PPE_LVD(0xc0083, spiClockReg);
            spiClockReg = ( (spiClockReg & SPI_CLOCK_DIVIDER_DELAY_MASK) |
fff81354:	57 de 05 3e 	clrlwi  r30,r30,20
fff81358:	7d 4a 43 78 	or      r10,r10,r8
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.tpm_spi_clock_delay)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
fff8135c:	7d 48 f3 78 	or      r8,r10,r30
fff81360:	7c a9 fb 78 	or      r9,r5,r31
            PPE_STVD(0xc0083, spiClockReg);
fff81364:	19 1d 00 00 	stvd    d8,0(r29)
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
            SBEM_INFO(SBEM_FUNC "MPIPL Path, TPM Freq[0x%02X] TPM Divider[0x%04X] TPM Delay[0x%02X] Pau Freq[0x%04X]",
                lfrReg.tpm_spi_clock_freq_Mhz, tpmSpiClockDivider, lfrReg.tpm_spi_clock_delay, lfrReg.pau_freq_in_mhz);
fff81368:	7c e6 3b 78 	mr      r6,r7
fff8136c:	80 e1 00 0c 	lwz     r7,12(r1)
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.tpm_spi_clock_delay)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
fff81370:	a1 01 00 0e 	lhz     r8,14(r1)
fff81374:	3d 20 00 03 	lis     r9,3
            SBEM_INFO(SBEM_FUNC "MPIPL Path, TPM Freq[0x%02X] TPM Divider[0x%04X] TPM Delay[0x%02X] Pau Freq[0x%04X]",
                lfrReg.tpm_spi_clock_freq_Mhz, tpmSpiClockDivider, lfrReg.tpm_spi_clock_delay, lfrReg.pau_freq_in_mhz);
fff81378:	3c 60 f9 65 	lis     r3,-1691
fff8137c:	88 a1 00 0b 	lbz     r5,11(r1)
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.tpm_spi_clock_delay)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
fff81380:	61 29 d0 90 	ori     r9,r9,53392
            SBEM_INFO(SBEM_FUNC "MPIPL Path, TPM Freq[0x%02X] TPM Divider[0x%04X] TPM Delay[0x%02X] Pau Freq[0x%04X]",
                lfrReg.tpm_spi_clock_freq_Mhz, tpmSpiClockDivider, lfrReg.tpm_spi_clock_delay, lfrReg.pau_freq_in_mhz);
fff81384:	60 63 00 04 	ori     r3,r3,4
fff81388:	54 e7 27 3e 	rlwinm  r7,r7,4,28,31
                            ((uint64_t)tpmSpiClockDivider << SPI_CLOCK_DIVIDER_SHIFT) |
                            ((uint64_t)DEFAULT_SPI_CLOCK_DELAY << (SPI_CLOCK_DELAY_SHIFT - lfrReg.tpm_spi_clock_delay)) |
                            ((uint64_t)ECC_SPIMM_ADDR_CORRECTION_DIS << SPI_ECC_SPIMM_ADDR_CORRECTION_SHIFT) |
                            ((uint64_t)ECC_CONTROL_TRANSPARENT_READ << SPI_ECC_CONTROL_SHIFT) );
            PPE_STVD(0xc0083, spiClockReg);
            g_sbemfreqency = (lfrReg.pau_freq_in_mhz * 1000 * 1000)/4; // this is required for pk init
fff8138c:	7d 28 49 d6 	mullw   r9,r8,r9
fff81390:	91 2d 13 70 	stw     r9,4976(r13)
            SBEM_INFO(SBEM_FUNC "MPIPL Path, TPM Freq[0x%02X] TPM Divider[0x%04X] TPM Delay[0x%02X] Pau Freq[0x%04X]",
                lfrReg.tpm_spi_clock_freq_Mhz, tpmSpiClockDivider, lfrReg.tpm_spi_clock_delay, lfrReg.pau_freq_in_mhz);
fff81394:	48 00 1c d1 	bl      fff83064 <pk_trace_big>
        }
        //////////////////////////////////// Lock PAU DPLL ////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////

        //Check SBE Role
        g_sbeRole = checkSbeRole();
fff81398:	48 00 32 25 	bl      fff845bc <_Z12checkSbeRolev>
fff8139c:	7c 65 1b 78 	mr      r5,r3
fff813a0:	90 6d 13 6c 	stw     r3,4972(r13)
        SBEM_INFO(SBEM_FUNC "SBE Role is %x", g_sbeRole);
fff813a4:	3c 60 14 df 	lis     r3,5343
fff813a8:	60 63 00 01 	ori     r3,r3,1
fff813ac:	38 c0 00 00 	li      r6,0
fff813b0:	38 e0 00 00 	li      r7,0
fff813b4:	39 00 00 00 	li      r8,0
fff813b8:	48 00 1c ad 	bl      fff83064 <pk_trace_big>
        rc = pk_initialize((PkAddress)measurment_Kernel_NC_Int_stack,
                MEASUREMENT_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbemfreqency );
fff813bc:	3c 60 ff f9 	lis     r3,-7
fff813c0:	80 ed 13 70 	lwz     r7,4976(r13)
fff813c4:	38 63 a5 18 	addi    r3,r3,-23272
fff813c8:	38 80 02 00 	li      r4,512
fff813cc:	38 a0 00 00 	li      r5,0
fff813d0:	38 c0 00 00 	li      r6,0
fff813d4:	4b ff f6 09 	bl      fff809dc <pk_initialize>
fff813d8:	7c 7f 1b 78 	mr      r31,r3
        if (rc)
        {
            SBEM_ERROR(SBEM_FUNC "pk_initialize failed with rc 0x%08X", rc);
fff813dc:	3c 60 e9 81 	lis     r3,-5759
        SBEM_INFO(SBEM_FUNC "SBE Role is %x", g_sbeRole);
        rc = pk_initialize((PkAddress)measurment_Kernel_NC_Int_stack,
                MEASUREMENT_NONCRITICAL_STACK_SIZE,
                INITIAL_PK_TIMEBASE, // initial_timebase
                g_sbemfreqency );
        if (rc)
fff813e0:	06 5f 00 5c 	bwnz    r31,fff81498 <main+0x37c>
        {
            SBEM_ERROR(SBEM_FUNC "pk_initialize failed with rc 0x%08X", rc);
            break;
        }
        // Read LFR again since it is going to change
        PPE_LVD(0xc0002040, lfrReg);
fff813e4:	3d 00 c0 00 	lis     r8,-16384
fff813e8:	61 08 20 40 	ori     r8,r8,8256
fff813ec:	15 08 00 00 	lvd     d8,0(r8)
fff813f0:	19 01 00 08 	stvd    d8,8(r1)
        uint32_t tempDivider = ((lfrReg.pau_freq_in_mhz/(lfrReg.tpm_spi_clock_freq_Mhz * 8)) - 1);
fff813f4:	55 23 04 3e 	clrlwi  r3,r9,16
fff813f8:	88 81 00 0b 	lbz     r4,11(r1)
fff813fc:	54 84 18 38 	rlwinm  r4,r4,3,0,28
fff81400:	48 00 15 49 	bl      fff82948 <__divsi3>
fff81404:	3b e3 ff ff 	addi    r31,r3,-1

        SBEM_INFO(SBEM_FUNC "Completed PK init for Measurement Image with Freq [0x%08X]", g_sbemfreqency);
fff81408:	80 ad 13 70 	lwz     r5,4976(r13)
fff8140c:	3c 60 42 3c 	lis     r3,16956
fff81410:	60 63 00 01 	ori     r3,r3,1
fff81414:	38 c0 00 00 	li      r6,0
fff81418:	38 e0 00 00 	li      r7,0
fff8141c:	39 00 00 00 	li      r8,0
fff81420:	48 00 1c 45 	bl      fff83064 <pk_trace_big>
        SBEM_INFO(SBEM_FUNC "LFR clock divider and round trip delay = [0x%04X 0x%02X]", lfrReg.spi_clock_divider, lfrReg.round_trip_delay);
fff81424:	80 c1 00 08 	lwz     r6,8(r1)
fff81428:	3c 60 86 57 	lis     r3,-31145
fff8142c:	54 c5 65 3e 	rlwinm  r5,r6,12,20,31
fff81430:	60 63 00 02 	ori     r3,r3,2
fff81434:	54 c6 c7 3e 	rlwinm  r6,r6,24,28,31
fff81438:	38 e0 00 00 	li      r7,0
fff8143c:	39 00 00 00 	li      r8,0
fff81440:	48 00 1c 25 	bl      fff83064 <pk_trace_big>
        SBEM_INFO(SBEM_FUNC "TPM SPI Clock divider and round trip delay and Frequency = [0x%04X 0x%02X 0x%02X]",
            tempDivider, lfrReg.tpm_spi_clock_delay, lfrReg.tpm_spi_clock_freq_Mhz);
fff81444:	80 c1 00 0c 	lwz     r6,12(r1)
fff81448:	88 e1 00 0b 	lbz     r7,11(r1)
fff8144c:	3c 60 4d ab 	lis     r3,19883
fff81450:	7f e5 fb 78 	mr      r5,r31
fff81454:	60 63 00 03 	ori     r3,r3,3
fff81458:	54 c6 27 3e 	rlwinm  r6,r6,4,28,31
fff8145c:	39 00 00 00 	li      r8,0
fff81460:	48 00 1c 05 	bl      fff83064 <pk_trace_big>
        rc = createAndResumeThreadHelper(&sbem_thread,
                sbemthreadroutine,
                (void *)0,
                (PkAddress)measurmentSecureBoot_stack,
                MEASUREMENT_THREAD_SECURE_BOOT_STACK_SIZE,
                THREAD_PRIORITY_5);
fff81464:	3c 60 ff f9 	lis     r3,-7
fff81468:	3c 80 ff f8 	lis     r4,-8
fff8146c:	3c c0 ff f8 	lis     r6,-8
fff81470:	38 63 a4 e8 	addi    r3,r3,-23320
fff81474:	38 84 14 f4 	addi    r4,r4,5364
fff81478:	38 a0 00 00 	li      r5,0
fff8147c:	38 c6 7c e8 	addi    r6,r6,31976
fff81480:	38 e0 28 00 	li      r7,10240
fff81484:	39 00 00 05 	li      r8,5
fff81488:	4b ff f7 91 	bl      fff80c18 <_Z27createAndResumeThreadHelperP8PkThreadPFvPvES1_mj19sbeThreadPriorities>
fff8148c:	7c 7f 1b 78 	mr      r31,r3
        if (rc)
fff81490:	06 c3 00 12 	bwz     r3,fff814b4 <main+0x398>
        {
            SBEM_ERROR(SBEM_FUNC "Initialize secure boot thread failed with rc 0x%08X", rc);
fff81494:	3c 60 49 9b 	lis     r3,18843
fff81498:	60 63 00 01 	ori     r3,r3,1
fff8149c:	7f e5 fb 78 	mr      r5,r31
fff814a0:	38 c0 00 00 	li      r6,0
fff814a4:	38 e0 00 00 	li      r7,0
fff814a8:	39 00 00 00 	li      r8,0
fff814ac:	48 00 1b b9 	bl      fff83064 <pk_trace_big>
            break;
fff814b0:	48 00 00 10 	b       fff814c0 <main+0x3a4>
        }

        SBEM_INFO("sbemSecureBoot_thread thread initilised");
fff814b4:	3c 60 01 50 	lis     r3,336
fff814b8:	4b ff ec c1 	bl      fff80178 <pk_trace_tiny>
        pk_start_threads();
fff814bc:	48 00 19 7d 	bl      fff82e38 <pk_start_threads>

    }while(false);

    SBEM_EXIT(SBEM_FUNC);
    return rc;
}
fff814c0:	80 01 00 2c 	lwz     r0,44(r1)
fff814c4:	7f e3 fb 78 	mr      r3,r31
fff814c8:	7c 08 03 a6 	mtlr    r0
fff814cc:	17 81 00 18 	lvd     d28,24(r1)
fff814d0:	17 c1 00 20 	lvd     d30,32(r1)
fff814d4:	38 21 00 28 	addi    r1,r1,40
fff814d8:	4e 80 00 20 	blr

fff814dc <_GLOBAL__sub_I_measurment_Kernel_NC_Int_stack>:
////////////////////////////////////////////////////////////////////
PkThread sbem_thread;

// SBE Frequency to be used to initialise PK
uint32_t g_sbemfreqency = SBE_REF_BASE_FREQ_HZ;
sbe_local_LFR lfrReg;
fff814dc:	38 6d 40 28 	addi    r3,r13,16424
fff814e0:	4b ff f6 98 	b       fff80b78 <_ZN13sbe_local_LFRC1Ev>

fff814e4 <__sbe_register_saveoff>:

#include "sbeirq.H"

extern "C" void __sbe_register_saveoff()
{
    asm("b pk_halt\n");
fff814e4:	4b ff ed 80 	b       fff80264 <pk_halt>
fff814e8:	4e 80 00 20 	blr

fff814ec <__sbe_machine_check_handler>:
}

extern "C" void __sbe_machine_check_handler()
{
    asm("b pk_halt\n");
fff814ec:	4b ff ed 78 	b       fff80264 <pk_halt>
fff814f0:	4e 80 00 20 	blr

fff814f4 <_Z17sbemthreadroutinePv>:
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 3], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG7), hashData);
}

void sbemthreadroutine(void *i_pArg)
{
fff814f4:	94 21 ff 48 	stwu    r1,-184(r1)
fff814f8:	7c 08 02 a6 	mflr    r0
fff814fc:	1b c1 00 b0 	stvd    d30,176(r1)
    #define SBEM_FUNC " sbemthreadroutine "
    SBEM_ENTER(SBEM_FUNC);

    int rc = 0;
    uint64_t data = 0;
fff81500:	39 00 00 00 	li      r8,0
fff81504:	39 20 00 00 	li      r9,0
    uint8_t reserved[6];

    //Constructor
    securityState_PCR6()
    {
        jumperState = 0;
fff81508:	3b e0 00 00 	li      r31,0
        minimumSecureVersion = 0;
        memset(reserved, 0x0, 6 * sizeof(uint8_t));
fff8150c:	38 61 00 8a 	addi    r3,r1,138
fff81510:	38 80 00 00 	li      r4,0
fff81514:	38 a0 00 06 	li      r5,6
fff81518:	19 01 00 a0 	stvd    d8,160(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff8151c:	19 01 00 98 	stvd    d8,152(r1)
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 3], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG7), hashData);
}

void sbemthreadroutine(void *i_pArg)
{
fff81520:	90 01 00 bc 	stw     r0,188(r1)
fff81524:	1b 81 00 a8 	stvd    d28,168(r1)
    uint8_t reserved[6];

    //Constructor
    securityState_PCR6()
    {
        jumperState = 0;
fff81528:	9b e1 00 88 	stb     r31,136(r1)
        minimumSecureVersion = 0;
fff8152c:	9b e1 00 89 	stb     r31,137(r1)
        memset(reserved, 0x0, 6 * sizeof(uint8_t));
fff81530:	48 00 14 f5 	bl      fff82a24 <memset>
    //Constructor
    securityState_PCR1()
    {
        jumperState = 0;
        isPrimary = 0;
        isMpipl = 0;
fff81534:	39 20 00 00 	li      r9,0

    do
    {
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_TPM_INIT_SEQUENCE_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);
fff81538:	3d 40 00 05 	lis     r10,5
fff8153c:	99 21 00 91 	stb     r9,145(r1)
        mSeepromLock = 0;
fff81540:	99 21 00 92 	stb     r9,146(r1)
        minimumSecureVersion = 0;
fff81544:	99 21 00 93 	stb     r9,147(r1)
        mSeepromVersion = 0;
fff81548:	91 21 00 94 	stw     r9,148(r1)
    uint32_t mSeepromVersion;

    //Constructor
    securityState_PCR1()
    {
        jumperState = 0;
fff8154c:	9b e1 00 90 	stb     r31,144(r1)
fff81550:	39 00 00 08 	li      r8,8
fff81554:	39 20 00 00 	li      r9,0
fff81558:	61 4a 00 09 	ori     r10,r10,9
fff8155c:	19 0a 00 00 	stvd    d8,0(r10)

        // Reset the MAILBOX_SCRATCH_REG_11.
        PPE_STVD(0x50182, data);
fff81560:	3d 40 00 05 	lis     r10,5
fff81564:	15 01 00 a0 	lvd     d8,160(r1)
fff81568:	61 4a 01 82 	ori     r10,r10,386
fff8156c:	19 0a 00 00 	stvd    d8,0(r10)

        // Startup TPM Sequence for Master Chip, Poison for Alt-master and Deconfig Bit for Secondary chips
        rc = performTPMSequences(g_sbeRole);
fff81570:	80 6d 13 6c 	lwz     r3,4972(r13)
        // Update the Code Flow status in messaging register 50009
        scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_TPM_INIT_SEQUENCE_MSG)<<32;
        PPE_STVD(0x50009, scratchMsgReg);

        // Reset the MAILBOX_SCRATCH_REG_11.
        PPE_STVD(0x50182, data);
fff81574:	19 01 00 a0 	stvd    d8,160(r1)

        // Startup TPM Sequence for Master Chip, Poison for Alt-master and Deconfig Bit for Secondary chips
        rc = performTPMSequences(g_sbeRole);
fff81578:	48 00 0c 81 	bl      fff821f8 <_Z19performTPMSequencesm>
        if (rc)
fff8157c:	06 c3 00 10 	bwz     r3,fff8159c <_Z17sbemthreadroutinePv+0xa8>
        {
            SBEM_ERROR(SBEM_FUNC "performTPMSequences failed with rc 0x%08X. "
fff81580:	3c 60 9e 93 	lis     r3,-24941
fff81584:	60 63 00 01 	ori     r3,r3,1
fff81588:	38 a0 00 01 	li      r5,1
fff8158c:	38 c0 00 00 	li      r6,0
fff81590:	38 e0 00 00 	li      r7,0
fff81594:	39 00 00 00 	li      r8,0
fff81598:	48 00 1a cd 	bl      fff83064 <pk_trace_big>
                                 "Deconfigured TPM and updated scratch 11", rc);
        }

        //Write extendSecurityStatePCR6 into measurement register x10010
        securityStatePCR6.update(g_sbeRole);
fff8159c:	80 8d 13 6c 	lwz     r4,4972(r13)
fff815a0:	38 61 00 88 	addi    r3,r1,136
fff815a4:	48 00 12 1d 	bl      fff827c0 <_ZN18securityState_PCR66updateEm>
        data = 0;
fff815a8:	3b c0 00 00 	li      r30,0
        memcpy(&data, (uint8_t *)&securityStatePCR6, sizeof(securityState_PCR6_t));
fff815ac:	38 81 00 88 	addi    r4,r1,136
                                 "Deconfigured TPM and updated scratch 11", rc);
        }

        //Write extendSecurityStatePCR6 into measurement register x10010
        securityStatePCR6.update(g_sbeRole);
        data = 0;
fff815b0:	3b e0 00 00 	li      r31,0
        memcpy(&data, (uint8_t *)&securityStatePCR6, sizeof(securityState_PCR6_t));
fff815b4:	38 a0 00 08 	li      r5,8
fff815b8:	38 61 00 a0 	addi    r3,r1,160
                                 "Deconfigured TPM and updated scratch 11", rc);
        }

        //Write extendSecurityStatePCR6 into measurement register x10010
        securityStatePCR6.update(g_sbeRole);
        data = 0;
fff815bc:	1b c1 00 a0 	stvd    d30,160(r1)
        memcpy(&data, (uint8_t *)&securityStatePCR6, sizeof(securityState_PCR6_t));
fff815c0:	48 00 15 39 	bl      fff82af8 <memcpy>
        SBEM_INFO("Writing extendSecurityStatePCR6 details [0x%08X 0x%08X] into Register [0x%08X]",
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG0);
fff815c4:	14 a1 00 a0 	lvd     d5,160(r1)
fff815c8:	3c 60 24 28 	lis     r3,9256
fff815cc:	3c e0 00 01 	lis     r7,1
fff815d0:	60 e7 00 10 	ori     r7,r7,16
fff815d4:	39 00 00 00 	li      r8,0
fff815d8:	60 63 00 03 	ori     r3,r3,3
fff815dc:	48 00 1a 89 	bl      fff83064 <pk_trace_big>
        putscom_abs(OTPROM_MEASUREMENT_REG0, data);
fff815e0:	14 a1 00 a0 	lvd     d5,160(r1)
fff815e4:	3c 60 00 01 	lis     r3,1
fff815e8:	60 63 00 10 	ori     r3,r3,16
fff815ec:	48 00 14 15 	bl      fff82a00 <putscom_abs>

        //Write extendSecurityStatePCR1 into measurement register x10012
        securityStatePCR1.update(g_sbeRole);
fff815f0:	80 8d 13 6c 	lwz     r4,4972(r13)
fff815f4:	38 61 00 90 	addi    r3,r1,144
fff815f8:	48 00 12 45 	bl      fff8283c <_ZN18securityState_PCR16updateEm>
        data = 0;
        memcpy(&data, (uint8_t *)&securityStatePCR1, sizeof(securityState_PCR1_t));
fff815fc:	38 81 00 90 	addi    r4,r1,144
fff81600:	38 a0 00 08 	li      r5,8
fff81604:	38 61 00 a0 	addi    r3,r1,160
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG0);
        putscom_abs(OTPROM_MEASUREMENT_REG0, data);

        //Write extendSecurityStatePCR1 into measurement register x10012
        securityStatePCR1.update(g_sbeRole);
        data = 0;
fff81608:	1b c1 00 a0 	stvd    d30,160(r1)
        memcpy(&data, (uint8_t *)&securityStatePCR1, sizeof(securityState_PCR1_t));
fff8160c:	48 00 14 ed 	bl      fff82af8 <memcpy>
        SBEM_INFO("Writing extendSecurityStatePCR1 details [0x%08X 0x%08X] into Register [0x%08X]",
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG2);
fff81610:	14 a1 00 a0 	lvd     d5,160(r1)
fff81614:	3c 60 c5 11 	lis     r3,-15087
fff81618:	3c e0 00 01 	lis     r7,1
fff8161c:	60 e7 00 12 	ori     r7,r7,18
fff81620:	39 00 00 00 	li      r8,0
fff81624:	60 63 00 03 	ori     r3,r3,3
fff81628:	48 00 1a 3d 	bl      fff83064 <pk_trace_big>
        putscom_abs(OTPROM_MEASUREMENT_REG2, data);
fff8162c:	14 a1 00 a0 	lvd     d5,160(r1)
fff81630:	3c 60 00 01 	lis     r3,1
fff81634:	60 63 00 12 	ori     r3,r3,18

        //Measure/Calculate SHA512 of .sb_verification XIP Section
        memset(sha512truncatedVerification, 0x00, sizeof(SHA512truncated_t));
fff81638:	3b c1 00 48 	addi    r30,r1,72
        securityStatePCR1.update(g_sbeRole);
        data = 0;
        memcpy(&data, (uint8_t *)&securityStatePCR1, sizeof(securityState_PCR1_t));
        SBEM_INFO("Writing extendSecurityStatePCR1 details [0x%08X 0x%08X] into Register [0x%08X]",
                SBE::higher32BWord(data),SBE::lower32BWord(data), OTPROM_MEASUREMENT_REG2);
        putscom_abs(OTPROM_MEASUREMENT_REG2, data);
fff8163c:	48 00 13 c5 	bl      fff82a00 <putscom_abs>

        //Measure/Calculate SHA512 of .sb_verification XIP Section
        memset(sha512truncatedVerification, 0x00, sizeof(SHA512truncated_t));
fff81640:	7f c3 f3 78 	mr      r3,r30
fff81644:	38 80 00 00 	li      r4,0
fff81648:	38 a0 00 20 	li      r5,32
fff8164c:	48 00 13 d9 	bl      fff82a24 <memset>
        if(getXipSize(P9_XIP_SECTION_SBE_SB_VERIFICATION) != 0x00)
fff81650:	38 60 00 16 	li      r3,22
fff81654:	48 00 43 25 	bl      fff85978 <_Z10getXipSize20p9_xip_section_sbe_t>
fff81658:	06 c3 00 34 	bwz     r3,fff816c0 <_Z17sbemthreadroutinePv+0x1cc>
        {
            SBEM_INFO("Measure/Calculate SHA512 of .sb_verification XIP Section");
fff8165c:	3c 60 e6 01 	lis     r3,-6655
fff81660:	4b ff eb 19 	bl      fff80178 <pk_trace_tiny>
            SHA512_XIP_section(P9_XIP_SECTION_SBE_SB_VERIFICATION, &sha512Verification);
fff81664:	38 60 00 16 	li      r3,22
fff81668:	38 81 00 08 	addi    r4,r1,8
fff8166c:	48 00 31 ad 	bl      fff84818 <_Z18SHA512_XIP_section20p9_xip_section_sbe_tPA64_h>

            // Update the Code Flow status in messaging register 50009
            scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_SHA512_COMPLETE)<<32;
            PPE_STVD(0x50009, scratchMsgReg);
fff81670:	3d 40 00 05 	lis     r10,5
fff81674:	39 00 00 09 	li      r8,9
fff81678:	39 20 00 00 	li      r9,0
fff8167c:	61 4a 00 09 	ori     r10,r10,9
fff81680:	19 0a 00 00 	stvd    d8,0(r10)
fff81684:	3b e1 00 08 	addi    r31,r1,8

            for (uint8_t i=0; i<sizeof(sha512Verification); i=i+4)
            {
                SBEM_INFO("SHA512 of .sb_verification XIP Section is %x %x %x %x",
                        sha512Verification[i],sha512Verification[i+1],sha512Verification[i+2],sha512Verification[i+3]);
fff81688:	88 bf 00 00 	lbz     r5,0(r31)
fff8168c:	88 df 00 01 	lbz     r6,1(r31)
fff81690:	88 ff 00 02 	lbz     r7,2(r31)
fff81694:	89 1f 00 03 	lbz     r8,3(r31)
fff81698:	3c 60 d1 84 	lis     r3,-11900
fff8169c:	60 63 00 04 	ori     r3,r3,4
fff816a0:	3b ff 00 04 	addi    r31,r31,4
fff816a4:	48 00 19 c1 	bl      fff83064 <pk_trace_big>

            // Update the Code Flow status in messaging register 50009
            scratchMsgReg = (uint64_t)(SBE_CODE_MEASURMENT_SHA512_COMPLETE)<<32;
            PPE_STVD(0x50009, scratchMsgReg);

            for (uint8_t i=0; i<sizeof(sha512Verification); i=i+4)
fff816a8:	04 5e ff f0 	cmpwbne r30,r31,fff81688 <_Z17sbemthreadroutinePv+0x194>
            {
                SBEM_INFO("SHA512 of .sb_verification XIP Section is %x %x %x %x",
                        sha512Verification[i],sha512Verification[i+1],sha512Verification[i+2],sha512Verification[i+3]);
            }
            memcpy(sha512truncatedVerification, sha512Verification, sizeof(SHA512truncated_t));
fff816ac:	7f c3 f3 78 	mr      r3,r30
fff816b0:	38 81 00 08 	addi    r4,r1,8
fff816b4:	38 a0 00 20 	li      r5,32
fff816b8:	48 00 14 41 	bl      fff82af8 <memcpy>
fff816bc:	48 00 00 14 	b       fff816d0 <_Z17sbemthreadroutinePv+0x1dc>
        }
        else
        {
            SBEM_ERROR(SBEM_FUNC ".sb_verification XIP section not found. Verification code not found.");
fff816c0:	3c 60 6d 78 	lis     r3,28024
fff816c4:	4b ff ea b5 	bl      fff80178 <pk_trace_tiny>
            SBEM_ERROR(SBEM_FUNC "SHA512 not calculated for .sb_verification XIP section.");
fff816c8:	3c 60 62 22 	lis     r3,25122
fff816cc:	4b ff ea ad 	bl      fff80178 <pk_trace_tiny>

extern uint32_t g_sbeRole;

static void writeTruncatedVerificationImageHash(SHA512truncated_t &i_shaResult)
{
    uint64_t hashData = 0;
fff816d0:	3b 80 00 00 	li      r28,0
fff816d4:	3b a0 00 00 	li      r29,0
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 0], sizeof(uint64_t));
fff816d8:	7f c4 f3 78 	mr      r4,r30
fff816dc:	38 a0 00 08 	li      r5,8
fff816e0:	38 61 00 68 	addi    r3,r1,104

extern uint32_t g_sbeRole;

static void writeTruncatedVerificationImageHash(SHA512truncated_t &i_shaResult)
{
    uint64_t hashData = 0;
fff816e4:	1b 81 00 68 	stvd    d28,104(r1)
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 0], sizeof(uint64_t));
fff816e8:	48 00 14 11 	bl      fff82af8 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG4), hashData);
fff816ec:	14 a1 00 68 	lvd     d5,104(r1)
fff816f0:	3c 60 00 01 	lis     r3,1
fff816f4:	60 63 00 14 	ori     r3,r3,20
fff816f8:	48 00 13 09 	bl      fff82a00 <putscom_abs>
    hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 1], sizeof(uint64_t));
fff816fc:	38 81 00 50 	addi    r4,r1,80
fff81700:	38 a0 00 08 	li      r5,8
fff81704:	38 61 00 68 	addi    r3,r1,104
static void writeTruncatedVerificationImageHash(SHA512truncated_t &i_shaResult)
{
    uint64_t hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG4), hashData);
    hashData = 0;
fff81708:	1b 81 00 68 	stvd    d28,104(r1)
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 1], sizeof(uint64_t));
fff8170c:	48 00 13 ed 	bl      fff82af8 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG5), hashData);
fff81710:	14 a1 00 68 	lvd     d5,104(r1)
fff81714:	3c 60 00 01 	lis     r3,1
fff81718:	60 63 00 15 	ori     r3,r3,21
fff8171c:	48 00 12 e5 	bl      fff82a00 <putscom_abs>
    hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 2], sizeof(uint64_t));
fff81720:	38 81 00 58 	addi    r4,r1,88
fff81724:	38 a0 00 08 	li      r5,8
fff81728:	38 61 00 68 	addi    r3,r1,104
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 0], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG4), hashData);
    hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG5), hashData);
    hashData = 0;
fff8172c:	1b 81 00 68 	stvd    d28,104(r1)
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 2], sizeof(uint64_t));
fff81730:	48 00 13 c9 	bl      fff82af8 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG6), hashData);
fff81734:	14 a1 00 68 	lvd     d5,104(r1)
fff81738:	3c 60 00 01 	lis     r3,1
fff8173c:	60 63 00 16 	ori     r3,r3,22
fff81740:	48 00 12 c1 	bl      fff82a00 <putscom_abs>
    hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 3], sizeof(uint64_t));
fff81744:	38 81 00 60 	addi    r4,r1,96
fff81748:	38 a0 00 08 	li      r5,8
fff8174c:	38 61 00 68 	addi    r3,r1,104
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 1], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG5), hashData);
    hashData = 0;
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 2], sizeof(uint64_t));
    putscom_abs((OTPROM_MEASUREMENT_REG6), hashData);
    hashData = 0;
fff81750:	1b 81 00 68 	stvd    d28,104(r1)
    memcpy(&hashData, &i_shaResult[sizeof(uint64_t) * 3], sizeof(uint64_t));
fff81754:	48 00 13 a5 	bl      fff82af8 <memcpy>
    putscom_abs((OTPROM_MEASUREMENT_REG7), hashData);
fff81758:	14 a1 00 68 	lvd     d5,104(r1)
fff8175c:	3c 60 00 01 	lis     r3,1
fff81760:	60 63 00 17 	ori     r3,r3,23
fff81764:	48 00 12 9d 	bl      fff82a00 <putscom_abs>
            SBEM_ERROR(SBEM_FUNC "SHA512 not calculated for .sb_verification XIP section.");
        }
        writeTruncatedVerificationImageHash(sha512truncatedVerification);

        // Grab HW key hash from sb_settings
        memset(sha512truncated, 0x00, sizeof(SHA512truncated_t));
fff81768:	38 61 00 68 	addi    r3,r1,104
fff8176c:	38 80 00 00 	li      r4,0
fff81770:	38 a0 00 20 	li      r5,32
fff81774:	48 00 12 b1 	bl      fff82a24 <memset>
        if(getXipSize(P9_XIP_SECTION_SBE_SB_SETTINGS) != 0x00)
fff81778:	38 60 00 15 	li      r3,21
fff8177c:	48 00 41 fd 	bl      fff85978 <_Z10getXipSize20p9_xip_section_sbe_t>
fff81780:	06 c3 00 10 	bwz     r3,fff817a0 <_Z17sbemthreadroutinePv+0x2ac>
        {
            memcpy(sha512truncated, (uint8_t *)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS)), sizeof(SHA512truncated_t));
fff81784:	38 60 00 15 	li      r3,21
fff81788:	48 00 41 dd 	bl      fff85964 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fff8178c:	7c 64 1b 78 	mr      r4,r3
fff81790:	38 a0 00 20 	li      r5,32
fff81794:	38 61 00 68 	addi    r3,r1,104
fff81798:	48 00 13 61 	bl      fff82af8 <memcpy>
fff8179c:	48 00 00 0c 	b       fff817a8 <_Z17sbemthreadroutinePv+0x2b4>
        }
        else
        {
            SBEM_ERROR(SBEM_FUNC ".sb_settings XIP section not found. HW key hash not found. Extending 0x00 into TPM_PCR6 and TPM_PCR1");
fff817a0:	3c 60 c9 b7 	lis     r3,-13897
fff817a4:	4b ff e9 d5 	bl      fff80178 <pk_trace_tiny>
        }

        // Write the first 8 bytes of the HW key hash into measurement reg 1
        data = 0;
fff817a8:	39 20 00 00 	li      r9,0
fff817ac:	39 00 00 00 	li      r8,0
        memcpy(&data, sha512truncated, sizeof(uint64_t));
fff817b0:	38 81 00 68 	addi    r4,r1,104
fff817b4:	38 a0 00 08 	li      r5,8
fff817b8:	38 61 00 a0 	addi    r3,r1,160
        {
            SBEM_ERROR(SBEM_FUNC ".sb_settings XIP section not found. HW key hash not found. Extending 0x00 into TPM_PCR6 and TPM_PCR1");
        }

        // Write the first 8 bytes of the HW key hash into measurement reg 1
        data = 0;
fff817bc:	19 01 00 a0 	stvd    d8,160(r1)
        memcpy(&data, sha512truncated, sizeof(uint64_t));
fff817c0:	48 00 13 39 	bl      fff82af8 <memcpy>
        putscom_abs(OTPROM_MEASUREMENT_REG1, data);
fff817c4:	14 a1 00 a0 	lvd     d5,160(r1)
fff817c8:	3c 60 00 01 	lis     r3,1
fff817cc:	60 63 00 11 	ori     r3,r3,17
fff817d0:	48 00 12 31 	bl      fff82a00 <putscom_abs>

        // Read the Security Switch Register for the TPM Deconfig Bit incase TPM is already
        // deconfigured at this point
        getscom_abs(0x10005, &securityReg());
fff817d4:	3c 60 00 01 	lis     r3,1
fff817d8:	60 63 00 05 	ori     r3,r3,5
fff817dc:	38 81 00 98 	addi    r4,r1,152
fff817e0:	48 00 12 31 	bl      fff82a10 <getscom_abs>

        //Skip if error/rc/deconfig bit set in TPM sequence.
        if((g_sbeRole == SBE_ROLE_MASTER) && (!(securityReg.getBit<TPM_DECONFIG_BIT>())) )
fff817e4:	81 2d 13 6c 	lwz     r9,4972(r13)
fff817e8:	06 c9 00 06 	bwz     r9,fff817f4 <_Z17sbemthreadroutinePv+0x300>
    SHA512_t sha512Verification;
    SHA512truncated_t sha512truncated;
    SHA512truncated_t sha512truncatedVerification;
    securityState_PCR6_t securityStatePCR6;
    securityState_PCR1_t securityStatePCR1;
    uint32_t tpmRespCode = SBEM_TPM_OPERATION_SUCCESSFUL;
fff817ec:	3b e0 00 00 	li      r31,0
fff817f0:	48 00 00 34 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>
        // Read the Security Switch Register for the TPM Deconfig Bit incase TPM is already
        // deconfigured at this point
        getscom_abs(0x10005, &securityReg());

        //Skip if error/rc/deconfig bit set in TPM sequence.
        if((g_sbeRole == SBE_ROLE_MASTER) && (!(securityReg.getBit<TPM_DECONFIG_BIT>())) )
fff817f4:	81 21 00 98 	lwz     r9,152(r1)
fff817f8:	07 09 67 fa 	bb1wi   r9,12,fff817ec <_Z17sbemthreadroutinePv+0x2f8>
        {
            //Extend HW key hash to PCR6 and PCR1 if SBE role is master.
            SBEM_INFO("Extending HW key hash into TPM_PCR6");
fff817fc:	3c 60 f4 d1 	lis     r3,-2863
fff81800:	4b ff e9 79 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR6, sha512truncated, sizeof(SHA512truncated_t));
fff81804:	38 60 00 06 	li      r3,6
fff81808:	38 81 00 68 	addi    r4,r1,104
fff8180c:	38 a0 00 20 	li      r5,32
fff81810:	48 00 3c c1 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff81814:	06 c3 00 7e 	bwz     r3,fff81910 <_Z17sbemthreadroutinePv+0x41c>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending HW key hash into PCR6");
fff81818:	3c 60 f0 f9 	lis     r3,-3847
fff8181c:	4b ff e9 5d 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_HW_KEY_HASH_PCR6_FAILURE;
fff81820:	3b e0 00 07 	li      r31,7
                break;
            }
        }
    }while(false);

    if((g_sbeRole == SBE_ROLE_MASTER) && (tpmRespCode != SBEM_TPM_OPERATION_SUCCESSFUL))
fff81824:	81 2d 13 6c 	lwz     r9,4972(r13)
fff81828:	06 49 00 32 	bwnz    r9,fff8188c <_Z17sbemthreadroutinePv+0x398>
fff8182c:	06 df 00 30 	bwz     r31,fff8188c <_Z17sbemthreadroutinePv+0x398>
    {
        SBEM_INFO(SBEM_FUNC "Setting the TPM deconfig bit");
fff81830:	3c 60 b9 ec 	lis     r3,-17940
fff81834:	4b ff e9 45 	bl      fff80178 <pk_trace_tiny>
        rc = setTPMDeconfigBit();
fff81838:	48 00 40 b9 	bl      fff858f0 <_Z17setTPMDeconfigBitv>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff8183c:	06 c3 00 10 	bwz     r3,fff8185c <_Z17sbemthreadroutinePv+0x368>
        {
            SBEM_ERROR(SBEM_FUNC "Failed to set the deconfig bit with rc 0x%08X", rc);
fff81840:	3c 60 37 6b 	lis     r3,14187
fff81844:	60 63 00 01 	ori     r3,r3,1
fff81848:	38 a0 00 01 	li      r5,1
fff8184c:	38 c0 00 00 	li      r6,0
fff81850:	38 e0 00 00 	li      r7,0
fff81854:	39 00 00 00 	li      r8,0
fff81858:	48 00 18 0d 	bl      fff83064 <pk_trace_big>
        }
        SBEM_INFO(SBEM_FUNC "Setting the TPM response code into Scratch Reg 11");
fff8185c:	3c 60 10 6c 	lis     r3,4204
fff81860:	4b ff e9 19 	bl      fff80178 <pk_trace_tiny>
        rc = setTPMFailureRespCode(tpmRespCode);
fff81864:	7f e3 fb 78 	mr      r3,r31
fff81868:	48 00 08 d1 	bl      fff82138 <_Z21setTPMFailureRespCodem>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff8186c:	06 c3 00 10 	bwz     r3,fff8188c <_Z17sbemthreadroutinePv+0x398>
        {
            SBEM_ERROR(SBEM_FUNC "Failed to set the scratch reg with the response code, rc 0x%08X", rc);
fff81870:	3c 60 08 89 	lis     r3,2185
fff81874:	60 63 00 01 	ori     r3,r3,1
fff81878:	38 a0 00 01 	li      r5,1
fff8187c:	38 c0 00 00 	li      r6,0
fff81880:	38 e0 00 00 	li      r7,0
fff81884:	39 00 00 00 	li      r8,0
fff81888:	48 00 17 dd 	bl      fff83064 <pk_trace_big>
    }

    // Load .sb_verification section into PIBMEM.
    P9XipHeader *hdr = getXipHdr();
    P9XipSection* pSection = &hdr->iv_section[P9_XIP_SECTION_SBE_SB_VERIFICATION];
    uint32_t dsize = pSection->iv_size;
fff8188c:	3f e0 ff 80 	lis     r31,-128
    if(dsize)
fff81890:	81 3f 01 4c 	lwz     r9,332(r31)
fff81894:	06 c9 00 38 	bwz     r9,fff81904 <_Z17sbemthreadroutinePv+0x410>
    {
        SBEM_INFO(SBEM_FUNC "Verification Image found in the Boot Seeprom Image");
fff81898:	3c 60 90 ff 	lis     r3,-28417
fff8189c:	4b ff e8 dd 	bl      fff80178 <pk_trace_tiny>
        uint32_t verificationOffset = pSection->iv_offset;;
        uint32_t verificationAddress = (g_headerAddr + verificationOffset);
fff818a0:	83 ff 01 48 	lwz     r31,328(r31)
        P9XipHeader *vhdr = (P9XipHeader *)(verificationAddress);

        P9XipSection* pVBase = &vhdr->iv_section[P9_XIP_SECTION_SBE_BASE];
        uint64_t *srcAddr = (uint64_t *)(pVBase->iv_offset + (uint32_t)vhdr);
        SBEM_INFO("Verification Image Source addr in Boot Seeprom is [0x%08X]", srcAddr);
fff818a4:	3c 60 9d 8e 	lis     r3,-25202
    uint32_t dsize = pSection->iv_size;
    if(dsize)
    {
        SBEM_INFO(SBEM_FUNC "Verification Image found in the Boot Seeprom Image");
        uint32_t verificationOffset = pSection->iv_offset;;
        uint32_t verificationAddress = (g_headerAddr + verificationOffset);
fff818a8:	3f ff ff 80 	addis   r31,r31,-128
        P9XipHeader *vhdr = (P9XipHeader *)(verificationAddress);

        P9XipSection* pVBase = &vhdr->iv_section[P9_XIP_SECTION_SBE_BASE];
        uint64_t *srcAddr = (uint64_t *)(pVBase->iv_offset + (uint32_t)vhdr);
fff818ac:	83 df 00 ac 	lwz     r30,172(r31)
        SBEM_INFO("Verification Image Source addr in Boot Seeprom is [0x%08X]", srcAddr);
fff818b0:	38 c0 00 00 	li      r6,0
        uint32_t verificationOffset = pSection->iv_offset;;
        uint32_t verificationAddress = (g_headerAddr + verificationOffset);
        P9XipHeader *vhdr = (P9XipHeader *)(verificationAddress);

        P9XipSection* pVBase = &vhdr->iv_section[P9_XIP_SECTION_SBE_BASE];
        uint64_t *srcAddr = (uint64_t *)(pVBase->iv_offset + (uint32_t)vhdr);
fff818b4:	7f df f2 14 	add     r30,r31,r30
        SBEM_INFO("Verification Image Source addr in Boot Seeprom is [0x%08X]", srcAddr);
fff818b8:	7f c5 f3 78 	mr      r5,r30
fff818bc:	38 e0 00 00 	li      r7,0
fff818c0:	39 00 00 00 	li      r8,0
fff818c4:	60 63 00 01 	ori     r3,r3,1
fff818c8:	48 00 17 9d 	bl      fff83064 <pk_trace_big>
        loadSectionForVerification(srcAddr, (uint64_t *)(vhdr->iv_L1LoaderAddr));
fff818cc:	80 9f 00 0c 	lwz     r4,12(r31)
fff818d0:	7f c3 f3 78 	mr      r3,r30
fff818d4:	48 00 0d 99 	bl      fff8266c <_Z26loadSectionForVerificationPyS_>
        SBEM_INFO("Completed Loading of .sb_verification into PIBMEM, Jump to Verification Image");
fff818d8:	3c 60 bc 7f 	lis     r3,-17281
fff818dc:	4b ff e8 9d 	bl      fff80178 <pk_trace_tiny>
        jump2verificationImage((uint32_t )vhdr->iv_kernelAddr, (uint32_t)vhdr->iv_L1LoaderAddr);
fff818e0:	80 7f 00 1c 	lwz     r3,28(r31)
fff818e4:	80 9f 00 0c 	lwz     r4,12(r31)
fff818e8:	48 00 0d 31 	bl      fff82618 <jump2verificationImage>
        pk_halt();
    }

    SBEM_EXIT(SBEM_FUNC);
    #undef SBEM_FUNC
}
fff818ec:	80 01 00 bc 	lwz     r0,188(r1)
fff818f0:	17 81 00 a8 	lvd     d28,168(r1)
fff818f4:	7c 08 03 a6 	mtlr    r0
fff818f8:	17 c1 00 b0 	lvd     d30,176(r1)
fff818fc:	38 21 00 b8 	addi    r1,r1,184
fff81900:	4e 80 00 20 	blr
        SBEM_INFO("Completed Loading of .sb_verification into PIBMEM, Jump to Verification Image");
        jump2verificationImage((uint32_t )vhdr->iv_kernelAddr, (uint32_t)vhdr->iv_L1LoaderAddr);
    }
    else
    {
        SBEM_ERROR("No verification image, Halting PPE, crorecoversbe boot seeprom again using Secure Jumper");
fff81904:	3c 60 7e 6a 	lis     r3,32362
fff81908:	4b ff e8 71 	bl      fff80178 <pk_trace_tiny>
        // If this happens in lab, we have to put jumper to recover the image, the security will
        // be enabled by default here.
        pk_halt();
fff8190c:	4b ff e9 59 	bl      fff80264 <pk_halt>
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending HW key hash into PCR6");
                tpmRespCode = SBEM_TPM_EXTEND_HW_KEY_HASH_PCR6_FAILURE;
                break;
            }

            SBEM_INFO("Extending HW key hash into TPM_PCR1");
fff81910:	3c 60 da 0c 	lis     r3,-9716
fff81914:	4b ff e8 65 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR1, sha512truncated, sizeof(SHA512truncated_t));
fff81918:	38 60 00 01 	li      r3,1
fff8191c:	38 81 00 68 	addi    r4,r1,104
fff81920:	38 a0 00 20 	li      r5,32
fff81924:	48 00 3b ad 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff81928:	06 c3 00 0a 	bwz     r3,fff8193c <_Z17sbemthreadroutinePv+0x448>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending HW key hash into PCR1");
fff8192c:	3c 60 c9 7b 	lis     r3,-13957
fff81930:	4b ff e8 49 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_HW_KEY_HASH_PCR1_FAILURE;
fff81934:	3b e0 00 08 	li      r31,8
                break;
fff81938:	4b ff fe ec 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>
            }

            //Extend Security state to PCR6.i.e Jumper State and MSV.
            memset(sha512truncated, 0x00, sizeof(SHA512truncated_t));
fff8193c:	38 80 00 00 	li      r4,0
fff81940:	38 a0 00 20 	li      r5,32
fff81944:	38 61 00 68 	addi    r3,r1,104
fff81948:	48 00 10 dd 	bl      fff82a24 <memset>
            memcpy(sha512truncated, &securityStatePCR6, sizeof(securityStatePCR6));
fff8194c:	38 81 00 88 	addi    r4,r1,136
fff81950:	38 a0 00 08 	li      r5,8
fff81954:	38 61 00 68 	addi    r3,r1,104
fff81958:	48 00 11 a1 	bl      fff82af8 <memcpy>
            SBEM_INFO("Extending extendSecurityStatePCR6 details into TPM_PCR6");
fff8195c:	3c 60 37 f7 	lis     r3,14327
fff81960:	4b ff e8 19 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR6, sha512truncated, sizeof(SHA512truncated_t));
fff81964:	38 60 00 06 	li      r3,6
fff81968:	38 81 00 68 	addi    r4,r1,104
fff8196c:	38 a0 00 20 	li      r5,32
fff81970:	48 00 3b 61 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff81974:	06 c3 00 0a 	bwz     r3,fff81988 <_Z17sbemthreadroutinePv+0x494>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending SecurityState into PCR6");
fff81978:	3c 60 08 b7 	lis     r3,2231
fff8197c:	4b ff e7 fd 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_SECURITY_STATE_PCR6_FAILURE;
fff81980:	3b e0 00 09 	li      r31,9
                break;
fff81984:	4b ff fe a0 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>
            }

            //Extend Security state to PCR1.
            memset(sha512truncated, 0x00, sizeof(SHA512truncated_t));
fff81988:	38 80 00 00 	li      r4,0
fff8198c:	38 a0 00 20 	li      r5,32
fff81990:	38 61 00 68 	addi    r3,r1,104
fff81994:	48 00 10 91 	bl      fff82a24 <memset>
            memcpy(sha512truncated, &securityStatePCR1, sizeof(securityStatePCR1));
fff81998:	38 81 00 90 	addi    r4,r1,144
fff8199c:	38 a0 00 08 	li      r5,8
fff819a0:	38 61 00 68 	addi    r3,r1,104
fff819a4:	48 00 11 55 	bl      fff82af8 <memcpy>
            SBEM_INFO("Extending extendSecurityStatePCR1 details into TPM_PCR1");
fff819a8:	3c 60 8d 81 	lis     r3,-29311
fff819ac:	4b ff e7 cd 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR1, sha512truncated, sizeof(SHA512truncated_t));
fff819b0:	38 60 00 01 	li      r3,1
fff819b4:	38 81 00 68 	addi    r4,r1,104
fff819b8:	38 a0 00 20 	li      r5,32
fff819bc:	48 00 3b 15 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff819c0:	06 c3 00 0a 	bwz     r3,fff819d4 <_Z17sbemthreadroutinePv+0x4e0>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending extending SecurityState into PCR1");
fff819c4:	3c 60 f3 ba 	lis     r3,-3142
fff819c8:	4b ff e7 b1 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_SECURITY_STATE_PCR1_FAILURE;
fff819cc:	3b e0 00 0a 	li      r31,10
                break;
fff819d0:	4b ff fe 54 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>
            }

            //Extend MSB 32 Bytes of result into TPM PCR0 and PCR6 if SBE
            //role is master.
            SBEM_INFO("Extending .sb_verification XIP Section hash into TPM_PCR0");
fff819d4:	3c 60 36 37 	lis     r3,13879
fff819d8:	4b ff e7 a1 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR0, sha512truncatedVerification, sizeof(SHA512truncated_t));
fff819dc:	38 60 00 00 	li      r3,0
fff819e0:	7f c4 f3 78 	mr      r4,r30
fff819e4:	38 a0 00 20 	li      r5,32
fff819e8:	48 00 3a e9 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff819ec:	06 c3 00 0a 	bwz     r3,fff81a00 <_Z17sbemthreadroutinePv+0x50c>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending extending Verification image has key into PCR0");
fff819f0:	3c 60 a9 00 	lis     r3,-22272
fff819f4:	4b ff e7 85 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_VERIFICATION_IMAGE_HASH_PCR0_FAILURE;
fff819f8:	3b e0 00 0b 	li      r31,11
                break;
fff819fc:	4b ff fe 28 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>
            }
            SBEM_INFO("Extending .sb_verification XIP Section hash into TPM_PCR6");
fff81a00:	3c 60 9d 0d 	lis     r3,-25331
fff81a04:	4b ff e7 75 	bl      fff80178 <pk_trace_tiny>
            rc = tpmExtendPCR(TPM_PCR6, sha512truncatedVerification, sizeof(SHA512truncated_t));
fff81a08:	38 60 00 06 	li      r3,6
fff81a0c:	7f c4 f3 78 	mr      r4,r30
fff81a10:	38 a0 00 20 	li      r5,32
fff81a14:	48 00 3a bd 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
            if(rc)
fff81a18:	06 c3 06 ea 	bwz     r3,fff817ec <_Z17sbemthreadroutinePv+0x2f8>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed while extending extending Verification image hash key into PCR6");
fff81a1c:	3c 60 64 9a 	lis     r3,25754
fff81a20:	4b ff e7 59 	bl      fff80178 <pk_trace_tiny>
                tpmRespCode = SBEM_TPM_EXTEND_VERIFICATION_IMAGE_HASH_PCR6_FAILURE;
fff81a24:	3b e0 00 0c 	li      r31,12
                break;
fff81a28:	4b ff fd fc 	b       fff81824 <_Z17sbemthreadroutinePv+0x330>

fff81a2c <_Z29tpmSequenceToReadDIDAndVendorv>:
#include "sbemTPMSequences.H"

using namespace fapi2;

fapi2::ReturnCode tpmSequenceToReadDIDAndVendor()
{
fff81a2c:	94 21 ff c8 	stwu    r1,-56(r1)
fff81a30:	7c 08 02 a6 	mflr    r0
fff81a34:	1b 81 00 28 	stvd    d28,40(r1)
fff81a38:	90 01 00 3c 	stw     r0,60(r1)
fff81a3c:	1b c1 00 30 	stvd    d30,48(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff81a40:	48 00 4a 7d 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
                engine(i_engine),
                slave(i_slave),
                base_addr(i_pib_access ?
                          SPIM_BASEADDRESS_PIB + this->engine * SPIM_ENGINEOFFSET :
                          SPIM_BASEADDRESS_FSI + this->engine * SPIM_ENGINEOFFSET ),
                pibAccess(i_pib_access)
fff81a44:	39 20 00 04 	li      r9,4
fff81a48:	3d 40 00 0c 	lis     r10,12
fff81a4c:	61 4a 00 80 	ori     r10,r10,128
fff81a50:	90 61 00 08 	stw     r3,8(r1)
fff81a54:	99 21 00 0c 	stb     r9,12(r1)
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = 0x0F00;  // Relative address to read from TPM.
        uint8_t  rbuf[8];
        uint32_t readBytes = 2;

        SBEM_INFO(SBE_FUNC " Read TPM_DID_VID_0 (Vendor and device ID offset xF00)");
fff81a58:	3c 60 1f 42 	lis     r3,8002
fff81a5c:	39 20 00 01 	li      r9,1
fff81a60:	b1 21 00 0e 	sth     r9,14(r1)
fff81a64:	91 41 00 10 	stw     r10,16(r1)
fff81a68:	99 21 00 14 	stb     r9,20(r1)
fff81a6c:	4b ff e7 0d 	bl      fff80178 <pk_trace_tiny>
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&rbuf);
fff81a70:	38 61 00 08 	addi    r3,r1,8
fff81a74:	38 80 00 00 	li      r4,0
fff81a78:	38 a0 0f 00 	li      r5,3840
fff81a7c:	38 c0 00 02 	li      r6,2
fff81a80:	38 e1 00 18 	addi    r7,r1,24
fff81a84:	48 00 26 e9 	bl      fff8416c <spi_tpm_read_secure>
fff81a88:	7c 7d 1b 78 	mr      r29,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff81a8c:	06 43 00 10 	bwnz    r3,fff81aac <_Z29tpmSequenceToReadDIDAndVendorv+0x80>
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < readBytes; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", rbuf[i]);
fff81a90:	88 61 00 18 	lbz     r3,24(r1)
fff81a94:	64 63 00 0b 	oris    r3,r3,11
fff81a98:	4b ff e6 e1 	bl      fff80178 <pk_trace_tiny>
fff81a9c:	88 61 00 19 	lbz     r3,25(r1)
fff81aa0:	64 63 00 0b 	oris    r3,r3,11
fff81aa4:	4b ff e6 d5 	bl      fff80178 <pk_trace_tiny>
fff81aa8:	48 00 00 34 	b       fff81adc <_Z29tpmSequenceToReadDIDAndVendorv+0xb0>

        SBEM_INFO(SBE_FUNC " Read TPM_DID_VID_0 (Vendor and device ID offset xF00)");
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&rbuf);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed with rc 08%08X", rc);
fff81aac:	7c 7e 1b 78 	mr      r30,r3
fff81ab0:	3b e0 00 00 	li      r31,0
fff81ab4:	3c 60 36 07 	lis     r3,13831
fff81ab8:	60 63 00 01 	ori     r3,r3,1
fff81abc:	7f a5 eb 78 	mr      r5,r29
fff81ac0:	7f e6 fb 78 	mr      r6,r31
fff81ac4:	38 e0 00 00 	li      r7,0
fff81ac8:	39 00 00 00 	li      r8,0
fff81acc:	48 00 15 99 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff81ad0:	3d 20 00 05 	lis     r9,5
fff81ad4:	61 29 01 85 	ori     r9,r9,389
fff81ad8:	1b c9 00 00 	stvd    d30,0(r9)
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff81adc:	80 01 00 3c 	lwz     r0,60(r1)
fff81ae0:	7f a3 eb 78 	mr      r3,r29
fff81ae4:	7c 08 03 a6 	mtlr    r0
fff81ae8:	17 81 00 28 	lvd     d28,40(r1)
fff81aec:	17 c1 00 30 	lvd     d30,48(r1)
fff81af0:	38 21 00 38 	addi    r1,r1,56
fff81af4:	4e 80 00 20 	blr

fff81af8 <_Z28tpmSequenceToAccessLocality0v>:

fapi2::ReturnCode tpmSequenceToAccessLocality0()
{
fff81af8:	94 21 ff c8 	stwu    r1,-56(r1)
fff81afc:	7c 08 02 a6 	mflr    r0
fff81b00:	1b 81 00 28 	stvd    d28,40(r1)
fff81b04:	90 01 00 3c 	stw     r0,60(r1)
fff81b08:	1b c1 00 30 	stvd    d30,48(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff81b0c:	48 00 49 b1 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff81b10:	39 20 00 04 	li      r9,4
fff81b14:	99 21 00 0c 	stb     r9,12(r1)
fff81b18:	39 20 00 01 	li      r9,1
fff81b1c:	b1 21 00 0e 	sth     r9,14(r1)
fff81b20:	99 21 00 14 	stb     r9,20(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = 0x0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        uint8_t tpmData = 0x02;
fff81b24:	7c 3f 0b 78 	mr      r31,r1
fff81b28:	39 20 00 02 	li      r9,2
fff81b2c:	9d 3f 00 18 	stbu    r9,24(r31)
fff81b30:	3d 40 00 0c 	lis     r10,12
fff81b34:	61 4a 00 80 	ori     r10,r10,128
fff81b38:	90 61 00 08 	stw     r3,8(r1)
        uint8_t *buf = &tpmData;

        SBEM_INFO(SBE_FUNC "Write 002h to TPM_ACCESS_0 (0000h) to request access to locality 0");
fff81b3c:	3c 60 33 7f 	lis     r3,13183
fff81b40:	91 41 00 10 	stw     r10,16(r1)
fff81b44:	4b ff e6 35 	bl      fff80178 <pk_trace_tiny>
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, readBytes, buf);
fff81b48:	38 61 00 08 	addi    r3,r1,8
fff81b4c:	38 80 00 00 	li      r4,0
fff81b50:	38 a0 00 00 	li      r5,0
fff81b54:	38 c0 00 01 	li      r6,1
fff81b58:	7f e7 fb 78 	mr      r7,r31
fff81b5c:	48 00 29 a5 	bl      fff84500 <spi_tpm_write_with_wait>
fff81b60:	7c 7d 1b 78 	mr      r29,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff81b64:	06 c3 00 1a 	bwz     r3,fff81b98 <_Z28tpmSequenceToAccessLocality0v+0xa0>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed with rc 08%08X", rc);
fff81b68:	7c 7e 1b 78 	mr      r30,r3
fff81b6c:	3b e0 00 00 	li      r31,0
fff81b70:	3c 60 78 bc 	lis     r3,30908
fff81b74:	60 63 00 01 	ori     r3,r3,1
fff81b78:	7f a5 eb 78 	mr      r5,r29
fff81b7c:	7f e6 fb 78 	mr      r6,r31
fff81b80:	38 e0 00 00 	li      r7,0
fff81b84:	39 00 00 00 	li      r8,0
fff81b88:	48 00 14 dd 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff81b8c:	3d 20 00 05 	lis     r9,5
fff81b90:	61 29 01 85 	ori     r9,r9,389
fff81b94:	1b c9 00 00 	stvd    d30,0(r9)
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff81b98:	80 01 00 3c 	lwz     r0,60(r1)
fff81b9c:	7f a3 eb 78 	mr      r3,r29
fff81ba0:	7c 08 03 a6 	mtlr    r0
fff81ba4:	17 81 00 28 	lvd     d28,40(r1)
fff81ba8:	17 c1 00 30 	lvd     d30,48(r1)
fff81bac:	38 21 00 38 	addi    r1,r1,56
fff81bb0:	4e 80 00 20 	blr

fff81bb4 <_Z20tpmSequenceToStartupv>:

fapi2::ReturnCode tpmSequenceToStartup()
{
fff81bb4:	94 21 ff 88 	stwu    r1,-120(r1)
fff81bb8:	7c 08 02 a6 	mflr    r0
fff81bbc:	1b c1 00 70 	stvd    d30,112(r1)
fff81bc0:	90 01 00 7c 	stw     r0,124(r1)
fff81bc4:	1b 81 00 68 	stvd    d28,104(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff81bc8:	48 00 48 f5 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff81bcc:	39 20 00 04 	li      r9,4
fff81bd0:	99 21 00 4c 	stb     r9,76(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);
        uint8_t tpmStartCommand[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00};
fff81bd4:	3b c1 00 08 	addi    r30,r1,8
fff81bd8:	3d 20 00 0c 	lis     r9,12
fff81bdc:	3b e0 00 01 	li      r31,1
fff81be0:	61 29 00 80 	ori     r9,r9,128
fff81be4:	38 80 00 00 	li      r4,0
fff81be8:	38 a0 00 40 	li      r5,64
fff81bec:	90 61 00 48 	stw     r3,72(r1)
fff81bf0:	7f c3 f3 78 	mr      r3,r30
fff81bf4:	b3 e1 00 4e 	sth     r31,78(r1)
fff81bf8:	91 21 00 50 	stw     r9,80(r1)
fff81bfc:	9b e1 00 54 	stb     r31,84(r1)
fff81c00:	48 00 0e 25 	bl      fff82a24 <memset>
fff81c04:	39 20 ff 80 	li      r9,-128
fff81c08:	99 21 00 08 	stb     r9,8(r1)
fff81c0c:	39 20 00 0c 	li      r9,12
fff81c10:	99 21 00 0d 	stb     r9,13(r1)
fff81c14:	39 20 00 44 	li      r9,68
fff81c18:	99 21 00 11 	stb     r9,17(r1)
        uint32_t buflen = 64;
        uint32_t cmdLen = 12;
        SBEM_INFO(SBEM_FUNC "Send the startup command to TPM.");
fff81c1c:	3c 60 8e 15 	lis     r3,-29163
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);
        uint8_t tpmStartCommand[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00};
        uint32_t buflen = 64;
fff81c20:	39 20 00 40 	li      r9,64
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);
        uint8_t tpmStartCommand[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00};
fff81c24:	9b e1 00 09 	stb     r31,9(r1)
fff81c28:	9b e1 00 10 	stb     r31,16(r1)
        uint32_t buflen = 64;
fff81c2c:	91 21 00 58 	stw     r9,88(r1)
        uint32_t cmdLen = 12;
        SBEM_INFO(SBEM_FUNC "Send the startup command to TPM.");
fff81c30:	4b ff e5 49 	bl      fff80178 <pk_trace_tiny>
        rc = tpmTransmit(handle, (void *)tpmStartCommand, buflen, cmdLen);
fff81c34:	38 61 00 48 	addi    r3,r1,72
fff81c38:	7f c4 f3 78 	mr      r4,r30
fff81c3c:	38 a1 00 58 	addi    r5,r1,88
fff81c40:	38 c0 00 0c 	li      r6,12
fff81c44:	48 00 37 29 	bl      fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fff81c48:	7c 7d 1b 78 	mr      r29,r3
fff81c4c:	3b e0 00 00 	li      r31,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff81c50:	06 c3 00 1c 	bwz     r3,fff81c88 <_Z20tpmSequenceToStartupv+0xd4>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fff81c54:	7c 7e 1b 78 	mr      r30,r3
fff81c58:	3b e0 00 00 	li      r31,0
fff81c5c:	3c 60 d3 48 	lis     r3,-11448
fff81c60:	60 63 00 01 	ori     r3,r3,1
fff81c64:	7f a5 eb 78 	mr      r5,r29
fff81c68:	7f e6 fb 78 	mr      r6,r31
fff81c6c:	38 e0 00 00 	li      r7,0
fff81c70:	39 00 00 00 	li      r8,0
fff81c74:	48 00 13 f1 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff81c78:	3d 20 00 05 	lis     r9,5
fff81c7c:	61 29 01 85 	ori     r9,r9,389
fff81c80:	1b c9 00 00 	stvd    d30,0(r9)
            break;
fff81c84:	48 00 00 98 	b       fff81d1c <_Z20tpmSequenceToStartupv+0x168>
        }
        for(uint32_t i = 0; i < buflen; i++)
fff81c88:	81 21 00 58 	lwz     r9,88(r1)
fff81c8c:	05 1f 48 0c 	cmplwbge r31,r9,fff81ca4 <_Z20tpmSequenceToStartupv+0xf0>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
fff81c90:	7c 7e f8 ae 	lbzx    r3,r30,r31
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < buflen; i++)
fff81c94:	3b ff 00 01 	addi    r31,r31,1
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
fff81c98:	64 63 90 a5 	oris    r3,r3,37029
fff81c9c:	4b ff e4 dd 	bl      fff80178 <pk_trace_tiny>
fff81ca0:	4b ff ff e8 	b       fff81c88 <_Z20tpmSequenceToStartupv+0xd4>
        }
        uint32_t tpmRc = (tpmStartCommand[6] << 24) | (tpmStartCommand[7] << 16) |  (tpmStartCommand[8] << 8) | tpmStartCommand[9];
fff81ca4:	89 21 00 0e 	lbz     r9,14(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81ca8:	3b e0 00 00 	li      r31,0
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
        }
        uint32_t tpmRc = (tpmStartCommand[6] << 24) | (tpmStartCommand[7] << 16) |  (tpmStartCommand[8] << 8) | tpmStartCommand[9];
fff81cac:	55 3c c0 0e 	rlwinm  r28,r9,24,0,7
fff81cb0:	89 21 00 0f 	lbz     r9,15(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81cb4:	3c 60 df 7f 	lis     r3,-8321
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
        }
        uint32_t tpmRc = (tpmStartCommand[6] << 24) | (tpmStartCommand[7] << 16) |  (tpmStartCommand[8] << 8) | tpmStartCommand[9];
fff81cb8:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fff81cbc:	7f 89 4b 78 	or      r9,r28,r9
fff81cc0:	8b 81 00 11 	lbz     r28,17(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81cc4:	60 63 00 01 	ori     r3,r3,1
fff81cc8:	7d 3c e3 78 	or      r28,r9,r28
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
        }
        uint32_t tpmRc = (tpmStartCommand[6] << 24) | (tpmStartCommand[7] << 16) |  (tpmStartCommand[8] << 8) | tpmStartCommand[9];
fff81ccc:	89 21 00 10 	lbz     r9,16(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81cd0:	7f e6 fb 78 	mr      r6,r31
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmStartCommand[i]);
        }
        uint32_t tpmRc = (tpmStartCommand[6] << 24) | (tpmStartCommand[7] << 16) |  (tpmStartCommand[8] << 8) | tpmStartCommand[9];
fff81cd4:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fff81cd8:	7f 9c 4b 78 	or      r28,r28,r9
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81cdc:	7f 85 e3 78 	mr      r5,r28
fff81ce0:	38 e0 00 00 	li      r7,0
fff81ce4:	39 00 00 00 	li      r8,0
fff81ce8:	7f 9e e3 78 	mr      r30,r28
fff81cec:	48 00 13 79 	bl      fff83064 <pk_trace_big>
        if(tpmRc || buflen < 10)
fff81cf0:	06 5c 00 08 	bwnz    r28,fff81d00 <_Z20tpmSequenceToStartupv+0x14c>
fff81cf4:	81 21 00 58 	lwz     r9,88(r1)
fff81cf8:	28 09 00 09 	cmplwi  r9,9
fff81cfc:	41 81 00 20 	bgt     fff81d1c <_Z20tpmSequenceToStartupv+0x168>
        {
            SBEM_ERROR(SBEM_FUNC "TPM startup command failed.");
fff81d00:	3c 60 a5 fc 	lis     r3,-23044
fff81d04:	4b ff e4 75 	bl      fff80178 <pk_trace_tiny>
            SET_TPM_RC(tpmRc);
fff81d08:	3d 20 00 05 	lis     r9,5
fff81d0c:	61 29 01 85 	ori     r9,r9,389
fff81d10:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fff81d14:	3f a0 02 00 	lis     r29,512
fff81d18:	63 bd 00 01 	ori     r29,r29,1
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff81d1c:	80 01 00 7c 	lwz     r0,124(r1)
fff81d20:	7f a3 eb 78 	mr      r3,r29
fff81d24:	7c 08 03 a6 	mtlr    r0
fff81d28:	17 81 00 68 	lvd     d28,104(r1)
fff81d2c:	17 c1 00 70 	lvd     d30,112(r1)
fff81d30:	38 21 00 78 	addi    r1,r1,120
fff81d34:	4e 80 00 20 	blr

fff81d38 <_Z23tpmSequenceToDetectPCRsRb>:

fapi2::ReturnCode tpmSequenceToDetectPCRs(bool &pcrAllocation)
{
fff81d38:	94 21 ff 38 	stwu    r1,-200(r1)
fff81d3c:	7c 08 02 a6 	mflr    r0
fff81d40:	1b 81 00 b8 	stvd    d28,184(r1)
fff81d44:	90 01 00 cc 	stw     r0,204(r1)
fff81d48:	1b c1 00 c0 	stvd    d30,192(r1)
fff81d4c:	90 61 00 a8 	stw     r3,168(r1)
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
fff81d50:	3b e1 00 48 	addi    r31,r1,72
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff81d54:	48 00 47 69 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff81d58:	3d 00 00 0c 	lis     r8,12
fff81d5c:	3b c0 00 01 	li      r30,1
fff81d60:	3b 80 00 04 	li      r28,4
fff81d64:	61 08 00 80 	ori     r8,r8,128
fff81d68:	90 61 00 88 	stw     r3,136(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
fff81d6c:	38 80 00 00 	li      r4,0
fff81d70:	38 a0 00 40 	li      r5,64
fff81d74:	7f e3 fb 78 	mr      r3,r31
fff81d78:	9b 81 00 8c 	stb     r28,140(r1)
fff81d7c:	91 01 00 90 	stw     r8,144(r1)
fff81d80:	b3 c1 00 8e 	sth     r30,142(r1)
fff81d84:	9b c1 00 94 	stb     r30,148(r1)
fff81d88:	48 00 0c 9d 	bl      fff82a24 <memset>
fff81d8c:	39 00 00 16 	li      r8,22
fff81d90:	99 01 00 4d 	stb     r8,77(r1)
fff81d94:	39 00 00 7a 	li      r8,122
fff81d98:	38 e0 ff 80 	li      r7,-128
fff81d9c:	3b a0 00 40 	li      r29,64
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81da0:	38 80 00 00 	li      r4,0
fff81da4:	38 a0 00 40 	li      r5,64
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
fff81da8:	99 01 00 51 	stb     r8,81(r1)
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81dac:	38 61 00 08 	addi    r3,r1,8
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
fff81db0:	39 00 00 05 	li      r8,5
fff81db4:	98 e1 00 48 	stb     r7,72(r1)
fff81db8:	99 01 00 55 	stb     r8,85(r1)
fff81dbc:	9b a1 00 5d 	stb     r29,93(r1)
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81dc0:	90 e1 00 ac 	stw     r7,172(r1)
fff81dc4:	91 01 00 b0 	stw     r8,176(r1)
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
fff81dc8:	9b c1 00 49 	stb     r30,73(r1)
fff81dcc:	9b c1 00 50 	stb     r30,80(r1)
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81dd0:	48 00 0c 55 	bl      fff82a24 <memset>
fff81dd4:	39 40 00 0b 	li      r10,11
fff81dd8:	80 e1 00 ac 	lwz     r7,172(r1)
fff81ddc:	81 01 00 b0 	lwz     r8,176(r1)
fff81de0:	39 20 00 25 	li      r9,37
fff81de4:	99 41 00 22 	stb     r10,34(r1)
fff81de8:	39 40 ff ff 	li      r10,-1
fff81dec:	99 21 00 0d 	stb     r9,13(r1)
fff81df0:	99 41 00 24 	stb     r10,36(r1)
fff81df4:	39 20 00 03 	li      r9,3
fff81df8:	99 41 00 25 	stb     r10,37(r1)
fff81dfc:	99 41 00 26 	stb     r10,38(r1)
        uint32_t buflen = 64;
        uint32_t cmdLen = 22;
        SBEM_INFO(SBEM_FUNC "Call TPM_CAP_PCRS ");
fff81e00:	3c 60 06 99 	lis     r3,1689
        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81e04:	39 40 00 0c 	li      r10,12
fff81e08:	98 e1 00 08 	stb     r7,8(r1)
fff81e0c:	99 01 00 16 	stb     r8,22(r1)
fff81e10:	99 21 00 1a 	stb     r9,26(r1)
fff81e14:	9b 81 00 1c 	stb     r28,28(r1)
fff81e18:	99 21 00 1d 	stb     r9,29(r1)
fff81e1c:	99 21 00 23 	stb     r9,35(r1)
fff81e20:	99 41 00 28 	stb     r10,40(r1)
fff81e24:	99 21 00 29 	stb     r9,41(r1)
        uint32_t buflen = 64;
fff81e28:	93 a1 00 98 	stw     r29,152(r1)
        uint8_t tpmCapPCR[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x01, 0x7A, 0x00,
                                 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40};
        uint8_t tpmPCRAllocated[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03,
                                       0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c,
                                       0x03, 0x00, 0x00, 0x00};
fff81e2c:	9b c1 00 09 	stb     r30,9(r1)
        uint32_t buflen = 64;
        uint32_t cmdLen = 22;
        SBEM_INFO(SBEM_FUNC "Call TPM_CAP_PCRS ");
fff81e30:	4b ff e3 49 	bl      fff80178 <pk_trace_tiny>
        rc = tpmTransmit(handle, (void *)tpmCapPCR, buflen, cmdLen);
fff81e34:	38 61 00 88 	addi    r3,r1,136
fff81e38:	7f e4 fb 78 	mr      r4,r31
fff81e3c:	38 a1 00 98 	addi    r5,r1,152
fff81e40:	38 c0 00 16 	li      r6,22
fff81e44:	48 00 35 29 	bl      fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fff81e48:	7c 7d 1b 78 	mr      r29,r3
fff81e4c:	3b 80 00 00 	li      r28,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff81e50:	06 c3 00 1e 	bwz     r3,fff81e8c <_Z23tpmSequenceToDetectPCRsRb+0x154>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fff81e54:	7c 7e 1b 78 	mr      r30,r3
fff81e58:	3b e0 00 00 	li      r31,0
fff81e5c:	3c 60 2b d9 	lis     r3,11225
fff81e60:	60 63 00 01 	ori     r3,r3,1
fff81e64:	7f a5 eb 78 	mr      r5,r29
fff81e68:	7f e6 fb 78 	mr      r6,r31
fff81e6c:	38 e0 00 00 	li      r7,0
fff81e70:	39 00 00 00 	li      r8,0
fff81e74:	48 00 11 f1 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff81e78:	3d 20 00 05 	lis     r9,5
fff81e7c:	61 29 01 85 	ori     r9,r9,389
fff81e80:	1b c9 00 00 	stvd    d30,0(r9)
            break;
fff81e84:	48 00 00 c0 	b       fff81f44 <_Z23tpmSequenceToDetectPCRsRb+0x20c>
        }
        for(uint32_t i = 0; i < buflen; i++)
fff81e88:	3b 9c 00 01 	addi    r28,r28,1
fff81e8c:	81 41 00 98 	lwz     r10,152(r1)
fff81e90:	05 1c 50 1e 	cmplwbge r28,r10,fff81ecc <_Z23tpmSequenceToDetectPCRsRb+0x194>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmCapPCR[i]);
fff81e94:	7c 7f e0 ae 	lbzx    r3,r31,r28
fff81e98:	64 63 ba 26 	oris    r3,r3,47654
fff81e9c:	4b ff e2 dd 	bl      fff80178 <pk_trace_tiny>
            SBEM_INFO(SBEM_FUNC "TPM expected data is 0x%02X", tpmPCRAllocated[i]);
fff81ea0:	39 21 00 08 	addi    r9,r1,8
fff81ea4:	7d 49 e0 ae 	lbzx    r10,r9,r28
fff81ea8:	65 43 cc d2 	oris    r3,r10,52434
fff81eac:	91 41 00 ac 	stw     r10,172(r1)
fff81eb0:	4b ff e2 c9 	bl      fff80178 <pk_trace_tiny>
            if(tpmCapPCR[i] != tpmPCRAllocated[i])
fff81eb4:	7d 1f e0 ae 	lbzx    r8,r31,r28
fff81eb8:	81 41 00 ac 	lwz     r10,172(r1)
fff81ebc:	04 c8 57 e6 	cmpwbeq r8,r10,fff81e88 <_Z23tpmSequenceToDetectPCRsRb+0x150>
            {
                pcrAllocation = false;
fff81ec0:	81 41 00 a8 	lwz     r10,168(r1)
fff81ec4:	39 20 00 00 	li      r9,0
fff81ec8:	99 2a 00 00 	stb     r9,0(r10)
                break;
            }
        }
        uint32_t tpmRc = (tpmCapPCR[6] << 24) | (tpmCapPCR[7] << 16) |  (tpmCapPCR[8] << 8) | tpmCapPCR[9];
fff81ecc:	89 21 00 4e 	lbz     r9,78(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81ed0:	3b e0 00 00 	li      r31,0
            {
                pcrAllocation = false;
                break;
            }
        }
        uint32_t tpmRc = (tpmCapPCR[6] << 24) | (tpmCapPCR[7] << 16) |  (tpmCapPCR[8] << 8) | tpmCapPCR[9];
fff81ed4:	55 3c c0 0e 	rlwinm  r28,r9,24,0,7
fff81ed8:	89 21 00 4f 	lbz     r9,79(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81edc:	3c 60 75 a5 	lis     r3,30117
            {
                pcrAllocation = false;
                break;
            }
        }
        uint32_t tpmRc = (tpmCapPCR[6] << 24) | (tpmCapPCR[7] << 16) |  (tpmCapPCR[8] << 8) | tpmCapPCR[9];
fff81ee0:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fff81ee4:	7f 89 4b 78 	or      r9,r28,r9
fff81ee8:	8b 81 00 51 	lbz     r28,81(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81eec:	60 63 00 01 	ori     r3,r3,1
fff81ef0:	7d 3c e3 78 	or      r28,r9,r28
            {
                pcrAllocation = false;
                break;
            }
        }
        uint32_t tpmRc = (tpmCapPCR[6] << 24) | (tpmCapPCR[7] << 16) |  (tpmCapPCR[8] << 8) | tpmCapPCR[9];
fff81ef4:	89 21 00 50 	lbz     r9,80(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81ef8:	7f e6 fb 78 	mr      r6,r31
            {
                pcrAllocation = false;
                break;
            }
        }
        uint32_t tpmRc = (tpmCapPCR[6] << 24) | (tpmCapPCR[7] << 16) |  (tpmCapPCR[8] << 8) | tpmCapPCR[9];
fff81efc:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fff81f00:	7f 9c 4b 78 	or      r28,r28,r9
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff81f04:	7f 85 e3 78 	mr      r5,r28
fff81f08:	38 e0 00 00 	li      r7,0
fff81f0c:	39 00 00 00 	li      r8,0
fff81f10:	7f 9e e3 78 	mr      r30,r28
fff81f14:	48 00 11 51 	bl      fff83064 <pk_trace_big>
        if(tpmRc || buflen < 10)
fff81f18:	06 5c 00 08 	bwnz    r28,fff81f28 <_Z23tpmSequenceToDetectPCRsRb+0x1f0>
fff81f1c:	81 21 00 98 	lwz     r9,152(r1)
fff81f20:	28 09 00 09 	cmplwi  r9,9
fff81f24:	41 81 00 20 	bgt     fff81f44 <_Z23tpmSequenceToDetectPCRsRb+0x20c>
        {
            SBEM_ERROR(SBEM_FUNC " tpmSequenceToDetectPCRs command failed.");
fff81f28:	3c 60 2e 3f 	lis     r3,11839
fff81f2c:	4b ff e2 4d 	bl      fff80178 <pk_trace_tiny>
            SET_TPM_RC(tpmRc);
fff81f30:	3d 20 00 05 	lis     r9,5
fff81f34:	61 29 01 85 	ori     r9,r9,389
fff81f38:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fff81f3c:	3f a0 02 00 	lis     r29,512
fff81f40:	63 bd 00 01 	ori     r29,r29,1
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff81f44:	80 01 00 cc 	lwz     r0,204(r1)
fff81f48:	7f a3 eb 78 	mr      r3,r29
fff81f4c:	7c 08 03 a6 	mtlr    r0
fff81f50:	17 81 00 b8 	lvd     d28,184(r1)
fff81f54:	17 c1 00 c0 	lvd     d30,192(r1)
fff81f58:	38 21 00 c8 	addi    r1,r1,200
fff81f5c:	4e 80 00 20 	blr

fff81f60 <_Z25tpmSequenceToAllocatePCRsv>:

fapi2::ReturnCode tpmSequenceToAllocatePCRs()
{
fff81f60:	94 21 ff 88 	stwu    r1,-120(r1)
fff81f64:	7c 08 02 a6 	mflr    r0
fff81f68:	1b 81 00 68 	stvd    d28,104(r1)
fff81f6c:	90 01 00 7c 	stw     r0,124(r1)
fff81f70:	1b c1 00 70 	stvd    d30,112(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff81f74:	48 00 45 49 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmAllocatePCR[64] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x01, 0x2b, 0x40, 0x00,
                                      0x00, 0x0c, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03, 0x00, 0x00,
                                      0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x00};
fff81f78:	3b c1 00 08 	addi    r30,r1,8
fff81f7c:	3d 20 00 0c 	lis     r9,12
fff81f80:	3b a0 00 01 	li      r29,1
fff81f84:	61 29 00 80 	ori     r9,r9,128
fff81f88:	38 80 00 00 	li      r4,0
fff81f8c:	38 a0 00 40 	li      r5,64
fff81f90:	90 61 00 48 	stw     r3,72(r1)
fff81f94:	3b 80 00 04 	li      r28,4
fff81f98:	7f c3 f3 78 	mr      r3,r30
fff81f9c:	b3 a1 00 4e 	sth     r29,78(r1)
fff81fa0:	91 21 00 50 	stw     r9,80(r1)
fff81fa4:	9b a1 00 54 	stb     r29,84(r1)
fff81fa8:	9b 81 00 4c 	stb     r28,76(r1)
fff81fac:	48 00 0a 79 	bl      fff82a24 <memset>
fff81fb0:	39 20 ff 80 	li      r9,-128
fff81fb4:	99 21 00 08 	stb     r9,8(r1)
fff81fb8:	39 20 00 02 	li      r9,2
fff81fbc:	99 21 00 09 	stb     r9,9(r1)
fff81fc0:	39 20 00 31 	li      r9,49
fff81fc4:	99 21 00 0d 	stb     r9,13(r1)
fff81fc8:	39 20 00 2b 	li      r9,43
fff81fcc:	99 21 00 11 	stb     r9,17(r1)
fff81fd0:	39 40 00 0b 	li      r10,11
fff81fd4:	39 20 00 09 	li      r9,9
fff81fd8:	3b e0 00 40 	li      r31,64
fff81fdc:	39 00 00 0c 	li      r8,12
fff81fe0:	99 21 00 19 	stb     r9,25(r1)
fff81fe4:	99 21 00 1d 	stb     r9,29(r1)
fff81fe8:	99 41 00 2e 	stb     r10,46(r1)
fff81fec:	39 20 00 03 	li      r9,3
fff81ff0:	39 40 ff ff 	li      r10,-1
        uint32_t buflen = 64;
        uint32_t cmdLen = 49;
        SBEM_INFO(SBEM_FUNC "Call TPM_CAP_PCRS ");
fff81ff4:	3c 60 34 c3 	lis     r3,13507
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmAllocatePCR[64] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x01, 0x2b, 0x40, 0x00,
                                      0x00, 0x0c, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03, 0x00, 0x00,
                                      0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x00};
fff81ff8:	9b a1 00 10 	stb     r29,16(r1)
fff81ffc:	9b e1 00 12 	stb     r31,18(r1)
fff82000:	99 01 00 15 	stb     r8,21(r1)
fff82004:	9b e1 00 1a 	stb     r31,26(r1)
fff82008:	99 21 00 26 	stb     r9,38(r1)
fff8200c:	99 21 00 29 	stb     r9,41(r1)
fff82010:	99 21 00 2f 	stb     r9,47(r1)
fff82014:	99 41 00 30 	stb     r10,48(r1)
fff82018:	99 41 00 31 	stb     r10,49(r1)
fff8201c:	99 41 00 32 	stb     r10,50(r1)
fff82020:	99 01 00 34 	stb     r8,52(r1)
fff82024:	99 21 00 35 	stb     r9,53(r1)
        uint32_t buflen = 64;
fff82028:	93 e1 00 58 	stw     r31,88(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        uint8_t tpmAllocatePCR[64] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x01, 0x2b, 0x40, 0x00,
                                      0x00, 0x0c, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x03, 0x00, 0x00,
                                      0x00, 0x00, 0x0b, 0x03, 0xff, 0xff, 0xff, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x00};
fff8202c:	9b 81 00 28 	stb     r28,40(r1)
        uint32_t buflen = 64;
        uint32_t cmdLen = 49;
        SBEM_INFO(SBEM_FUNC "Call TPM_CAP_PCRS ");
fff82030:	4b ff e1 49 	bl      fff80178 <pk_trace_tiny>
        rc = tpmTransmit(handle, (void *)tpmAllocatePCR, buflen, cmdLen);
fff82034:	38 61 00 48 	addi    r3,r1,72
fff82038:	7f c4 f3 78 	mr      r4,r30
fff8203c:	38 a1 00 58 	addi    r5,r1,88
fff82040:	38 c0 00 31 	li      r6,49
fff82044:	48 00 33 29 	bl      fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fff82048:	7c 7d 1b 78 	mr      r29,r3
fff8204c:	3b e0 00 00 	li      r31,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82050:	06 c3 00 1c 	bwz     r3,fff82088 <_Z25tpmSequenceToAllocatePCRsv+0x128>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fff82054:	7c 7e 1b 78 	mr      r30,r3
fff82058:	3b e0 00 00 	li      r31,0
fff8205c:	3c 60 4f ea 	lis     r3,20458
fff82060:	60 63 00 01 	ori     r3,r3,1
fff82064:	7f a5 eb 78 	mr      r5,r29
fff82068:	7f e6 fb 78 	mr      r6,r31
fff8206c:	38 e0 00 00 	li      r7,0
fff82070:	39 00 00 00 	li      r8,0
fff82074:	48 00 0f f1 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff82078:	3d 20 00 05 	lis     r9,5
fff8207c:	61 29 01 85 	ori     r9,r9,389
fff82080:	1b c9 00 00 	stvd    d30,0(r9)
            break;
fff82084:	48 00 00 98 	b       fff8211c <_Z25tpmSequenceToAllocatePCRsv+0x1bc>
        }
        for(uint32_t i = 0; i < buflen; i++)
fff82088:	81 21 00 58 	lwz     r9,88(r1)
fff8208c:	05 1f 48 0c 	cmplwbge r31,r9,fff820a4 <_Z25tpmSequenceToAllocatePCRsv+0x144>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
fff82090:	7c 7e f8 ae 	lbzx    r3,r30,r31
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < buflen; i++)
fff82094:	3b ff 00 01 	addi    r31,r31,1
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
fff82098:	64 63 8d e7 	oris    r3,r3,36327
fff8209c:	4b ff e0 dd 	bl      fff80178 <pk_trace_tiny>
fff820a0:	4b ff ff e8 	b       fff82088 <_Z25tpmSequenceToAllocatePCRsv+0x128>
        }
        uint32_t tpmRc = (tpmAllocatePCR[6] << 24) | (tpmAllocatePCR[7] << 16) |  (tpmAllocatePCR[8] << 8) | tpmAllocatePCR[9];
fff820a4:	89 21 00 0e 	lbz     r9,14(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff820a8:	3b e0 00 00 	li      r31,0
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
        }
        uint32_t tpmRc = (tpmAllocatePCR[6] << 24) | (tpmAllocatePCR[7] << 16) |  (tpmAllocatePCR[8] << 8) | tpmAllocatePCR[9];
fff820ac:	55 3c c0 0e 	rlwinm  r28,r9,24,0,7
fff820b0:	89 21 00 0f 	lbz     r9,15(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff820b4:	3c 60 07 21 	lis     r3,1825
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
        }
        uint32_t tpmRc = (tpmAllocatePCR[6] << 24) | (tpmAllocatePCR[7] << 16) |  (tpmAllocatePCR[8] << 8) | tpmAllocatePCR[9];
fff820b8:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fff820bc:	7f 89 4b 78 	or      r9,r28,r9
fff820c0:	8b 81 00 11 	lbz     r28,17(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff820c4:	60 63 00 01 	ori     r3,r3,1
fff820c8:	7d 3c e3 78 	or      r28,r9,r28
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
        }
        uint32_t tpmRc = (tpmAllocatePCR[6] << 24) | (tpmAllocatePCR[7] << 16) |  (tpmAllocatePCR[8] << 8) | tpmAllocatePCR[9];
fff820cc:	89 21 00 10 	lbz     r9,16(r1)
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff820d0:	7f e6 fb 78 	mr      r6,r31
        }
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", tpmAllocatePCR[i]);
        }
        uint32_t tpmRc = (tpmAllocatePCR[6] << 24) | (tpmAllocatePCR[7] << 16) |  (tpmAllocatePCR[8] << 8) | tpmAllocatePCR[9];
fff820d4:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fff820d8:	7f 9c 4b 78 	or      r28,r28,r9
        SBEM_INFO(SBEM_FUNC "TPM rc is 0x%08X", tpmRc);
fff820dc:	7f 85 e3 78 	mr      r5,r28
fff820e0:	38 e0 00 00 	li      r7,0
fff820e4:	39 00 00 00 	li      r8,0
fff820e8:	7f 9e e3 78 	mr      r30,r28
fff820ec:	48 00 0f 79 	bl      fff83064 <pk_trace_big>
        if(tpmRc || buflen < 10)
fff820f0:	06 5c 00 08 	bwnz    r28,fff82100 <_Z25tpmSequenceToAllocatePCRsv+0x1a0>
fff820f4:	81 21 00 58 	lwz     r9,88(r1)
fff820f8:	28 09 00 09 	cmplwi  r9,9
fff820fc:	41 81 00 20 	bgt     fff8211c <_Z25tpmSequenceToAllocatePCRsv+0x1bc>
        {
            SBEM_ERROR(SBEM_FUNC " tpmSequenceToAllocatePCRs command failed.");
fff82100:	3c 60 4d bb 	lis     r3,19899
fff82104:	4b ff e0 75 	bl      fff80178 <pk_trace_tiny>
            SET_TPM_RC(tpmRc);
fff82108:	3d 20 00 05 	lis     r9,5
fff8210c:	61 29 01 85 	ori     r9,r9,389
fff82110:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fff82114:	3f a0 02 00 	lis     r29,512
fff82118:	63 bd 00 01 	ori     r29,r29,1
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff8211c:	80 01 00 7c 	lwz     r0,124(r1)
fff82120:	7f a3 eb 78 	mr      r3,r29
fff82124:	7c 08 03 a6 	mtlr    r0
fff82128:	17 81 00 68 	lvd     d28,104(r1)
fff8212c:	17 c1 00 70 	lvd     d30,112(r1)
fff82130:	38 21 00 78 	addi    r1,r1,120
fff82134:	4e 80 00 20 	blr

fff82138 <_Z21setTPMFailureRespCodem>:

fapi2::ReturnCode setTPMFailureRespCode(uint32_t failCode)
{
fff82138:	94 21 ff d8 	stwu    r1,-40(r1)
fff8213c:	7c 08 02 a6 	mflr    r0
fff82140:	1b c1 00 20 	stvd    d30,32(r1)
    #define SBEM_FUNC " setTPMFailureRespCode "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        SBEM_INFO(SBEM_FUNC "failCode passed is 0x%08X", failCode);
fff82144:	7c 7f 1b 78 	mr      r31,r3
fff82148:	3c 60 84 6a 	lis     r3,-31638
fff8214c:	7f e5 fb 78 	mr      r5,r31
fff82150:	38 c0 00 00 	li      r6,0
fff82154:	38 e0 00 00 	li      r7,0
fff82158:	39 00 00 00 	li      r8,0
fff8215c:	60 63 00 01 	ori     r3,r3,1
fff82160:	3b c0 00 00 	li      r30,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode setTPMFailureRespCode(uint32_t failCode)
{
fff82164:	90 01 00 2c 	stw     r0,44(r1)
fff82168:	1b 81 00 18 	stvd    d28,24(r1)
    do
    {
        SBEM_INFO(SBEM_FUNC "failCode passed is 0x%08X", failCode);
        Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
        uint64_t scomData = failCode;
        scomData = (scomData << 48) & 0x00FF000000000000;
fff8216c:	7b de 83 c6 	rldicr  d30,d30,48,15
    #define SBEM_FUNC " setTPMFailureRespCode "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        SBEM_INFO(SBEM_FUNC "failCode passed is 0x%08X", failCode);
fff82170:	48 00 0e f5 	bl      fff83064 <pk_trace_big>
        Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
fff82174:	7c 3d 0b 78 	mr      r29,r1
fff82178:	48 00 43 45 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff8217c:	94 7d 00 08 	stwu    r3,8(r29)
        uint64_t scomData = failCode;
        scomData = (scomData << 48) & 0x00FF000000000000;
fff82180:	57 de 02 1e 	rlwinm  r30,r30,0,8,15
        SBEM_INFO(SBEM_FUNC "Final Mailbox scratch data is 0x%08X %08X", scomData >> 32, scomData);
fff82184:	3c 60 92 26 	lis     r3,-28122
fff82188:	60 63 00 02 	ori     r3,r3,2
fff8218c:	7f c5 f3 78 	mr      r5,r30
fff82190:	38 c0 00 00 	li      r6,0
fff82194:	38 e0 00 00 	li      r7,0
fff82198:	39 00 00 00 	li      r8,0
fff8219c:	48 00 0e c9 	bl      fff83064 <pk_trace_big>
        rc = putscom_abs_wrap (&target, MAILBOX_SCRATCH_REG_11, scomData);
fff821a0:	3c 80 00 05 	lis     r4,5
fff821a4:	7f a3 eb 78 	mr      r3,r29
fff821a8:	60 84 01 82 	ori     r4,r4,386
fff821ac:	7f c5 f3 78 	mr      r5,r30
fff821b0:	38 c0 00 00 	li      r6,0
fff821b4:	48 00 42 09 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff821b8:	7c 7f 1b 78 	mr      r31,r3
        if(rc)
fff821bc:	06 c3 00 10 	bwz     r3,fff821dc <_Z21setTPMFailureRespCodem+0xa4>
        {
            SBEM_ERROR(SBEM_FUNC " putscom failed on MAILBOX_SCRATCH_REG_11 with rc 0x%08X", rc);
fff821c0:	3c 60 b7 de 	lis     r3,-18466
fff821c4:	60 63 00 01 	ori     r3,r3,1
fff821c8:	7f e5 fb 78 	mr      r5,r31
fff821cc:	38 c0 00 00 	li      r6,0
fff821d0:	38 e0 00 00 	li      r7,0
fff821d4:	39 00 00 00 	li      r8,0
fff821d8:	48 00 0e 8d 	bl      fff83064 <pk_trace_big>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff821dc:	80 01 00 2c 	lwz     r0,44(r1)
fff821e0:	7f e3 fb 78 	mr      r3,r31
fff821e4:	7c 08 03 a6 	mtlr    r0
fff821e8:	17 81 00 18 	lvd     d28,24(r1)
fff821ec:	17 c1 00 20 	lvd     d30,32(r1)
fff821f0:	38 21 00 28 	addi    r1,r1,40
fff821f4:	4e 80 00 20 	blr

fff821f8 <_Z19performTPMSequencesm>:

fapi2::ReturnCode performTPMSequences(uint32_t sbeRole)
{
fff821f8:	94 21 ff d8 	stwu    r1,-40(r1)
fff821fc:	7c 08 02 a6 	mflr    r0
fff82200:	1b 81 00 18 	stvd    d28,24(r1)
fff82204:	90 01 00 2c 	stw     r0,44(r1)
fff82208:	1b c1 00 20 	stvd    d30,32(r1)
fff8220c:	7c 7d 1b 78 	mr      r29,r3
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t tpmRespCode = SBEM_TPM_OPERATION_SUCCESSFUL;
    do
    {
        if(sbeRole == SBE_ROLE_SLAVE)
fff82210:	06 43 08 10 	cmpwibne r3,1,fff82230 <_Z19performTPMSequencesm+0x38>
        {
            SBEM_INFO(SBE_FUNC "Current Proc is slave. Do not access TPM");
fff82214:	3c 60 86 6e 	lis     r3,-31122
fff82218:	4b ff df 61 	bl      fff80178 <pk_trace_tiny>
            rc = setTPMDeconfigBit();
fff8221c:	48 00 36 d5 	bl      fff858f0 <_Z17setTPMDeconfigBitv>
fff82220:	7c 7f 1b 78 	mr      r31,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
            {
                SBEM_ERROR(SBEM_FUNC "Failed to set the deconfig bit with rc 0x%08X", rc);
fff82224:	3c 60 9a 36 	lis     r3,-26058
    {
        if(sbeRole == SBE_ROLE_SLAVE)
        {
            SBEM_INFO(SBE_FUNC "Current Proc is slave. Do not access TPM");
            rc = setTPMDeconfigBit();
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82228:	06 df 00 ee 	bwz     r31,fff82404 <_Z19performTPMSequencesm+0x20c>
fff8222c:	48 00 01 c0 	b       fff823ec <_Z19performTPMSequencesm+0x1f4>
                SBEM_ERROR(SBEM_FUNC "Failed to set the deconfig bit with rc 0x%08X", rc);
            }
            break;
        }

        SBEM_INFO(SBEM_FUNC "Perform TPM sequence to Read Vendor and DeviceID");
fff82230:	3c 60 f1 11 	lis     r3,-3823
fff82234:	4b ff df 45 	bl      fff80178 <pk_trace_tiny>
        rc = tpmSequenceToReadDIDAndVendor();
fff82238:	4b ff f7 f5 	bl      fff81a2c <_Z29tpmSequenceToReadDIDAndVendorv>
fff8223c:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82240:	06 c3 00 14 	bwz     r3,fff82268 <_Z19performTPMSequencesm+0x70>
        {
            SBEM_ERROR(SBEM_FUNC "tpmSequenceToReadDIDAndVendor Failed with rc 0x%08X", rc);
fff82244:	3c 60 93 ee 	lis     r3,-27666
fff82248:	60 63 00 01 	ori     r3,r3,1
fff8224c:	7f e5 fb 78 	mr      r5,r31
fff82250:	38 c0 00 00 	li      r6,0
fff82254:	38 e0 00 00 	li      r7,0
fff82258:	39 00 00 00 	li      r8,0
fff8225c:	48 00 0e 09 	bl      fff83064 <pk_trace_big>
            tpmRespCode = SBEM_TPM_READ_DID_AND_VID_FAILURE;
fff82260:	3b c0 00 01 	li      r30,1
            break;
fff82264:	48 00 01 44 	b       fff823a8 <_Z19performTPMSequencesm+0x1b0>
        }

        SBEM_INFO(SBEM_FUNC "Perfrom TPM sequence to access the TPM locality");
fff82268:	3c 60 02 96 	lis     r3,662
fff8226c:	4b ff df 0d 	bl      fff80178 <pk_trace_tiny>
        rc = tpmSequenceToAccessLocality0();
fff82270:	4b ff f8 89 	bl      fff81af8 <_Z28tpmSequenceToAccessLocality0v>
fff82274:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82278:	06 c3 00 14 	bwz     r3,fff822a0 <_Z19performTPMSequencesm+0xa8>
        {
            SBEM_ERROR(SBEM_FUNC "tpmSequenceToAccessLocality0 Failed with rc 0x%08X", rc);
fff8227c:	3c 60 7c b3 	lis     r3,31923
fff82280:	60 63 00 01 	ori     r3,r3,1
fff82284:	7f e5 fb 78 	mr      r5,r31
fff82288:	38 c0 00 00 	li      r6,0
fff8228c:	38 e0 00 00 	li      r7,0
fff82290:	39 00 00 00 	li      r8,0
fff82294:	48 00 0d d1 	bl      fff83064 <pk_trace_big>
            tpmRespCode = SBEM_TPM_ACCESS_LOCALITY0_FAILURE;
fff82298:	3b c0 00 02 	li      r30,2
            break;
fff8229c:	48 00 01 0c 	b       fff823a8 <_Z19performTPMSequencesm+0x1b0>
        }

        SBEM_INFO(SBEM_FUNC "Perfrom TPM sequence to Start TPM");
fff822a0:	3c 60 11 f0 	lis     r3,4592
fff822a4:	4b ff de d5 	bl      fff80178 <pk_trace_tiny>
        rc = tpmSequenceToStartup();
fff822a8:	4b ff f9 0d 	bl      fff81bb4 <_Z20tpmSequenceToStartupv>
fff822ac:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff822b0:	06 c3 00 14 	bwz     r3,fff822d8 <_Z19performTPMSequencesm+0xe0>
        {
            SBEM_ERROR(SBEM_FUNC "tpmSequenceToStartup Failed with rc 0x%08X", rc);
fff822b4:	3c 60 5a de 	lis     r3,23262
fff822b8:	60 63 00 01 	ori     r3,r3,1
fff822bc:	7f e5 fb 78 	mr      r5,r31
fff822c0:	38 c0 00 00 	li      r6,0
fff822c4:	38 e0 00 00 	li      r7,0
fff822c8:	39 00 00 00 	li      r8,0
fff822cc:	48 00 0d 99 	bl      fff83064 <pk_trace_big>
            tpmRespCode = SBEM_TPM_START_TPM_SEQUENCE_FAILURE;
fff822d0:	3b c0 00 03 	li      r30,3
            break;
fff822d4:	48 00 00 d4 	b       fff823a8 <_Z19performTPMSequencesm+0x1b0>
        }

        SBEM_INFO(SBEM_FUNC "Perfrom TPM sequence to detect allocated PCRs");
fff822d8:	3c 60 23 c5 	lis     r3,9157
fff822dc:	4b ff de 9d 	bl      fff80178 <pk_trace_tiny>
        bool pcrAllocation = true;
fff822e0:	7c 23 0b 78 	mr      r3,r1
fff822e4:	39 20 00 01 	li      r9,1
fff822e8:	9d 23 00 08 	stbu    r9,8(r3)
        rc = tpmSequenceToDetectPCRs(pcrAllocation);
fff822ec:	4b ff fa 4d 	bl      fff81d38 <_Z23tpmSequenceToDetectPCRsRb>
fff822f0:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff822f4:	06 c3 00 14 	bwz     r3,fff8231c <_Z19performTPMSequencesm+0x124>
        {
            SBEM_ERROR(SBEM_FUNC "tpmSequenceToDetectPCRs Failed with rc 0x%08X", rc);
fff822f8:	3c 60 e0 f5 	lis     r3,-7947
fff822fc:	60 63 00 01 	ori     r3,r3,1
fff82300:	7f e5 fb 78 	mr      r5,r31
fff82304:	38 c0 00 00 	li      r6,0
fff82308:	38 e0 00 00 	li      r7,0
fff8230c:	39 00 00 00 	li      r8,0
fff82310:	48 00 0d 55 	bl      fff83064 <pk_trace_big>
            tpmRespCode = SBEM_TPM_DETECT_PCR_ALLOCATION_FAILURE;
fff82314:	3b c0 00 04 	li      r30,4
            break;
fff82318:	48 00 00 90 	b       fff823a8 <_Z19performTPMSequencesm+0x1b0>
        }

        SBEM_INFO(SBEM_FUNC "PCR Allocation is set to %d", pcrAllocation);
fff8231c:	88 61 00 08 	lbz     r3,8(r1)
fff82320:	64 63 ba d2 	oris    r3,r3,47826
fff82324:	4b ff de 55 	bl      fff80178 <pk_trace_tiny>
        if(!pcrAllocation)
fff82328:	89 21 00 08 	lbz     r9,8(r1)
fff8232c:	06 49 00 1e 	bwnz    r9,fff82368 <_Z19performTPMSequencesm+0x170>
        {
            SBEM_INFO(SBEM_FUNC "Perfrom TPM sequence to allocate PCRs");
fff82330:	3c 60 94 65 	lis     r3,-27547
fff82334:	4b ff de 45 	bl      fff80178 <pk_trace_tiny>
            rc = tpmSequenceToAllocatePCRs();
fff82338:	4b ff fc 29 	bl      fff81f60 <_Z25tpmSequenceToAllocatePCRsv>
fff8233c:	7c 7f 1b 78 	mr      r31,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82340:	06 c3 00 14 	bwz     r3,fff82368 <_Z19performTPMSequencesm+0x170>
            {
                SBEM_ERROR(SBEM_FUNC "tpmSequenceToAllocatePCRs Failed with rc 0x%08X", rc);
fff82344:	3c 60 14 86 	lis     r3,5254
fff82348:	60 63 00 01 	ori     r3,r3,1
fff8234c:	7f e5 fb 78 	mr      r5,r31
fff82350:	38 c0 00 00 	li      r6,0
fff82354:	38 e0 00 00 	li      r7,0
fff82358:	39 00 00 00 	li      r8,0
fff8235c:	48 00 0d 09 	bl      fff83064 <pk_trace_big>
                tpmRespCode = SBEM_TPM_PCR_ALLOCATION_FAILURE;
fff82360:	3b c0 00 05 	li      r30,5
                break;
fff82364:	48 00 00 44 	b       fff823a8 <_Z19performTPMSequencesm+0x1b0>
fff82368:	3b e0 00 00 	li      r31,0
            }
        }

        if(sbeRole == SBE_ROLE_ALT_MASTER)
fff8236c:	06 5d 10 4c 	cmpwibne r29,2,fff82404 <_Z19performTPMSequencesm+0x20c>
        {
            SBEM_INFO(SBEM_FUNC "Poison TPM incase of ALT master");
fff82370:	3c 60 de 15 	lis     r3,-8683
fff82374:	4b ff de 05 	bl      fff80178 <pk_trace_tiny>
            rc = tpmPoisonPCR();
fff82378:	48 00 33 a5 	bl      fff8571c <_Z12tpmPoisonPCRv>
fff8237c:	7c 7f 1b 78 	mr      r31,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff82380:	06 c3 00 42 	bwz     r3,fff82404 <_Z19performTPMSequencesm+0x20c>
            {
                SBEM_ERROR(SBEM_FUNC "tpmPoisonPCR failed with rc 0x%08X", rc);
fff82384:	3c 60 ed 5e 	lis     r3,-4770
fff82388:	60 63 00 01 	ori     r3,r3,1
fff8238c:	7f e5 fb 78 	mr      r5,r31
fff82390:	38 c0 00 00 	li      r6,0
fff82394:	38 e0 00 00 	li      r7,0
fff82398:	39 00 00 00 	li      r8,0
fff8239c:	48 00 0c c9 	bl      fff83064 <pk_trace_big>
                tpmRespCode = SBEM_TPM_POISON_FAILURE;
fff823a0:	3b c0 00 06 	li      r30,6
fff823a4:	48 00 00 08 	b       fff823ac <_Z19performTPMSequencesm+0x1b4>
            }
            break;
        }
    }while(0);
    if((sbeRole != SBE_ROLE_SLAVE) && (rc != fapi2::FAPI2_RC_SUCCESS))
fff823a8:	06 dd 08 2e 	cmpwibeq r29,1,fff82404 <_Z19performTPMSequencesm+0x20c>
fff823ac:	06 df 00 2c 	bwz     r31,fff82404 <_Z19performTPMSequencesm+0x20c>
    {
        rc = setTPMDeconfigBit();
fff823b0:	48 00 35 41 	bl      fff858f0 <_Z17setTPMDeconfigBitv>
fff823b4:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff823b8:	06 c3 00 10 	bwz     r3,fff823d8 <_Z19performTPMSequencesm+0x1e0>
        {
            SBEM_ERROR(SBEM_FUNC "Failed to set the deconfig bit with rc 0x%08X", rc);
fff823bc:	3c 60 9a 36 	lis     r3,-26058
fff823c0:	60 63 00 01 	ori     r3,r3,1
fff823c4:	7f e5 fb 78 	mr      r5,r31
fff823c8:	38 c0 00 00 	li      r6,0
fff823cc:	38 e0 00 00 	li      r7,0
fff823d0:	39 00 00 00 	li      r8,0
fff823d4:	48 00 0c 91 	bl      fff83064 <pk_trace_big>
        }
        rc = setTPMFailureRespCode(tpmRespCode);
fff823d8:	7f c3 f3 78 	mr      r3,r30
fff823dc:	4b ff fd 5d 	bl      fff82138 <_Z21setTPMFailureRespCodem>
fff823e0:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff823e4:	06 c3 00 10 	bwz     r3,fff82404 <_Z19performTPMSequencesm+0x20c>
        {
            SBEM_ERROR(SBEM_FUNC "Failed to set the scratch reg with the response code, rc 0x%08X", rc);
fff823e8:	3c 60 b1 93 	lis     r3,-20077
fff823ec:	60 63 00 01 	ori     r3,r3,1
fff823f0:	7f e5 fb 78 	mr      r5,r31
fff823f4:	38 c0 00 00 	li      r6,0
fff823f8:	38 e0 00 00 	li      r7,0
fff823fc:	39 00 00 00 	li      r8,0
fff82400:	48 00 0c 65 	bl      fff83064 <pk_trace_big>
        }
    }
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff82404:	80 01 00 2c 	lwz     r0,44(r1)
fff82408:	7f e3 fb 78 	mr      r3,r31
fff8240c:	7c 08 03 a6 	mtlr    r0
fff82410:	17 81 00 18 	lvd     d28,24(r1)
fff82414:	17 c1 00 20 	lvd     d30,32(r1)
fff82418:	38 21 00 28 	addi    r1,r1,40
fff8241c:	4e 80 00 20 	blr

fff82420 <_Z10decompressPhS_>:
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

uint8_t decompress(uint8_t * compBuffer, uint8_t * decompBuffer)
{
fff82420:	94 21 fb c8 	stwu    r1,-1080(r1)
fff82424:	7c 08 02 a6 	mflr    r0
fff82428:	1b c1 04 30 	stvd    d30,1072(r1)
fff8242c:	90 01 04 3c 	stw     r0,1084(r1)

        uint32_t dict[256];
        for(iCount = 0; iCount < 256; iCount++)
        {
           uint64_t temp = *(uint64_t *)compBuffer;
           dict[iCount] = (uint32_t)(((temp) & 0xFFFFFFFF00000000LL) >> 32);
fff82430:	38 00 00 80 	li      r0,128
fff82434:	7c 09 03 a6 	mtctr   r0
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

uint8_t decompress(uint8_t * compBuffer, uint8_t * decompBuffer)
{
fff82438:	7c 3f 0b 78 	mr      r31,r1
fff8243c:	1b 81 04 28 	stvd    d28,1064(r1)
fff82440:	39 20 00 00 	li      r9,0

        uint32_t dict[256];
        for(iCount = 0; iCount < 256; iCount++)
        {
           uint64_t temp = *(uint64_t *)compBuffer;
           dict[iCount] = (uint32_t)(((temp) & 0xFFFFFFFF00000000LL) >> 32);
fff82444:	38 bf 00 08 	addi    r5,r31,8
fff82448:	7d 43 4a 14 	add     r10,r3,r9
fff8244c:	7c e3 48 2e 	lwzx    r7,r3,r9
        int32_t jCount = 0;

        uint32_t dict[256];
        for(iCount = 0; iCount < 256; iCount++)
        {
           uint64_t temp = *(uint64_t *)compBuffer;
fff82450:	81 0a 00 04 	lwz     r8,4(r10)
           dict[iCount] = (uint32_t)(((temp) & 0xFFFFFFFF00000000LL) >> 32);
fff82454:	7c aa 2b 78 	mr      r10,r5
fff82458:	7c ea 49 2e 	stwx    r7,r10,r9
fff8245c:	7d 4a 4a 14 	add     r10,r10,r9
fff82460:	39 29 00 08 	addi    r9,r9,8
           ++iCount;
           dict[iCount] = (uint32_t)(((temp) & 0xFFFFFFFFLL));
fff82464:	91 0a 00 04 	stw     r8,4(r10)
fff82468:	42 00 ff e0 	bdnz    fff82448 <_Z10decompressPhS_+0x28>
           compBuffer = compBuffer + 8;
        }

        //Get the file size.
        uint64_t compfileSize = *((uint64_t * )compBuffer);
fff8246c:	17 83 04 00 	lvd     d28,1024(r3)
        compBuffer = compBuffer + 8;
fff82470:	38 63 04 08 	addi    r3,r3,1032
        uint32_t quo = compfileSize / 128;
fff82474:	7b 88 c9 c2 	rldicl  d8,d28,57,7
        uint32_t rem = compfileSize % (128);
fff82478:	57 aa 06 7e 	clrlwi  r10,r29,25
        }

        //Get the file size.
        uint64_t compfileSize = *((uint64_t * )compBuffer);
        compBuffer = compBuffer + 8;
        uint32_t quo = compfileSize / 128;
fff8247c:	7d 27 4b 78 	mr      r7,r9
        uint32_t rem = compfileSize % (128);
fff82480:	7d 49 03 a6 	mtctr   r10
        uint32_t bitCount;
        if(rem == 0)
fff82484:	06 ca 00 04 	bwz     r10,fff8248c <_Z10decompressPhS_+0x6c>
            bitCount = quo;
        else
            bitCount = quo + 1;
fff82488:	38 e9 00 01 	addi    r7,r9,1

        uint32_t bitArray[bitCount];
fff8248c:	54 e9 10 3a 	rlwinm  r9,r7,2,0,29
fff82490:	39 29 00 12 	addi    r9,r9,18
fff82494:	55 29 00 36 	rlwinm  r9,r9,0,0,27
fff82498:	81 41 00 00 	lwz     r10,0(r1)
fff8249c:	7d 29 00 d0 	neg     r9,r9
fff824a0:	7c 00 00 a6 	mfmsr   r0
fff824a4:	7c 00 01 46 	wrteei  0
fff824a8:	7d 41 49 2e 	stwx    r10,r1,r9
fff824ac:	7c 21 4a 14 	add     r1,r1,r9
fff824b0:	7c 00 01 24 	mtmsr   r0

        for(iCount = 0; iCount < bitCount; iCount++)
fff824b4:	39 00 00 00 	li      r8,0
        if(rem == 0)
            bitCount = quo;
        else
            bitCount = quo + 1;

        uint32_t bitArray[bitCount];
fff824b8:	3b a1 00 08 	addi    r29,r1,8
fff824bc:	7f a9 eb 78 	mr      r9,r29
fff824c0:	39 43 00 08 	addi    r10,r3,8

        for(iCount = 0; iCount < bitCount; iCount++)
fff824c4:	05 08 38 12 	cmplwbge r8,r7,fff824e8 <_Z10decompressPhS_+0xc8>
        {
            uint64_t temp = *(uint64_t *)compBuffer;
fff824c8:	80 03 00 00 	lwz     r0,0(r3)
fff824cc:	80 c3 00 04 	lwz     r6,4(r3)
            bitArray[iCount] = (uint32_t)(((temp) & 0xFFFFFFFF00000000LL) >> 32);
fff824d0:	90 09 00 00 	stw     r0,0(r9)
            ++iCount;
            bitArray[iCount] = (uint32_t)((temp) & 0xFFFFFFFFLL);
fff824d4:	90 c9 00 04 	stw     r6,4(r9)
            compBuffer = compBuffer + 8;
fff824d8:	7d 43 53 78 	mr      r3,r10
        else
            bitCount = quo + 1;

        uint32_t bitArray[bitCount];

        for(iCount = 0; iCount < bitCount; iCount++)
fff824dc:	39 08 00 02 	addi    r8,r8,2
fff824e0:	39 29 00 08 	addi    r9,r9,8
fff824e4:	4b ff ff dc 	b       fff824c0 <_Z10decompressPhS_+0xa0>
            ++iCount;
            bitArray[iCount] = (uint32_t)((temp) & 0xFFFFFFFFLL);
            compBuffer = compBuffer + 8;
        }

        uint64_t eightByte = *(uint64_t *)compBuffer;
fff824e8:	15 03 00 00 	lvd     d8,0(r3)
        {
            //Extract a bit from 32 bit integer.
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
                j = rem/4 -1;
fff824ec:	7f 89 02 a6 	mfctr   r28
            ++iCount;
            bitArray[iCount] = (uint32_t)((temp) & 0xFFFFFFFFLL);
            compBuffer = compBuffer + 8;
        }

        uint64_t eightByte = *(uint64_t *)compBuffer;
fff824f0:	19 1f 04 08 	stvd    d8,1032(r31)
        for(iCount = 0; iCount < bitCount ; iCount++)
        {
            //Extract a bit from 32 bit integer.
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
fff824f4:	38 07 ff ff 	addi    r0,r7,-1
                j = rem/4 -1;
fff824f8:	57 89 f0 be 	rlwinm  r9,r28,30,2,31
fff824fc:	39 29 ff ff 	addi    r9,r9,-1
        for(iCount = 0; iCount < bitCount ; iCount++)
        {
            //Extract a bit from 32 bit integer.
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
fff82500:	90 1f 04 20 	stw     r0,1056(r31)
                j = rem/4 -1;
fff82504:	91 3f 04 1c 	stw     r9,1052(r31)
        uint64_t eightByte = *(uint64_t *)compBuffer;
        uint8_t *ptr = (uint8_t *)&eightByte;
        compBuffer = compBuffer + 8;
        uint32_t kCount = 0;

        for(iCount = 0; iCount < bitCount ; iCount++)
fff82508:	38 c0 00 00 	li      r6,0
        }

        uint64_t eightByte = *(uint64_t *)compBuffer;
        uint8_t *ptr = (uint8_t *)&eightByte;
        compBuffer = compBuffer + 8;
        uint32_t kCount = 0;
fff8250c:	39 20 00 00 	li      r9,0

        for(iCount = 0; iCount < bitCount ; iCount++)
fff82510:	04 c6 38 74 	cmpwbeq r6,r7,fff825f8 <_Z10decompressPhS_+0x1d8>
        {
            //Extract a bit from 32 bit integer.
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
fff82514:	81 1f 04 20 	lwz     r8,1056(r31)
        uint32_t kCount = 0;

        for(iCount = 0; iCount < bitCount ; iCount++)
        {
            //Extract a bit from 32 bit integer.
            int32_t j = 31;
fff82518:	38 60 00 1f 	li      r3,31
fff8251c:	90 7f 04 24 	stw     r3,1060(r31)

            if((iCount == bitCount - 1) && (rem != 0))
fff82520:	04 46 40 0a 	cmpwbne r6,r8,fff82534 <_Z10decompressPhS_+0x114>
fff82524:	7f 89 02 a6 	mfctr   r28
fff82528:	06 dc 00 06 	bwz     r28,fff82534 <_Z10decompressPhS_+0x114>
                j = rem/4 -1;
fff8252c:	80 1f 04 1c 	lwz     r0,1052(r31)
fff82530:	90 1f 04 24 	stw     r0,1060(r31)
fff82534:	54 c3 10 3a 	rlwinm  r3,r6,2,0,29
fff82538:	90 7f 04 18 	stw     r3,1048(r31)
                        ++kCount;
                        if(kCount == 8)
                        {
                            eightByte = *(uint64_t *)compBuffer;
                            compBuffer = compBuffer + 8;
                            kCount = 0;
fff8253c:	80 7f 04 24 	lwz     r3,1060(r31)
fff82540:	3b c4 00 04 	addi    r30,r4,4
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
                j = rem/4 -1;

            for (jCount = j; jCount >= 0; jCount--)
fff82544:	2c 03 ff ff 	cmpwi   r3,-1
fff82548:	41 82 00 98 	beq     fff825e0 <_Z10decompressPhS_+0x1c0>
            {
                char isCompressed = (bitArray[iCount] >> jCount) & 1;
fff8254c:	81 1f 04 18 	lwz     r8,1048(r31)
fff82550:	3b 9e ff fb 	addi    r28,r30,-5
fff82554:	7c 1d 40 2e 	lwzx    r0,r29,r8
fff82558:	7c 08 1c 30 	srw     r8,r0,r3
                        ++kCount;
                        if(kCount == 8)
                        {
                            eightByte = *(uint64_t *)compBuffer;
                            compBuffer = compBuffer + 8;
                            kCount = 0;
fff8255c:	38 00 00 04 	li      r0,4
fff82560:	7c 08 03 a6 	mtlr    r0
                j = rem/4 -1;

            for (jCount = j; jCount >= 0; jCount--)
            {
                char isCompressed = (bitArray[iCount] >> jCount) & 1;
                if(isCompressed == 1)
fff82564:	07 88 f8 22 	bb0wi   r8,31,fff825a8 <_Z10decompressPhS_+0x188>
                {
                    //Read a byte.
                    uint8_t index = *(ptr + kCount);
fff82568:	7f 85 4a 14 	add     r28,r5,r9
                    ++kCount;
fff8256c:	39 29 00 01 	addi    r9,r9,1
            {
                char isCompressed = (bitArray[iCount] >> jCount) & 1;
                if(isCompressed == 1)
                {
                    //Read a byte.
                    uint8_t index = *(ptr + kCount);
fff82570:	88 1c 04 00 	lbz     r0,1024(r28)
                    ++kCount;
                    if(kCount == 8)
fff82574:	06 49 40 0a 	cmpwibne r9,8,fff82588 <_Z10decompressPhS_+0x168>
                    {
                        eightByte = *(uint64_t *)compBuffer;
fff82578:	15 0a 00 00 	lvd     d8,0(r10)
                        compBuffer = compBuffer + 8;
fff8257c:	39 4a 00 08 	addi    r10,r10,8
                    //Read a byte.
                    uint8_t index = *(ptr + kCount);
                    ++kCount;
                    if(kCount == 8)
                    {
                        eightByte = *(uint64_t *)compBuffer;
fff82580:	19 1f 04 08 	stvd    d8,1032(r31)
                        compBuffer = compBuffer + 8;
                        kCount = 0;
fff82584:	39 20 00 00 	li      r9,0
                    }
                    uint32_t value = dict[index];
fff82588:	54 00 10 3a 	rlwinm  r0,r0,2,0,29
	            uint32_t * pTemp = (uint32_t *) decompBuffer;
                    *pTemp = value; 
fff8258c:	7c 05 00 2e 	lwzx    r0,r5,r0
fff82590:	90 1e ff fc 	stw     r0,-4(r30)
fff82594:	48 00 00 40 	b       fff825d4 <_Z10decompressPhS_+0x1b4>
                }
                else
                {
                    //Read four bytes.
                    uint8_t i;
                    for(i = 0; i < 4; i++)
fff82598:	7c 08 02 a6 	mflr    r0
fff8259c:	34 00 ff ff 	addic.  r0,r0,-1
fff825a0:	7c 08 03 a6 	mtlr    r0
fff825a4:	41 82 00 30 	beq     fff825d4 <_Z10decompressPhS_+0x1b4>
                    {
                        *decompBuffer = *(ptr + kCount);
fff825a8:	7c 05 4a 14 	add     r0,r5,r9
fff825ac:	7c 08 03 78 	mr      r8,r0
fff825b0:	88 08 04 00 	lbz     r0,1024(r8)
                        ++kCount;
fff825b4:	39 29 00 01 	addi    r9,r9,1
                {
                    //Read four bytes.
                    uint8_t i;
                    for(i = 0; i < 4; i++)
                    {
                        *decompBuffer = *(ptr + kCount);
fff825b8:	9c 1c 00 01 	stbu    r0,1(r28)
                        ++kCount;
                        if(kCount == 8)
fff825bc:	06 49 47 ee 	cmpwibne r9,8,fff82598 <_Z10decompressPhS_+0x178>
                        {
                            eightByte = *(uint64_t *)compBuffer;
fff825c0:	15 0a 00 00 	lvd     d8,0(r10)
                            compBuffer = compBuffer + 8;
fff825c4:	39 4a 00 08 	addi    r10,r10,8
                    {
                        *decompBuffer = *(ptr + kCount);
                        ++kCount;
                        if(kCount == 8)
                        {
                            eightByte = *(uint64_t *)compBuffer;
fff825c8:	19 1f 04 08 	stvd    d8,1032(r31)
                            compBuffer = compBuffer + 8;
                            kCount = 0;
fff825cc:	39 20 00 00 	li      r9,0
fff825d0:	4b ff ff c8 	b       fff82598 <_Z10decompressPhS_+0x178>
            int32_t j = 31;

            if((iCount == bitCount - 1) && (rem != 0))
                j = rem/4 -1;

            for (jCount = j; jCount >= 0; jCount--)
fff825d4:	38 63 ff ff 	addi    r3,r3,-1
fff825d8:	3b de 00 04 	addi    r30,r30,4
fff825dc:	4b ff ff 68 	b       fff82544 <_Z10decompressPhS_+0x124>
fff825e0:	80 7f 04 24 	lwz     r3,1060(r31)
        uint64_t eightByte = *(uint64_t *)compBuffer;
        uint8_t *ptr = (uint8_t *)&eightByte;
        compBuffer = compBuffer + 8;
        uint32_t kCount = 0;

        for(iCount = 0; iCount < bitCount ; iCount++)
fff825e4:	38 c6 00 01 	addi    r6,r6,1
fff825e8:	39 03 00 01 	addi    r8,r3,1
fff825ec:	55 08 10 3a 	rlwinm  r8,r8,2,0,29
fff825f0:	7c 84 42 14 	add     r4,r4,r8
fff825f4:	4b ff ff 1c 	b       fff82510 <_Z10decompressPhS_+0xf0>
                }// else
            }// loop ends for (jCount = j; jCount >= 0; jCount--)
        }//loops ends for (iCount = 0; iCount < bitCount ; iCount++)
    } while(0);
   return rc;
}
fff825f8:	39 5f 04 38 	addi    r10,r31,1080
fff825fc:	80 0a 00 04 	lwz     r0,4(r10)
fff82600:	17 ca ff f8 	lvd     d30,-8(r10)
fff82604:	7c 08 03 a6 	mtlr    r0
fff82608:	38 60 00 00 	li      r3,0
fff8260c:	17 8a ff f0 	lvd     d28,-16(r10)
fff82610:	7d 41 53 78 	mr      r1,r10
fff82614:	4e 80 00 20 	blr

fff82618 <jump2verificationImage>:

/*
 * API to jump to verification code.
 */
void jump2verificationImage(uint32_t i_pkBootAddr, uint32_t i_ivprAddr)
{
fff82618:	94 21 ff f0 	stwu    r1,-16(r1)
fff8261c:	7c 08 02 a6 	mflr    r0
fff82620:	1b c1 00 08 	stvd    d30,8(r1)
fff82624:	90 01 00 14 	stw     r0,20(r1)
fff82628:	7c 7f 1b 78 	mr      r31,r3
fff8262c:	7c 9e 23 78 	mr      r30,r4
    if(!SBE::isSimicsRunning())
fff82630:	48 00 00 6d 	bl      fff8269c <_ZN3SBE15isSimicsRunningEv>
fff82634:	06 43 00 0c 	bwnz    r3,fff8264c <jump2verificationImage+0x34>
    {
        // Set the IVPR register. This is required so that interrupt vector table
        // points to pk interfaces.
        uint64_t data = (uint64_t)i_ivprAddr << 32;
        PPE_STVD(0xc0000160, data);
fff82638:	3d 40 c0 00 	lis     r10,-16384
{
    if(!SBE::isSimicsRunning())
    {
        // Set the IVPR register. This is required so that interrupt vector table
        // points to pk interfaces.
        uint64_t data = (uint64_t)i_ivprAddr << 32;
fff8263c:	7f c8 f3 78 	mr      r8,r30
fff82640:	39 20 00 00 	li      r9,0
        PPE_STVD(0xc0000160, data);
fff82644:	61 4a 01 60 	ori     r10,r10,352
fff82648:	19 0a 00 00 	stvd    d8,0(r10)
    }
    asm volatile ( "mr %0, %1" : : "i" (6), "r" (i_pkBootAddr) : "memory" );
fff8264c:	7f e6 fb 78 	mr      r6,r31
    asm(
            "mtctr %r6\n"
            "bctr\n"
       );
fff82650:	7c c9 03 a6 	mtctr   r6
fff82654:	4e 80 04 20 	bctr
}
fff82658:	80 01 00 14 	lwz     r0,20(r1)
fff8265c:	17 c1 00 08 	lvd     d30,8(r1)
fff82660:	7c 08 03 a6 	mtlr    r0
fff82664:	38 21 00 10 	addi    r1,r1,16
fff82668:	4e 80 00 20 	blr

fff8266c <_Z26loadSectionForVerificationPyS_>:
} // end extern "C"

int32_t loadSectionForVerification( uint64_t *i_srcAddr, uint64_t *i_destAddr )
{
fff8266c:	94 21 ff f8 	stwu    r1,-8(r1)
fff82670:	7c 08 02 a6 	mflr    r0
fff82674:	90 01 00 0c 	stw     r0,12(r1)
    uint32_t rc = 0;
    do {
         uint8_t rc = decompress((uint8_t *)i_srcAddr, (uint8_t *)i_destAddr);
fff82678:	4b ff fd a9 	bl      fff82420 <_Z10decompressPhS_>
         if (rc != 0 )
           break;
       } while(0);
    return rc;
}
fff8267c:	80 01 00 0c 	lwz     r0,12(r1)
fff82680:	38 60 00 00 	li      r3,0
fff82684:	7c 08 03 a6 	mtlr    r0
fff82688:	38 21 00 08 	addi    r1,r1,8
fff8268c:	4e 80 00 20 	blr

fff82690 <_ZN3SBE8isSimicsEv>:
    bool isSimics() __attribute__((alias("__isSimicsRunning")));
    extern "C" void __isSimicsRunning() __attribute__ ((noinline));

    void __isSimicsRunning()
    {
        asm volatile("li 3, 0");
fff82690:	38 60 00 00 	li      r3,0
{
    register int n = _n;
    asm volatile("rlwimi %0,%0,0,%1,%2"       \
        :: "i" (((n) >> 8) & 0x1f),           \
        "i" (((n) >> 4) & 0xf),               \
        "i" ((((n) >> 0) & 0xf) | 16));
fff82694:	53 ff 01 20 	rlwimi  r31,r31,0,4,16
fff82698:	4e 80 00 20 	blr

fff8269c <_ZN3SBE15isSimicsRunningEv>:
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fff8269c:	89 2d 40 38 	lbz     r9,16440(r13)
fff826a0:	7d 29 07 74 	extsb   r9,r9
fff826a4:	06 49 00 1a 	bwnz    r9,fff826d8 <_ZN3SBE15isSimicsRunningEv+0x3c>
        asm volatile("li 3, 0");
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
fff826a8:	94 21 ff f8 	stwu    r1,-8(r1)
fff826ac:	7c 08 02 a6 	mflr    r0
fff826b0:	90 01 00 0c 	stw     r0,12(r1)
        static bool simics = isSimics();
fff826b4:	4b ff ff dd 	bl      fff82690 <_ZN3SBE8isSimicsEv>
        return simics;
    }
fff826b8:	80 01 00 0c 	lwz     r0,12(r1)
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fff826bc:	98 6d 40 30 	stb     r3,16432(r13)
        return simics;
    }
fff826c0:	7c 08 03 a6 	mtlr    r0
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fff826c4:	39 20 00 01 	li      r9,1
        return simics;
    }
fff826c8:	88 6d 40 30 	lbz     r3,16432(r13)
        SBE_MAGIC_INSTRUCTION(MAGIC_SIMICS_CHECK);
    }

    bool isSimicsRunning()
    {
        static bool simics = isSimics();
fff826cc:	99 2d 40 38 	stb     r9,16440(r13)
        return simics;
    }
fff826d0:	38 21 00 08 	addi    r1,r1,8
fff826d4:	4e 80 00 20 	blr
fff826d8:	88 6d 40 30 	lbz     r3,16432(r13)
fff826dc:	4e 80 00 20 	blr

fff826e0 <_ZN19SBEGlobalsSingleton11getInstanceEv>:
uint8_t sbeAsyncCommandProcessor_stack[SBE_THREAD_ASYNC_CMD_PROC_STACK_SIZE];

SBEGlobalsSingleton* sbeGlobal = &SBEGlobalsSingleton::getInstance();
SBEGlobalsSingleton& SBEGlobalsSingleton::getInstance()
{
    static SBEGlobalsSingleton iv_instance;
fff826e0:	89 2d 40 40 	lbz     r9,16448(r13)
fff826e4:	3c 60 ff f9 	lis     r3,-7
fff826e8:	7d 29 07 74 	extsb   r9,r9
fff826ec:	38 63 a7 18 	addi    r3,r3,-22760
fff826f0:	06 49 00 54 	bwnz    r9,fff82798 <_ZN19SBEGlobalsSingleton11getInstanceEv+0xb8>
    sbeStashMemoryPair()
    {
        for(uint8_t cnt=0; cnt<MAX_ROW_COUNT; cnt++)
        {
            keyValuePairfromHost.addr[cnt] = 0xFFFFFFFFFFFFFFFFULL;
            keyValuePairfromHost.key[cnt] = 0xFF;
fff826f4:	39 00 00 08 	li      r8,8
fff826f8:	7d 09 03 a6 	mtctr   r8
            sbeSemCmdProcess(),
            sbeSemAsyncProcess(),
            SBERole(SBE_ROLE_MASTER),
            sbefreq(( 133 * 1000 * 1000)/SBE::SBE_TO_NEST_FREQ_FACTOR),
            sbeFWSecurityEnabled(1),
            sbeDmtStateComplete(0)
fff826fc:	b1 23 00 08 	sth     r9,8(r3)
fff82700:	b1 23 00 0a 	sth     r9,10(r3)
fff82704:	91 23 00 24 	stw     r9,36(r3)
fff82708:	91 23 00 28 	stw     r9,40(r3)
fff8270c:	91 23 00 2c 	stw     r9,44(r3)
fff82710:	91 23 00 30 	stw     r9,48(r3)
fff82714:	91 23 00 34 	stw     r9,52(r3)
fff82718:	91 23 00 38 	stw     r9,56(r3)
fff8271c:	91 23 00 3c 	stw     r9,60(r3)
fff82720:	91 23 00 40 	stw     r9,64(r3)
fff82724:	91 23 00 44 	stw     r9,68(r3)
fff82728:	91 23 00 54 	stw     r9,84(r3)
fff8272c:	3d 20 01 fb 	lis     r9,507
fff82730:	38 c0 00 00 	li      r6,0
fff82734:	38 e0 00 00 	li      r7,0
fff82738:	39 40 00 00 	li      r10,0
fff8273c:	61 29 5a d0 	ori     r9,r9,23248
fff82740:	18 c3 00 00 	stvd    d6,0(r3)
fff82744:	18 c3 00 10 	stvd    d6,16(r3)
fff82748:	18 c3 00 18 	stvd    d6,24(r3)
fff8274c:	99 43 00 20 	stb     r10,32(r3)
fff82750:	99 43 00 21 	stb     r10,33(r3)
fff82754:	99 43 00 22 	stb     r10,34(r3)
fff82758:	91 23 00 58 	stw     r9,88(r3)
fff8275c:	39 43 00 80 	addi    r10,r3,128
fff82760:	39 20 00 00 	li      r9,0
    // Default Constructor to initialize addr/key to 0xFF
    sbeStashMemoryPair()
    {
        for(uint8_t cnt=0; cnt<MAX_ROW_COUNT; cnt++)
        {
            keyValuePairfromHost.addr[cnt] = 0xFFFFFFFFFFFFFFFFULL;
fff82764:	38 c0 ff ff 	li      r6,-1
fff82768:	38 e0 ff ff 	li      r7,-1
            keyValuePairfromHost.key[cnt] = 0xFF;
fff8276c:	38 a0 ff ff 	li      r5,-1
fff82770:	7d 03 4a 14 	add     r8,r3,r9
    // Default Constructor to initialize addr/key to 0xFF
    sbeStashMemoryPair()
    {
        for(uint8_t cnt=0; cnt<MAX_ROW_COUNT; cnt++)
        {
            keyValuePairfromHost.addr[cnt] = 0xFFFFFFFFFFFFFFFFULL;
fff82774:	58 ca 00 08 	stvdu   d6,8(r10)
fff82778:	39 29 00 01 	addi    r9,r9,1
            keyValuePairfromHost.key[cnt] = 0xFF;
fff8277c:	98 a8 00 80 	stb     r5,128(r8)
fff82780:	42 00 ff f0 	bdnz    fff82770 <_ZN19SBEGlobalsSingleton11getInstanceEv+0x90>
fff82784:	39 20 00 01 	li      r9,1
fff82788:	39 40 00 00 	li      r10,0
fff8278c:	99 23 00 c8 	stb     r9,200(r3)
fff82790:	91 43 00 d0 	stw     r10,208(r3)
fff82794:	99 2d 40 40 	stb     r9,16448(r13)
    return iv_instance;
}
fff82798:	4e 80 00 20 	blr

fff8279c <_GLOBAL__sub_I_sbe_Kernel_NCInt_stack>:
uint8_t  SBEGlobalsSingleton::failedCmd        = 0;

bool  SBEGlobalsSingleton::isHreset = false;

#ifdef SBE_CONSOLE_SUPPORT
bool SBEGlobalsSingleton::sbeUartActive = false;
fff8279c:	94 21 ff f8 	stwu    r1,-8(r1)
fff827a0:	7c 08 02 a6 	mflr    r0
fff827a4:	90 01 00 0c 	stw     r0,12(r1)
uint8_t sbe_Kernel_NCInt_stack[SBE_NONCRITICAL_STACK_SIZE];
uint8_t sbeCommandReceiver_stack[SBE_THREAD_CMD_RECV_STACK_SIZE];
uint8_t sbeSyncCommandProcessor_stack[SBE_THREAD_SYNC_CMD_PROC_STACK_SIZE];
uint8_t sbeAsyncCommandProcessor_stack[SBE_THREAD_ASYNC_CMD_PROC_STACK_SIZE];

SBEGlobalsSingleton* sbeGlobal = &SBEGlobalsSingleton::getInstance();
fff827a8:	4b ff ff 39 	bl      fff826e0 <_ZN19SBEGlobalsSingleton11getInstanceEv>
uint8_t  SBEGlobalsSingleton::failedCmd        = 0;

bool  SBEGlobalsSingleton::isHreset = false;

#ifdef SBE_CONSOLE_SUPPORT
bool SBEGlobalsSingleton::sbeUartActive = false;
fff827ac:	80 01 00 0c 	lwz     r0,12(r1)
uint8_t sbe_Kernel_NCInt_stack[SBE_NONCRITICAL_STACK_SIZE];
uint8_t sbeCommandReceiver_stack[SBE_THREAD_CMD_RECV_STACK_SIZE];
uint8_t sbeSyncCommandProcessor_stack[SBE_THREAD_SYNC_CMD_PROC_STACK_SIZE];
uint8_t sbeAsyncCommandProcessor_stack[SBE_THREAD_ASYNC_CMD_PROC_STACK_SIZE];

SBEGlobalsSingleton* sbeGlobal = &SBEGlobalsSingleton::getInstance();
fff827b0:	90 6d 40 48 	stw     r3,16456(r13)
uint8_t  SBEGlobalsSingleton::failedCmd        = 0;

bool  SBEGlobalsSingleton::isHreset = false;

#ifdef SBE_CONSOLE_SUPPORT
bool SBEGlobalsSingleton::sbeUartActive = false;
fff827b4:	7c 08 03 a6 	mtlr    r0
fff827b8:	38 21 00 08 	addi    r1,r1,8
fff827bc:	4e 80 00 20 	blr

fff827c0 <_ZN18securityState_PCR66updateEm>:
#include "p10_scom_proc_f.H"
#include "sha512.H"
#include "sbestates.H"

void securityState_PCR6::update(uint32_t sbe_role)
{
fff827c0:	94 21 ff e0 	stwu    r1,-32(r1)
fff827c4:	7c 08 02 a6 	mflr    r0
fff827c8:	7c 24 0b 78 	mr      r4,r1
fff827cc:	39 00 00 00 	li      r8,0
fff827d0:	39 20 00 00 	li      r9,0
fff827d4:	90 01 00 24 	stw     r0,36(r1)
fff827d8:	1b c1 00 18 	stvd    d30,24(r1)
fff827dc:	7c 7f 1b 78 	mr      r31,r3
fff827e0:	59 04 00 08 	stvdu   d8,8(r4)
    SBEM_ENTER(SBEM_FUNC);

    fapi2::buffer<uint64_t> cbs_cs_reg;

    //Fetch Jumper state
    getscom_abs(scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
fff827e4:	3c 60 00 05 	lis     r3,5
fff827e8:	60 63 00 01 	ori     r3,r3,1
fff827ec:	48 00 02 25 	bl      fff82a10 <getscom_abs>
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff827f0:	15 01 00 08 	lvd     d8,8(r1)
    jumperState = cbs_cs_reg.getBit<5>();

    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);
fff827f4:	38 60 00 15 	li      r3,21
fff827f8:	79 08 36 a0 	rldicl  d8,d8,6,58
fff827fc:	55 29 07 fe 	clrlwi  r9,r9,31

    fapi2::buffer<uint64_t> cbs_cs_reg;

    //Fetch Jumper state
    getscom_abs(scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
    jumperState = cbs_cs_reg.getBit<5>();
fff82800:	99 3f 00 00 	stb     r9,0(r31)

    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);
fff82804:	48 00 31 61 	bl      fff85964 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fff82808:	88 a3 00 40 	lbz     r5,64(r3)
    SBEM_INFO("MinimumSecureVersion: [%d]  Jumper State: [%d]", minimumSecureVersion, jumperState);
fff8280c:	88 df 00 00 	lbz     r6,0(r31)
    //Fetch Jumper state
    getscom_abs(scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
    jumperState = cbs_cs_reg.getBit<5>();

    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);
fff82810:	98 bf 00 01 	stb     r5,1(r31)
    SBEM_INFO("MinimumSecureVersion: [%d]  Jumper State: [%d]", minimumSecureVersion, jumperState);
fff82814:	3c 60 1a 4c 	lis     r3,6732
fff82818:	60 63 00 02 	ori     r3,r3,2
fff8281c:	38 e0 00 00 	li      r7,0
fff82820:	39 00 00 00 	li      r8,0
fff82824:	48 00 08 41 	bl      fff83064 <pk_trace_big>

    SBEM_EXIT(SBEM_FUNC);
    #undef SBEM_FUNC
}
fff82828:	80 01 00 24 	lwz     r0,36(r1)
fff8282c:	17 c1 00 18 	lvd     d30,24(r1)
fff82830:	7c 08 03 a6 	mtlr    r0
fff82834:	38 21 00 20 	addi    r1,r1,32
fff82838:	4e 80 00 20 	blr

fff8283c <_ZN18securityState_PCR16updateEm>:

void securityState_PCR1::update(uint32_t sbe_role)
{
fff8283c:	94 21 ff e0 	stwu    r1,-32(r1)
fff82840:	7c 08 02 a6 	mflr    r0
fff82844:	1b c1 00 18 	stvd    d30,24(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff82848:	39 00 00 00 	li      r8,0
fff8284c:	39 20 00 00 	li      r9,0
fff82850:	7c 9e 23 78 	mr      r30,r4
fff82854:	7c 24 0b 78 	mr      r4,r1
fff82858:	90 01 00 24 	stw     r0,36(r1)
fff8285c:	7c 7f 1b 78 	mr      r31,r3
fff82860:	59 04 00 08 	stvdu   d8,8(r4)
    fapi2::buffer<uint64_t> MSMLockReg;
    fapi2::buffer<uint64_t> cbs_cs_reg;
    sbe_local_LFR lfrReg;

    //Fetch Jumper state
    getscom_abs(scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
fff82864:	3c 60 00 05 	lis     r3,5
fff82868:	60 63 00 01 	ori     r3,r3,1
fff8286c:	19 01 00 10 	stvd    d8,16(r1)
fff82870:	48 00 01 a1 	bl      fff82a10 <getscom_abs>
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff82874:	15 01 00 08 	lvd     d8,8(r1)
fff82878:	79 08 36 a0 	rldicl  d8,d8,6,58
fff8287c:	55 29 07 fe 	clrlwi  r9,r9,31
    jumperState = cbs_cs_reg.getBit<5>();

    //Fetch the MPIPL state from LFR
    PPE_LVD(0xc0002040, lfrReg);
fff82880:	3d 00 c0 00 	lis     r8,-16384
    fapi2::buffer<uint64_t> cbs_cs_reg;
    sbe_local_LFR lfrReg;

    //Fetch Jumper state
    getscom_abs(scomt::perv::FSXCOMP_FSXLOG_CBS_CS, &cbs_cs_reg());
    jumperState = cbs_cs_reg.getBit<5>();
fff82884:	99 3f 00 00 	stb     r9,0(r31)

    //Fetch the MPIPL state from LFR
    PPE_LVD(0xc0002040, lfrReg);
fff82888:	61 08 20 40 	ori     r8,r8,8256
fff8288c:	15 08 00 00 	lvd     d8,0(r8)
    if (lfrReg.mpipl)
fff82890:	07 88 70 0a 	bb0wi   r8,14,fff828a4 <_ZN18securityState_PCR16updateEm+0x68>
    {
        isMpipl = 0x1;
fff82894:	89 3f 00 01 	lbz     r9,1(r31)
fff82898:	55 29 00 36 	rlwinm  r9,r9,0,0,27
fff8289c:	61 29 00 01 	ori     r9,r9,1
fff828a0:	99 3f 00 01 	stb     r9,1(r31)
    }

    //Check if primary proc
    if(sbe_role == SBE_ROLE_MASTER)
fff828a4:	06 5e 00 0a 	bwnz    r30,fff828b8 <_ZN18securityState_PCR16updateEm+0x7c>
    {
        isPrimary = 0x1;
fff828a8:	89 3f 00 01 	lbz     r9,1(r31)
fff828ac:	55 29 07 3e 	clrlwi  r9,r9,28
fff828b0:	61 29 00 10 	ori     r9,r9,16
fff828b4:	99 3f 00 01 	stb     r9,1(r31)
    }

    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);
fff828b8:	38 60 00 15 	li      r3,21
fff828bc:	48 00 30 a9 	bl      fff85964 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>
fff828c0:	89 23 00 40 	lbz     r9,64(r3)

    //Fetch Measurement Seeprom Lock
    getscom_abs(scomt::proc::TP_TPCHIP_PIB_OTP_OTPC_M_EXPORT_REGL_STATUS, &MSMLockReg());
fff828c4:	3c 60 00 01 	lis     r3,1
    {
        isPrimary = 0x1;
    }

    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);
fff828c8:	99 3f 00 03 	stb     r9,3(r31)

    //Fetch Measurement Seeprom Lock
    getscom_abs(scomt::proc::TP_TPCHIP_PIB_OTP_OTPC_M_EXPORT_REGL_STATUS, &MSMLockReg());
fff828cc:	38 81 00 10 	addi    r4,r1,16
fff828d0:	60 63 00 09 	ori     r3,r3,9
fff828d4:	48 00 01 3d 	bl      fff82a10 <getscom_abs>
fff828d8:	15 01 00 10 	lvd     d8,16(r1)
    mSeepromLock = MSMLockReg.getBit<12>();

    //Fetch Measurement Image version
    mSeepromVersion = *(uint32_t*)(getXipOffsetAbsMeasurement(P9_XIP_SECTION_SBE_SB_SETTINGS));
fff828dc:	38 60 00 15 	li      r3,21
fff828e0:	79 08 6c e0 	rldicl  d8,d8,13,51
fff828e4:	55 29 07 fe 	clrlwi  r9,r9,31
    //Fetch Minimum Secure Version
    minimumSecureVersion = *(uint8_t*)(getXipOffsetAbs(P9_XIP_SECTION_SBE_SB_SETTINGS) + SHA512_DIGEST_LENGTH);

    //Fetch Measurement Seeprom Lock
    getscom_abs(scomt::proc::TP_TPCHIP_PIB_OTP_OTPC_M_EXPORT_REGL_STATUS, &MSMLockReg());
    mSeepromLock = MSMLockReg.getBit<12>();
fff828e8:	99 3f 00 02 	stb     r9,2(r31)

    //Fetch Measurement Image version
    mSeepromVersion = *(uint32_t*)(getXipOffsetAbsMeasurement(P9_XIP_SECTION_SBE_SB_SETTINGS));
fff828ec:	48 00 30 9d 	bl      fff85988 <_Z26getXipOffsetAbsMeasurement20p9_xip_section_sbe_t>
fff828f0:	81 23 00 00 	lwz     r9,0(r3)
    SBEM_INFO("Jumper State: [%d] Primary Proc: [%d]  MeasurementSeepromLock: [%d] "
fff828f4:	80 df 00 00 	lwz     r6,0(r31)
    //Fetch Measurement Seeprom Lock
    getscom_abs(scomt::proc::TP_TPCHIP_PIB_OTP_OTPC_M_EXPORT_REGL_STATUS, &MSMLockReg());
    mSeepromLock = MSMLockReg.getBit<12>();

    //Fetch Measurement Image version
    mSeepromVersion = *(uint32_t*)(getXipOffsetAbsMeasurement(P9_XIP_SECTION_SBE_SB_SETTINGS));
fff828f8:	91 3f 00 04 	stw     r9,4(r31)
    SBEM_INFO("Jumper State: [%d] Primary Proc: [%d]  MeasurementSeepromLock: [%d] "
        "Minimum Secure Version: [%d]", jumperState, isPrimary, mSeepromLock, minimumSecureVersion);
fff828fc:	88 bf 00 00 	lbz     r5,0(r31)
fff82900:	88 ff 00 02 	lbz     r7,2(r31)
fff82904:	89 1f 00 03 	lbz     r8,3(r31)
fff82908:	3c 60 31 cb 	lis     r3,12747
fff8290c:	60 63 00 04 	ori     r3,r3,4
fff82910:	54 c6 67 3e 	rlwinm  r6,r6,12,28,31
fff82914:	48 00 07 51 	bl      fff83064 <pk_trace_big>
    SBEM_INFO("Measurement Image Version [0x%08X]", mSeepromVersion);
fff82918:	80 bf 00 04 	lwz     r5,4(r31)
fff8291c:	3c 60 09 66 	lis     r3,2406
fff82920:	60 63 00 01 	ori     r3,r3,1
fff82924:	38 c0 00 00 	li      r6,0
fff82928:	38 e0 00 00 	li      r7,0
fff8292c:	39 00 00 00 	li      r8,0
fff82930:	48 00 07 35 	bl      fff83064 <pk_trace_big>

    SBEM_EXIT(SBEM_FUNC);
    #undef SBEM_FUNC
}
fff82934:	80 01 00 24 	lwz     r0,36(r1)
fff82938:	17 c1 00 18 	lvd     d30,24(r1)
fff8293c:	7c 08 03 a6 	mtlr    r0
fff82940:	38 21 00 20 	addi    r1,r1,32
fff82944:	4e 80 00 20 	blr

fff82948 <__divsi3>:
// if DERP/DORP not available then use __udivsi3/_umodsi3 defined in div32.S
// by including div32.o in your objects.

// 32 bit signed divide
int __divsi3(int _a, int _b)
{
fff82948:	94 21 ff f0 	stwu    r1,-16(r1)
fff8294c:	7c 08 02 a6 	mflr    r0
fff82950:	1b c1 00 08 	stvd    d30,8(r1)
fff82954:	90 01 00 14 	stw     r0,20(r1)
fff82958:	7c 69 1b 78 	mr      r9,r3
fff8295c:	7c 8a 23 78 	mr      r10,r4
    register unsigned long neg = 0;

    if(_a & 0x80000000)
fff82960:	06 03 00 0a 	bwgez   r3,fff82974 <__divsi3+0x2c>
    {
        neg = !neg;
        _a = (~_a) + 1;
fff82964:	7d 23 00 d0 	neg     r9,r3
{
    register unsigned long neg = 0;

    if(_a & 0x80000000)
    {
        neg = !neg;
fff82968:	3b e0 00 01 	li      r31,1
        _a = (~_a) + 1;
    }

    if(_b & 0x80000000)
fff8296c:	06 04 00 14 	bwgez   r4,fff82994 <__divsi3+0x4c>
fff82970:	48 00 00 0c 	b       fff8297c <__divsi3+0x34>
fff82974:	06 04 00 16 	bwgez   r4,fff829a0 <__divsi3+0x58>
// by including div32.o in your objects.

// 32 bit signed divide
int __divsi3(int _a, int _b)
{
    register unsigned long neg = 0;
fff82978:	3b e0 00 00 	li      r31,0
    {
        _b = (~_b) + 1;
        neg = !neg;
    }

    int c = (int)__udivsi3((unsigned long)_a, (unsigned long)_b);
fff8297c:	7d 23 4b 78 	mr      r3,r9
fff82980:	7c 8a 00 d0 	neg     r4,r10
fff82984:	48 00 02 25 	bl      fff82ba8 <__udivsi3>

    if(neg)
fff82988:	06 df 08 16 	cmpwibeq r31,1,fff829b4 <__divsi3+0x6c>
    {
        c = (~c) + 1;
fff8298c:	7c 63 00 d0 	neg     r3,r3
fff82990:	48 00 00 24 	b       fff829b4 <__divsi3+0x6c>
    {
        _b = (~_b) + 1;
        neg = !neg;
    }

    int c = (int)__udivsi3((unsigned long)_a, (unsigned long)_b);
fff82994:	7d 23 4b 78 	mr      r3,r9
fff82998:	48 00 02 11 	bl      fff82ba8 <__udivsi3>
fff8299c:	4b ff ff f0 	b       fff8298c <__divsi3+0x44>
    {
        c = (~c) + 1;
    }

    return c;
}
fff829a0:	80 01 00 14 	lwz     r0,20(r1)
fff829a4:	17 c1 00 08 	lvd     d30,8(r1)
fff829a8:	7c 08 03 a6 	mtlr    r0
fff829ac:	38 21 00 10 	addi    r1,r1,16
    {
        _b = (~_b) + 1;
        neg = !neg;
    }

    int c = (int)__udivsi3((unsigned long)_a, (unsigned long)_b);
fff829b0:	48 00 01 f8 	b       fff82ba8 <__udivsi3>
    {
        c = (~c) + 1;
    }

    return c;
}
fff829b4:	80 01 00 14 	lwz     r0,20(r1)
fff829b8:	17 c1 00 08 	lvd     d30,8(r1)
fff829bc:	7c 08 03 a6 	mtlr    r0
fff829c0:	38 21 00 10 	addi    r1,r1,16
fff829c4:	4e 80 00 20 	blr

fff829c8 <__muldi3>:

#endif //__PPE42A__

// 64 bit signed multiply
unsigned long long __muldi3(unsigned long long _a, unsigned long long _b)
{
fff829c8:	7c 89 23 78 	mr      r9,r4
fff829cc:	7c 68 1b 78 	mr      r8,r3
    unsigned long long sum = 0;
fff829d0:	38 80 00 00 	li      r4,0
fff829d4:	38 60 00 00 	li      r3,0

    while(_a)
fff829d8:	7d 0a 4b 78 	or      r10,r8,r9
fff829dc:	06 ca 00 10 	bwz     r10,fff829fc <__muldi3+0x34>
    {
        if(_a & 1)
fff829e0:	55 2a 07 fe 	clrlwi  r10,r9,31
fff829e4:	06 ca 00 06 	bwz     r10,fff829f0 <__muldi3+0x28>
        {
            sum += _b;
fff829e8:	7c 84 30 14 	addc    r4,r4,r6
fff829ec:	7c 63 29 14 	adde    r3,r3,r5
        }

        _a >>= 1;
fff829f0:	79 08 f8 42 	rldicl  d8,d8,63,1
        _b <<= 1;
fff829f4:	78 a5 0f a4 	rldicr  d5,d5,1,62
fff829f8:	4b ff ff e0 	b       fff829d8 <__muldi3+0x10>
    }

    return sum;
}
fff829fc:	4e 80 00 20 	blr

fff82a00 <putscom_abs>:

uint32_t putscom_abs(const uint32_t i_address, uint64_t i_data)
{

    // Perform the Store Virtual Double instruction
    PPE_STVD(i_address, i_data);
fff82a00:	18 a3 00 00 	stvd    d5,0(r3)

    // Get the MSR[SIBRC] as the return code
    uint32_t rc = mfmsr();
fff82a04:	7c 60 00 a6 	mfmsr   r3
    rc = ((rc & MSR_SIBRC) >> (32 - (MSR_SIBRC_START_BIT + MSR_SIBRC_LEN)));
    return (rc);

}
fff82a08:	54 63 67 7e 	rlwinm  r3,r3,12,29,31
fff82a0c:	4e 80 00 20 	blr

fff82a10 <getscom_abs>:

uint32_t getscom_abs( const uint32_t i_address, uint64_t* o_data)
{
    uint64_t temp;
    // Perform the Load Virtual Double instruction
    PPE_LVD(i_address, temp);
fff82a10:	15 03 00 00 	lvd     d8,0(r3)
    PPE_STVD(o_data, temp);
fff82a14:	19 04 00 00 	stvd    d8,0(r4)

    // Get the MSR[SIBRC] as the return code
    uint32_t rc = mfmsr();
fff82a18:	7c 60 00 a6 	mfmsr   r3
    rc = ((rc & MSR_SIBRC) >> (32 - (MSR_SIBRC_START_BIT + MSR_SIBRC_LEN)));
    return (rc);
}
fff82a1c:	54 63 67 7e 	rlwinm  r3,r3,12,29,31
fff82a20:	4e 80 00 20 	blr

fff82a24 <memset>:
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
    uint32_t addr = (uint32_t)vdest;
fff82a24:	39 45 00 01 	addi    r10,r5,1
#ifdef __cplusplus
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
fff82a28:	94 21 ff e8 	stwu    r1,-24(r1)
    uint32_t addr = (uint32_t)vdest;
fff82a2c:	7d 49 03 a6 	mtctr   r10
#ifdef __cplusplus
extern "C"
{
#endif
void* memset(void* vdest, int ch, size_t len)
{
fff82a30:	1b 81 00 08 	stvd    d28,8(r1)
fff82a34:	1b c1 00 10 	stvd    d30,16(r1)
    uint32_t addr = (uint32_t)vdest;
fff82a38:	7c 69 1b 78 	mr      r9,r3
fff82a3c:	42 40 00 28 	bdz     fff82a64 <memset+0x40>

    while(len && (addr & 0x7)) // not 8 byte aligned
fff82a40:	55 2a 07 7e 	clrlwi  r10,r9,29
fff82a44:	06 ca 00 0a 	bwz     r10,fff82a58 <memset+0x34>
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
fff82a48:	98 89 00 00 	stb     r4,0(r9)
        ++addr;
        --len;
fff82a4c:	38 a5 ff ff 	addi    r5,r5,-1

    while(len && (addr & 0x7)) // not 8 byte aligned
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
        ++addr;
fff82a50:	39 29 00 01 	addi    r9,r9,1
fff82a54:	4b ff ff e8 	b       fff82a3c <memset+0x18>
        --len;
    }

    if(len >= sizeof(uint64_t))
fff82a58:	28 05 00 07 	cmplwi  r5,7
fff82a5c:	7c aa 2b 78 	mr      r10,r5
fff82a60:	41 a1 00 14 	bgt     fff82a74 <memset+0x50>
fff82a64:	38 a5 00 01 	addi    r5,r5,1
fff82a68:	39 40 00 00 	li      r10,0
fff82a6c:	7c a9 03 a6 	mtctr   r5
fff82a70:	48 00 00 68 	b       fff82ad8 <memset+0xb4>
fff82a74:	39 05 ff f8 	addi    r8,r5,-8
    {
        uint64_t lch = ch & 0xff;
fff82a78:	54 9f 06 3e 	clrlwi  r31,r4,24
fff82a7c:	3b c0 00 00 	li      r30,0
fff82a80:	55 08 e8 fe 	rlwinm  r8,r8,29,3,31
        lch |= lch << 8;
fff82a84:	7b dc 45 e4 	rldicr  d28,d30,8,55
fff82a88:	39 08 00 01 	addi    r8,r8,1
fff82a8c:	7f a7 fb 78 	or      r7,r29,r31
fff82a90:	7f 86 e3 78 	mr      r6,r28
fff82a94:	7d 09 03 a6 	mtctr   r8
        lch |= lch << 16;
fff82a98:	78 de 83 e4 	rldicr  d30,d6,16,47
fff82a9c:	7f e0 3b 78 	or      r0,r31,r7
fff82aa0:	7f c6 33 78 	or      r6,r30,r6
        lch |= lch << 32;
fff82aa4:	7c 06 33 78 	or      r6,r0,r6
fff82aa8:	38 e9 ff f8 	addi    r7,r9,-8
fff82aac:	39 07 00 08 	addi    r8,r7,8

        while(len >= sizeof(uint64_t))
        {
            uint64_t* p = (uint64_t*)addr;
            *p = lch;
fff82ab0:	90 c7 00 08 	stw     r6,8(r7)
fff82ab4:	90 07 00 0c 	stw     r0,12(r7)
fff82ab8:	7d 07 43 78 	mr      r7,r8
        uint64_t lch = ch & 0xff;
        lch |= lch << 8;
        lch |= lch << 16;
        lch |= lch << 32;

        while(len >= sizeof(uint64_t))
fff82abc:	42 00 ff f0 	bdnz    fff82aac <memset+0x88>
fff82ac0:	39 4a ff f8 	addi    r10,r10,-8
fff82ac4:	39 29 00 08 	addi    r9,r9,8
fff82ac8:	55 4a 00 38 	rlwinm  r10,r10,0,0,28
fff82acc:	54 a5 07 7e 	clrlwi  r5,r5,29
fff82ad0:	7d 29 52 14 	add     r9,r9,r10
fff82ad4:	4b ff ff 90 	b       fff82a64 <memset+0x40>
            len -= sizeof(uint64_t);
            addr += sizeof(uint64_t);
        }
    }

    while(len)
fff82ad8:	42 40 00 10 	bdz     fff82ae8 <memset+0xc4>
    {
        uint8_t* p = (uint8_t*)addr;
        *p = ch;
fff82adc:	7c 8a 49 ae 	stbx    r4,r10,r9
fff82ae0:	39 4a 00 01 	addi    r10,r10,1
fff82ae4:	4b ff ff f4 	b       fff82ad8 <memset+0xb4>
        ++addr;
        --len;
    }

    return vdest;
}
fff82ae8:	17 81 00 08 	lvd     d28,8(r1)
fff82aec:	17 c1 00 10 	lvd     d30,16(r1)
fff82af0:	38 21 00 18 	addi    r1,r1,24
fff82af4:	4e 80 00 20 	blr

fff82af8 <memcpy>:

    // Loop, copying 4 bytes
    long* ldest = (long*)vdest;
    const long* lsrc = (const long*)vsrc;

    while (len >= sizeof(long))
fff82af8:	54 a9 f0 be 	rlwinm  r9,r5,30,2,31
fff82afc:	39 29 00 01 	addi    r9,r9,1
fff82b00:	7d 29 03 a6 	mtctr   r9
fff82b04:	39 40 00 00 	li      r10,0
fff82b08:	42 40 00 14 	bdz     fff82b1c <memcpy+0x24>
    {
        *ldest++ = *lsrc++;
fff82b0c:	7d 24 50 2e 	lwzx    r9,r4,r10
fff82b10:	7d 23 51 2e 	stwx    r9,r3,r10
fff82b14:	39 4a 00 04 	addi    r10,r10,4
fff82b18:	4b ff ff f0 	b       fff82b08 <memcpy+0x10>
fff82b1c:	54 a9 07 be 	clrlwi  r9,r5,30
    }

    // Loop, copying 1 byte
    char* cdest = (char*)ldest;
    const char* csrc = (const char*)lsrc;
    size_t i = 0;
fff82b20:	39 29 00 01 	addi    r9,r9,1
fff82b24:	7d 29 03 a6 	mtctr   r9
fff82b28:	54 a5 00 3a 	rlwinm  r5,r5,0,0,29
fff82b2c:	7d 03 2a 14 	add     r8,r3,r5
fff82b30:	39 40 00 00 	li      r10,0
fff82b34:	7c a4 2a 14 	add     r5,r4,r5

    for (; i < len; ++i)
fff82b38:	42 40 00 14 	bdz     fff82b4c <memcpy+0x54>
    {
        cdest[i] = csrc[i];
fff82b3c:	7d 25 50 ae 	lbzx    r9,r5,r10
fff82b40:	7d 28 51 ae 	stbx    r9,r8,r10
    // Loop, copying 1 byte
    char* cdest = (char*)ldest;
    const char* csrc = (const char*)lsrc;
    size_t i = 0;

    for (; i < len; ++i)
fff82b44:	39 4a 00 01 	addi    r10,r10,1
fff82b48:	4b ff ff f0 	b       fff82b38 <memcpy+0x40>
    {
        cdest[i] = csrc[i];
    }

    return vdest;
}
fff82b4c:	4e 80 00 20 	blr
	...

fff82b60 <udivmodsi4_loop>:
fff82b60:	05 04 18 0e 	cmplwbge r4,r3,fff82b7c <udivmodsi4_loop+0x1c>
fff82b64:	42 40 00 14 	bdz     fff82b78 <udivmodsi4_loop+0x18>
fff82b68:	06 84 00 0a 	bwltz   r4,fff82b7c <udivmodsi4_loop+0x1c>
fff82b6c:	54 84 08 3c 	rlwinm  r4,r4,1,0,30
fff82b70:	55 29 08 3c 	rlwinm  r9,r9,1,0,30
fff82b74:	4b ff ff ec 	b       fff82b60 <udivmodsi4_loop>
fff82b78:	39 20 00 00 	li      r9,0
fff82b7c:	39 40 00 00 	li      r10,0
fff82b80:	06 c9 00 0e 	bwz     r9,fff82b9c <udivmodsi4_loop+0x3c>
fff82b84:	05 83 20 06 	cmplwblt r3,r4,fff82b90 <udivmodsi4_loop+0x30>
fff82b88:	7c 64 18 50 	subf    r3,r4,r3
fff82b8c:	7d 4a 4b 78 	or      r10,r10,r9
fff82b90:	55 29 f8 7e 	rlwinm  r9,r9,31,1,31
fff82b94:	54 84 f8 7e 	rlwinm  r4,r4,31,1,31
fff82b98:	4b ff ff e8 	b       fff82b80 <udivmodsi4_loop+0x20>
fff82b9c:	06 45 00 04 	bwnz    r5,fff82ba4 <udivmodsi4_loop+0x44>
fff82ba0:	7d 43 53 78 	mr      r3,r10
fff82ba4:	4e 80 00 20 	blr

fff82ba8 <__udivsi3>:
fff82ba8:	38 a0 00 00 	li      r5,0
fff82bac:	39 40 00 21 	li      r10,33
fff82bb0:	7d 49 03 a6 	mtctr   r10
fff82bb4:	39 20 00 01 	li      r9,1
fff82bb8:	4b ff ff a8 	b       fff82b60 <udivmodsi4_loop>

fff82bbc <__pk_start_threads>:
// This is considered part of pk_start_threads() and so is also considered a
// 'core' routine.

void
__pk_start_threads(void)
{
fff82bbc:	94 21 ff f8 	stwu    r1,-8(r1)
fff82bc0:	7c 08 02 a6 	mflr    r0
fff82bc4:	90 01 00 0c 	stw     r0,12(r1)
    PK_START_THREADS_HOOK;

    __pk_next_thread_resume();
fff82bc8:	4b ff d6 c9 	bl      fff80290 <__pk_next_thread_resume>

    PK_PANIC(PK_START_THREADS_RETURNED);
fff82bcc:	7f e4 18 08 	twu     r4,r3
}
fff82bd0:	80 01 00 0c 	lwz     r0,12(r1)
fff82bd4:	7c 08 03 a6 	mtlr    r0
fff82bd8:	38 21 00 08 	addi    r1,r1,8
fff82bdc:	4e 80 00 20 	blr

fff82be0 <__pk_thread_map>:
__pk_thread_map(PkThread* thread)
{
    PkThreadPriority priority;

    priority = thread->priority;
    __pk_priority_map[priority] = thread;
fff82be0:	89 43 00 10 	lbz     r10,16(r3)
fff82be4:	39 0d 12 b0 	addi    r8,r13,4784
fff82be8:	55 49 10 3a 	rlwinm  r9,r10,2,0,29
fff82bec:	7c 68 49 2e 	stwx    r3,r8,r9

    if (thread->state == PK_THREAD_STATE_SUSPENDED_RUNNABLE)
fff82bf0:	89 23 00 11 	lbz     r9,17(r3)
fff82bf4:	06 c9 08 10 	cmpwibeq r9,1,fff82c14 <__pk_thread_map+0x34>
    {

        __pk_thread_queue_insert(&__pk_run_queue, priority);

    }
    else if (thread->flags & PK_THREAD_FLAG_SEMAPHORE_PEND)
fff82bf8:	89 23 00 12 	lbz     r9,18(r3)
fff82bfc:	07 89 f8 22 	bb0wi   r9,31,fff82c40 <__pk_thread_map+0x60>
    {

        if (thread->semaphore->count)
fff82c00:	81 23 00 0c 	lwz     r9,12(r3)
fff82c04:	81 09 00 04 	lwz     r8,4(r9)
fff82c08:	06 c8 00 12 	bwz     r8,fff82c2c <__pk_thread_map+0x4c>
        {

            thread->semaphore->count--;
fff82c0c:	39 08 ff ff 	addi    r8,r8,-1
fff82c10:	91 09 00 04 	stw     r8,4(r9)
}

static inline void
__pk_thread_queue_insert(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue |= (0x80000000u >> priority);
fff82c14:	81 2d 13 4c 	lwz     r9,4940(r13)
fff82c18:	3d 00 80 00 	lis     r8,-32768
fff82c1c:	7d 0a 54 30 	srw     r10,r8,r10
fff82c20:	7d 4a 4b 78 	or      r10,r10,r9
fff82c24:	91 4d 13 4c 	stw     r10,4940(r13)
fff82c28:	48 00 00 18 	b       fff82c40 <__pk_thread_map+0x60>
fff82c2c:	81 09 00 00 	lwz     r8,0(r9)
fff82c30:	3c e0 80 00 	lis     r7,-32768
fff82c34:	7c ea 54 30 	srw     r10,r7,r10
fff82c38:	7d 4a 43 78 	or      r10,r10,r8
fff82c3c:	91 49 00 00 	stw     r10,0(r9)
            __pk_thread_queue_insert(&(thread->semaphore->pending_threads),
                                     priority);
        }
    }

    thread->state = PK_THREAD_STATE_MAPPED;
fff82c40:	39 20 00 02 	li      r9,2
fff82c44:	99 23 00 11 	stb     r9,17(r3)
fff82c48:	4e 80 00 20 	blr

fff82c4c <__pk_thread_unmap>:
__pk_thread_unmap(PkThread* thread)
{
    PkThreadPriority priority;

    priority = thread->priority;
    __pk_priority_map[priority] = 0;
fff82c4c:	89 23 00 10 	lbz     r9,16(r3)
fff82c50:	39 0d 12 b0 	addi    r8,r13,4784
fff82c54:	55 2a 10 3a 	rlwinm  r10,r9,2,0,29
fff82c58:	38 e0 00 00 	li      r7,0
fff82c5c:	7c e8 51 2e 	stwx    r7,r8,r10
}

static inline int
__pk_thread_queue_member(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
return ((*queue >> (31 - priority)) & 1);
fff82c60:	81 0d 13 4c 	lwz     r8,4940(r13)
fff82c64:	89 43 00 10 	lbz     r10,16(r3)
fff82c68:	21 4a 00 1f 	subfic  r10,r10,31
fff82c6c:	7d 0a 54 30 	srw     r10,r8,r10

    if (__pk_thread_is_runnable(thread))
fff82c70:	07 8a f8 12 	bb0wi   r10,31,fff82c94 <__pk_thread_unmap+0x48>
    {

        thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fff82c74:	39 40 00 01 	li      r10,1
}

static inline void
__pk_thread_queue_delete(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue &= ~(0x80000000u >> priority);
fff82c78:	81 0d 13 4c 	lwz     r8,4940(r13)
fff82c7c:	99 43 00 11 	stb     r10,17(r3)
fff82c80:	3d 40 80 00 	lis     r10,-32768
fff82c84:	7d 49 4c 30 	srw     r9,r10,r9
fff82c88:	7d 09 48 78 	andc    r9,r8,r9
fff82c8c:	91 2d 13 4c 	stw     r9,4940(r13)
fff82c90:	4e 80 00 20 	blr

    }
    else
    {

        thread->state = PK_THREAD_STATE_SUSPENDED_BLOCKED;
fff82c94:	39 40 00 03 	li      r10,3
fff82c98:	99 43 00 11 	stb     r10,17(r3)

        if (thread->flags & PK_THREAD_FLAG_SEMAPHORE_PEND)
fff82c9c:	89 43 00 12 	lbz     r10,18(r3)
fff82ca0:	07 8a f8 0e 	bb0wi   r10,31,fff82cbc <__pk_thread_unmap+0x70>
        {
            __pk_thread_queue_delete(&(thread->semaphore->pending_threads),
fff82ca4:	81 03 00 0c 	lwz     r8,12(r3)
fff82ca8:	3d 40 80 00 	lis     r10,-32768
fff82cac:	80 e8 00 00 	lwz     r7,0(r8)
fff82cb0:	7d 49 4c 30 	srw     r9,r10,r9
fff82cb4:	7c e9 48 78 	andc    r9,r7,r9
fff82cb8:	91 28 00 00 	stw     r9,0(r8)
fff82cbc:	4e 80 00 20 	blr

fff82cc0 <__pk_schedule>:
}

static inline PkThreadPriority
__pk_thread_queue_min(volatile PkThreadQueue* queue)
{
return cntlzw(*queue);
fff82cc0:	81 2d 13 4c 	lwz     r9,4940(r13)
fff82cc4:	7d 29 00 34 	cntlzw  r9,r9
fff82cc8:	55 29 06 3e 	clrlwi  r9,r9,24
// end of interrupt processing.

void
__pk_schedule(void)
{
    __pk_next_priority = __pk_thread_queue_min(&__pk_run_queue);
fff82ccc:	99 2d 13 3c 	stb     r9,4924(r13)
    __pk_next_thread = __pk_priority_map[__pk_next_priority];
fff82cd0:	39 4d 12 b0 	addi    r10,r13,4784
fff82cd4:	89 2d 13 3c 	lbz     r9,4924(r13)
fff82cd8:	55 29 10 3a 	rlwinm  r9,r9,2,0,29
fff82cdc:	7d 2a 48 2e 	lwzx    r9,r10,r9
fff82ce0:	91 2d 13 40 	stw     r9,4928(r13)

    if ((__pk_next_thread == 0) ||
fff82ce4:	06 c9 00 06 	bwz     r9,fff82cf0 <__pk_schedule+0x30>
fff82ce8:	81 4d 13 44 	lwz     r10,4932(r13)
fff82cec:	04 c9 50 1a 	cmpwbeq r9,r10,fff82d20 <__pk_schedule+0x60>
        (__pk_next_thread != __pk_current_thread))
    {

        if (__pk_kernel_mode_thread())
fff82cf0:	7d 30 42 a6 	mfsprg  r9,0
fff82cf4:	06 09 00 16 	bwgez   r9,fff82d20 <__pk_schedule+0x60>
        {
            if (__pk_kernel_context_thread())
fff82cf8:	7d 30 42 a6 	mfsprg  r9,0
fff82cfc:	3d 40 80 00 	lis     r10,-32768
fff82d00:	55 29 00 02 	rlwinm  r9,r9,0,0,1
fff82d04:	04 49 50 0a 	cmpwbne r9,r10,fff82d18 <__pk_schedule+0x58>
            {
                if (__pk_current_thread != 0)
fff82d08:	81 2d 13 44 	lwz     r9,4932(r13)
fff82d0c:	06 c9 00 04 	bwz     r9,fff82d14 <__pk_schedule+0x54>
                {
                    __pk_switch();
fff82d10:	4b ff d6 1c 	b       fff8032c <__ctx_switch>
                }
                else
                {
                    __pk_next_thread_resume();
fff82d14:	4b ff d5 7c 	b       fff80290 <__pk_next_thread_resume>
                }
            }
            else
            {
                __pk_delayed_switch = 1;
fff82d18:	39 20 00 01 	li      r9,1
fff82d1c:	91 2d 13 48 	stw     r9,4936(r13)
fff82d20:	4e 80 00 20 	blr

fff82d24 <__pk_thread_delete>:
// Note that we do not create trace events for unmapped threads since the trace
// tag only encodes the priority, which may be in use by a mapped thread.

void
__pk_thread_delete(PkThread* thread, PkThreadState final_state)
{
fff82d24:	94 21 ff e8 	stwu    r1,-24(r1)
fff82d28:	7c 08 02 a6 	mflr    r0
fff82d2c:	1b 81 00 08 	stvd    d28,8(r1)
fff82d30:	90 01 00 1c 	stw     r0,28(r1)
fff82d34:	1b c1 00 10 	stvd    d30,16(r1)
fff82d38:	7c 7c 1b 78 	mr      r28,r3
fff82d3c:	7c 9d 23 78 	mr      r29,r4

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff82d40:	7f c0 00 a6 	mfmsr   r30

wrteei(0);
fff82d44:	7c 00 01 46 	wrteei  0
// Interrupts must be disabled at entry.

static inline int
__pk_thread_is_mapped(PkThread* thread)
{
    return (thread->state == PK_THREAD_STATE_MAPPED);
fff82d48:	8b e3 00 11 	lbz     r31,17(r3)
fff82d4c:	6b ff 00 02 	xori    r31,r31,2
fff82d50:	3b ff ff ff 	addi    r31,r31,-1
fff82d54:	57 ff 0f fe 	rlwinm  r31,r31,1,31,31

    pk_critical_section_enter(&ctx);

    mapped = __pk_thread_is_mapped(thread);

    if (mapped)
fff82d58:	06 df 00 04 	bwz     r31,fff82d60 <__pk_thread_delete+0x3c>
    {
        __pk_thread_unmap(thread);
fff82d5c:	4b ff fe f1 	bl      fff82c4c <__pk_thread_unmap>
    }

    __pk_timer_cancel(&(thread->timer));
fff82d60:	38 7c 00 18 	addi    r3,r28,24
fff82d64:	4b ff d9 1d 	bl      fff80680 <__pk_timer_cancel>
    thread->state = final_state;
fff82d68:	9b bc 00 11 	stb     r29,17(r28)

    if (mapped)
fff82d6c:	06 df 00 0c 	bwz     r31,fff82d84 <__pk_thread_delete+0x60>
            {
                PK_KERN_TRACE("THREAD_COMPLETED(%d)", thread->priority);
            }
        }

        if (thread == __pk_current_thread)
fff82d70:	81 2d 13 44 	lwz     r9,4932(r13)
fff82d74:	04 5c 48 06 	cmpwbne r28,r9,fff82d80 <__pk_thread_delete+0x5c>
        {
            __pk_current_thread = 0;
fff82d78:	39 20 00 00 	li      r9,0
fff82d7c:	91 2d 13 44 	stw     r9,4932(r13)
        }

        __pk_schedule();
fff82d80:	4b ff ff 41 	bl      fff82cc0 <__pk_schedule>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff82d84:	7f c0 01 24 	mtmsr   r30
    }

    pk_critical_section_exit(&ctx);
}
fff82d88:	80 01 00 1c 	lwz     r0,28(r1)
fff82d8c:	17 81 00 08 	lvd     d28,8(r1)
fff82d90:	7c 08 03 a6 	mtlr    r0
fff82d94:	17 c1 00 10 	lvd     d30,16(r1)
fff82d98:	38 21 00 18 	addi    r1,r1,24
fff82d9c:	4e 80 00 20 	blr

fff82da0 <__pk_thread_timeout>:
// Note that we do not create trace events for unmapped threads since the trace
// tag only encodes the priority, which may be in use by a mapped thread.

void
__pk_thread_timeout(void* arg)
{
fff82da0:	94 21 ff f0 	stwu    r1,-16(r1)
fff82da4:	7c 08 02 a6 	mflr    r0
fff82da8:	1b c1 00 08 	stvd    d30,8(r1)
fff82dac:	90 01 00 14 	stw     r0,20(r1)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff82db0:	7f e0 00 a6 	mfmsr   r31

wrteei(0);
fff82db4:	7c 00 01 46 	wrteei  0
    PkMachineContext ctx;
    PkThread* thread = (PkThread*)arg;

    pk_critical_section_enter(&ctx);

    switch (thread->state)
fff82db8:	89 23 00 11 	lbz     r9,17(r3)
fff82dbc:	06 c9 10 0a 	cmpwibeq r9,2,fff82dd0 <__pk_thread_timeout+0x30>
fff82dc0:	06 c9 18 26 	cmpwibeq r9,3,fff82e0c <__pk_thread_timeout+0x6c>
fff82dc4:	06 c9 08 2e 	cmpwibeq r9,1,fff82e20 <__pk_thread_timeout+0x80>
            thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
            thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
            break;

        default:
            PK_PANIC(PK_THREAD_TIMEOUT_STATE);
fff82dc8:	7f e4 38 08 	twu     r4,r7
fff82dcc:	48 00 00 54 	b       fff82e20 <__pk_thread_timeout+0x80>
}

static inline int
__pk_thread_queue_member(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
return ((*queue >> (31 - priority)) & 1);
fff82dd0:	89 03 00 10 	lbz     r8,16(r3)
fff82dd4:	81 4d 13 4c 	lwz     r10,4940(r13)
fff82dd8:	21 28 00 1f 	subfic  r9,r8,31
fff82ddc:	7d 4a 4c 30 	srw     r10,r10,r9

    switch (thread->state)
    {

        case PK_THREAD_STATE_MAPPED:
            if (!__pk_thread_is_runnable(thread))
fff82de0:	07 0a f8 20 	bb1wi   r10,31,fff82e20 <__pk_thread_timeout+0x80>
            {
                thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
fff82de4:	89 43 00 12 	lbz     r10,18(r3)
}

static inline void
__pk_thread_queue_insert(volatile PkThreadQueue* queue, PkThreadPriority priority)
{
*queue |= (0x80000000u >> priority);
fff82de8:	3d 20 80 00 	lis     r9,-32768
fff82dec:	61 4a 00 04 	ori     r10,r10,4
fff82df0:	99 43 00 12 	stb     r10,18(r3)
fff82df4:	81 4d 13 4c 	lwz     r10,4940(r13)
fff82df8:	7d 29 44 30 	srw     r9,r9,r8
fff82dfc:	7d 29 53 78 	or      r9,r9,r10
fff82e00:	91 2d 13 4c 	stw     r9,4940(r13)
                __pk_thread_queue_insert(&__pk_run_queue, thread->priority);
                __pk_schedule();
fff82e04:	4b ff fe bd 	bl      fff82cc0 <__pk_schedule>
fff82e08:	48 00 00 18 	b       fff82e20 <__pk_thread_timeout+0x80>

        case PK_THREAD_STATE_SUSPENDED_RUNNABLE:
            break;

        case PK_THREAD_STATE_SUSPENDED_BLOCKED:
            thread->flags |= PK_THREAD_FLAG_TIMED_OUT;
fff82e0c:	89 23 00 12 	lbz     r9,18(r3)
fff82e10:	61 29 00 04 	ori     r9,r9,4
fff82e14:	99 23 00 12 	stb     r9,18(r3)
            thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fff82e18:	39 20 00 01 	li      r9,1
fff82e1c:	99 23 00 11 	stb     r9,17(r3)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff82e20:	7f e0 01 24 	mtmsr   r31
        default:
            PK_PANIC(PK_THREAD_TIMEOUT_STATE);
    }

    pk_critical_section_exit(&ctx);
}
fff82e24:	80 01 00 14 	lwz     r0,20(r1)
fff82e28:	17 c1 00 08 	lvd     d30,8(r1)
fff82e2c:	7c 08 03 a6 	mtlr    r0
fff82e30:	38 21 00 10 	addi    r1,r1,16
fff82e34:	4e 80 00 20 	blr

fff82e38 <pk_start_threads>:
int
pk_start_threads(void)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(__pk_kernel_mode_thread(), PK_ILLEGAL_CONTEXT_THREAD);
fff82e38:	7d 30 42 a6 	mfsprg  r9,0
fff82e3c:	38 60 fe fe 	li      r3,-258
fff82e40:	06 89 00 16 	bwltz   r9,fff82e6c <pk_start_threads+0x34>

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff82e44:	7d 20 00 a6 	mfmsr   r9

wrteei(0);
fff82e48:	7c 00 01 46 	wrteei  0
    }

    __pk_call_pk_start_threads();
fff82e4c:	3d 20 ff f8 	lis     r9,-8
fff82e50:	81 4d 13 54 	lwz     r10,4948(r13)
fff82e54:	39 29 2b bc 	addi    r9,r9,11196
fff82e58:	7d 41 53 78 	mr      r1,r10
fff82e5c:	7d 28 03 a6 	mtlr    r9
fff82e60:	4e 80 00 21 	blrl
fff82e64:	7f e4 18 08 	twu     r4,r3

    return 0;
fff82e68:	38 60 00 00 	li      r3,0
}
fff82e6c:	4e 80 00 20 	blr

fff82e70 <pk_thread_resume>:
{
    PkMachineContext ctx;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_RESUME1);
fff82e70:	06 c3 00 38 	bwz     r3,fff82ee0 <pk_thread_resume+0x70>
/// \retval -PK_PRIORITY_IN_USE_AT_RESUME Another thread is already mapped at
/// the priority of the \a thread.

int
pk_thread_resume(PkThread* thread)
{
fff82e74:	94 21 ff f0 	stwu    r1,-16(r1)
fff82e78:	7c 08 02 a6 	mflr    r0
fff82e7c:	1b c1 00 08 	stvd    d30,8(r1)
fff82e80:	90 01 00 14 	stw     r0,20(r1)

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff82e84:	7f e0 00 a6 	mfmsr   r31

wrteei(0);
fff82e88:	7c 00 01 46 	wrteei  0
fff82e8c:	89 03 00 11 	lbz     r8,17(r3)

    pk_critical_section_enter(&ctx);

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF_CRITICAL(!__pk_thread_is_active(thread),
fff82e90:	39 48 ff fc 	addi    r10,r8,-4
fff82e94:	28 0a 00 01 	cmplwi  r10,1
fff82e98:	41 a1 00 10 	bgt     fff82ea8 <pk_thread_resume+0x38>
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff82e9c:	7f e0 01 24 	mtmsr   r31
fff82ea0:	38 60 fe fb 	li      r3,-261
fff82ea4:	48 00 00 44 	b       fff82ee8 <pk_thread_resume+0x78>
                             PK_INVALID_THREAD_AT_RESUME2,
                             &ctx);
    }

    if (!__pk_thread_is_mapped(thread))
fff82ea8:	06 c8 10 16 	cmpwibeq r8,2,fff82ed4 <pk_thread_resume+0x64>
    {

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF_CRITICAL(__pk_priority_map[thread->priority] != 0,
fff82eac:	89 23 00 10 	lbz     r9,16(r3)
fff82eb0:	39 4d 12 b0 	addi    r10,r13,4784
fff82eb4:	55 29 10 3a 	rlwinm  r9,r9,2,0,29
fff82eb8:	7d 2a 48 2e 	lwzx    r9,r10,r9
fff82ebc:	06 c9 00 08 	bwz     r9,fff82ecc <pk_thread_resume+0x5c>
fff82ec0:	7f e0 01 24 	mtmsr   r31
fff82ec4:	38 60 fc f8 	li      r3,-776
fff82ec8:	48 00 00 20 	b       fff82ee8 <pk_thread_resume+0x78>
                                 PK_PRIORITY_IN_USE_AT_RESUME,
                                 &ctx);
        }

        __pk_thread_map(thread);
fff82ecc:	4b ff fd 15 	bl      fff82be0 <__pk_thread_map>
        __pk_schedule();
fff82ed0:	4b ff fd f1 	bl      fff82cc0 <__pk_schedule>
fff82ed4:	7f e0 01 24 	mtmsr   r31
    }

    pk_critical_section_exit(&ctx);

    return PK_OK;
fff82ed8:	38 60 00 00 	li      r3,0
fff82edc:	48 00 00 0c 	b       fff82ee8 <pk_thread_resume+0x78>
{
    PkMachineContext ctx;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_RESUME1);
fff82ee0:	38 60 fe fc 	li      r3,-260
fff82ee4:	4e 80 00 20 	blr
    }

    pk_critical_section_exit(&ctx);

    return PK_OK;
}
fff82ee8:	80 01 00 14 	lwz     r0,20(r1)
fff82eec:	17 c1 00 08 	lvd     d30,8(r1)
fff82ef0:	7c 08 03 a6 	mtlr    r0
fff82ef4:	38 21 00 10 	addi    r1,r1,16
fff82ef8:	4e 80 00 20 	blr

fff82efc <pk_complete>:
int
pk_complete(void)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
fff82efc:	7d 30 42 a6 	mfsprg  r9,0
fff82f00:	3d 40 80 00 	lis     r10,-32768
fff82f04:	55 29 00 02 	rlwinm  r9,r9,0,0,1
fff82f08:	38 60 ff 00 	li      r3,-256
fff82f0c:	04 49 50 16 	cmpwbne r9,r10,fff82f38 <pk_complete+0x3c>

// Note: Casting __pk_current_thread removes the 'volatile' attribute.

int
pk_complete(void)
{
fff82f10:	94 21 ff f8 	stwu    r1,-8(r1)
fff82f14:	7c 08 02 a6 	mflr    r0
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
fff82f18:	80 6d 13 44 	lwz     r3,4932(r13)
fff82f1c:	38 80 00 04 	li      r4,4

// Note: Casting __pk_current_thread removes the 'volatile' attribute.

int
pk_complete(void)
{
fff82f20:	90 01 00 0c 	stw     r0,12(r1)
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_UNLESS_THREAD_CONTEXT();
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
fff82f24:	4b ff fe 01 	bl      fff82d24 <__pk_thread_delete>
                       PK_THREAD_STATE_COMPLETED);

    return PK_OK;
}
fff82f28:	80 01 00 0c 	lwz     r0,12(r1)
fff82f2c:	7c 08 03 a6 	mtlr    r0
fff82f30:	38 21 00 08 	addi    r1,r1,8
    }

    __pk_thread_delete((PkThread*)__pk_current_thread,
                       PK_THREAD_STATE_COMPLETED);

    return PK_OK;
fff82f34:	38 60 00 00 	li      r3,0
}
fff82f38:	4e 80 00 20 	blr

fff82f3c <pk_thread_create>:
                 PkThreadRoutine  thread_routine,
                 void*              arg,
                 PkAddress        stack,
                 size_t            stack_size,
                 PkThreadPriority priority)
{
fff82f3c:	94 21 ff d8 	stwu    r1,-40(r1)
fff82f40:	7c 08 02 a6 	mflr    r0
fff82f44:	1b c1 00 20 	stvd    d30,32(r1)
fff82f48:	90 01 00 2c 	stw     r0,44(r1)
fff82f4c:	1b 81 00 18 	stvd    d28,24(r1)
fff82f50:	7c 7f 1b 78 	mr      r31,r3
fff82f54:	18 c1 00 08 	stvd    d6,8(r1)
    int rc;

    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF(thread == 0, PK_INVALID_THREAD_AT_CREATE);
fff82f58:	3b c0 fe e3 	li      r30,-285
fff82f5c:	06 c3 00 48 	bwz     r3,fff82fec <pk_thread_create+0xb0>
fff82f60:	7c 9d 23 78 	mr      r29,r4
        PK_ERROR_IF((thread_routine == 0) ||
fff82f64:	3b c0 fc fe 	li      r30,-770
fff82f68:	06 c4 00 42 	bwz     r4,fff82fec <pk_thread_create+0xb0>
fff82f6c:	28 08 00 1f 	cmplwi  r8,31
fff82f70:	41 81 00 7c 	bgt     fff82fec <pk_thread_create+0xb0>
                    (priority >= PK_THREADS),
                    PK_INVALID_ARGUMENT_THREAD1);
    }

    rc = __pk_stack_init(&stack, &stack_size);
fff82f74:	38 61 00 08 	addi    r3,r1,8
fff82f78:	38 81 00 0c 	addi    r4,r1,12
fff82f7c:	91 01 00 10 	stw     r8,16(r1)
fff82f80:	7c bc 2b 78 	mr      r28,r5
fff82f84:	4b ff db 89 	bl      fff80b0c <__pk_stack_init>
fff82f88:	7c 7e 1b 78 	mr      r30,r3

    if (rc)
fff82f8c:	81 01 00 10 	lwz     r8,16(r1)
fff82f90:	06 43 00 2e 	bwnz    r3,fff82fec <pk_thread_create+0xb0>
    {
        return rc;
    }

    thread->saved_stack_pointer = stack;
fff82f94:	15 21 00 08 	lvd     d9,8(r1)
fff82f98:	91 3f 00 00 	stw     r9,0(r31)
    thread->stack_base = stack;

    if (PK_STACK_DIRECTION < 0)
    {

        thread->stack_limit = stack - stack_size;
fff82f9c:	7d 4a 48 50 	subf    r10,r10,r9
    {
        return rc;
    }

    thread->saved_stack_pointer = stack;
    thread->stack_base = stack;
fff82fa0:	91 3f 00 08 	stw     r9,8(r31)

    if (PK_STACK_DIRECTION < 0)
    {

        thread->stack_limit = stack - stack_size;
fff82fa4:	91 5f 00 04 	stw     r10,4(r31)

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF(thread->stack_limit > thread->stack_base,
fff82fa8:	05 aa 48 20 	cmplwbgt r10,r9,fff82fe8 <pk_thread_create+0xac>
        }
    }

    thread->semaphore = 0;
    thread->priority = priority;
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fff82fac:	39 20 00 01 	li      r9,1
            PK_ERROR_IF(thread->stack_limit < thread->stack_base,
                        PK_INVALID_ARGUMENT_THREAD3);
        }
    }

    thread->semaphore = 0;
fff82fb0:	90 7f 00 0c 	stw     r3,12(r31)
    thread->priority = priority;
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
    thread->flags = 0;
fff82fb4:	98 7f 00 12 	stb     r3,18(r31)
                        PK_INVALID_ARGUMENT_THREAD3);
        }
    }

    thread->semaphore = 0;
    thread->priority = priority;
fff82fb8:	99 1f 00 10 	stb     r8,16(r31)
    thread->state = PK_THREAD_STATE_SUSPENDED_RUNNABLE;
fff82fbc:	99 3f 00 11 	stb     r9,17(r31)
    thread->flags = 0;

    pk_timer_create(&(thread->timer),
fff82fc0:	3c 80 ff f8 	lis     r4,-8
fff82fc4:	7f e5 fb 78 	mr      r5,r31
fff82fc8:	38 7f 00 18 	addi    r3,r31,24
fff82fcc:	38 84 2d a0 	addi    r4,r4,11680
fff82fd0:	48 00 00 39 	bl      fff83008 <pk_timer_create>
                    __pk_thread_timeout,
                    (void*)thread);

    __pk_thread_context_initialize(thread, thread_routine, arg);
fff82fd4:	7f e3 fb 78 	mr      r3,r31
fff82fd8:	7f a4 eb 78 	mr      r4,r29
fff82fdc:	7f 85 e3 78 	mr      r5,r28
fff82fe0:	48 00 01 59 	bl      fff83138 <__pk_thread_context_initialize>

    return rc;
fff82fe4:	48 00 00 08 	b       fff82fec <pk_thread_create+0xb0>

        thread->stack_limit = stack - stack_size;

        if (PK_ERROR_CHECK_API)
        {
            PK_ERROR_IF(thread->stack_limit > thread->stack_base,
fff82fe8:	3b c0 fc fd 	li      r30,-771
                    (void*)thread);

    __pk_thread_context_initialize(thread, thread_routine, arg);

    return rc;
}
fff82fec:	80 01 00 2c 	lwz     r0,44(r1)
fff82ff0:	7f c3 f3 78 	mr      r3,r30
fff82ff4:	7c 08 03 a6 	mtlr    r0
fff82ff8:	17 81 00 18 	lvd     d28,24(r1)
fff82ffc:	17 c1 00 20 	lvd     d30,32(r1)
fff83000:	38 21 00 28 	addi    r1,r1,40
fff83004:	4e 80 00 20 	blr

fff83008 <pk_timer_create>:

int
pk_timer_create(PkTimer*         timer,
                PkTimerCallback callback,
                void*             arg)
{
fff83008:	94 21 ff e8 	stwu    r1,-24(r1)
fff8300c:	7c 08 02 a6 	mflr    r0
fff83010:	1b c1 00 10 	stvd    d30,16(r1)
fff83014:	90 01 00 1c 	stw     r0,28(r1)
fff83018:	1b 81 00 08 	stvd    d28,8(r1)
fff8301c:	7c 7f 1b 78 	mr      r31,r3
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((timer == 0), PK_INVALID_TIMER_AT_CREATE);
fff83020:	06 c3 00 14 	bwz     r3,fff83048 <pk_timer_create+0x40>
fff83024:	7c be 2b 78 	mr      r30,r5
fff83028:	7c 9d 23 78 	mr      r29,r4
    }

    pk_deque_element_create((PkDeque*)timer);
fff8302c:	4b ff d5 0d 	bl      fff80538 <pk_deque_element_create>
    timer->timeout = 0;
fff83030:	39 00 00 00 	li      r8,0
fff83034:	39 20 00 00 	li      r9,0
fff83038:	19 1f 00 08 	stvd    d8,8(r31)
    timer->callback = callback;
fff8303c:	1b bf 00 10 	stvd    d29,16(r31)
    timer->arg = arg;

    return PK_OK;
fff83040:	38 60 00 00 	li      r3,0
fff83044:	48 00 00 08 	b       fff8304c <pk_timer_create+0x44>
                PkTimerCallback callback,
                void*             arg)
{
    if (PK_ERROR_CHECK_API)
    {
        PK_ERROR_IF((timer == 0), PK_INVALID_TIMER_AT_CREATE);
fff83048:	38 60 fd fa 	li      r3,-518
    timer->timeout = 0;
    timer->callback = callback;
    timer->arg = arg;

    return PK_OK;
}
fff8304c:	80 01 00 1c 	lwz     r0,28(r1)
fff83050:	17 81 00 08 	lvd     d28,8(r1)
fff83054:	7c 08 03 a6 	mtlr    r0
fff83058:	17 c1 00 10 	lvd     d30,16(r1)
fff8305c:	38 21 00 18 	addi    r1,r1,24
fff83060:	4e 80 00 20 	blr

fff83064 <pk_trace_big>:
#include "pk_trace.h"

#if (PK_TRACE_SUPPORT)
void pk_trace_big(uint32_t i_hash_and_count,
                  uint64_t i_parm1, uint64_t i_parm2)
{
fff83064:	94 21 ff e0 	stwu    r1,-32(r1)
fff83068:	7c 08 02 a6 	mflr    r0
fff8306c:	1b 81 00 10 	stvd    d28,16(r1)
fff83070:	1b c1 00 18 	stvd    d30,24(r1)
fff83074:	90 01 00 24 	stw     r0,36(r1)
fff83078:	7c bc 2b 78 	mr      r28,r5
fff8307c:	7c dd 33 78 	mr      r29,r6
fff83080:	7d 1f 43 78 	mr      r31,r8
fff83084:	7c fe 3b 78 	mr      r30,r7
    uint32_t            parm_size;
    uint32_t            cur_offset;
    uint32_t            footer_offset;

    //fill in the footer data
    tb64 = pk_timebase_get();
fff83088:	90 61 00 08 	stw     r3,8(r1)
fff8308c:	4b ff d4 15 	bl      fff804a0 <pk_timebase_get>
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fff83090:	80 01 00 08 	lwz     r0,8(r1)
    //fill in the footer data
    tb64 = pk_timebase_get();
    footer.parms.word32 = i_hash_and_count; //this has the parm count and hash
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;
fff83094:	39 20 00 02 	li      r9,2
fff83098:	51 24 07 be 	rlwimi  r4,r9,0,30,31

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fff8309c:	54 09 06 3e 	clrlwi  r9,r0,24
fff830a0:	28 09 00 02 	cmplwi  r9,2
    {
        parm_size = 8;
fff830a4:	38 a0 00 08 	li      r5,8
    state.tbu32 = tb64 >> 32;
    footer.time_format.word32 = tb64 & 0x00000000ffffffffull;
    footer.time_format.format = PK_TRACE_FORMAT_BIG;

    //round up to 8 byte boundary
    if(footer.parms.num_parms <= 2)
fff830a8:	40 81 00 08 	ble     fff830b0 <pk_trace_big+0x4c>
    {
        parm_size = 8;
    }
    else
    {
        parm_size = 16;
fff830ac:	38 a0 00 10 	li      r5,16

UNLESS__PPE42_CORE_C__(extern)
inline int
pk_interrupt_disable(PkMachineContext* context)
{
*context = mfmsr();
fff830b0:	7d 00 00 a6 	mfmsr   r8
fff830b4:	7d 09 03 a6 	mtctr   r8

wrteei(0);
fff830b8:	7c 00 01 46 	wrteei  0

    //*****The following operations must be done atomically*****
    pk_critical_section_enter(&ctx);

    //load in the offset in the cb for the entry we are adding
    cur_offset = g_pk_trace_buf.state.offset;
fff830bc:	39 4d 00 20 	addi    r10,r13,32
fff830c0:	81 2a 00 34 	lwz     r9,52(r10)
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fff830c4:	90 6a 00 30 	stw     r3,48(r10)

    //load in the offset in the cb for the entry we are adding
    cur_offset = g_pk_trace_buf.state.offset;

    //Find the offset for the footer (at the end of the entry)
    footer_offset = cur_offset + parm_size;
fff830c8:	7c c5 4a 14 	add     r6,r5,r9

    //calculate the address of the footer
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[footer_offset & PK_TRACE_CB_MASK];
fff830cc:	54 c8 05 3e 	clrlwi  r8,r6,20
fff830d0:	39 08 00 30 	addi    r8,r8,48
fff830d4:	7d 08 52 14 	add     r8,r8,r10
fff830d8:	38 e8 00 08 	addi    r7,r8,8

    //calculate the offset for the next entry in the cb
    state.offset = footer_offset + sizeof(PkTraceBig);
fff830dc:	38 c6 00 08 	addi    r6,r6,8
    }

#endif

    //update the cb state (tbu and offset)
    g_pk_trace_buf.state.word64 = state.word64;
fff830e0:	90 ca 00 34 	stw     r6,52(r10)

    //write the data to the circular buffer including the
    //timesamp, string hash, and 16bit parameter
    *ptr64 = footer.word64;
fff830e4:	90 08 00 08 	stw     r0,8(r8)
fff830e8:	90 87 00 04 	stw     r4,4(r7)
if (PK_ERROR_CHECK_API)
{
PK_ERROR_IF(context == 0, PK_INVALID_ARGUMENT_CONTEXT_SET);
}

mtmsr(*context);
fff830ec:	7d 09 02 a6 	mfctr   r8
fff830f0:	7d 00 01 24 	mtmsr   r8
    pk_critical_section_exit(&ctx);


    //write parm values to the circular buffer
    footer_ptr = (PkTraceBig*)ptr64;
    ptr64 = (uint64_t*)&g_pk_trace_buf.cb[cur_offset & PK_TRACE_CB_MASK];
fff830f4:	55 28 05 3e 	clrlwi  r8,r9,20
    *ptr64 = i_parm1;
fff830f8:	39 4a 00 08 	addi    r10,r10,8
fff830fc:	7d 0a 42 14 	add     r8,r10,r8
fff83100:	1b 88 00 30 	stvd    d28,48(r8)

    if(parm_size > 8)
fff83104:	06 c5 40 0a 	cmpwibeq r5,8,fff83118 <pk_trace_big+0xb4>
    {
        ptr64 = (uint64_t*)&g_pk_trace_buf.cb[(cur_offset + 8) & PK_TRACE_CB_MASK];
fff83108:	39 29 00 08 	addi    r9,r9,8
fff8310c:	55 29 05 3e 	clrlwi  r9,r9,20
        *ptr64 = i_parm2;
fff83110:	7d 2a 4a 14 	add     r9,r10,r9
fff83114:	1b c9 00 30 	stvd    d30,48(r9)
    }

    //Mark the trace entry update as being completed
    footer_ptr->parms.complete = 1;
fff83118:	39 20 00 01 	li      r9,1
fff8311c:	99 27 00 02 	stb     r9,2(r7)

}
fff83120:	80 01 00 24 	lwz     r0,36(r1)
fff83124:	17 81 00 10 	lvd     d28,16(r1)
fff83128:	7c 08 03 a6 	mtlr    r0
fff8312c:	17 c1 00 18 	lvd     d30,24(r1)
fff83130:	38 21 00 20 	addi    r1,r1,32
fff83134:	4e 80 00 20 	blr

fff83138 <__pk_thread_context_initialize>:
fff83138:	80 c3 00 00 	lwz     r6,0(r3)
fff8313c:	94 c6 ff a8 	stwu    r6,-88(r6)
fff83140:	38 e0 00 00 	li      r7,0
fff83144:	90 e6 00 08 	stw     r7,8(r6)
fff83148:	3c e0 ff f8 	lis     r7,-8
fff8314c:	60 e7 2e fc 	ori     r7,r7,12028
fff83150:	90 e6 00 5c 	stw     r7,92(r6)
fff83154:	90 a6 00 18 	stw     r5,24(r6)
fff83158:	38 e0 04 04 	li      r7,1028
fff8315c:	90 e6 00 1c 	stw     r7,28(r6)
fff83160:	38 e0 05 05 	li      r7,1285
fff83164:	90 e6 00 20 	stw     r7,32(r6)
fff83168:	38 e0 06 06 	li      r7,1542
fff8316c:	90 e6 00 24 	stw     r7,36(r6)
fff83170:	38 e0 00 00 	li      r7,0
fff83174:	90 e6 00 38 	stw     r7,56(r6)
fff83178:	90 e6 00 3c 	stw     r7,60(r6)
fff8317c:	90 86 00 40 	stw     r4,64(r6)
fff83180:	80 ed 13 38 	lwz     r7,4920(r13)
fff83184:	90 e6 00 44 	stw     r7,68(r6)
fff83188:	38 e0 00 00 	li      r7,0
fff8318c:	90 e6 00 10 	stw     r7,16(r6)
fff83190:	38 e0 07 07 	li      r7,1799
fff83194:	90 e6 00 28 	stw     r7,40(r6)
fff83198:	38 e0 08 08 	li      r7,2056
fff8319c:	90 e6 00 2c 	stw     r7,44(r6)
fff831a0:	38 e0 09 09 	li      r7,2313
fff831a4:	90 e6 00 30 	stw     r7,48(r6)
fff831a8:	38 e0 10 10 	li      r7,4112
fff831ac:	90 e6 00 34 	stw     r7,52(r6)
fff831b0:	38 e0 28 28 	li      r7,10280
fff831b4:	90 e6 00 48 	stw     r7,72(r6)
fff831b8:	38 e0 29 29 	li      r7,10537
fff831bc:	90 e6 00 4c 	stw     r7,76(r6)
fff831c0:	38 e0 30 30 	li      r7,12336
fff831c4:	90 e6 00 50 	stw     r7,80(r6)
fff831c8:	38 e0 31 31 	li      r7,12593
fff831cc:	90 e6 00 54 	stw     r7,84(r6)
fff831d0:	3c e0 80 00 	lis     r7,-32768
fff831d4:	90 e6 00 0c 	stw     r7,12(r6)
fff831d8:	90 c3 00 00 	stw     r6,0(r3)
fff831dc:	4e 80 00 20 	blr

fff831e0 <_ZL15spi_set_ecc_offR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_off(SpiControlHandle& i_handle)
{
fff831e0:	94 21 ff e0 	stwu    r1,-32(r1)
fff831e4:	7c 08 02 a6 	mflr    r0
fff831e8:	1b c1 00 18 	stvd    d30,24(r1)
fff831ec:	90 01 00 24 	stw     r0,36(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff831f0:	7c 25 0b 78 	mr      r5,r1
fff831f4:	39 00 00 00 	li      r8,0
fff831f8:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff831fc:	80 83 00 08 	lwz     r4,8(r3)
fff83200:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff83204:	38 84 00 03 	addi    r4,r4,3
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_off(SpiControlHandle& i_handle)
{
fff83208:	7c 7f 1b 78 	mr      r31,r3
fff8320c:	48 00 31 5d 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff83210:	90 6d 40 4c 	stw     r3,16460(r13)
fff83214:	06 43 00 14 	bwnz    r3,fff8323c <_ZL15spi_set_ecc_offR16SpiControlHandle+0x5c>
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            // This would be a candidate for a fast_mask (see variable_buffer) but
            // we'd need tables for all the integral types which maybe we need to
            // do ...
            iv_data |= (T(~0) >> (TT::bits_per_unit() - C)) << (TT::bits_per_unit() - B -
fff83218:	80 a1 00 08 	lwz     r5,8(r1)

    l_data.setBit<30>();

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff8321c:	80 9f 00 08 	lwz     r4,8(r31)
fff83220:	80 c1 00 0c 	lwz     r6,12(r1)
fff83224:	60 a5 00 02 	ori     r5,r5,2
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff83228:	7f e3 fb 78 	mr      r3,r31
fff8322c:	38 84 00 03 	addi    r4,r4,3
fff83230:	90 a1 00 08 	stw     r5,8(r1)
fff83234:	48 00 31 89 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83238:	90 6d 40 4c 	stw     r3,16460(r13)

fapi_try_exit:
    return fapi2::current_err;
}
fff8323c:	80 01 00 24 	lwz     r0,36(r1)
fff83240:	17 c1 00 18 	lvd     d30,24(r1)
fff83244:	7c 08 03 a6 	mtlr    r0
fff83248:	80 6d 40 4c 	lwz     r3,16460(r13)
fff8324c:	38 21 00 20 	addi    r1,r1,32
fff83250:	4e 80 00 20 	blr

fff83254 <_ZL14spi_set_ecc_onR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_on(SpiControlHandle& i_handle)
{
fff83254:	94 21 ff e0 	stwu    r1,-32(r1)
fff83258:	7c 08 02 a6 	mflr    r0
fff8325c:	1b c1 00 18 	stvd    d30,24(r1)
fff83260:	90 01 00 24 	stw     r0,36(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83264:	7c 25 0b 78 	mr      r5,r1
fff83268:	39 00 00 00 	li      r8,0
fff8326c:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff83270:	80 83 00 08 	lwz     r4,8(r3)
fff83274:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff83278:	38 84 00 03 	addi    r4,r4,3
#endif // #ifndef BOOTLOADER

#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_set_ecc_on(SpiControlHandle& i_handle)
{
fff8327c:	7c 7f 1b 78 	mr      r31,r3
fff83280:	48 00 30 e9 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
    fapi2::buffer<uint64_t> l_data = 0;
    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff83284:	90 6d 40 4c 	stw     r3,16460(r13)
fff83288:	06 43 00 14 	bwnz    r3,fff832b0 <_ZL14spi_set_ecc_onR16SpiControlHandle+0x5c>
        inline buffer & clearBit(void)
        {
            static_assert((B >= 0) &&
                          ((B + C - 1) < TT::bits_per_unit()), "failed range check");

            iv_data &= buffer<T>().template setBit<B, C>().invert();
fff8328c:	80 a1 00 08 	lwz     r5,8(r1)

    l_data.clearBit<30>();

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff83290:	80 9f 00 08 	lwz     r4,8(r31)
fff83294:	80 c1 00 0c 	lwz     r6,12(r1)
fff83298:	54 a5 07 fa 	rlwinm  r5,r5,0,31,29
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff8329c:	7f e3 fb 78 	mr      r3,r31
fff832a0:	38 84 00 03 	addi    r4,r4,3
fff832a4:	90 a1 00 08 	stw     r5,8(r1)
fff832a8:	48 00 31 15 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff832ac:	90 6d 40 4c 	stw     r3,16460(r13)

fapi_try_exit:
    return fapi2::current_err;
}
fff832b0:	80 01 00 24 	lwz     r0,36(r1)
fff832b4:	17 c1 00 18 	lvd     d30,24(r1)
fff832b8:	7c 08 03 a6 	mtlr    r0
fff832bc:	80 6d 40 4c 	lwz     r3,16460(r13)
fff832c0:	38 21 00 20 	addi    r1,r1,32
fff832c4:	4e 80 00 20 	blr

fff832c8 <_ZL9is_ecc_onR16SpiControlHandleRb>:

// ECC methods for SPI slave status reads
#ifndef BOOTLOADER
static fapi2::ReturnCode
is_ecc_on(SpiControlHandle& i_handle, bool& o_ecc)
{
fff832c8:	94 21 ff e0 	stwu    r1,-32(r1)
fff832cc:	7c 08 02 a6 	mflr    r0
fff832d0:	1b c1 00 18 	stvd    d30,24(r1)
fff832d4:	90 01 00 24 	stw     r0,36(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff832d8:	7c 25 0b 78 	mr      r5,r1
fff832dc:	39 00 00 00 	li      r8,0
fff832e0:	39 20 00 00 	li      r9,0
fff832e4:	7c 9f 23 78 	mr      r31,r4
    fapi2::buffer<uint64_t> l_data = 0;
    uint32_t l_ecc_cntl = 0;

    FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_CLOCKCONFIGREG, l_data));
fff832e8:	80 83 00 08 	lwz     r4,8(r3)
fff832ec:	59 05 00 08 	stvdu   d8,8(r5)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff832f0:	38 84 00 03 	addi    r4,r4,3
fff832f4:	48 00 30 75 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff832f8:	90 6d 40 4c 	stw     r3,16460(r13)
fff832fc:	06 43 00 12 	bwnz    r3,fff83320 <_ZL9is_ecc_onR16SpiControlHandleRb+0x58>
                source <<= shift;
            }
            else
            {
                shift = target_start - source_start;
                source >>= shift;
fff83300:	15 01 00 08 	lvd     d8,8(r1)
fff83304:	79 08 f8 60 	rldicl  d8,d8,31,33

    l_data.extractToRight(l_ecc_cntl, 29, 2);

    if( l_ecc_cntl % 2 == 0)
fff83308:	55 29 07 fe 	clrlwi  r9,r9,31
fff8330c:	06 49 00 08 	bwnz    r9,fff8331c <_ZL9is_ecc_onR16SpiControlHandleRb+0x54>
    {
        o_ecc = true;
fff83310:	39 20 00 01 	li      r9,1
fff83314:	99 3f 00 00 	stb     r9,0(r31)
fff83318:	48 00 00 08 	b       fff83320 <_ZL9is_ecc_onR16SpiControlHandleRb+0x58>
    }
    else
    {
        o_ecc = false;
fff8331c:	98 7f 00 00 	stb     r3,0(r31)
    }

fapi_try_exit:
    return fapi2::current_err;
}
fff83320:	80 01 00 24 	lwz     r0,36(r1)
fff83324:	17 c1 00 18 	lvd     d30,24(r1)
fff83328:	7c 08 03 a6 	mtlr    r0
fff8332c:	80 6d 40 4c 	lwz     r3,16460(r13)
fff83330:	38 21 00 20 	addi    r1,r1,32
fff83334:	4e 80 00 20 	blr

fff83338 <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>:
    return static_cast<uint64_t>(i_value);
};

// convert platform target handle to a uint64_t
template<fapi2::TargetType T, fapi2::MulticastType M>
inline uint64_t convertType( const fapi2::Target<T, M>& i_value)
fff83338:	94 21 ff e0 	stwu    r1,-32(r1)
fff8333c:	7c 08 02 a6 	mflr    r0
fff83340:	1b c1 00 18 	stvd    d30,24(r1)
fff83344:	90 01 00 24 	stw     r0,36(r1)
fff83348:	7c 7f 1b 78 	mr      r31,r3
        /// @brief Get the handle.
        /// @return V The target's handle, or value
        ///
        V get(void) const
        {
            return iv_handle;
fff8334c:	81 23 00 00 	lwz     r9,0(r3)
{
    // send the target type and instance as ffdc they will be used
    // to instantiate a target before logging the ffdc data
    return static_cast<uint64_t>(
               (static_cast<uint64_t>(
                    (i_value.get().getFapiTargetType() |
fff83350:	7c 23 0b 78 	mr      r3,r1
fff83354:	95 23 00 08 	stwu    r9,8(r3)
fff83358:	48 00 31 6d 	bl      fff864c4 <_ZNK5fapi218plat_target_handle17getFapiTargetTypeEv>
                     (i_value.get().fields.is_multicast << 31))
                ) << 32) | i_value.get().getTargetInstance());
};
fff8335c:	80 01 00 24 	lwz     r0,36(r1)
fff83360:	88 7f 00 00 	lbz     r3,0(r31)
fff83364:	7c 08 03 a6 	mtlr    r0
    // to instantiate a target before logging the ffdc data
    return static_cast<uint64_t>(
               (static_cast<uint64_t>(
                    (i_value.get().getFapiTargetType() |
                     (i_value.get().fields.is_multicast << 31))
                ) << 32) | i_value.get().getTargetInstance());
fff83368:	54 63 c8 00 	rlwinm  r3,r3,25,0,0
};
fff8336c:	7c 83 1b 78 	or      r3,r4,r3
fff83370:	88 9f 00 01 	lbz     r4,1(r31)
fff83374:	17 c1 00 18 	lvd     d30,24(r1)
fff83378:	38 21 00 20 	addi    r1,r1,32
fff8337c:	4e 80 00 20 	blr

fff83380 <spi_precheck>:
#endif // #ifndef BOOTLOADER

//Check the h/w is in the expected state
fapi2::ReturnCode
spi_precheck(SpiControlHandle& i_handle)
{
fff83380:	94 21 ff d0 	stwu    r1,-48(r1)
fff83384:	7c 08 02 a6 	mflr    r0
fff83388:	1b 81 00 20 	stvd    d28,32(r1)
fff8338c:	1b c1 00 28 	stvd    d30,40(r1)
fff83390:	90 01 00 34 	stw     r0,52(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83394:	7c 25 0b 78 	mr      r5,r1
fff83398:	39 00 00 00 	li      r8,0
fff8339c:	39 20 00 00 	li      r9,0
    fapi2::buffer<uint64_t> status_reg = 0;
    uint64_t temp, flags;

    FAPI_TRY(getScom(i_handle.target_chip,
fff833a0:	80 83 00 08 	lwz     r4,8(r3)
fff833a4:	59 05 00 08 	stvdu   d8,8(r5)
fff833a8:	38 84 00 08 	addi    r4,r4,8
#endif // #ifndef BOOTLOADER

//Check the h/w is in the expected state
fapi2::ReturnCode
spi_precheck(SpiControlHandle& i_handle)
{
fff833ac:	7c 7d 1b 78 	mr      r29,r3
fff833b0:	48 00 2f b9 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff833b4:	7c 7e 1b 78 	mr      r30,r3
    fapi2::buffer<uint64_t> status_reg = 0;
    uint64_t temp, flags;

    FAPI_TRY(getScom(i_handle.target_chip,
fff833b8:	90 6d 40 4c 	stw     r3,16460(r13)
fff833bc:	06 43 00 4c 	bwnz    r3,fff83454 <spi_precheck+0xd4>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fff833c0:	83 81 00 08 	lwz     r28,8(r1)
fff833c4:	81 01 00 0c 	lwz     r8,12(r1)
    flags = SPI_RDR_FULL | SPI_RDR_OVERRUN |
            SPI_RDR_UNDERRUN | SPI_TDR_FULL |
            SPI_TDR_OVERRUN /*| SPI_TDR_UNDERRUN*/;

    // Check the h/w is in the expected state
    FAPI_ASSERT( !(temp & flags),
fff833c8:	77 89 ec 00 	andis.  r9,r28,60416
fff833cc:	06 c9 00 44 	bwz     r9,fff83454 <spi_precheck+0xd4>
    {

    }
    SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE()
    {
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fff833d0:	3d 40 00 e1 	lis     r10,225
fff833d4:	61 4a 64 fb 	ori     r10,r10,25851
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("The SPI status register state bits check validation failed.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fff833d8:	3d 20 ff f9 	lis     r9,-7
fff833dc:	3b e9 a8 80 	addi    r31,r9,-22400
fff833e0:	91 49 a8 80 	stw     r10,-22400(r9)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff833e4:	7f a3 eb 78 	mr      r3,r29
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("The SPI status register state bits check validation failed.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fff833e8:	39 20 00 30 	li      r9,48
fff833ec:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE()
    {
        fapi2::current_err = RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE;
fff833f0:	91 4d 40 4c 	stw     r10,16460(r13)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff833f4:	91 01 00 18 	stw     r8,24(r1)
fff833f8:	4b ff ff 41 	bl      fff83338 <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff833fc:	39 20 00 00 	li      r9,0
fff83400:	61 29 ff fe 	ori     r9,r9,65534
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff83404:	90 7f 00 0c 	stw     r3,12(r31)
fff83408:	90 9f 00 10 	stw     r4,16(r31)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff8340c:	91 3f 00 08 	stw     r9,8(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83410:	3c c0 ec 00 	lis     r6,-5120
fff83414:	81 3d 00 08 	lwz     r9,8(r29)
template<typename T>
inline uint64_t convertType( T& i_value )
{
    // for simplicity sake, all FFDC chunks from the SBE
    // are going to be sent as a uint64_t
    return static_cast<uint64_t>(i_value);
fff83418:	93 df 00 18 	stw     r30,24(r31)
fff8341c:	39 29 00 08 	addi    r9,r9,8
fff83420:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83424:	39 20 00 04 	li      r9,4
fff83428:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff8342c:	93 9f 00 24 	stw     r28,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83430:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83434:	81 01 00 18 	lwz     r8,24(r1)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83438:	38 e0 00 00 	li      r7,0
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff8343c:	91 1f 00 28 	stw     r8,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83440:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE& set_CHECK_FLAGS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83444:	18 df 00 30 	stvd    d6,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83448:	91 3f 00 2c 	stw     r9,44(r31)
fff8344c:	3c 60 7c 91 	lis     r3,31889
fff83450:	4b ff cd 29 	bl      fff80178 <pk_trace_tiny>
#else
                 RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE);
#endif
fapi_try_exit:
    return fapi2::current_err;
}
fff83454:	80 01 00 34 	lwz     r0,52(r1)
fff83458:	17 81 00 20 	lvd     d28,32(r1)
fff8345c:	7c 08 03 a6 	mtlr    r0
fff83460:	17 c1 00 28 	lvd     d30,40(r1)
fff83464:	80 6d 40 4c 	lwz     r3,16460(r13)
fff83468:	38 21 00 30 	addi    r1,r1,48
fff8346c:	4e 80 00 20 	blr

fff83470 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>:
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
fff83470:	94 21 ff f0 	stwu    r1,-16(r1)
fff83474:	7c 08 02 a6 	mflr    r0
fff83478:	1b c1 00 08 	stvd    d30,8(r1)
fff8347c:	7c 7f 1b 78 	mr      r31,r3
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff83480:	7c 83 23 78 	mr      r3,r4
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
fff83484:	90 01 00 14 	stw     r0,20(r1)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff83488:	4b ff fe b1 	bl      fff83338 <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
fff8348c:	3d 20 ff f9 	lis     r9,-7
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83490:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff83494:	39 29 a8 80 	addi    r9,r9,-22400
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83498:	61 4a ff fe 	ori     r10,r10,65534
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff8349c:	90 69 00 0c 	stw     r3,12(r9)
fff834a0:	90 89 00 10 	stw     r4,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff834a4:	91 49 00 08 	stw     r10,8(r9)
        return *this;
    };
fff834a8:	7f e3 fb 78 	mr      r3,r31
fff834ac:	80 01 00 14 	lwz     r0,20(r1)
fff834b0:	17 c1 00 08 	lvd     d30,8(r1)
fff834b4:	7c 08 03 a6 	mtlr    r0
fff834b8:	38 21 00 10 	addi    r1,r1,16
fff834bc:	4e 80 00 20 	blr

fff834c0 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>:
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
fff834c0:	94 21 ff f0 	stwu    r1,-16(r1)
fff834c4:	7c 08 02 a6 	mflr    r0
fff834c8:	1b c1 00 08 	stvd    d30,8(r1)
fff834cc:	7c 7f 1b 78 	mr      r31,r3
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff834d0:	7c 83 23 78 	mr      r3,r4
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
        return *this;
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
fff834d4:	90 01 00 14 	stw     r0,20(r1)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff834d8:	4b ff fe 61 	bl      fff83338 <_ZN5fapi211convertTypeILNS_10TargetTypeE4ELNS_13MulticastTypeE0EEEyRKNS_6TargetIXT_EXT0_ENS_18plat_target_handleEEE>
fff834dc:	3d 20 ff f9 	lis     r9,-7
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff834e0:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff834e4:	39 29 a8 80 	addi    r9,r9,-22400
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff834e8:	61 4a ff fe 	ori     r10,r10,65534
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_CHIP_TARGET(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff834ec:	90 69 00 0c 	stw     r3,12(r9)
fff834f0:	90 89 00 10 	stw     r4,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff834f4:	91 49 00 08 	stw     r10,8(r9)
        return *this;
    };
fff834f8:	7f e3 fb 78 	mr      r3,r31
fff834fc:	80 01 00 14 	lwz     r0,20(r1)
fff83500:	17 c1 00 08 	lvd     d30,8(r1)
fff83504:	7c 08 03 a6 	mtlr    r0
fff83508:	38 21 00 10 	addi    r1,r1,16
fff8350c:	4e 80 00 20 	blr

fff83510 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>:
#endif // #ifndef BOOTLOADER

//waits for transmit-data-register empty
static fapi2::ReturnCode
spi_wait_for_tdr_empty(SpiControlHandle& i_handle)
{
fff83510:	94 21 ff d0 	stwu    r1,-48(r1)
fff83514:	7c 08 02 a6 	mflr    r0
fff83518:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff8351c:	39 00 00 00 	li      r8,0
fff83520:	7c 3f 0b 78 	mr      r31,r1
fff83524:	39 20 00 00 	li      r9,0
fff83528:	1b 81 00 20 	stvd    d28,32(r1)
fff8352c:	90 01 00 34 	stw     r0,52(r1)
fff83530:	59 1f 00 08 	stvdu   d8,8(r31)
fff83534:	7c 7e 1b 78 	mr      r30,r3
fff83538:	3b 80 00 00 	li      r28,0
fff8353c:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fff83540:	80 9e 00 08 	lwz     r4,8(r30)
fff83544:	7f c3 f3 78 	mr      r3,r30
fff83548:	38 84 00 08 	addi    r4,r4,8
fff8354c:	7f e5 fb 78 	mr      r5,r31
fff83550:	48 00 2e 19 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff83554:	7c 69 1b 78 	mr      r9,r3
fff83558:	90 6d 40 4c 	stw     r3,16460(r13)
fff8355c:	06 43 00 82 	bwnz    r3,fff83660 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x150>
                          i_handle.base_addr + SPIM_STATUSREG, data64));

        //checking for multiplexing error
        FAPI_ASSERT( (data64.getBit<50>() == 0),
fff83560:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff83564:	81 41 00 08 	lwz     r10,8(r1)
fff83568:	07 88 90 36 	bb0wi   r8,18,fff835d4 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0xc4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff8356c:	3d 00 00 cd 	lis     r8,205
fff83570:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83574:	3d 40 ff f9 	lis     r10,-7
fff83578:	3b ea a8 80 	addi    r31,r10,-22400
fff8357c:	91 0a a8 80 	stw     r8,-22400(r10)
fff83580:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 3 * sizeof(sbeFfdc_t);
fff83584:	39 40 00 24 	li      r10,36
fff83588:	7f c4 f3 78 	mr      r4,r30
fff8358c:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83590:	91 0d 40 4c 	stw     r8,16460(r13)
fff83594:	91 21 00 18 	stw     r9,24(r1)
fff83598:	4b ff fe d9 	bl      fff83470 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff8359c:	81 5e 00 08 	lwz     r10,8(r30)
fff835a0:	3c 60 46 80 	lis     r3,18048
fff835a4:	39 4a 00 08 	addi    r10,r10,8
fff835a8:	91 5f 00 1c 	stw     r10,28(r31)
fff835ac:	81 21 00 18 	lwz     r9,24(r1)
fff835b0:	91 3f 00 18 	stw     r9,24(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff835b4:	39 20 00 04 	li      r9,4
fff835b8:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff835bc:	15 01 00 08 	lvd     d8,8(r1)
fff835c0:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff835c4:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff835c8:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff835cc:	91 3f 00 20 	stw     r9,32(r31)
fff835d0:	48 00 00 8c 	b       fff8365c <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x14c>
                     "Port multiplexer setting error set in spi_wait_for_tdr_empty");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(!(data64.getBit<4>()))
fff835d4:	07 8a 20 46 	bb0wi   r10,4,fff83660 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x150>
fff835d8:	33 bd ff ff 	addic   r29,r29,-1
fff835dc:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> data64 = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fff835e0:	7f 8a eb 78 	or      r10,r28,r29
fff835e4:	06 4a 07 ae 	bwnz    r10,fff83540 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff835e8:	3d 00 00 1e 	lis     r8,30
fff835ec:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fff835f0:	3d 20 ff f9 	lis     r9,-7
fff835f4:	3b e9 a8 80 	addi    r31,r9,-22400
fff835f8:	91 09 a8 80 	stw     r8,-22400(r9)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fff835fc:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fff83600:	39 20 00 30 	li      r9,48
fff83604:	7f c4 f3 78 	mr      r4,r30
fff83608:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff8360c:	91 0d 40 4c 	stw     r8,16460(r13)
fff83610:	91 41 00 18 	stw     r10,24(r1)
fff83614:	4b ff fe ad 	bl      fff834c0 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83618:	81 3e 00 08 	lwz     r9,8(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff8361c:	38 c0 00 00 	li      r6,0
fff83620:	39 29 00 08 	addi    r9,r9,8
fff83624:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83628:	39 20 00 04 	li      r9,4
fff8362c:	81 41 00 18 	lwz     r10,24(r1)
fff83630:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83634:	15 01 00 08 	lvd     d8,8(r1)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83638:	38 e0 27 10 	li      r7,10000
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff8363c:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83640:	39 20 00 08 	li      r9,8
fff83644:	91 5f 00 18 	stw     r10,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83648:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff8364c:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83650:	18 df 00 30 	stvd    d6,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83654:	91 3f 00 2c 	stw     r9,44(r31)
fff83658:	3c 60 3f 0b 	lis     r3,16139
fff8365c:	4b ff cb 1d 	bl      fff80178 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fff83660:	80 01 00 34 	lwz     r0,52(r1)
fff83664:	17 81 00 20 	lvd     d28,32(r1)
fff83668:	7c 08 03 a6 	mtlr    r0
fff8366c:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fff83670:	80 6d 40 4c 	lwz     r3,16460(r13)
}
fff83674:	38 21 00 30 	addi    r1,r1,48
fff83678:	4e 80 00 20 	blr

fff8367c <_ZL17spi_wait_for_idleR16SpiControlHandle>:
}

//waits for the fsm of the spi-master to be idle
static fapi2::ReturnCode
spi_wait_for_idle(SpiControlHandle& i_handle)
{
fff8367c:	94 21 ff d0 	stwu    r1,-48(r1)
fff83680:	7c 08 02 a6 	mflr    r0
fff83684:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83688:	39 00 00 00 	li      r8,0
fff8368c:	7c 3f 0b 78 	mr      r31,r1
fff83690:	39 20 00 00 	li      r9,0
fff83694:	1b 81 00 20 	stvd    d28,32(r1)
fff83698:	90 01 00 34 	stw     r0,52(r1)
fff8369c:	59 1f 00 08 	stvdu   d8,8(r31)
fff836a0:	7c 7e 1b 78 	mr      r30,r3
fff836a4:	3b 80 00 00 	li      r28,0
fff836a8:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fff836ac:	80 9e 00 08 	lwz     r4,8(r30)
fff836b0:	7f c3 f3 78 	mr      r3,r30
fff836b4:	38 84 00 08 	addi    r4,r4,8
fff836b8:	7f e5 fb 78 	mr      r5,r31
fff836bc:	48 00 2c ad 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff836c0:	7c 69 1b 78 	mr      r9,r3
fff836c4:	90 6d 40 4c 	stw     r3,16460(r13)
fff836c8:	06 43 00 82 	bwnz    r3,fff837cc <_ZL17spi_wait_for_idleR16SpiControlHandle+0x150>
                          i_handle.base_addr + SPIM_STATUSREG, data64));

        //checking for multiplexing error
        FAPI_ASSERT( (data64.getBit<50>() == 0),
fff836cc:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff836d0:	81 41 00 08 	lwz     r10,8(r1)
fff836d4:	07 88 90 36 	bb0wi   r8,18,fff83740 <_ZL17spi_wait_for_idleR16SpiControlHandle+0xc4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff836d8:	3d 00 00 cd 	lis     r8,205
fff836dc:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff836e0:	3d 40 ff f9 	lis     r10,-7
fff836e4:	3b ea a8 80 	addi    r31,r10,-22400
fff836e8:	91 0a a8 80 	stw     r8,-22400(r10)
fff836ec:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 3 * sizeof(sbeFfdc_t);
fff836f0:	39 40 00 24 	li      r10,36
fff836f4:	7f c4 f3 78 	mr      r4,r30
fff836f8:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff836fc:	91 0d 40 4c 	stw     r8,16460(r13)
fff83700:	91 21 00 18 	stw     r9,24(r1)
fff83704:	4b ff fd 6d 	bl      fff83470 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83708:	81 5e 00 08 	lwz     r10,8(r30)
fff8370c:	3c 60 4b 06 	lis     r3,19206
fff83710:	39 4a 00 08 	addi    r10,r10,8
fff83714:	91 5f 00 1c 	stw     r10,28(r31)
fff83718:	81 21 00 18 	lwz     r9,24(r1)
fff8371c:	91 3f 00 18 	stw     r9,24(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83720:	39 20 00 04 	li      r9,4
fff83724:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83728:	15 01 00 08 	lvd     d8,8(r1)
fff8372c:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83730:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83734:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83738:	91 3f 00 20 	stw     r9,32(r31)
fff8373c:	48 00 00 8c 	b       fff837c8 <_ZL17spi_wait_for_idleR16SpiControlHandle+0x14c>
                     "Port multiplexer setting error set in spi_wait_for_idle");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(data64.getBit<15>())  //seq fsm Idle
fff83740:	07 0a 78 46 	bb1wi   r10,15,fff837cc <_ZL17spi_wait_for_idleR16SpiControlHandle+0x150>
fff83744:	33 bd ff ff 	addic   r29,r29,-1
fff83748:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> data64 = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fff8374c:	7f 8a eb 78 	or      r10,r28,r29
fff83750:	06 4a 07 ae 	bwnz    r10,fff836ac <_ZL17spi_wait_for_idleR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff83754:	3d 00 00 1e 	lis     r8,30
fff83758:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fff8375c:	3d 20 ff f9 	lis     r9,-7
fff83760:	3b e9 a8 80 	addi    r31,r9,-22400
fff83764:	91 09 a8 80 	stw     r8,-22400(r9)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fff83768:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fff8376c:	39 20 00 30 	li      r9,48
fff83770:	7f c4 f3 78 	mr      r4,r30
fff83774:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff83778:	91 0d 40 4c 	stw     r8,16460(r13)
fff8377c:	91 41 00 18 	stw     r10,24(r1)
fff83780:	4b ff fd 41 	bl      fff834c0 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83784:	81 3e 00 08 	lwz     r9,8(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83788:	38 c0 00 00 	li      r6,0
fff8378c:	39 29 00 08 	addi    r9,r9,8
fff83790:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83794:	39 20 00 04 	li      r9,4
fff83798:	81 41 00 18 	lwz     r10,24(r1)
fff8379c:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff837a0:	15 01 00 08 	lvd     d8,8(r1)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff837a4:	38 e0 27 10 	li      r7,10000
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff837a8:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff837ac:	39 20 00 08 	li      r9,8
fff837b0:	91 5f 00 18 	stw     r10,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff837b4:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff837b8:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff837bc:	18 df 00 30 	stvd    d6,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fff837c0:	91 3f 00 2c 	stw     r9,44(r31)
fff837c4:	3c 60 02 03 	lis     r3,515
fff837c8:	4b ff c9 b1 	bl      fff80178 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fff837cc:	80 01 00 34 	lwz     r0,52(r1)
fff837d0:	17 81 00 20 	lvd     d28,32(r1)
fff837d4:	7c 08 03 a6 	mtlr    r0
fff837d8:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fff837dc:	80 6d 40 4c 	lwz     r3,16460(r13)
}
fff837e0:	38 21 00 30 	addi    r1,r1,48
fff837e4:	4e 80 00 20 	blr

fff837e8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>:
}

//waits for receive-data-register full
static fapi2::ReturnCode
spi_wait_for_rdr_full(SpiControlHandle& i_handle)
{
fff837e8:	94 21 ff d0 	stwu    r1,-48(r1)
fff837ec:	7c 08 02 a6 	mflr    r0
fff837f0:	1b c1 00 28 	stvd    d30,40(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff837f4:	39 00 00 00 	li      r8,0
fff837f8:	7c 3f 0b 78 	mr      r31,r1
fff837fc:	39 20 00 00 	li      r9,0
fff83800:	1b 81 00 20 	stvd    d28,32(r1)
fff83804:	90 01 00 34 	stw     r0,52(r1)
fff83808:	59 1f 00 08 	stvdu   d8,8(r31)
fff8380c:	7c 7e 1b 78 	mr      r30,r3
fff83810:	3b 80 00 00 	li      r28,0
fff83814:	3b a0 27 10 	li      r29,10000

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fff83818:	80 9e 00 08 	lwz     r4,8(r30)
fff8381c:	7f c3 f3 78 	mr      r3,r30
fff83820:	38 84 00 08 	addi    r4,r4,8
fff83824:	7f e5 fb 78 	mr      r5,r31
fff83828:	48 00 2b 41 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff8382c:	7c 69 1b 78 	mr      r9,r3
fff83830:	90 6d 40 4c 	stw     r3,16460(r13)
fff83834:	06 43 00 82 	bwnz    r3,fff83938 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x150>
                          i_handle.base_addr + SPIM_STATUSREG, status_reg));

        //checking for multiplexing error
        FAPI_ASSERT( (status_reg.getBit<50>() == 0),
fff83838:	81 01 00 0c 	lwz     r8,12(r1)
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff8383c:	81 41 00 08 	lwz     r10,8(r1)
fff83840:	07 88 90 36 	bb0wi   r8,18,fff838ac <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0xc4>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83844:	3d 00 00 cd 	lis     r8,205
fff83848:	61 08 af 48 	ori     r8,r8,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff8384c:	3d 40 ff f9 	lis     r10,-7
fff83850:	3b ea a8 80 	addi    r31,r10,-22400
fff83854:	91 0a a8 80 	stw     r8,-22400(r10)
fff83858:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 3 * sizeof(sbeFfdc_t);
fff8385c:	39 40 00 24 	li      r10,36
fff83860:	7f c4 f3 78 	mr      r4,r30
fff83864:	91 5f 00 04 	stw     r10,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83868:	91 0d 40 4c 	stw     r8,16460(r13)
fff8386c:	91 21 00 18 	stw     r9,24(r1)
fff83870:	4b ff fc 01 	bl      fff83470 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83874:	81 5e 00 08 	lwz     r10,8(r30)
fff83878:	3c 60 92 f0 	lis     r3,-27920
fff8387c:	39 4a 00 08 	addi    r10,r10,8
fff83880:	91 5f 00 1c 	stw     r10,28(r31)
fff83884:	81 21 00 18 	lwz     r9,24(r1)
fff83888:	91 3f 00 18 	stw     r9,24(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff8388c:	39 20 00 04 	li      r9,4
fff83890:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83894:	15 01 00 08 	lvd     d8,8(r1)
fff83898:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff8389c:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff838a0:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff838a4:	91 3f 00 20 	stw     r9,32(r31)
fff838a8:	48 00 00 8c 	b       fff83934 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x14c>
                     "Port multiplexer setting error set in spi_wait_for_rdr_full");
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        if(status_reg.getBit<0>()) //Wait until RX Buffer is full
fff838ac:	06 8a 00 46 	bwltz   r10,fff83938 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x150>
fff838b0:	33 bd ff ff 	addic   r29,r29,-1
fff838b4:	7f 9c 01 d4 	addme   r28,r28
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout)
fff838b8:	7f 8a eb 78 	or      r10,r28,r29
fff838bc:	06 4a 07 ae 	bwnz    r10,fff83818 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle+0x30>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff838c0:	3d 00 00 1e 	lis     r8,30
fff838c4:	61 08 da 3a 	ori     r8,r8,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fff838c8:	3d 20 ff f9 	lis     r9,-7
fff838cc:	3b e9 a8 80 	addi    r31,r9,-22400
fff838d0:	91 09 a8 80 	stw     r8,-22400(r9)
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
        --timeout;
    }

    FAPI_ASSERT( timeout != 0,
fff838d4:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fff838d8:	39 20 00 30 	li      r9,48
fff838dc:	7f c4 f3 78 	mr      r4,r30
fff838e0:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff838e4:	91 0d 40 4c 	stw     r8,16460(r13)
fff838e8:	91 41 00 18 	stw     r10,24(r1)
fff838ec:	4b ff fb d5 	bl      fff834c0 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff838f0:	81 3e 00 08 	lwz     r9,8(r30)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff838f4:	38 c0 00 00 	li      r6,0
fff838f8:	39 29 00 08 	addi    r9,r9,8
fff838fc:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83900:	39 20 00 04 	li      r9,4
fff83904:	81 41 00 18 	lwz     r10,24(r1)
fff83908:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff8390c:	15 01 00 08 	lvd     d8,8(r1)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83910:	38 e0 27 10 	li      r7,10000
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83914:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83918:	39 20 00 08 	li      r9,8
fff8391c:	91 5f 00 18 	stw     r10,24(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83920:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83924:	91 3f 00 20 	stw     r9,32(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83928:	18 df 00 30 	stvd    d6,48(r31)
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fff8392c:	91 3f 00 2c 	stw     r9,44(r31)
fff83930:	3c 60 14 43 	lis     r3,5187
fff83934:	4b ff c8 45 	bl      fff80178 <pk_trace_tiny>
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fff83938:	80 01 00 34 	lwz     r0,52(r1)
fff8393c:	17 81 00 20 	lvd     d28,32(r1)
fff83940:	7c 08 03 a6 	mtlr    r0
fff83944:	17 c1 00 28 	lvd     d30,40(r1)
#else
                 RC_SBE_SPI_HANG_TIMEOUT );
#endif

fapi_try_exit:
    return fapi2::current_err;
fff83948:	80 6d 40 4c 	lwz     r3,16460(r13)
}
fff8394c:	38 21 00 30 	addi    r1,r1,48
fff83950:	4e 80 00 20 	blr

fff83954 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>:
    uint64_t CNT = 0;
    uint64_t TDR;
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    int number_rdr = i_length / 8;

    if ((i_length > MAX_LENGTH_TRNS) || (i_length % 8))
fff83954:	28 05 00 08 	cmplwi  r5,8
 */
#ifndef BOOTLOADER
static fapi2::ReturnCode
spi_read_secure(SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
                uint8_t* o_buffer, SPI_ECC_CONTROL_STATUS i_eccStatus)
{
fff83958:	94 21 ff c8 	stwu    r1,-56(r1)
fff8395c:	7c 08 02 a6 	mflr    r0
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83960:	39 00 00 00 	li      r8,0
fff83964:	39 20 00 00 	li      r9,0
fff83968:	1b 81 00 28 	stvd    d28,40(r1)
fff8396c:	90 01 00 3c 	stw     r0,60(r1)
fff83970:	1b c1 00 30 	stvd    d30,48(r1)
fff83974:	7c bd 2b 78 	mr      r29,r5
fff83978:	90 c1 00 18 	stw     r6,24(r1)
fff8397c:	19 01 00 08 	stvd    d8,8(r1)
    uint64_t CNT = 0;
    uint64_t TDR;
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    int number_rdr = i_length / 8;

    if ((i_length > MAX_LENGTH_TRNS) || (i_length % 8))
fff83980:	41 81 00 0c 	bgt     fff8398c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x38>
fff83984:	54 a9 07 7e 	clrlwi  r9,r5,29
fff83988:	06 c9 00 08 	bwz     r9,fff83998 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x44>
    {
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
fff8398c:	3c 60 04 00 	lis     r3,1024
fff83990:	60 63 00 04 	ori     r3,r3,4
fff83994:	48 00 01 7c 	b       fff83b10 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1bc>
fff83998:	7c 7f 1b 78 	mr      r31,r3
fff8399c:	7c 9e 23 78 	mr      r30,r4
    }


    if((i_eccStatus == STANDARD_ECC_ACCESS) ||
fff839a0:	07 47 f0 18 	clrbwibnz r7,30,fff839d0 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x7c>
       (i_eccStatus == DISCARD_ECC_ACCESS)   )
    {
        if (i_address % 8) //Address should be aligned for ecc
fff839a4:	54 89 07 7e 	clrlwi  r9,r4,29
fff839a8:	06 49 07 f2 	bwnz    r9,fff8398c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x38>
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        if (i_length <= 8)
        {
            SEQ = 0x1034491000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); // slave0, TX4, RX9, loop
fff839ac:	a1 23 00 06 	lhz     r9,6(r3)
fff839b0:	39 00 00 00 	li      r8,0
fff839b4:	79 08 c1 c6 	rldicr  d8,d8,56,7
fff839b8:	65 05 10 34 	oris    r5,r8,4148
            FAPI_ERR( "spi_read_secure: (ecc) Read length is greater than 40 bytes, which cannot be"
                      " done in a secure read. i_length = %d", i_length);
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        i_address = i_address * 9 / 8;
fff839bc:	1f c4 00 09 	mulli   r30,r4,9
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        if (i_length <= 8)
        {
            SEQ = 0x1034491000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); // slave0, TX4, RX9, loop
fff839c0:	60 a5 49 10 	ori     r5,r5,18704
fff839c4:	7d 26 4b 78 	mr      r6,r9
            FAPI_ERR( "spi_read_secure: (ecc) Read length is greater than 40 bytes, which cannot be"
                      " done in a secure read. i_length = %d", i_length);
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }

        i_address = i_address * 9 / 8;
fff839c8:	57 de e8 fe 	rlwinm  r30,r30,29,3,31
fff839cc:	48 00 00 1c 	b       fff839e8 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x94>
    }
    else
    {
        if (i_length <= 8)
        {
            SEQ = 0x1034481000000000ULL | (static_cast<uint64_t>(i_handle.slave) << 56); //slave0, TX4, RX8, loop
fff839d0:	a1 23 00 06 	lhz     r9,6(r3)
fff839d4:	39 00 00 00 	li      r8,0
fff839d8:	79 08 c1 c6 	rldicr  d8,d8,56,7
fff839dc:	65 05 10 34 	oris    r5,r8,4148
fff839e0:	60 a5 48 10 	ori     r5,r5,18448
fff839e4:	7d 26 4b 78 	mr      r6,r9
            return fapi2::FAPI2_RC_INVALID_PARAMETER;
        }
    }

    //Check the state of the h/w
    rc = spi_precheck(i_handle);
fff839e8:	7f e3 fb 78 	mr      r3,r31
fff839ec:	90 a1 00 1c 	stw     r5,28(r1)
fff839f0:	90 c1 00 20 	stw     r6,32(r1)
fff839f4:	4b ff f9 8d 	bl      fff83380 <spi_precheck>
fff839f8:	7c 7c 1b 78 	mr      r28,r3

    if (rc != fapi2::FAPI2_RC_SUCCESS)
fff839fc:	80 a1 00 1c 	lwz     r5,28(r1)
fff83a00:	80 c1 00 20 	lwz     r6,32(r1)
fff83a04:	06 5c 00 86 	bwnz    r28,fff83b10 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1bc>
    }

    /*Read command (0x3)|| address in TDR to be sent to the slave*/
    TDR = SPI_SLAVE_RD_CMD | ((uint64_t)i_address << 32);

    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fff83a08:	80 9f 00 08 	lwz     r4,8(r31)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff83a0c:	7f e3 fb 78 	mr      r3,r31
fff83a10:	38 84 00 07 	addi    r4,r4,7
fff83a14:	48 00 29 a9 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83a18:	90 6d 40 4c 	stw     r3,16460(r13)
fff83a1c:	06 43 00 78 	bwnz    r3,fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fff83a20:	80 9f 00 08 	lwz     r4,8(r31)
fff83a24:	7f e3 fb 78 	mr      r3,r31
fff83a28:	38 84 00 01 	addi    r4,r4,1
fff83a2c:	38 a0 00 00 	li      r5,0
fff83a30:	38 c0 00 00 	li      r6,0
fff83a34:	48 00 29 89 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83a38:	90 6d 40 4c 	stw     r3,16460(r13)
fff83a3c:	06 43 00 68 	bwnz    r3,fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, TDR));
fff83a40:	80 9f 00 08 	lwz     r4,8(r31)
fff83a44:	67 c5 03 00 	oris    r5,r30,768
fff83a48:	7f e3 fb 78 	mr      r3,r31
fff83a4c:	38 84 00 05 	addi    r4,r4,5
fff83a50:	38 c0 00 00 	li      r6,0
fff83a54:	48 00 29 69 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83a58:	90 6d 40 4c 	stw     r3,16460(r13)
fff83a5c:	3b c0 00 00 	li      r30,0
fff83a60:	06 43 00 56 	bwnz    r3,fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
    {
        rc = spi_wait_for_rdr_full(i_handle);
fff83a64:	7f e3 fb 78 	mr      r3,r31
        }

        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
fff83a68:	05 1e e8 24 	cmplwbge r30,r29,fff83ab0 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x15c>
    {
        rc = spi_wait_for_rdr_full(i_handle);
fff83a6c:	4b ff fd 7d 	bl      fff837e8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fff83a70:	7c 7c 1b 78 	mr      r28,r3

        if (rc)
fff83a74:	06 c3 00 06 	bwz     r3,fff83a80 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x12c>
        {
            FAPI_ERR("Error in spi_wait_for_rdr_full");
fff83a78:	3c 60 c9 6f 	lis     r3,-13969
fff83a7c:	48 00 00 44 	b       fff83ac0 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x16c>
            fapi2::current_err = rc;
            goto fapi_try_exit;
        }

        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fff83a80:	80 9f 00 08 	lwz     r4,8(r31)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff83a84:	7f e3 fb 78 	mr      r3,r31
fff83a88:	38 84 00 06 	addi    r4,r4,6
fff83a8c:	38 a1 00 08 	addi    r5,r1,8
fff83a90:	48 00 28 d9 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff83a94:	90 6d 40 4c 	stw     r3,16460(r13)
fff83a98:	06 43 00 3a 	bwnz    r3,fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fff83a9c:	15 01 00 08 	lvd     d8,8(r1)
        data64.extract<0, 64>(temp);
#ifndef _BIG_ENDIAN
        fapi2::endian_swap(temp);
#endif
        ((uint64_t*)o_buffer)[i / 8] = temp;
fff83aa0:	81 41 00 18 	lwz     r10,24(r1)
        }

        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
    }

    for (uint32_t i = 0; i < i_length; i += 8)
fff83aa4:	3b de 00 08 	addi    r30,r30,8
        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
        data64.extract<0, 64>(temp);
#ifndef _BIG_ENDIAN
        fapi2::endian_swap(temp);
#endif
        ((uint64_t*)o_buffer)[i / 8] = temp;
fff83aa8:	19 0a 00 00 	stvd    d8,0(r10)
fff83aac:	4b ff ff b8 	b       fff83a64 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x110>
    }

    rc = spi_wait_for_idle(i_handle);
fff83ab0:	4b ff fb cd 	bl      fff8367c <_ZL17spi_wait_for_idleR16SpiControlHandle>
fff83ab4:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fff83ab8:	06 c3 00 0a 	bwz     r3,fff83acc <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x178>
    {
        FAPI_ERR("Multiplexing Error in spi_wait_for_idle ");
fff83abc:	3c 60 03 7d 	lis     r3,893
fff83ac0:	4b ff c6 b9 	bl      fff80178 <pk_trace_tiny>
        fapi2::current_err = rc;
fff83ac4:	93 8d 40 4c 	stw     r28,16460(r13)
        goto fapi_try_exit;
fff83ac8:	48 00 00 44 	b       fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    }

    /*Restore the default counter and seq used by the side band path*/
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, 0x0ULL));
fff83acc:	80 9f 00 08 	lwz     r4,8(r31)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff83ad0:	7f e3 fb 78 	mr      r3,r31
fff83ad4:	38 84 00 01 	addi    r4,r4,1
fff83ad8:	38 a0 00 00 	li      r5,0
fff83adc:	38 c0 00 00 	li      r6,0
fff83ae0:	48 00 28 dd 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83ae4:	90 6d 40 4c 	stw     r3,16460(r13)
fff83ae8:	06 43 00 12 	bwnz    r3,fff83b0c <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS+0x1b8>
    FAPI_TRY(putScom(i_handle.target_chip,
fff83aec:	80 9f 00 08 	lwz     r4,8(r31)
fff83af0:	3c a0 11 34 	lis     r5,4404
fff83af4:	7f e3 fb 78 	mr      r3,r31
fff83af8:	38 84 00 07 	addi    r4,r4,7
fff83afc:	60 a5 49 10 	ori     r5,r5,18704
fff83b00:	38 c0 00 00 	li      r6,0
fff83b04:	48 00 28 b9 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83b08:	90 6d 40 4c 	stw     r3,16460(r13)
                     i_handle.base_addr + SPIM_SEQREG, SPI_DEFAULT_SEQ));

fapi_try_exit:
    return fapi2::current_err;
fff83b0c:	80 6d 40 4c 	lwz     r3,16460(r13)
}
fff83b10:	80 01 00 3c 	lwz     r0,60(r1)
fff83b14:	17 81 00 28 	lvd     d28,40(r1)
fff83b18:	7c 08 03 a6 	mtlr    r0
fff83b1c:	17 c1 00 30 	lvd     d30,48(r1)
fff83b20:	38 21 00 38 	addi    r1,r1,56
fff83b24:	4e 80 00 20 	blr

fff83b28 <spi_read>:

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fff83b28:	94 21 ff c8 	stwu    r1,-56(r1)
fff83b2c:	7c 08 02 a6 	mflr    r0
fff83b30:	1b 81 00 28 	stvd    d28,40(r1)
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fff83b34:	39 20 00 00 	li      r9,0

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fff83b38:	7c 9c 23 78 	mr      r28,r4
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fff83b3c:	7c 24 0b 78 	mr      r4,r1

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fff83b40:	1b c1 00 30 	stvd    d30,48(r1)
fff83b44:	90 01 00 3c 	stw     r0,60(r1)
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
fff83b48:	9d 24 00 08 	stbu    r9,8(r4)

#ifndef BOOTLOADER
fapi2::ReturnCode
spi_read( SpiControlHandle& i_handle, uint32_t i_address, uint32_t i_length,
          SPI_ECC_CONTROL_STATUS i_eccStatus, uint8_t* o_buffer )
{
fff83b4c:	7c 7f 1b 78 	mr      r31,r3
fff83b50:	7c be 2b 78 	mr      r30,r5
fff83b54:	90 c1 00 18 	stw     r6,24(r1)
fff83b58:	7c fd 3b 78 	mr      r29,r7
    fapi2::ReturnCode rc  = fapi2::FAPI2_RC_SUCCESS;
    uint32_t readlen = 0, i;
    bool l_ecc = false;
    is_ecc_on(i_handle, l_ecc);
fff83b5c:	4b ff f7 6d 	bl      fff832c8 <_ZL9is_ecc_onR16SpiControlHandleRb>

    if ((i_eccStatus == RAW_BYTE_ACCESS) && (l_ecc))
fff83b60:	81 21 00 18 	lwz     r9,24(r1)
fff83b64:	06 49 08 0a 	cmpwibne r9,1,fff83b78 <spi_read+0x50>
fff83b68:	89 21 00 08 	lbz     r9,8(r1)
fff83b6c:	06 c9 00 06 	bwz     r9,fff83b78 <spi_read+0x50>
    {
        spi_set_ecc_off(i_handle);
fff83b70:	7f e3 fb 78 	mr      r3,r31
fff83b74:	4b ff f6 6d 	bl      fff831e0 <_ZL15spi_set_ecc_offR16SpiControlHandle>
    }

    do
    {

        if (i_length <= MAX_LENGTH_TRNS)
fff83b78:	28 1e 00 08 	cmplwi  r30,8
fff83b7c:	39 00 00 00 	li      r8,0
fff83b80:	41 a1 00 68 	bgt     fff83be8 <spi_read+0xc0>
        {
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
fff83b84:	80 e1 00 18 	lwz     r7,24(r1)
fff83b88:	7f e3 fb 78 	mr      r3,r31
fff83b8c:	7f 84 e3 78 	mr      r4,r28
fff83b90:	7f c5 f3 78 	mr      r5,r30
fff83b94:	7f a6 eb 78 	mr      r6,r29
fff83b98:	4b ff fd bd 	bl      fff83954 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>
fff83b9c:	7c 6a 1b 78 	mr      r10,r3
            break;
fff83ba0:	48 00 00 60 	b       fff83c00 <spi_read+0xd8>
        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
        {
            readlen = (i_length - i) < MAX_LENGTH_TRNS ?
                      (i_length - i) : MAX_LENGTH_TRNS;

            if (readlen == 0)
fff83ba4:	06 c9 00 2c 	bwz     r9,fff83bfc <spi_read+0xd4>
            {
                break;
            }

            rc = spi_read_secure( i_handle, i_address,
                                  readlen, o_buffer, i_eccStatus );
fff83ba8:	80 e1 00 18 	lwz     r7,24(r1)
fff83bac:	7d 25 4b 78 	mr      r5,r9
fff83bb0:	7f e3 fb 78 	mr      r3,r31
fff83bb4:	7f 84 e3 78 	mr      r4,r28
fff83bb8:	7f a6 eb 78 	mr      r6,r29
fff83bbc:	91 01 00 20 	stw     r8,32(r1)
fff83bc0:	91 21 00 1c 	stw     r9,28(r1)
fff83bc4:	4b ff fd 91 	bl      fff83954 <_ZL15spi_read_secureR16SpiControlHandlemmPh22SPI_ECC_CONTROL_STATUS>
fff83bc8:	7c 6a 1b 78 	mr      r10,r3

            if (rc != fapi2::FAPI2_RC_SUCCESS)
fff83bcc:	81 01 00 20 	lwz     r8,32(r1)
fff83bd0:	81 21 00 1c 	lwz     r9,28(r1)
fff83bd4:	06 43 00 16 	bwnz    r3,fff83c00 <spi_read+0xd8>
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
            break;
        }

        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
fff83bd8:	39 08 00 08 	addi    r8,r8,8
            if (rc != fapi2::FAPI2_RC_SUCCESS)
            {
                break;
            }

            i_address += readlen;
fff83bdc:	7f 9c 4a 14 	add     r28,r28,r9
            o_buffer = (uint8_t*)(reinterpret_cast<uint64_t>(o_buffer) + readlen);
fff83be0:	7f bd 4a 14 	add     r29,r29,r9
            rc = spi_read_secure( i_handle, i_address,
                                  i_length, o_buffer, i_eccStatus );
            break;
        }

        for(i = 0; i < i_length; i += MAX_LENGTH_TRNS)
fff83be4:	05 08 f0 0e 	cmplwbge r8,r30,fff83c00 <spi_read+0xd8>
fff83be8:	7d 28 f0 50 	subf    r9,r8,r30
        {
            readlen = (i_length - i) < MAX_LENGTH_TRNS ?
                      (i_length - i) : MAX_LENGTH_TRNS;
fff83bec:	28 09 00 08 	cmplwi  r9,8
fff83bf0:	40 a1 ff b4 	ble     fff83ba4 <spi_read+0x7c>
fff83bf4:	39 20 00 08 	li      r9,8
fff83bf8:	4b ff ff b0 	b       fff83ba8 <spi_read+0x80>
fff83bfc:	39 40 00 00 	li      r10,0

    }
    while(0);

    // Restore ECC setting, if necessary
    if ((i_eccStatus == RAW_BYTE_ACCESS) && (l_ecc))
fff83c00:	81 21 00 18 	lwz     r9,24(r1)
fff83c04:	06 49 08 0e 	cmpwibne r9,1,fff83c20 <spi_read+0xf8>
fff83c08:	89 21 00 08 	lbz     r9,8(r1)
fff83c0c:	06 c9 00 0a 	bwz     r9,fff83c20 <spi_read+0xf8>
    {
        spi_set_ecc_on(i_handle);
fff83c10:	7f e3 fb 78 	mr      r3,r31
fff83c14:	91 41 00 1c 	stw     r10,28(r1)
fff83c18:	4b ff f6 3d 	bl      fff83254 <_ZL14spi_set_ecc_onR16SpiControlHandle>
fff83c1c:	81 41 00 1c 	lwz     r10,28(r1)
    }

    return rc;
}
fff83c20:	80 01 00 3c 	lwz     r0,60(r1)
fff83c24:	17 81 00 28 	lvd     d28,40(r1)
fff83c28:	7c 08 03 a6 	mtlr    r0
fff83c2c:	17 c1 00 30 	lvd     d30,48(r1)
fff83c30:	7d 43 53 78 	mr      r3,r10
fff83c34:	38 21 00 38 	addi    r1,r1,56
fff83c38:	4e 80 00 20 	blr

fff83c3c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23>:
 * @param[in]  i_handle - handle for SPI operations
 * @param[in]  i_index - SEQ index to check has executed
 * @return     Error RC if timeout or multiplexing error detected
 */
static fapi2::ReturnCode
spi_wait_for_seq_index_pass(SpiControlHandle& i_handle, const uint32_t i_index)
fff83c3c:	94 21 ff d0 	stwu    r1,-48(r1)
fff83c40:	7c 08 02 a6 	mflr    r0
fff83c44:	1b 81 00 20 	stvd    d28,32(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83c48:	39 00 00 00 	li      r8,0
fff83c4c:	7c 3c 0b 78 	mr      r28,r1
fff83c50:	39 20 00 00 	li      r9,0
fff83c54:	1b c1 00 28 	stvd    d30,40(r1)
fff83c58:	90 01 00 34 	stw     r0,52(r1)
fff83c5c:	59 1c 00 08 	stvdu   d8,8(r28)
fff83c60:	7c 7d 1b 78 	mr      r29,r3
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;
fff83c64:	3b c0 00 00 	li      r30,0
fff83c68:	3b e0 27 10 	li      r31,10000

    while(timeout--)
fff83c6c:	33 ff ff ff 	addic   r31,r31,-1
fff83c70:	7f de 01 d4 	addme   r30,r30
fff83c74:	2c 1e ff ff 	cmpwi   r30,-1
fff83c78:	41 82 00 b4 	beq     fff83d2c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0xf0>
    {
        FAPI_TRY(getScom( i_handle.target_chip,
fff83c7c:	80 9d 00 08 	lwz     r4,8(r29)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff83c80:	7f a3 eb 78 	mr      r3,r29
fff83c84:	38 84 00 08 	addi    r4,r4,8
fff83c88:	7f 85 e3 78 	mr      r5,r28
fff83c8c:	48 00 26 dd 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff83c90:	7c 68 1b 78 	mr      r8,r3
fff83c94:	90 6d 40 4c 	stw     r3,16460(r13)
fff83c98:	06 43 00 96 	bwnz    r3,fff83dc4 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x188>
        /// @note 0 is left-most
        ///
        template< bits_type B, bits_type C = 1>
        inline bool getBit(void) const
        {
            return buffer<T>().template setBit<B, C>() & iv_data;
fff83c9c:	15 21 00 08 	lvd     d9,8(r1)
fff83ca0:	55 4a 04 a4 	rlwinm  r10,r10,0,18,18
                          i_handle.base_addr + SPIM_STATUSREG, status_reg));

        //checking for multiplexing error
        FAPI_ASSERT( (status_reg.getBit<50>() == 0),
fff83ca4:	06 ca 00 38 	bwz     r10,fff83d14 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0xd8>
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83ca8:	3d 40 00 cd 	lis     r10,205
fff83cac:	61 4a af 48 	ori     r10,r10,44872
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83cb0:	3d 20 ff f9 	lis     r9,-7
fff83cb4:	3b e9 a8 80 	addi    r31,r9,-22400
fff83cb8:	91 49 a8 80 	stw     r10,-22400(r9)
fff83cbc:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 3 * sizeof(sbeFfdc_t);
fff83cc0:	39 20 00 24 	li      r9,36
fff83cc4:	7f a4 eb 78 	mr      r4,r29
fff83cc8:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_INVALID_PORT_MULTIPLEX_SET()
    {
        fapi2::current_err = RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET;
fff83ccc:	91 4d 40 4c 	stw     r10,16460(r13)
fff83cd0:	91 01 00 18 	stw     r8,24(r1)
fff83cd4:	4b ff f7 9d 	bl      fff83470 <_ZN5fapi234SBE_SPI_INVALID_PORT_MULTIPLEX_SET15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83cd8:	81 3d 00 08 	lwz     r9,8(r29)
fff83cdc:	3c 60 03 ff 	lis     r3,1023
fff83ce0:	39 29 00 08 	addi    r9,r9,8
fff83ce4:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83ce8:	39 20 00 04 	li      r9,4
fff83cec:	81 01 00 18 	lwz     r8,24(r1)
fff83cf0:	91 3f 00 14 	stw     r9,20(r31)
fff83cf4:	91 1f 00 18 	stw     r8,24(r31)
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83cf8:	15 01 00 08 	lvd     d8,8(r1)
fff83cfc:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83d00:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_INVALID_PORT_MULTIPLEX_SET& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83d04:	91 1f 00 24 	stw     r8,36(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83d08:	91 3f 00 20 	stw     r9,32(r31)
fff83d0c:	4b ff c4 6d 	bl      fff80178 <pk_trace_tiny>
fff83d10:	48 00 00 b4 	b       fff83dc4 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x188>
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        // 28 to 31 Sequencer index - Sequence index currently being executed
        status_reg = (status_reg >> 32) & 0x000000000000000FULL;
fff83d14:	55 29 07 3e 	clrlwi  r9,r9,28

        if(status_reg > i_index)
fff83d18:	28 09 00 03 	cmplwi  r9,3
#else
                     RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET);
#endif

        // 28 to 31 Sequencer index - Sequence index currently being executed
        status_reg = (status_reg >> 32) & 0x000000000000000FULL;
fff83d1c:	91 41 00 08 	stw     r10,8(r1)
fff83d20:	91 21 00 0c 	stw     r9,12(r1)

        if(status_reg > i_index)
fff83d24:	40 81 ff 48 	ble     fff83c6c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x30>
fff83d28:	48 00 00 10 	b       fff83d38 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0xfc>
{
    fapi2::buffer<uint64_t> status_reg = 0;

    uint64_t timeout = SPI_TIMEOUT_MAX_WAIT_COUNT;

    while(timeout--)
fff83d2c:	2c 1f ff ff 	cmpwi   r31,-1
fff83d30:	40 82 ff 4c 	bne     fff83c7c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x40>
fff83d34:	48 00 00 90 	b       fff83dc4 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x188>
        fapi2::delay(SPI_TIMEOUT_DELAY_NS, SPI_TIMEOUT_DELAY_NS_SIM_CYCLES);
#endif
    }

    FAPI_DBG("wait_for_seq_index_pass(%d) timeout %lld msec", i_index, timeout);
    FAPI_ASSERT( timeout != 0,
fff83d38:	7f de fb 78 	or      r30,r30,r31
fff83d3c:	06 5e 00 44 	bwnz    r30,fff83dc4 <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23+0x188>
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff83d40:	3d 40 00 1e 	lis     r10,30
fff83d44:	61 4a da 3a 	ori     r10,r10,55866
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion.");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SPI_HANG_TIMEOUT;
fff83d48:	3d 20 ff f9 	lis     r9,-7
fff83d4c:	3b e9 a8 80 	addi    r31,r9,-22400
fff83d50:	91 49 a8 80 	stw     r10,-22400(r9)
fff83d54:	38 61 00 10 	addi    r3,r1,16
        fapi2::g_FfdcData.ffdcLength = 4 * sizeof(sbeFfdc_t);
fff83d58:	39 20 00 30 	li      r9,48
fff83d5c:	7f a4 eb 78 	mr      r4,r29
fff83d60:	91 3f 00 04 	stw     r9,4(r31)
    {

    }
    SBE_SPI_HANG_TIMEOUT()
    {
        fapi2::current_err = RC_SBE_SPI_HANG_TIMEOUT;
fff83d64:	91 4d 40 4c 	stw     r10,16460(r13)
fff83d68:	4b ff f7 59 	bl      fff834c0 <_ZN5fapi220SBE_SPI_HANG_TIMEOUT15set_CHIP_TARGETINS_6TargetILNS_10TargetTypeE4ELNS_13MulticastTypeE0ENS_18plat_target_handleEEEEERS0_RKT_>
fff83d6c:	81 3d 00 08 	lwz     r9,8(r29)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83d70:	38 c0 00 00 	li      r6,0
fff83d74:	39 29 00 08 	addi    r9,r9,8
fff83d78:	91 3f 00 1c 	stw     r9,28(r31)
  public:
    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_BASE_ADDRESS(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83d7c:	39 20 00 04 	li      r9,4
fff83d80:	91 3f 00 14 	stw     r9,20(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83d84:	15 01 00 08 	lvd     d8,8(r1)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83d88:	38 e0 27 10 	li      r7,10000
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83d8c:	91 3f 00 28 	stw     r9,40(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83d90:	39 20 00 08 	li      r9,8
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
fff83d94:	18 df 00 30 	stvd    d6,48(r31)
    };

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_STATUS_REGISTER(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[2].data= convertType(i_value);
fff83d98:	91 1f 00 24 	stw     r8,36(r31)
fff83d9c:	3c 60 66 d3 	lis     r3,26323
fff83da0:	93 df 00 18 	stw     r30,24(r31)
        fapi2::g_FfdcData.ffdcData[2].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83da4:	91 3f 00 20 	stw     r9,32(r31)

    template< typename T >
    inline SBE_SPI_HANG_TIMEOUT& set_TIMEOUT_MSEC(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[3].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[3].size = fapi2::getErrorInfoFfdcSize(i_value);
fff83da8:	91 3f 00 2c 	stw     r9,44(r31)
fff83dac:	60 63 00 01 	ori     r3,r3,1
fff83db0:	38 a0 00 03 	li      r5,3
fff83db4:	38 c0 00 00 	li      r6,0
fff83db8:	38 e0 00 00 	li      r7,0
fff83dbc:	39 00 00 00 	li      r8,0
fff83dc0:	4b ff f2 a5 	bl      fff83064 <pk_trace_big>
                 RC_SBE_SPI_HANG_TIMEOUT);
#endif

fapi_try_exit:
    return fapi2::current_err;
}
fff83dc4:	80 01 00 34 	lwz     r0,52(r1)
fff83dc8:	17 81 00 20 	lvd     d28,32(r1)
fff83dcc:	7c 08 03 a6 	mtlr    r0
fff83dd0:	17 c1 00 28 	lvd     d30,40(r1)
fff83dd4:	80 6d 40 4c 	lwz     r3,16460(r13)
fff83dd8:	38 21 00 30 	addi    r1,r1,48
fff83ddc:	4e 80 00 20 	blr

fff83de0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>:
  */
fapi2::ReturnCode spi_tpm_read_internal_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_address,
        uint8_t i_length,
        uint8_t* o_buffer )
{
fff83de0:	94 21 ff c8 	stwu    r1,-56(r1)
fff83de4:	7c 08 02 a6 	mflr    r0
    tpmSpiCmd_t startReadCmd = {0};

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fff83de8:	28 05 00 08 	cmplwi  r5,8
  */
fapi2::ReturnCode spi_tpm_read_internal_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_address,
        uint8_t i_length,
        uint8_t* o_buffer )
{
fff83dec:	1b 81 00 28 	stvd    d28,40(r1)
fff83df0:	1b c1 00 30 	stvd    d30,48(r1)
fff83df4:	90 01 00 3c 	stw     r0,60(r1)
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff83df8:	39 00 00 00 	li      r8,0
fff83dfc:	39 20 00 00 	li      r9,0
fff83e00:	7c 7d 1b 78 	mr      r29,r3
fff83e04:	7c bf 2b 78 	mr      r31,r5
fff83e08:	7c de 33 78 	mr      r30,r6
fff83e0c:	19 01 00 10 	stvd    d8,16(r1)
    uint64_t SEQ;
    uint64_t CNT;
    fapi2::buffer<uint64_t> data64 = 0;
    uint64_t temp = 0;
fff83e10:	19 01 00 08 	stvd    d8,8(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpmSpiCmd_t startReadCmd = {0};
fff83e14:	3b 80 00 00 	li      r28,0
fff83e18:	a0 e3 00 06 	lhz     r7,6(r3)

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fff83e1c:	41 81 00 38 	bgt     fff83e54 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x74>
        // Shift out 4 bytes of TDR (the read/write bit, the size, the address),
        // then switch to reading and if the next bytes is not 1, then go to
        // sequence opcode (2), and keep doing that until the data is 0x1.
        // (that covers the flow control), then start reading the actual # of
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fff83e20:	54 e9 04 3e 	clrlwi  r9,r7,16
fff83e24:	39 00 00 00 	li      r8,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e28:	79 08 c1 c6 	rldicr  d8,d8,56,7
        // Shift out 4 bytes of TDR (the read/write bit, the size, the address),
        // then switch to reading and if the next bytes is not 1, then go to
        // sequence opcode (2), and keep doing that until the data is 0x1.
        // (that covers the flow control), then start reading the actual # of
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fff83e2c:	7c a7 2b 78 	mr      r7,r5
fff83e30:	65 08 10 34 	oris    r8,r8,4148
fff83e34:	38 c0 00 00 	li      r6,0
fff83e38:	78 c6 c1 e4 	rldicr  d6,d6,24,39
fff83e3c:	61 08 41 62 	ori     r8,r8,16738
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e40:	64 e9 40 10 	oris    r9,r7,16400
fff83e44:	7d 05 33 78 	or      r5,r8,r6
        CNT = 0;
fff83e48:	39 40 00 00 	li      r10,0
fff83e4c:	38 e0 00 00 	li      r7,0
fff83e50:	48 00 00 58 	b       fff83ea8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xc8>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e54:	54 e9 04 3e 	clrlwi  r9,r7,16
fff83e58:	39 00 00 00 	li      r8,0
fff83e5c:	79 08 c1 c6 	rldicr  d8,d8,56,7
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0;
    }
    else if((i_length % 8) == 0)
fff83e60:	54 a5 07 7e 	clrlwi  r5,r5,29
fff83e64:	57 ea e8 fe 	rlwinm  r10,r31,29,3,31
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e68:	65 08 10 34 	oris    r8,r8,4148
        // bytes the TPM is trying to send back
        SEQ = 0x1034416240100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0;
    }
    else if((i_length % 8) == 0)
fff83e6c:	06 45 00 0a 	bwnz    r5,fff83e80 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xa0>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416248E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e70:	3d 20 48 e4 	lis     r9,18660
fff83e74:	61 05 41 62 	ori     r5,r8,16738
fff83e78:	61 29 10 00 	ori     r9,r9,4096
fff83e7c:	48 00 00 24 	b       fff83ea0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0xc0>
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  40 = Shift_N2 - 0 bytes to receive
        //                    10 = select_slave 0 - deselect any slave
        //                      00 = STOP
        SEQ = 0x1034416248E44010ULL | (static_cast<uint64_t>((i_length) % 8) << 8)
              | (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e80:	7c a7 2b 78 	mr      r7,r5
fff83e84:	38 c0 00 00 	li      r6,0
fff83e88:	3d 20 48 e4 	lis     r9,18660
        //              48 = Shift_N2 - 8 bytes to receive
        //                E4 = Branch if Not Equal and Increment - SEQ opcode (4)
        //                  40 = Shift_N2 - 0 bytes to receive
        //                    10 = select_slave 0 - deselect any slave
        //                      00 = STOP
        SEQ = 0x1034416248E44010ULL | (static_cast<uint64_t>((i_length) % 8) << 8)
fff83e8c:	78 c6 45 e4 	rldicr  d6,d6,8,55
fff83e90:	61 08 41 62 	ori     r8,r8,16738
              | (static_cast<uint64_t>(i_handle.slave) << 56);
fff83e94:	61 29 40 10 	ori     r9,r9,16400
fff83e98:	7d 05 33 78 	or      r5,r8,r6
fff83e9c:	7d 29 3b 78 	or      r9,r9,r7
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x6F) << 8);
fff83ea0:	39 4a ff ff 	addi    r10,r10,-1
fff83ea4:	38 e0 6f 00 	li      r7,28416
    }

    // Initial TDR command
    startReadCmd.cmd_bits.readNotWrite = 1;
fff83ea8:	38 c0 00 01 	li      r6,1
fff83eac:	50 dc f8 00 	rlwimi  r28,r6,31,0,0
    startReadCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fff83eb0:	38 df ff ff 	addi    r6,r31,-1
fff83eb4:	50 dc c0 8e 	rlwimi  r28,r6,24,2,7
    startReadCmd.cmd_bits.addr = i_address;
fff83eb8:	50 9c 02 3e 	rlwimi  r28,r4,0,8,31

    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fff83ebc:	80 9d 00 08 	lwz     r4,8(r29)
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff83ec0:	7f a3 eb 78 	mr      r3,r29
fff83ec4:	38 84 00 07 	addi    r4,r4,7
fff83ec8:	7d 26 4b 78 	mr      r6,r9
fff83ecc:	90 e1 00 20 	stw     r7,32(r1)
fff83ed0:	91 41 00 1c 	stw     r10,28(r1)
fff83ed4:	48 00 24 e9 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83ed8:	90 6d 40 4c 	stw     r3,16460(r13)
fff83edc:	80 e1 00 20 	lwz     r7,32(r1)
fff83ee0:	81 41 00 1c 	lwz     r10,28(r1)
fff83ee4:	06 c3 00 06 	bwz     r3,fff83ef0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x110>
        ///
        /// @brief Constructor.
        /// @param[in] i_rc the rc to set
        ///
        ReturnCode(const uint32_t i_rc = FAPI2_RC_SUCCESS):
            iv_rc(i_rc)
fff83ee8:	3b 80 00 00 	li      r28,0
fff83eec:	48 00 02 64 	b       fff84150 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x370>
    FAPI_DBG("Address: 0x%08X, MMSPIMREG: 0x%016X", i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg));
fff83ef0:	80 9d 00 08 	lwz     r4,8(r29)
fff83ef4:	3c c0 ff 01 	lis     r6,-255
fff83ef8:	7f a3 eb 78 	mr      r3,r29
fff83efc:	38 84 00 04 	addi    r4,r4,4
fff83f00:	38 a0 00 00 	li      r5,0
fff83f04:	60 c6 ff 00 	ori     r6,r6,65280
fff83f08:	90 e1 00 20 	stw     r7,32(r1)
fff83f0c:	91 41 00 1c 	stw     r10,28(r1)
fff83f10:	48 00 24 ad 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83f14:	90 6d 40 4c 	stw     r3,16460(r13)
fff83f18:	80 e1 00 20 	lwz     r7,32(r1)
fff83f1c:	81 41 00 1c 	lwz     r10,28(r1)
fff83f20:	06 43 07 e4 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("Address: 0x%08X, COUNTERREG: 0x%016X", i_handle.base_addr + SPIM_COUNTERREG, CNT);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fff83f24:	80 9d 00 08 	lwz     r4,8(r29)
fff83f28:	7f a3 eb 78 	mr      r3,r29
fff83f2c:	38 84 00 01 	addi    r4,r4,1
fff83f30:	7d 45 53 78 	mr      r5,r10
fff83f34:	7c e6 3b 78 	mr      r6,r7
fff83f38:	48 00 24 85 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83f3c:	90 6d 40 4c 	stw     r3,16460(r13)
fff83f40:	06 43 07 d4 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startReadCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startReadCmd.val));
fff83f44:	80 9d 00 08 	lwz     r4,8(r29)
fff83f48:	7f a3 eb 78 	mr      r3,r29
fff83f4c:	38 84 00 05 	addi    r4,r4,5
fff83f50:	7f 85 e3 78 	mr      r5,r28
fff83f54:	38 c0 00 00 	li      r6,0
fff83f58:	48 00 24 65 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83f5c:	90 6d 40 4c 	stw     r3,16460(r13)
fff83f60:	06 43 07 c4 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
    FAPI_DBG("spi_wait_for_tdr_empty()");
    rc = spi_wait_for_tdr_empty(i_handle);
fff83f64:	7f a3 eb 78 	mr      r3,r29
fff83f68:	4b ff f5 a9 	bl      fff83510 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>
fff83f6c:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
    {
        FAPI_ERR("Error in spi_wait_for_tdr_empty");
fff83f70:	3c 60 07 35 	lis     r3,1845
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startReadCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startReadCmd.val));
    FAPI_DBG("spi_wait_for_tdr_empty()");
    rc = spi_wait_for_tdr_empty(i_handle);

    if (rc)
fff83f74:	06 5c 00 ea 	bwnz    r28,fff84148 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
        FAPI_ERR("Error in spi_wait_for_tdr_empty");
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    if (i_length > 8)
fff83f78:	28 1f 00 08 	cmplwi  r31,8
fff83f7c:	41 81 00 34 	bgt     fff83fb0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1d0>
        FAPI_DBG("TDR 0 done");
    }

    // Wait until sequence index 3 has executed (TPM finished
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);
fff83f80:	7f a3 eb 78 	mr      r3,r29
fff83f84:	4b ff fc b9 	bl      fff83c3c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23>
fff83f88:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fff83f8c:	06 c3 00 24 	bwz     r3,fff83fd4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1f4>
    {
        FAPI_ERR("Error in wait_for_seq_index_pass, rc: 0x%08X",
fff83f90:	3c 60 29 d3 	lis     r3,10707
fff83f94:	60 63 00 01 	ori     r3,r3,1
fff83f98:	7f 85 e3 78 	mr      r5,r28
fff83f9c:	38 c0 00 00 	li      r6,0
fff83fa0:	38 e0 00 00 	li      r7,0
fff83fa4:	39 00 00 00 	li      r8,0
fff83fa8:	4b ff f0 bd 	bl      fff83064 <pk_trace_big>
fff83fac:	48 00 01 a0 	b       fff8414c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x36c>
    }

    if (i_length > 8)
    {
        FAPI_DBG("spi_wait_for_tdr_empty() done, TDR 0");
        FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, 0x0ULL));
fff83fb0:	80 9d 00 08 	lwz     r4,8(r29)
fff83fb4:	7f a3 eb 78 	mr      r3,r29
fff83fb8:	38 84 00 05 	addi    r4,r4,5
fff83fbc:	38 a0 00 00 	li      r5,0
fff83fc0:	38 c0 00 00 	li      r6,0
fff83fc4:	48 00 23 f9 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff83fc8:	90 6d 40 4c 	stw     r3,16460(r13)
fff83fcc:	06 c3 07 da 	bwz     r3,fff83f80 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x1a0>
fff83fd0:	4b ff ff 18 	b       fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    //receive data
    if(i_length <= 8)
fff83fd4:	28 1f 00 08 	cmplwi  r31,8
#endif
    }
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
fff83fd8:	39 3f ff f9 	addi    r9,r31,-7
fff83fdc:	3b 80 00 00 	li      r28,0
fff83fe0:	91 21 00 18 	stw     r9,24(r1)
        fapi2::current_err = rc;
        goto fapi_try_exit;
    }

    //receive data
    if(i_length <= 8)
fff83fe4:	41 a1 00 a4 	bgt     fff84088 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2a8>
    {
        rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fff83fe8:	7f a3 eb 78 	mr      r3,r29
fff83fec:	4b ff f7 fd 	bl      fff837e8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fff83ff0:	7c 7c 1b 78 	mr      r28,r3

        if (rc)
fff83ff4:	06 43 00 74 	bwnz    r3,fff840dc <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2fc>
            FAPI_ERR("Error in spi_wait_for_rdr_full");
            fapi2::current_err = rc;
            goto fapi_try_exit;
        }

        FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fff83ff8:	80 9d 00 08 	lwz     r4,8(r29)
        __attribute__((always_inline))
        inline ReturnCode  getScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                buffer<uint64_t>& o_data)
        {
            fapi2::ReturnCode l_rc;
            PLAT_GETSCOM(l_rc,
fff83ffc:	7f a3 eb 78 	mr      r3,r29
fff84000:	38 84 00 06 	addi    r4,r4,6
fff84004:	38 a1 00 10 	addi    r5,r1,16
fff84008:	48 00 23 61 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff8400c:	90 6d 40 4c 	stw     r3,16460(r13)
fff84010:	06 43 07 6c 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>

        FAPI_DBG("spi_wait_for_rdr_full finished, data read from rdr: 0x%016X", temp);

        // The value read from this RDR register is right-aligned.
        // Only copy the requested bytes of data
        temp = temp << ((8 - i_length) * 8);
fff84014:	21 1f 00 08 	subfic  r8,r31,8
fff84018:	55 0a 18 38 	rlwinm  r10,r8,3,0,28
fff8401c:	15 01 00 10 	lvd     d8,16(r1)
fff84020:	7d 08 50 76 	slvd    d8,d8,r10
fff84024:	19 01 00 08 	stvd    d8,8(r1)
#ifndef __PPE__
        memcpy(o_buffer, &temp, i_length);
#else
        uint8_t* tempPtr = (uint8_t*)&temp;

        for(uint32_t i = 0; i < i_length; i++)
fff84028:	39 40 00 00 	li      r10,0
fff8402c:	39 3f 00 01 	addi    r9,r31,1
fff84030:	06 5f 00 04 	bwnz    r31,fff84038 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x258>
fff84034:	39 20 00 01 	li      r9,1
fff84038:	35 29 ff ff 	addic.  r9,r9,-1
fff8403c:	41 82 00 5c 	beq     fff84098 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2b8>
        {
            *(o_buffer + i) = *(tempPtr + i);
fff84040:	39 01 00 08 	addi    r8,r1,8
fff84044:	7d 0a 40 ae 	lbzx    r8,r10,r8
fff84048:	7d 1e 51 ae 	stbx    r8,r30,r10
#ifndef __PPE__
        memcpy(o_buffer, &temp, i_length);
#else
        uint8_t* tempPtr = (uint8_t*)&temp;

        for(uint32_t i = 0; i < i_length; i++)
fff8404c:	39 4a 00 01 	addi    r10,r10,1
fff84050:	4b ff ff e8 	b       fff84038 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x258>
                FAPI_ERR("Error in spi_wait_for_rdr_full");
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fff84054:	80 9d 00 08 	lwz     r4,8(r29)
fff84058:	7f a3 eb 78 	mr      r3,r29
fff8405c:	38 84 00 06 	addi    r4,r4,6
fff84060:	38 a1 00 10 	addi    r5,r1,16
fff84064:	48 00 23 05 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff84068:	90 6d 40 4c 	stw     r3,16460(r13)
fff8406c:	06 43 07 3e 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
        inline buffer & extract(OT& o_out)
        {
            // Extraction is just an insert into o_out

            buffer<OT> out(o_out);
            out.template insert<TS, L, SS>(iv_data);
fff84070:	14 c1 00 10 	lvd     d6,16(r1)
            data64.extract<0, 64>(temp);
            FAPI_DBG("%d) spi_wait_for_rdr_full finished, data read from rdr: 0x%016X", i, temp);

            // add the full 8 bytes to buffer
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
fff84074:	57 89 00 38 	rlwinm  r9,r28,0,0,28
fff84078:	7d 3e 4a 14 	add     r9,r30,r9
            o_out = out;
fff8407c:	18 c1 00 08 	stvd    d6,8(r1)
fff84080:	18 c9 00 00 	stvd    d6,0(r9)
#endif
    }
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
fff84084:	3b 9c 00 08 	addi    r28,r28,8
fff84088:	81 21 00 18 	lwz     r9,24(r1)
fff8408c:	05 9c 48 12 	cmplwblt r28,r9,fff840b0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2d0>

            // add the full 8 bytes to buffer
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
        }

        if ((i_length % 8 != 0) && (i_length > 8))
fff84090:	57 e9 07 7e 	clrlwi  r9,r31,29
fff84094:	06 49 00 18 	bwnz    r9,fff840c4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2e4>
#endif
        }
    }

    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle");
    rc = spi_wait_for_idle(i_handle);
fff84098:	7f a3 eb 78 	mr      r3,r29
fff8409c:	4b ff f5 e1 	bl      fff8367c <_ZL17spi_wait_for_idleR16SpiControlHandle>
fff840a0:	7c 7c 1b 78 	mr      r28,r3
    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle done");

    if (rc)
fff840a4:	06 c3 00 56 	bwz     r3,fff84150 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x370>
    {
        FAPI_ERR("Multiplexing error in spi_wait_for_idle");
fff840a8:	3c 60 d8 b1 	lis     r3,-10063
fff840ac:	48 00 00 9c 	b       fff84148 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
    else
    {

        for (uint32_t i = 0; i < static_cast<uint32_t>(i_length - 7); i += 8)
        {
            rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fff840b0:	7f a3 eb 78 	mr      r3,r29
fff840b4:	4b ff f7 35 	bl      fff837e8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>

            if (rc)
fff840b8:	06 c3 07 ce 	bwz     r3,fff84054 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x274>
fff840bc:	7c 7c 1b 78 	mr      r28,r3
fff840c0:	48 00 00 1c 	b       fff840dc <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2fc>
            reinterpret_cast<uint64_t*>(o_buffer)[i / 8] = temp;
        }

        if ((i_length % 8 != 0) && (i_length > 8))
        {
            rc = spi_wait_for_rdr_full(i_handle);  //Wait for response
fff840c4:	7f a3 eb 78 	mr      r3,r29
fff840c8:	91 21 00 1c 	stw     r9,28(r1)
fff840cc:	4b ff f7 1d 	bl      fff837e8 <_ZL21spi_wait_for_rdr_fullR16SpiControlHandle>
fff840d0:	7c 7c 1b 78 	mr      r28,r3

            if (rc)
fff840d4:	81 21 00 1c 	lwz     r9,28(r1)
fff840d8:	06 c3 00 06 	bwz     r3,fff840e4 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x304>
            {
                FAPI_ERR("Error in spi_wait_for_rdr_full");
fff840dc:	3c 60 c9 6f 	lis     r3,-13969
fff840e0:	48 00 00 68 	b       fff84148 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x368>
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_TRY(getScom(i_handle.target_chip, i_handle.base_addr + SPIM_RDR, data64));
fff840e4:	80 9d 00 08 	lwz     r4,8(r29)
fff840e8:	7f a3 eb 78 	mr      r3,r29
fff840ec:	38 84 00 06 	addi    r4,r4,6
fff840f0:	38 a1 00 10 	addi    r5,r1,16
fff840f4:	91 21 00 1c 	stw     r9,28(r1)
fff840f8:	48 00 22 71 	bl      fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>
fff840fc:	90 6d 40 4c 	stw     r3,16460(r13)
fff84100:	81 21 00 1c 	lwz     r9,28(r1)
fff84104:	06 43 06 f2 	bwnz    r3,fff83ee8 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x108>
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fff84108:	20 c9 00 08 	subfic  r6,r9,8
fff8410c:	54 ca 18 38 	rlwinm  r10,r6,3,0,28
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fff84110:	39 29 00 01 	addi    r9,r9,1
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fff84114:	14 c1 00 10 	lvd     d6,16(r1)
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fff84118:	7d 29 03 a6 	mtctr   r9
            data64.extract<0, 64>(temp);
            FAPI_DBG("Read RDR data: 0x%016X", temp);

            // The value read from this RDR register is right-aligned.
            // Only copy the remaining requested bytes of data
            temp = temp << ((8 - (i_length % 8)) * 8);
fff8411c:	7c c6 50 76 	slvd    d6,d6,r10
fff84120:	18 c1 00 08 	stvd    d6,8(r1)
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fff84124:	39 40 00 00 	li      r10,0
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fff84128:	57 ff 00 38 	rlwinm  r31,r31,0,0,28
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fff8412c:	42 40 ff 6c 	bdz     fff84098 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x2b8>
            {
                *(o_buffer + i_length - (i_length % 8) + i) = *(tempPtr + i);
fff84130:	39 01 00 08 	addi    r8,r1,8
fff84134:	7d 0a 40 ae 	lbzx    r8,r10,r8
fff84138:	7d 3e 52 14 	add     r9,r30,r10
fff8413c:	7d 09 f9 ae 	stbx    r8,r9,r31
#ifndef __PPE__
            memcpy(&o_buffer[i_length - (i_length % 8)], &temp, i_length % 8);
#else
            uint8_t* tempPtr = (uint8_t*)&temp;

            for(uint32_t i = 0; i < (i_length % 8); i++)
fff84140:	39 4a 00 01 	addi    r10,r10,1
fff84144:	4b ff ff e8 	b       fff8412c <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh+0x34c>
    rc = spi_wait_for_idle(i_handle);
    FAPI_DBG("spi_tpm_read_with_wait: spi_wait_for_idle done");

    if (rc)
    {
        FAPI_ERR("Multiplexing error in spi_wait_for_idle");
fff84148:	4b ff c0 31 	bl      fff80178 <pk_trace_tiny>
        fapi2::current_err = rc;
fff8414c:	93 8d 40 4c 	stw     r28,16460(r13)
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_read_with_wait() exit. RC: 0x%02X", static_cast<int>(rc));
    return rc;
}
fff84150:	80 01 00 3c 	lwz     r0,60(r1)
fff84154:	7f 83 e3 78 	mr      r3,r28
fff84158:	7c 08 03 a6 	mtlr    r0
fff8415c:	17 81 00 28 	lvd     d28,40(r1)
fff84160:	17 c1 00 30 	lvd     d30,48(r1)
fff84164:	38 21 00 38 	addi    r1,r1,56
fff84168:	4e 80 00 20 	blr

fff8416c <spi_tpm_read_secure>:

    // 0xEX Op code is not allowed in secure mode so need to split
    // read into multiple transactions of TPM_SECURE_DATA_LEN max size
    do
    {
        if (i_length <= TPM_SECURE_DATA_LEN)
fff8416c:	28 06 00 08 	cmplwi  r6,8
fapi2::ReturnCode spi_tpm_read_secure( SpiControlHandle& i_handle,
                                       const uint32_t i_locality,
                                       const uint32_t i_address,
                                       const uint8_t i_length,
                                       uint8_t* o_buffer )
{
fff84170:	94 21 ff e0 	stwu    r1,-32(r1)
fff84174:	7c 08 02 a6 	mflr    r0
    uint8_t readlen = i_length;  // try to read full length if possible

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fff84178:	54 a5 05 3e 	clrlwi  r5,r5,20
fff8417c:	3c a5 00 d4 	addis   r5,r5,212
fff84180:	54 84 60 26 	rlwinm  r4,r4,12,0,19
fapi2::ReturnCode spi_tpm_read_secure( SpiControlHandle& i_handle,
                                       const uint32_t i_locality,
                                       const uint32_t i_address,
                                       const uint8_t i_length,
                                       uint8_t* o_buffer )
{
fff84184:	1b 81 00 10 	stvd    d28,16(r1)
fff84188:	1b c1 00 18 	stvd    d30,24(r1)
fff8418c:	90 01 00 24 	stw     r0,36(r1)
fff84190:	7c dd 33 78 	mr      r29,r6
    uint8_t readlen = i_length;  // try to read full length if possible

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fff84194:	7f 85 22 14 	add     r28,r5,r4
fff84198:	7c 6a 1b 78 	mr      r10,r3

    // 0xEX Op code is not allowed in secure mode so need to split
    // read into multiple transactions of TPM_SECURE_DATA_LEN max size
    do
    {
        if (i_length <= TPM_SECURE_DATA_LEN)
fff8419c:	3b e0 00 00 	li      r31,0
fff841a0:	41 a1 00 30 	bgt     fff841d0 <spi_tpm_read_secure+0x64>
        {
            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
fff841a4:	7c c5 33 78 	mr      r5,r6
fff841a8:	7f 84 e3 78 	mr      r4,r28
fff841ac:	7c e6 3b 78 	mr      r6,r7
fff841b0:	4b ff fc 31 	bl      fff83de0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>
fff841b4:	7c 69 1b 78 	mr      r9,r3
            break;
fff841b8:	48 00 00 88 	b       fff84240 <spi_tpm_read_secure+0xd4>
        }

        for(uint8_t i = 0; i < i_length; i += TPM_SECURE_DATA_LEN)
fff841bc:	3b ff 00 08 	addi    r31,r31,8
fff841c0:	57 de 06 3e 	clrlwi  r30,r30,24
fff841c4:	57 ff 06 3e 	clrlwi  r31,r31,24
                          "Failed address 0x%04X read at %d bytes out of %d total",
                          l_address, i, i_length);
                break;
            }

            o_buffer += readlen;
fff841c8:	7c e7 f2 14 	add     r7,r7,r30
        {
            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
            break;
        }

        for(uint8_t i = 0; i < i_length; i += TPM_SECURE_DATA_LEN)
fff841cc:	05 1f e8 3a 	cmplwbge r31,r29,fff84240 <spi_tpm_read_secure+0xd4>
        {
            readlen = (i_length - i) < TPM_SECURE_DATA_LEN ?
fff841d0:	7f df e8 50 	subf    r30,r31,r29
                      (i_length - i) : TPM_SECURE_DATA_LEN;
fff841d4:	06 3e 40 08 	cmpwible r30,8,fff841e4 <spi_tpm_read_secure+0x78>
fff841d8:	3b c0 00 08 	li      r30,8
fff841dc:	38 a0 00 08 	li      r5,8
fff841e0:	48 00 00 0c 	b       fff841ec <spi_tpm_read_secure+0x80>
fff841e4:	57 c5 06 3e 	clrlwi  r5,r30,24

            if (readlen == 0)
fff841e8:	06 c5 00 2a 	bwz     r5,fff8423c <spi_tpm_read_secure+0xd0>
            {
                break;
            }

            rc = spi_tpm_read_internal_with_wait( i_handle, l_address, readlen, o_buffer );
fff841ec:	7d 43 53 78 	mr      r3,r10
fff841f0:	7c e6 3b 78 	mr      r6,r7
fff841f4:	7f 84 e3 78 	mr      r4,r28
fff841f8:	90 e1 00 0c 	stw     r7,12(r1)
fff841fc:	91 41 00 08 	stw     r10,8(r1)
fff84200:	4b ff fb e1 	bl      fff83de0 <_Z31spi_tpm_read_internal_with_waitR16SpiControlHandlemhPh>
fff84204:	7c 69 1b 78 	mr      r9,r3

            if (rc != fapi2::FAPI2_RC_SUCCESS)
fff84208:	80 e1 00 0c 	lwz     r7,12(r1)
fff8420c:	81 41 00 08 	lwz     r10,8(r1)
fff84210:	06 c3 07 d6 	bwz     r3,fff841bc <spi_tpm_read_secure+0x50>
            {
                FAPI_ERR( "spi_tpm_read_secure: "
fff84214:	3c 60 f2 18 	lis     r3,-3560
fff84218:	60 63 00 03 	ori     r3,r3,3
fff8421c:	7f 85 e3 78 	mr      r5,r28
fff84220:	7f e6 fb 78 	mr      r6,r31
fff84224:	7f a7 eb 78 	mr      r7,r29
fff84228:	39 00 00 00 	li      r8,0
fff8422c:	91 21 00 08 	stw     r9,8(r1)
fff84230:	4b ff ee 35 	bl      fff83064 <pk_trace_big>
                          "Failed address 0x%04X read at %d bytes out of %d total",
                          l_address, i, i_length);
                break;
fff84234:	81 21 00 08 	lwz     r9,8(r1)
fff84238:	48 00 00 08 	b       fff84240 <spi_tpm_read_secure+0xd4>
fff8423c:	39 20 00 00 	li      r9,0
        }
    }
    while(0);

    return rc;
}
fff84240:	80 01 00 24 	lwz     r0,36(r1)
fff84244:	17 81 00 10 	lvd     d28,16(r1)
fff84248:	7c 08 03 a6 	mtlr    r0
fff8424c:	17 c1 00 18 	lvd     d30,24(r1)
fff84250:	7d 23 4b 78 	mr      r3,r9
fff84254:	38 21 00 20 	addi    r1,r1,32
fff84258:	4e 80 00 20 	blr

fff8425c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh>:
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff8425c:	94 21 ff d0 	stwu    r1,-48(r1)
    tpmSpiCmd_t startWriteCmd = {0};

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fff84260:	28 06 00 08 	cmplwi  r6,8
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff84264:	7c 08 02 a6 	mflr    r0
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fff84268:	54 a5 05 3e 	clrlwi  r5,r5,20
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff8426c:	1b c1 00 28 	stvd    d30,40(r1)
fff84270:	3c a5 00 d4 	addis   r5,r5,212
fff84274:	7c 7e 1b 78 	mr      r30,r3
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fff84278:	54 84 60 26 	rlwinm  r4,r4,12,0,19
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff8427c:	1b 81 00 20 	stvd    d28,32(r1)
    fapi2::buffer<uint64_t> data64 = 0;

    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
fff84280:	7c 65 22 14 	add     r3,r5,r4
fapi2::ReturnCode spi_tpm_write_with_wait_internal( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff84284:	90 01 00 34 	stw     r0,52(r1)
fff84288:	7c df 33 78 	mr      r31,r6
fff8428c:	90 e1 00 14 	stw     r7,20(r1)
    // Trusted Computing Group (TCG) standard requires
    // 3-byte addressing for SPI TPM operations
    // Change into TPM address on SPI ( D4_[locality]xxxh )
    uint32_t l_address = 0x00D40000 + (i_locality << 12) + (i_address & 0x0FFF);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpmSpiCmd_t startWriteCmd = {0};
fff84290:	3b a0 00 00 	li      r29,0
fff84294:	a0 be 00 06 	lhz     r5,6(r30)

    // Looking for last byte being a 0x01 which indicates end of wait period
    uint64_t memory_mapping_reg = 0x00000000FF01FF00;

    if(i_length <= 8)
fff84298:	41 81 00 38 	bgt     fff842d0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x74>
        //          41 = Shift_N2 - M = 1 byte to receive
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fff8429c:	54 a9 04 3e 	clrlwi  r9,r5,16
fff842a0:	39 00 00 00 	li      r8,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff842a4:	79 08 c1 c6 	rldicr  d8,d8,56,7
        //          41 = Shift_N2 - M = 1 byte to receive
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
fff842a8:	7c c7 33 78 	mr      r7,r6
fff842ac:	65 08 10 34 	oris    r8,r8,4148
fff842b0:	38 c0 00 00 	li      r6,0
fff842b4:	78 c6 c1 e4 	rldicr  d6,d6,24,39
fff842b8:	61 08 41 62 	ori     r8,r8,16738
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff842bc:	7d 08 33 78 	or      r8,r8,r6
        CNT = 0x0;
fff842c0:	3b 80 00 00 	li      r28,0
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              3M = Shift_N1 - M = i_length bytes of data to send
        //                10 = select_slave 0 - deselect any slave
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff842c4:	64 e6 30 10 	oris    r6,r7,12304
        CNT = 0x0;
fff842c8:	38 e0 00 00 	li      r7,0
fff842cc:	48 00 00 54 	b       fff84320 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xc4>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff842d0:	54 a9 04 3e 	clrlwi  r9,r5,16
fff842d4:	39 00 00 00 	li      r8,0
fff842d8:	79 08 c1 c6 	rldicr  d8,d8,56,7
fff842dc:	65 08 10 34 	oris    r8,r8,4148
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0x0;
    }
    else if((i_length % 8) == 0)
fff842e0:	54 c6 07 7e 	clrlwi  r6,r6,29
fff842e4:	57 e7 e8 fe 	rlwinm  r7,r31,29,3,31
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff842e8:	61 08 41 62 	ori     r8,r8,16738
        //                  00 = STOP
        SEQ = 0x1034416230100000ULL | (static_cast<uint64_t>(i_length) << 24) |
              (static_cast<uint64_t>(i_handle.slave) << 56);
        CNT = 0x0;
    }
    else if((i_length % 8) == 0)
fff842ec:	06 46 00 08 	bwnz    r6,fff842fc <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xa0>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to sendg
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  10 = select_slave 0 - deselect any slave
        //                    00 = STOP
        SEQ = 0x1034416238E41000ULL | (static_cast<uint64_t>(i_handle.slave) << 56);
fff842f0:	3c c0 38 e4 	lis     r6,14564
fff842f4:	60 c6 10 00 	ori     r6,r6,4096
fff842f8:	48 00 00 20 	b       fff84318 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xbc>
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to send
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  3M = Shift_N1 - M = i_length%8 of remaining data sent in TDR
        //                    10 = select_slave 0 - deselect any slave
        SEQ = 0x1034416238E43010ULL | (static_cast<uint64_t>((i_length) % 8) << 8) |
fff842fc:	7c c5 33 78 	mr      r5,r6
fff84300:	38 80 00 00 	li      r4,0
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff84304:	3c c0 38 e4 	lis     r6,14564
        //            62 = Branch if Not Equal RDR   -- use memory_mapping_reg
        //              38 = Shift_N1 - M = 8 bytes of data to send
        //                E4 = Branch to index 4 if not Equal and increment loop counter
        //                  3M = Shift_N1 - M = i_length%8 of remaining data sent in TDR
        //                    10 = select_slave 0 - deselect any slave
        SEQ = 0x1034416238E43010ULL | (static_cast<uint64_t>((i_length) % 8) << 8) |
fff84308:	78 84 45 e4 	rldicr  d4,d4,8,55
              (static_cast<uint64_t>(i_handle.slave) << 56);
fff8430c:	60 c6 30 10 	ori     r6,r6,12304
fff84310:	7d 08 23 78 	or      r8,r8,r4
fff84314:	7c c6 2b 78 	or      r6,r6,r5
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
fff84318:	38 e7 ff ff 	addi    r7,r7,-1
fff8431c:	3b 80 65 00 	li      r28,25856
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fff84320:	39 3f ff ff 	addi    r9,r31,-1
    startWriteCmd.cmd_bits.addr = l_address;


    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fff84324:	80 9e 00 08 	lwz     r4,8(r30)
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fff84328:	51 3d c0 8e 	rlwimi  r29,r9,24,2,7
    startWriteCmd.cmd_bits.addr = l_address;
fff8432c:	50 7d 02 3e 	rlwimi  r29,r3,0,8,31
    __attribute__((always_inline))
    inline ReturnCode  putScom(const Target<K, M, V>& i_target, const uint64_t i_address,
                       const buffer<uint64_t> i_data)
    {
        fapi2::ReturnCode l_rc;
        PLAT_PUTSCOM(l_rc,
fff84330:	38 84 00 07 	addi    r4,r4,7
fff84334:	7f c3 f3 78 	mr      r3,r30
fff84338:	7d 05 43 78 	mr      r5,r8
fff8433c:	90 e1 00 18 	stw     r7,24(r1)
        CNT = (static_cast<uint64_t>((i_length / 8) - 1) << 32) | ((0x65) << 8);
    }

    // Initial TDR command
    startWriteCmd.cmd_bits.readNotWrite = 0;
    startWriteCmd.cmd_bits.len = ((i_length - 1) & 0x3F);
fff84340:	91 21 00 08 	stw     r9,8(r1)
fff84344:	48 00 20 79 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
    startWriteCmd.cmd_bits.addr = l_address;


    FAPI_DBG("Address: 0x%08X, SEQ: 0x%016X", i_handle.base_addr + SPIM_SEQREG, SEQ);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_SEQREG, SEQ));
fff84348:	90 6d 40 4c 	stw     r3,16460(r13)
fff8434c:	80 e1 00 18 	lwz     r7,24(r1)
fff84350:	06 c3 00 06 	bwz     r3,fff8435c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x100>
fff84354:	3b 80 00 00 	li      r28,0
fff84358:	48 00 01 8c 	b       fff844e4 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
    FAPI_DBG("Address: 0x%08X, MEMORY_MAPPING_REG: 0x%016X", i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_MMSPISMREG, memory_mapping_reg));
fff8435c:	80 9e 00 08 	lwz     r4,8(r30)
fff84360:	3c c0 ff 01 	lis     r6,-255
fff84364:	7f c3 f3 78 	mr      r3,r30
fff84368:	38 84 00 04 	addi    r4,r4,4
fff8436c:	38 a0 00 00 	li      r5,0
fff84370:	60 c6 ff 00 	ori     r6,r6,65280
fff84374:	90 e1 00 18 	stw     r7,24(r1)
fff84378:	48 00 20 45 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff8437c:	90 6d 40 4c 	stw     r3,16460(r13)
fff84380:	80 e1 00 18 	lwz     r7,24(r1)
fff84384:	06 43 07 e8 	bwnz    r3,fff84354 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
    FAPI_DBG("Address: 0x%08X, CNT: 0x%016X", i_handle.base_addr + SPIM_COUNTERREG, CNT);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_COUNTERREG, CNT));
fff84388:	80 9e 00 08 	lwz     r4,8(r30)
fff8438c:	7f c3 f3 78 	mr      r3,r30
fff84390:	38 84 00 01 	addi    r4,r4,1
fff84394:	7c e5 3b 78 	mr      r5,r7
fff84398:	7f 86 e3 78 	mr      r6,r28
fff8439c:	48 00 20 21 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff843a0:	90 6d 40 4c 	stw     r3,16460(r13)
fff843a4:	06 43 07 d8 	bwnz    r3,fff84354 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
    FAPI_DBG("Address: 0x%08X, TDR: 0x%016X", i_handle.base_addr + SPIM_TDR, startWriteCmd.val);
    FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, startWriteCmd.val));
fff843a8:	80 9e 00 08 	lwz     r4,8(r30)
fff843ac:	7f c3 f3 78 	mr      r3,r30
fff843b0:	38 84 00 05 	addi    r4,r4,5
fff843b4:	7f a5 eb 78 	mr      r5,r29
fff843b8:	38 c0 00 00 	li      r6,0
fff843bc:	48 00 20 01 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff843c0:	90 6d 40 4c 	stw     r3,16460(r13)
fff843c4:	06 43 07 c8 	bwnz    r3,fff84354 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>


    // Wait until sequence index 3 has executed (TPM finished
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);
fff843c8:	7f c3 f3 78 	mr      r3,r30
fff843cc:	4b ff f8 71 	bl      fff83c3c <_ZL27spi_wait_for_seq_index_passR16SpiControlHandlem.constprop.23>
fff843d0:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fff843d4:	06 43 00 14 	bwnz    r3,fff843fc <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1a0>
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
                 ((i == (i_length - 1)) && ((i_length % 8) != 0)) )
            {
                data64 = data64 << (8 * (8 - i_length % 8));
fff843d8:	57 ea 07 7e 	clrlwi  r10,r31,29
fff843dc:	21 2a 00 08 	subfic  r9,r10,8
fff843e0:	55 29 18 38 	rlwinm  r9,r9,3,0,28
fff843e4:	91 21 00 10 	stw     r9,16(r1)
fff843e8:	91 41 00 0c 	stw     r10,12(r1)
fff843ec:	39 00 00 00 	li      r8,0
fff843f0:	39 20 00 00 	li      r9,0
fff843f4:	3b a0 00 00 	li      r29,0
fff843f8:	48 00 00 4c 	b       fff84444 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1e8>
    // inserting wait states)
    rc = spi_wait_for_seq_index_pass(i_handle, 3);

    if (rc)
    {
        FAPI_ERR("Error in wait_for_seq_index_pass, rc: 0x%08X", static_cast<uint32_t>(rc));
fff843fc:	3c 60 29 d3 	lis     r3,10707
fff84400:	60 63 00 01 	ori     r3,r3,1
fff84404:	7f 85 e3 78 	mr      r5,r28
fff84408:	38 c0 00 00 	li      r6,0
fff8440c:	38 e0 00 00 	li      r7,0
fff84410:	39 00 00 00 	li      r8,0
fff84414:	4b ff ec 51 	bl      fff83064 <pk_trace_big>
fff84418:	48 00 00 b8 	b       fff844d0 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x274>
    data64 = 0;

    // break data up into 8-byte sections
    for(int i = 0; i < i_length; i++)
    {
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);
fff8441c:	79 04 45 e4 	rldicr  d4,d8,8,55
fff84420:	81 21 00 14 	lwz     r9,20(r1)
fff84424:	7c 88 23 78 	mr      r8,r4
fff84428:	7c c9 e8 ae 	lbzx    r6,r9,r29
fff8442c:	7c c9 2b 78 	or      r9,r6,r5

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
fff84430:	57 a6 07 7e 	clrlwi  r6,r29,29
fff84434:	06 c6 38 0c 	cmpwibeq r6,7,fff8444c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1f0>
fff84438:	81 41 00 08 	lwz     r10,8(r1)
fff8443c:	04 dd 50 4e 	cmpwbeq r29,r10,fff844d8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x27c>
    }

    data64 = 0;

    // break data up into 8-byte sections
    for(int i = 0; i < i_length; i++)
fff84440:	3b bd 00 01 	addi    r29,r29,1
fff84444:	04 9d ff ec 	cmpwblt r29,r31,fff8441c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1c0>
fff84448:	48 00 00 70 	b       fff844b8 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x25c>
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
fff8444c:	28 1f 00 07 	cmplwi  r31,7
fff84450:	40 81 00 14 	ble     fff84464 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x208>
fff84454:	81 41 00 08 	lwz     r10,8(r1)
fff84458:	04 5d 50 0a 	cmpwbne r29,r10,fff8446c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x210>
                 ((i == (i_length - 1)) && ((i_length % 8) != 0)) )
fff8445c:	81 41 00 0c 	lwz     r10,12(r1)
fff84460:	06 ca 00 06 	bwz     r10,fff8446c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x210>
            {
                data64 = data64 << (8 * (8 - i_length % 8));
fff84464:	81 41 00 10 	lwz     r10,16(r1)
fff84468:	7d 08 50 76 	slvd    d8,d8,r10
            }

            rc = spi_wait_for_tdr_empty(i_handle);
fff8446c:	7f c3 f3 78 	mr      r3,r30
fff84470:	19 01 00 18 	stvd    d8,24(r1)
fff84474:	4b ff f0 9d 	bl      fff83510 <_ZL22spi_wait_for_tdr_emptyR16SpiControlHandle>
fff84478:	7c 7c 1b 78 	mr      r28,r3

            if (rc)
fff8447c:	15 01 00 18 	lvd     d8,24(r1)
fff84480:	06 c3 00 06 	bwz     r3,fff8448c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x230>
            {
                FAPI_ERR("Error in spi_wait_for_tdr_empty ");
fff84484:	3c 60 07 35 	lis     r3,1845
fff84488:	48 00 00 44 	b       fff844cc <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x270>
                fapi2::current_err = rc;
                goto fapi_try_exit;
            }

            FAPI_DBG("tpm_write() TDR: 0x%016X", data64);
            FAPI_TRY(putScom(i_handle.target_chip, i_handle.base_addr + SPIM_TDR, data64));
fff8448c:	80 9e 00 08 	lwz     r4,8(r30)
fff84490:	7d 05 43 78 	mr      r5,r8
fff84494:	7d 26 4b 78 	mr      r6,r9
fff84498:	7f c3 f3 78 	mr      r3,r30
fff8449c:	38 84 00 05 	addi    r4,r4,5
fff844a0:	19 01 00 18 	stvd    d8,24(r1)
fff844a4:	48 00 1f 19 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff844a8:	90 6d 40 4c 	stw     r3,16460(r13)
fff844ac:	15 01 00 18 	lvd     d8,24(r1)
fff844b0:	06 c3 07 c8 	bwz     r3,fff84440 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x1e4>
fff844b4:	4b ff fe a0 	b       fff84354 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0xf8>
        }
    }

    rc = spi_wait_for_idle(i_handle);
fff844b8:	7f c3 f3 78 	mr      r3,r30
fff844bc:	4b ff f1 c1 	bl      fff8367c <_ZL17spi_wait_for_idleR16SpiControlHandle>
fff844c0:	7c 7c 1b 78 	mr      r28,r3

    if (rc)
fff844c4:	06 c3 00 10 	bwz     r3,fff844e4 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
    {
        FAPI_ERR("Multiplexing error or timeout from spi_wait_for_idle ");
fff844c8:	3c 60 00 fa 	lis     r3,250
fff844cc:	4b ff bc ad 	bl      fff80178 <pk_trace_tiny>
        fapi2::current_err = rc;
fff844d0:	93 8d 40 4c 	stw     r28,16460(r13)
        goto fapi_try_exit;
fff844d4:	48 00 00 10 	b       fff844e4 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x288>
        data64 = (data64 << 8) | ((uint8_t)i_buffer[i]);

        if( ((i % 8) == 7) || (i == (i_length - 1)) )
        {
            // left-justify data if not full 8-bytes added
            if ( (i_length < 8) ||
fff844d8:	28 1f 00 07 	cmplwi  r31,7
fff844dc:	40 a1 ff 88 	ble     fff84464 <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x208>
fff844e0:	4b ff ff 7c 	b       fff8445c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh+0x200>
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_write_with_wait_internal() exit. RC: 0x%08X", static_cast<uint32_t>(rc));
    return rc;
}
fff844e4:	80 01 00 34 	lwz     r0,52(r1)
fff844e8:	7f 83 e3 78 	mr      r3,r28
fff844ec:	7c 08 03 a6 	mtlr    r0
fff844f0:	17 81 00 20 	lvd     d28,32(r1)
fff844f4:	17 c1 00 28 	lvd     d30,40(r1)
fff844f8:	38 21 00 30 	addi    r1,r1,48
fff844fc:	4e 80 00 20 	blr

fff84500 <spi_tpm_write_with_wait>:
fapi2::ReturnCode spi_tpm_write_with_wait( SpiControlHandle& i_handle,
        const uint32_t i_locality,
        const uint32_t i_address,
        const uint8_t i_length,
        const uint8_t* i_buffer )
{
fff84500:	94 21 ff d8 	stwu    r1,-40(r1)
fff84504:	7c 08 02 a6 	mflr    r0
fff84508:	1b 81 00 18 	stvd    d28,24(r1)
fff8450c:	90 01 00 2c 	stw     r0,44(r1)
fff84510:	1b c1 00 20 	stvd    d30,32(r1)
fff84514:	7c 7d 1b 78 	mr      r29,r3
fff84518:	7c 9c 23 78 	mr      r28,r4
fff8451c:	7c aa 2b 78 	mr      r10,r5
fff84520:	7c de 33 78 	mr      r30,r6
fff84524:	7c e8 3b 78 	mr      r8,r7

    // We're only allowing secure TPM writes, which are of length TPM_SECURE_DATA_LEN or less.
    // l_lengthTraversed will increase from 0 up to i_length in TPM_SECURE_DATA_LEN intervals or less.
    // l_lengthTraversed will be used to know from what offset in the buffer we're writing to the TPM.

    uint8_t l_lengthTraversed = 0;
fff84528:	38 00 00 00 	li      r0,0

    while (l_lengthTraversed < i_length)
fff8452c:	05 00 f0 2e 	cmplwbge r0,r30,fff84588 <spi_tpm_write_with_wait+0x88>
    {
        uint8_t l_minTravelLength = std::min(TPM_SECURE_DATA_LEN, (i_length - l_lengthTraversed));
fff84530:	7d 20 f0 50 	subf    r9,r0,r30
fff84534:	3b e0 00 08 	li      r31,8
     */
    template <class T>
    inline const T& 
    min(const T& a, const T& b)
    {
        if( b < a) return b;
fff84538:	06 a9 38 08 	cmpwibgt r9,7,fff84548 <spi_tpm_write_with_wait+0x48>
fff8453c:	55 3f 06 3e 	clrlwi  r31,r9,24

        // TODO RTC: 268091 Current SPI issue when writing 3 bytes. Must be broken down into smaller write ops.
        if (l_minTravelLength == 3)
fff84540:	06 5f 18 04 	cmpwibne r31,3,fff84548 <spi_tpm_write_with_wait+0x48>
        {
            l_minTravelLength = 2;
fff84544:	3b e0 00 02 	li      r31,2
        }

        rc = spi_tpm_write_with_wait_internal(i_handle, i_locality, i_address, l_minTravelLength,
                                              i_buffer + l_lengthTraversed);
fff84548:	7c e8 02 14 	add     r7,r8,r0
fff8454c:	7d 45 53 78 	mr      r5,r10
fff84550:	7f a3 eb 78 	mr      r3,r29
fff84554:	7f 84 e3 78 	mr      r4,r28
fff84558:	7f e6 fb 78 	mr      r6,r31
fff8455c:	90 01 00 08 	stw     r0,8(r1)
fff84560:	91 01 00 10 	stw     r8,16(r1)
fff84564:	91 41 00 0c 	stw     r10,12(r1)
fff84568:	4b ff fc f5 	bl      fff8425c <_Z32spi_tpm_write_with_wait_internalR16SpiControlHandlemmhPKh>

        if (rc)
fff8456c:	80 01 00 08 	lwz     r0,8(r1)
fff84570:	81 01 00 10 	lwz     r8,16(r1)
fff84574:	81 41 00 0c 	lwz     r10,12(r1)
fff84578:	06 43 00 0c 	bwnz    r3,fff84590 <spi_tpm_write_with_wait+0x90>
        {
            break;
        }

        l_lengthTraversed += l_minTravelLength;
fff8457c:	7f ff 02 14 	add     r31,r31,r0
fff84580:	57 e0 06 3e 	clrlwi  r0,r31,24
fff84584:	4b ff ff a8 	b       fff8452c <spi_tpm_write_with_wait+0x2c>
fff84588:	3b e0 00 00 	li      r31,0
fff8458c:	48 00 00 14 	b       fff845a0 <spi_tpm_write_with_wait+0xa0>
fff84590:	7c 7f 1b 78 	mr      r31,r3
    }

    if (rc)
    {
        FAPI_ERR("spi_tpm_write_with_wait: Error doing secure write.");
fff84594:	3c 60 a6 4f 	lis     r3,-22961
fff84598:	4b ff bb e1 	bl      fff80178 <pk_trace_tiny>
        fapi2::current_err = rc;
fff8459c:	93 ed 40 4c 	stw     r31,16460(r13)
    }

fapi_try_exit:
    FAPI_DBG("spi_tpm_write_with_wait() exit. RC: 0x%08X", static_cast<uint32_t>(rc));
    return rc;
}
fff845a0:	80 01 00 2c 	lwz     r0,44(r1)
fff845a4:	7f e3 fb 78 	mr      r3,r31
fff845a8:	7c 08 03 a6 	mtlr    r0
fff845ac:	17 81 00 18 	lvd     d28,24(r1)
fff845b0:	17 c1 00 20 	lvd     d30,32(r1)
fff845b4:	38 21 00 28 	addi    r1,r1,40
fff845b8:	4e 80 00 20 	blr

fff845bc <_Z12checkSbeRolev>:
#include <p10_scom_perv_e.H>

using namespace fapi2;

uint32_t checkSbeRole()
{
fff845bc:	94 21 ff d8 	stwu    r1,-40(r1)
fff845c0:	7c 08 02 a6 	mflr    r0
    do
    {
        fapi2::buffer<uint64_t> cbsreg;
        fapi2::buffer<uint64_t> scratchreg8;
        fapi2::buffer<uint64_t> scratchreg6;
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_CBS_ENVSTAT_RO, &cbsreg());
fff845c4:	3c 60 00 05 	lis     r3,5
        /// @brief Integral buffer assignment constructor
        /// @param[in] i_value initial value of the buffer
        /// Meaningless for variable types and thus protected.
        ///
        inline buffer(T i_value = 0):
            iv_data(i_value)
fff845c8:	39 20 00 00 	li      r9,0
fff845cc:	39 00 00 00 	li      r8,0
fff845d0:	38 81 00 18 	addi    r4,r1,24
fff845d4:	60 63 00 04 	ori     r3,r3,4
fff845d8:	19 01 00 18 	stvd    d8,24(r1)
fff845dc:	19 01 00 10 	stvd    d8,16(r1)
fff845e0:	19 01 00 08 	stvd    d8,8(r1)
#include <p10_scom_perv_e.H>

using namespace fapi2;

uint32_t checkSbeRole()
{
fff845e4:	90 01 00 2c 	stw     r0,44(r1)
    do
    {
        fapi2::buffer<uint64_t> cbsreg;
        fapi2::buffer<uint64_t> scratchreg8;
        fapi2::buffer<uint64_t> scratchreg6;
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_CBS_ENVSTAT_RO, &cbsreg());
fff845e8:	4b ff e4 29 	bl      fff82a10 <getscom_abs>
        SBE_INFO(SBE_FUNC "CBS_ENVSTAT_REG value is 0x%08X %08X", ((cbsreg >> 32) & 0xFFFFFFFF), (cbsreg & 0xFFFFFFFF));
fff845ec:	14 a1 00 18 	lvd     d5,24(r1)
fff845f0:	3c 60 47 58 	lis     r3,18264
fff845f4:	38 e0 00 00 	li      r7,0
fff845f8:	39 00 00 00 	li      r8,0
fff845fc:	60 63 00 02 	ori     r3,r3,2
fff84600:	4b ff ea 65 	bl      fff83064 <pk_trace_big>

        //Read Scratch register 8.
        rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_8_RW, &scratchreg8());
fff84604:	3c 60 00 05 	lis     r3,5
fff84608:	38 81 00 10 	addi    r4,r1,16
fff8460c:	60 63 00 3f 	ori     r3,r3,63
fff84610:	4b ff e4 01 	bl      fff82a10 <getscom_abs>
        SBE_INFO(SBE_FUNC "SCRTATCH_REG 8 is 0x%08X %08X",
            ((scratchreg8 >> 32) & 0xFFFFFFFF), (scratchreg8 & 0xFFFFFFFF));
fff84614:	3c 60 31 1b 	lis     r3,12571
fff84618:	14 a1 00 10 	lvd     d5,16(r1)
fff8461c:	60 63 00 02 	ori     r3,r3,2
fff84620:	38 e0 00 00 	li      r7,0
fff84624:	39 00 00 00 	li      r8,0
fff84628:	4b ff ea 3d 	bl      fff83064 <pk_trace_big>

        if(scratchreg8.getBit<5>())
fff8462c:	81 21 00 10 	lwz     r9,16(r1)
fff84630:	07 89 28 38 	bb0wi   r9,5,fff846a0 <_Z12checkSbeRolev+0xe4>
        {
            //Read Scratch Reg 6.
            rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_6_RW, &scratchreg6());
fff84634:	3c 60 00 05 	lis     r3,5
fff84638:	38 81 00 08 	addi    r4,r1,8
fff8463c:	60 63 00 3d 	ori     r3,r3,61
fff84640:	4b ff e3 d1 	bl      fff82a10 <getscom_abs>
            SBE_INFO(SBE_FUNC "SCRATCH_REG 6 is 0x%08X %08X",
                      ((scratchreg6 >> 32) & 0xFFFFFFFF), (scratchreg6 & 0xFFFFFFFF));
fff84644:	3c 60 75 d2 	lis     r3,30162
fff84648:	14 a1 00 08 	lvd     d5,8(r1)
fff8464c:	60 63 00 02 	ori     r3,r3,2
fff84650:	38 e0 00 00 	li      r7,0
fff84654:	39 00 00 00 	li      r8,0
fff84658:	4b ff ea 0d 	bl      fff83064 <pk_trace_big>
            if ( scratchreg6.getBit<24>() )
fff8465c:	81 41 00 08 	lwz     r10,8(r1)
fff84660:	81 21 00 18 	lwz     r9,24(r1)
fff84664:	07 8a c0 14 	bb0wi   r10,24,fff8468c <_Z12checkSbeRolev+0xd0>
            {
                sbeRole = SBE_ROLE_MASTER;
                if( !((cbsreg >> 32) & 0x8000000) )
fff84668:	07 09 20 0a 	bb1wi   r9,4,fff8467c <_Z12checkSbeRolev+0xc0>
                {
                    SBE_INFO(SBE_FUNC "SBE Role is Secondary");
fff8466c:	3c 60 e0 b1 	lis     r3,-8015
fff84670:	4b ff bb 09 	bl      fff80178 <pk_trace_tiny>
                    sbeRole = SBE_ROLE_SLAVE;
fff84674:	38 60 00 01 	li      r3,1
fff84678:	48 00 00 30 	b       fff846a8 <_Z12checkSbeRolev+0xec>
                }
                else
                {
                    SBE_INFO(SBE_FUNC "SBE Role is Master");
fff8467c:	3c 60 2c 35 	lis     r3,11317
fff84680:	4b ff ba f9 	bl      fff80178 <pk_trace_tiny>
            rc = getscom_abs (scomt::perv::FSXCOMP_FSXLOG_SCRATCH_REGISTER_6_RW, &scratchreg6());
            SBE_INFO(SBE_FUNC "SCRATCH_REG 6 is 0x%08X %08X",
                      ((scratchreg6 >> 32) & 0xFFFFFFFF), (scratchreg6 & 0xFFFFFFFF));
            if ( scratchreg6.getBit<24>() )
            {
                sbeRole = SBE_ROLE_MASTER;
fff84684:	38 60 00 00 	li      r3,0
fff84688:	48 00 00 20 	b       fff846a8 <_Z12checkSbeRolev+0xec>
                }
            }
            else
            {
               //ALT master
               if( ((cbsreg >> 32) & 0x8000000) )
fff8468c:	07 89 27 f0 	bb0wi   r9,4,fff8466c <_Z12checkSbeRolev+0xb0>
                {   
                    SBE_INFO(SBE_FUNC "SBE Role is Alt-Master");
fff84690:	3c 60 77 66 	lis     r3,30566
fff84694:	4b ff ba e5 	bl      fff80178 <pk_trace_tiny>
                    sbeRole = SBE_ROLE_ALT_MASTER;
fff84698:	38 60 00 02 	li      r3,2
fff8469c:	48 00 00 0c 	b       fff846a8 <_Z12checkSbeRolev+0xec>
                }
            }
        }
        else
        {
            if( (cbsreg >> 32) & 0x8000000 )
fff846a0:	81 21 00 18 	lwz     r9,24(r1)
fff846a4:	4b ff ff c4 	b       fff84668 <_Z12checkSbeRolev+0xac>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return sbeRole;
    #undef SBEM_FUNC
}
fff846a8:	80 01 00 2c 	lwz     r0,44(r1)
fff846ac:	7c 08 03 a6 	mtlr    r0
fff846b0:	38 21 00 28 	addi    r1,r1,40
fff846b4:	4e 80 00 20 	blr

fff846b8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX>:
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context)
{
fff846b8:	94 21 ef d0 	stwu    r1,-4144(r1)
fff846bc:	7c 08 02 a6 	mflr    r0
fff846c0:	1b c1 10 28 	stvd    d30,4136(r1)
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fff846c4:	38 a0 10 00 	li      r5,4096
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context)
{
fff846c8:	7c 7f 1b 78 	mr      r31,r3
fff846cc:	7c 9e 23 78 	mr      r30,r4
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fff846d0:	38 61 00 08 	addi    r3,r1,8
fff846d4:	38 80 00 00 	li      r4,0
#include "sbeglobals.H"

#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context)
{
fff846d8:	90 01 10 34 	stw     r0,4148(r1)
fff846dc:	1b 81 10 20 	stvd    d28,4128(r1)
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
fff846e0:	4b ff e3 45 	bl      fff82a24 <memset>
    uint32_t xipSectionSize = getXipSize(xipSection);
fff846e4:	7f e3 fb 78 	mr      r3,r31
fff846e8:	48 00 12 91 	bl      fff85978 <_Z10getXipSize20p9_xip_section_sbe_t>
fff846ec:	7c 7d 1b 78 	mr      r29,r3
    uint32_t xipSectionOffset = getXipOffset(xipSection);
fff846f0:	7f e3 fb 78 	mr      r3,r31
fff846f4:	48 00 12 61 	bl      fff85954 <_Z12getXipOffset20p9_xip_section_sbe_t>
fff846f8:	7c 7c 1b 78 	mr      r28,r3
    sbe_local_LFR lfrReg;

    SBE_INFO("Xip section details:Start Offset: [0x%08X] Size: [0x%08X] ", xipSectionOffset, xipSectionSize);
fff846fc:	3c 60 10 fc 	lis     r3,4348
fff84700:	60 63 00 02 	ori     r3,r3,2
fff84704:	7f 85 e3 78 	mr      r5,r28
fff84708:	7f a6 eb 78 	mr      r6,r29
fff8470c:	38 e0 00 00 	li      r7,0
fff84710:	39 00 00 00 	li      r8,0
fff84714:	4b ff e9 51 	bl      fff83064 <pk_trace_big>

    // Load the LFR, to fetch if secondary boots seeprom is in use.
    PPE_LVD(0xc0002040, lfrReg);
fff84718:	3d 00 c0 00 	lis     r8,-16384
fff8471c:	61 08 20 40 	ori     r8,r8,8256
fff84720:	15 08 00 00 	lvd     d8,0(r8)

    SBE_INFO("isSecondaryBootsSeeprom [0x%02x]", (uint8_t)lfrReg.sec_boot_seeprom);
fff84724:	55 1f 6f fe 	rlwinm  r31,r8,13,31,31
fff84728:	67 e3 e8 86 	oris    r3,r31,59526
fff8472c:	4b ff ba 4d 	bl      fff80178 <pk_trace_tiny>

    Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff84730:	48 00 1d 8d 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
                const bool i_pib_access = true):
                target_chip(i_target_chip),
                engine(i_engine),
                slave(i_slave),
                base_addr(i_pib_access ?
                          SPIM_BASEADDRESS_PIB + this->engine * SPIM_ENGINEOFFSET :
fff84734:	39 1f 60 00 	addi    r8,r31,24576
                          SPIM_BASEADDRESS_FSI + this->engine * SPIM_ENGINEOFFSET ),
                pibAccess(i_pib_access)
fff84738:	55 08 28 34 	rlwinm  r8,r8,5,0,26
fff8473c:	39 20 00 01 	li      r9,1
fff84740:	90 61 10 08 	stw     r3,4104(r1)
fff84744:	91 01 10 10 	stw     r8,4112(r1)
fff84748:	9b e1 10 0c 	stb     r31,4108(r1)
fff8474c:	b1 21 10 0e 	sth     r9,4110(r1)
fff84750:	99 21 10 14 	stb     r9,4116(r1)
#define SPI_READ_SIZE_BYTES 4096       //4KBytes SPI Buffer size for SHA512

void SHA512UpdateXipSection(p9_xip_section_sbe_t xipSection, SHA512_CTX* context)
{
    uint8_t buf[SPI_READ_SIZE_BYTES] __attribute__ ((aligned(8))) = {0x00};
    uint32_t xipSectionSize = getXipSize(xipSection);
fff84754:	7f bf eb 78 	mr      r31,r29
fff84758:	7d 3c ea 14 	add     r9,r28,r29
    //   isSecondaryBootsSeeprom = 0 ==> Primary Boots seeprom
    SpiControlHandle handle = SpiControlHandle(i_target_chip,
                          (lfrReg.sec_boot_seeprom ? SPI_ENGINE_BACKUP_BOOT_SEEPROM : SPI_ENGINE_PRIMARY_BOOT_SEEPROM));

    //Calculate SAH512 hash by reading chunks as per buf size
    while(xipSectionSize >= SPI_READ_SIZE_BYTES)
fff8475c:	28 1f 0f ff 	cmplwi  r31,4095
fff84760:	7c 9f 48 50 	subf    r4,r31,r9
fff84764:	40 81 00 38 	ble     fff8479c <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX+0xe4>
    {
        spi_read(handle, xipSectionOffset, SPI_READ_SIZE_BYTES, DISCARD_ECC_ACCESS, (uint8_t *)&buf);
fff84768:	38 a0 10 00 	li      r5,4096
fff8476c:	38 c0 00 02 	li      r6,2
fff84770:	38 e1 00 08 	addi    r7,r1,8
fff84774:	38 61 10 08 	addi    r3,r1,4104
fff84778:	91 21 10 18 	stw     r9,4120(r1)
fff8477c:	4b ff f3 ad 	bl      fff83b28 <spi_read>
        SHA512_Update(context, (uint8_t *)&buf, SPI_READ_SIZE_BYTES);
fff84780:	7f c3 f3 78 	mr      r3,r30
fff84784:	38 81 00 08 	addi    r4,r1,8
fff84788:	38 a0 10 00 	li      r5,4096
fff8478c:	48 00 18 f1 	bl      fff8607c <SHA512_Update>
        xipSectionOffset += SPI_READ_SIZE_BYTES;
        xipSectionSize -= SPI_READ_SIZE_BYTES;
fff84790:	3b ff f0 00 	addi    r31,r31,-4096
fff84794:	81 21 10 18 	lwz     r9,4120(r1)
fff84798:	4b ff ff c4 	b       fff8475c <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX+0xa4>
fff8479c:	57 a4 00 26 	rlwinm  r4,r29,0,0,19
fff847a0:	57 a9 05 3e 	clrlwi  r9,r29,20
fff847a4:	7c 84 e2 14 	add     r4,r4,r28
    }

    //Calculate SHA512 hash of left over bytes
    if(xipSectionSize != 0)
fff847a8:	06 c9 00 2c 	bwz     r9,fff84800 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX+0x148>
    {
        uint32_t xipSectionSizeActual = xipSectionSize;

        //SPI driver reads 8bytes chunk. If the length passed is not 8 Byte
        //alligned, it will not read that data.
        if(xipSectionSize % 8 != 0 )
fff847ac:	57 aa 07 7e 	clrlwi  r10,r29,29
fff847b0:	7d 3f 4b 78 	mr      r31,r9
fff847b4:	06 ca 00 06 	bwz     r10,fff847c0 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX+0x108>
            xipSectionSize += (8 - (xipSectionSize % 8));
fff847b8:	57 bd 05 38 	rlwinm  r29,r29,0,20,28
fff847bc:	3b fd 00 08 	addi    r31,r29,8

        spi_read(handle, xipSectionOffset, xipSectionSize, DISCARD_ECC_ACCESS, (uint8_t *)&buf);
fff847c0:	7f e5 fb 78 	mr      r5,r31
fff847c4:	38 c0 00 02 	li      r6,2
fff847c8:	38 e1 00 08 	addi    r7,r1,8
fff847cc:	38 61 10 08 	addi    r3,r1,4104
fff847d0:	91 21 10 18 	stw     r9,4120(r1)
fff847d4:	4b ff f3 55 	bl      fff83b28 <spi_read>
        //FIXME: This is a hack, to ensure if length is unaligned pad bytes of
        //the XIP section are zero.
        //Due to issues in IPL image tool .base setion has junk data
        //insted of zero pads. Once tool has been fixed the below piece of code
        //can be removed.
        memset(&buf[xipSectionSizeActual], 0x00, (xipSectionSize - xipSectionSizeActual));
fff847d8:	81 21 10 18 	lwz     r9,4120(r1)
fff847dc:	39 41 00 08 	addi    r10,r1,8
fff847e0:	38 80 00 00 	li      r4,0
fff847e4:	7c a9 f8 50 	subf    r5,r9,r31
fff847e8:	7c 6a 4a 14 	add     r3,r10,r9
fff847ec:	4b ff e2 39 	bl      fff82a24 <memset>

        //Calculate SHA512 for complete data read from SPI as we are aligning data to 8byte by
	    //padding zero's if unaligned during sigining process
        SHA512_Update(context, (uint8_t *)&buf, xipSectionSize);
fff847f0:	7f c3 f3 78 	mr      r3,r30
fff847f4:	38 81 00 08 	addi    r4,r1,8
fff847f8:	7f e5 fb 78 	mr      r5,r31
fff847fc:	48 00 18 81 	bl      fff8607c <SHA512_Update>
    }
}
fff84800:	80 01 10 34 	lwz     r0,4148(r1)
fff84804:	17 81 10 20 	lvd     d28,4128(r1)
fff84808:	7c 08 03 a6 	mtlr    r0
fff8480c:	17 c1 10 28 	lvd     d30,4136(r1)
fff84810:	38 21 10 30 	addi    r1,r1,4144
fff84814:	4e 80 00 20 	blr

fff84818 <_Z18SHA512_XIP_section20p9_xip_section_sbe_tPA64_h>:

void SHA512_XIP_section(p9_xip_section_sbe_t xipSection, SHA512_t *result)
{
fff84818:	94 21 ff 20 	stwu    r1,-224(r1)
fff8481c:	7c 08 02 a6 	mflr    r0
fff84820:	1b c1 00 d8 	stvd    d30,216(r1)
fff84824:	7c 7e 1b 78 	mr      r30,r3
    SHA512_CTX context;

    SHA512_Init(&context);
fff84828:	38 61 00 08 	addi    r3,r1,8
        SHA512_Update(context, (uint8_t *)&buf, xipSectionSize);
    }
}

void SHA512_XIP_section(p9_xip_section_sbe_t xipSection, SHA512_t *result)
{
fff8482c:	90 01 00 e4 	stw     r0,228(r1)
fff84830:	7c 9f 23 78 	mr      r31,r4
    SHA512_CTX context;

    SHA512_Init(&context);
fff84834:	48 00 17 ed 	bl      fff86020 <SHA512_Init>
    SHA512UpdateXipSection(xipSection , &context);
fff84838:	7f c3 f3 78 	mr      r3,r30
fff8483c:	38 81 00 08 	addi    r4,r1,8
fff84840:	4b ff fe 79 	bl      fff846b8 <_Z22SHA512UpdateXipSection20p9_xip_section_sbe_tP11_SHA512_CTX>
    SHA512_Final(&context, result);
fff84844:	38 61 00 08 	addi    r3,r1,8
fff84848:	7f e4 fb 78 	mr      r4,r31
fff8484c:	48 00 19 75 	bl      fff861c0 <SHA512_Final>
}
fff84850:	80 01 00 e4 	lwz     r0,228(r1)
fff84854:	17 c1 00 d8 	lvd     d30,216(r1)
fff84858:	7c 08 03 a6 	mtlr    r0
fff8485c:	38 21 00 e0 	addi    r1,r1,224
fff84860:	4e 80 00 20 	blr

fff84864 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>:
#include "sbemtrace.H"

static const size_t TPM_MAX_SPI_TRANSMIT_SIZE = 64;

fapi2::ReturnCode tpmReadSTSRegValid(SpiControlHandle &handle, tpm_sts_reg_t & o_stsReg)
{
fff84864:	94 21 ff e8 	stwu    r1,-24(r1)
fff84868:	7c 08 02 a6 	mflr    r0
fff8486c:	1b 81 00 08 	stvd    d28,8(r1)
fff84870:	90 01 00 1c 	stw     r0,28(r1)
fff84874:	1b c1 00 10 	stvd    d30,16(r1)
fff84878:	7c 7c 1b 78 	mr      r28,r3
fff8487c:	7c 9e 23 78 	mr      r30,r4
    #define SBEM_FUNC " tpmReadSTSRegValid "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t polls = 0;
fff84880:	3b a0 00 00 	li      r29,0
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&o_stsReg);
fff84884:	7f 83 e3 78 	mr      r3,r28
fff84888:	38 80 00 00 	li      r4,0
fff8488c:	38 a0 00 18 	li      r5,24
fff84890:	38 c0 00 01 	li      r6,1
fff84894:	7f c7 f3 78 	mr      r7,r30
fff84898:	4b ff f8 d5 	bl      fff8416c <spi_tpm_read_secure>
fff8489c:	7c 7f 1b 78 	mr      r31,r3
        if(rc != fapi2::FAPI2_RC_SUCCESS)
fff848a0:	06 c3 00 12 	bwz     r3,fff848c4 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x60>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading status with rc 0x%08X", rc);
fff848a4:	3c 60 80 46 	lis     r3,-32698
fff848a8:	60 63 00 01 	ori     r3,r3,1
fff848ac:	7f e5 fb 78 	mr      r5,r31
fff848b0:	38 c0 00 00 	li      r6,0
fff848b4:	38 e0 00 00 	li      r7,0
fff848b8:	39 00 00 00 	li      r8,0
fff848bc:	4b ff e7 a9 	bl      fff83064 <pk_trace_big>
            break;
fff848c0:	48 00 00 5c 	b       fff8491c <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb8>
        }
        SBEM_INFO(SBEM_FUNC "TPM status register value is 0x%02X", o_stsReg.value);
fff848c4:	88 7e 00 00 	lbz     r3,0(r30)
fff848c8:	64 63 2f b9 	oris    r3,r3,12217
fff848cc:	4b ff b8 ad 	bl      fff80178 <pk_trace_tiny>
        if((polls > MAX_STSVALID_POLLS) && !(o_stsReg.fields.stsValid))
fff848d0:	28 1d c3 50 	cmplwi  r29,50000
fff848d4:	89 3e 00 00 	lbz     r9,0(r30)
fff848d8:	40 81 00 1c 	ble     fff848f4 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x90>
fff848dc:	07 09 c0 0c 	bb1wi   r9,24,fff848f4 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x90>
        {
            SBEM_INFO(SBEM_FUNC "TPM timeout waiting for stsValid");
fff848e0:	3c 60 d8 0a 	lis     r3,-10230
            rc = fapi2::FAPI2_RC_FALSE;
fff848e4:	3f e0 04 00 	lis     r31,1024
            break;
        }
        SBEM_INFO(SBEM_FUNC "TPM status register value is 0x%02X", o_stsReg.value);
        if((polls > MAX_STSVALID_POLLS) && !(o_stsReg.fields.stsValid))
        {
            SBEM_INFO(SBEM_FUNC "TPM timeout waiting for stsValid");
fff848e8:	4b ff b8 91 	bl      fff80178 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fff848ec:	63 ff 00 06 	ori     r31,r31,6
            break;
fff848f0:	48 00 00 2c 	b       fff8491c <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb8>
        }
        else if(!o_stsReg.fields.stsValid)
fff848f4:	07 09 c0 10 	bb1wi   r9,24,fff84914 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0xb0>
        {
            fapi2::delay(1000, 1000);
fff848f8:	38 60 00 00 	li      r3,0
fff848fc:	38 80 03 e8 	li      r4,1000
fff84900:	38 a0 00 00 	li      r5,0
fff84904:	38 c0 03 e8 	li      r6,1000
fff84908:	38 e0 00 00 	li      r7,0
fff8490c:	48 00 1b 01 	bl      fff8640c <_ZN5fapi25delayEyyb>
            polls++;
fff84910:	3b bd 00 01 	addi    r29,r29,1
        }
    }while(!o_stsReg.fields.stsValid);
fff84914:	89 3e 00 00 	lbz     r9,0(r30)
{
    #define SBEM_FUNC " tpmReadSTSRegValid "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t polls = 0;
    do
fff84918:	07 89 c7 b6 	bb0wi   r9,24,fff84884 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t+0x20>
        }
    }while(!o_stsReg.fields.stsValid);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff8491c:	80 01 00 1c 	lwz     r0,28(r1)
fff84920:	7f e3 fb 78 	mr      r3,r31
fff84924:	7c 08 03 a6 	mtlr    r0
fff84928:	17 81 00 08 	lvd     d28,8(r1)
fff8492c:	17 c1 00 10 	lvd     d30,16(r1)
fff84930:	38 21 00 18 	addi    r1,r1,24
fff84934:	4e 80 00 20 	blr

fff84938 <_Z14tpmIsExpectingR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fff84938:	94 21 ff e0 	stwu    r1,-32(r1)
fff8493c:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsExpecting "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isExpect = false;
fff84940:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fff84944:	1b c1 00 18 	stvd    d30,24(r1)
fff84948:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsExpecting "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isExpect = false;
fff8494c:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fff84950:	7c 7f 1b 78 	mr      r31,r3
    isExpect = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fff84954:	3c 60 a4 d4 	lis     r3,-23340
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsExpecting(SpiControlHandle &handle, bool &isExpect )
{
fff84958:	7c 9e 23 78 	mr      r30,r4
    isExpect = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fff8495c:	4b ff b8 1d 	bl      fff80178 <pk_trace_tiny>
        rc = tpmReadSTSRegValid(handle, status);
fff84960:	7f e3 fb 78 	mr      r3,r31
fff84964:	38 81 00 08 	addi    r4,r1,8
fff84968:	4b ff fe fd 	bl      fff84864 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fff8496c:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84970:	06 c3 00 12 	bwz     r3,fff84994 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadSTSRegValid failed while reading TPM Status register with rc 0x%08X", rc);
fff84974:	3c 60 49 8b 	lis     r3,18827
fff84978:	60 63 00 01 	ori     r3,r3,1
fff8497c:	7f e5 fb 78 	mr      r5,r31
fff84980:	38 c0 00 00 	li      r6,0
fff84984:	38 e0 00 00 	li      r7,0
fff84988:	39 00 00 00 	li      r8,0
fff8498c:	4b ff e6 d9 	bl      fff83064 <pk_trace_big>
            break;
fff84990:	48 00 00 20 	b       fff849b0 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x78>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fff84994:	88 61 00 08 	lbz     r3,8(r1)
fff84998:	64 63 22 42 	oris    r3,r3,8770
fff8499c:	4b ff b7 dd 	bl      fff80178 <pk_trace_tiny>
        if(status.fields.expect)
fff849a0:	89 21 00 08 	lbz     r9,8(r1)
fff849a4:	07 89 e0 06 	bb0wi   r9,28,fff849b0 <_Z14tpmIsExpectingR16SpiControlHandleRb+0x78>
        {
            isExpect = true;
fff849a8:	39 20 00 01 	li      r9,1
fff849ac:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "isExpect is %d", isExpect);
fff849b0:	88 7e 00 00 	lbz     r3,0(r30)
fff849b4:	64 63 35 cb 	oris    r3,r3,13771
fff849b8:	4b ff b7 c1 	bl      fff80178 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff849bc:	80 01 00 24 	lwz     r0,36(r1)
fff849c0:	7f e3 fb 78 	mr      r3,r31
fff849c4:	7c 08 03 a6 	mtlr    r0
fff849c8:	17 c1 00 18 	lvd     d30,24(r1)
fff849cc:	38 21 00 20 	addi    r1,r1,32
fff849d0:	4e 80 00 20 	blr

fff849d4 <_Z14tpmIsDataAvailR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fff849d4:	94 21 ff e0 	stwu    r1,-32(r1)
fff849d8:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsDataAvail "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    dataAvail = false;
fff849dc:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fff849e0:	1b c1 00 18 	stvd    d30,24(r1)
fff849e4:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsDataAvail "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    dataAvail = false;
fff849e8:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fff849ec:	7c 7f 1b 78 	mr      r31,r3
    dataAvail = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fff849f0:	3c 60 9e 40 	lis     r3,-25024
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsDataAvail(SpiControlHandle &handle, bool &dataAvail )
{
fff849f4:	7c 9e 23 78 	mr      r30,r4
    dataAvail = false;
    tpm_sts_reg_t status;
    do
    {

        SBEM_INFO(SBEM_FUNC "Read TPM Status Register.");
fff849f8:	4b ff b7 81 	bl      fff80178 <pk_trace_tiny>
        rc = tpmReadSTSRegValid(handle, status);
fff849fc:	7f e3 fb 78 	mr      r3,r31
fff84a00:	38 81 00 08 	addi    r4,r1,8
fff84a04:	4b ff fe 61 	bl      fff84864 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fff84a08:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84a0c:	06 c3 00 12 	bwz     r3,fff84a30 <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadSTSRegValid failed while reading TPM Status register with rc 0x%08X", rc);
fff84a10:	3c 60 a5 3b 	lis     r3,-23237
fff84a14:	60 63 00 01 	ori     r3,r3,1
fff84a18:	7f e5 fb 78 	mr      r5,r31
fff84a1c:	38 c0 00 00 	li      r6,0
fff84a20:	38 e0 00 00 	li      r7,0
fff84a24:	39 00 00 00 	li      r8,0
fff84a28:	4b ff e6 3d 	bl      fff83064 <pk_trace_big>
            break;
fff84a2c:	48 00 00 20 	b       fff84a4c <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x78>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fff84a30:	88 61 00 08 	lbz     r3,8(r1)
fff84a34:	64 63 2e 67 	oris    r3,r3,11879
fff84a38:	4b ff b7 41 	bl      fff80178 <pk_trace_tiny>
        if(status.fields.dataAvail)
fff84a3c:	89 21 00 08 	lbz     r9,8(r1)
fff84a40:	07 89 d8 06 	bb0wi   r9,27,fff84a4c <_Z14tpmIsDataAvailR16SpiControlHandleRb+0x78>
        {
            dataAvail = true;
fff84a44:	39 20 00 01 	li      r9,1
fff84a48:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "dataAvail is %d", dataAvail);
fff84a4c:	88 7e 00 00 	lbz     r3,0(r30)
fff84a50:	64 63 54 39 	oris    r3,r3,21561
fff84a54:	4b ff b7 25 	bl      fff80178 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84a58:	80 01 00 24 	lwz     r0,36(r1)
fff84a5c:	7f e3 fb 78 	mr      r3,r31
fff84a60:	7c 08 03 a6 	mtlr    r0
fff84a64:	17 c1 00 18 	lvd     d30,24(r1)
fff84a68:	38 21 00 20 	addi    r1,r1,32
fff84a6c:	4e 80 00 20 	blr

fff84a70 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>:

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fff84a70:	94 21 ff e0 	stwu    r1,-32(r1)
fff84a74:	7c 08 02 a6 	mflr    r0
   #define SBEM_FUNC " tpmIsCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isCmdReady = false;
fff84a78:	39 20 00 00 	li      r9,0
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fff84a7c:	1b c1 00 18 	stvd    d30,24(r1)
fff84a80:	90 01 00 24 	stw     r0,36(r1)
   #define SBEM_FUNC " tpmIsCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    isCmdReady = false;
fff84a84:	99 24 00 00 	stb     r9,0(r4)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmIsCommandReady(SpiControlHandle &handle, bool &isCmdReady )
{
fff84a88:	7c 9e 23 78 	mr      r30,r4
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;

        SBEM_DEBUG(SBEM_FUNC "Read TPM Status Register.");
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&status);
fff84a8c:	38 a0 00 18 	li      r5,24
fff84a90:	38 80 00 00 	li      r4,0
fff84a94:	38 c0 00 01 	li      r6,1
fff84a98:	38 e1 00 08 	addi    r7,r1,8
fff84a9c:	4b ff f6 d1 	bl      fff8416c <spi_tpm_read_secure>
fff84aa0:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84aa4:	06 c3 00 12 	bwz     r3,fff84ac8 <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x58>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading TPM Status register with rc 0x%08X", rc);
fff84aa8:	3c 60 26 44 	lis     r3,9796
fff84aac:	60 63 00 01 	ori     r3,r3,1
fff84ab0:	7f e5 fb 78 	mr      r5,r31
fff84ab4:	38 c0 00 00 	li      r6,0
fff84ab8:	38 e0 00 00 	li      r7,0
fff84abc:	39 00 00 00 	li      r8,0
fff84ac0:	4b ff e5 a5 	bl      fff83064 <pk_trace_big>
            break;
fff84ac4:	48 00 00 20 	b       fff84ae4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x74>
        }
        SBEM_INFO(SBEM_FUNC "TPM read data is 0x%02X", status.value);
fff84ac8:	88 61 00 08 	lbz     r3,8(r1)
fff84acc:	64 63 d9 26 	oris    r3,r3,55590
fff84ad0:	4b ff b6 a9 	bl      fff80178 <pk_trace_tiny>
        if(status.fields.isCommandReady)
fff84ad4:	89 21 00 08 	lbz     r9,8(r1)
fff84ad8:	07 89 c8 06 	bb0wi   r9,25,fff84ae4 <_Z17tpmIsCommandReadyR16SpiControlHandleRb+0x74>
        {
            isCmdReady = true;
fff84adc:	39 20 00 01 	li      r9,1
fff84ae0:	99 3e 00 00 	stb     r9,0(r30)
        }
    }while(0);
    SBEM_INFO(SBEM_FUNC "TPM isCommand Ready is %d", isCmdReady);
fff84ae4:	88 7e 00 00 	lbz     r3,0(r30)
fff84ae8:	64 63 74 c5 	oris    r3,r3,29893
fff84aec:	4b ff b6 8d 	bl      fff80178 <pk_trace_tiny>
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84af0:	80 01 00 24 	lwz     r0,36(r1)
fff84af4:	7f e3 fb 78 	mr      r3,r31
fff84af8:	7c 08 03 a6 	mtlr    r0
fff84afc:	17 c1 00 18 	lvd     d30,24(r1)
fff84b00:	38 21 00 20 	addi    r1,r1,32
fff84b04:	4e 80 00 20 	blr

fff84b08 <_Z20tpmWriteCommandReadyR16SpiControlHandle>:

fapi2::ReturnCode tpmWriteCommandReady(SpiControlHandle &handle)
{
fff84b08:	94 21 ff e0 	stwu    r1,-32(r1)
fff84b0c:	7c 08 02 a6 	mflr    r0
    #define SBEM_FUNC " tpmWriteCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.isCommandReady = 1;
fff84b10:	7c 27 0b 78 	mr      r7,r1
fff84b14:	39 20 00 40 	li      r9,64
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmWriteCommandReady(SpiControlHandle &handle)
{
fff84b18:	1b c1 00 18 	stvd    d30,24(r1)
fff84b1c:	90 01 00 24 	stw     r0,36(r1)
    #define SBEM_FUNC " tpmWriteCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.isCommandReady = 1;
fff84b20:	9d 27 00 08 	stbu    r9,8(r7)
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&stsReg);
fff84b24:	38 80 00 00 	li      r4,0
fff84b28:	38 a0 00 18 	li      r5,24
fff84b2c:	38 c0 00 01 	li      r6,1
fff84b30:	4b ff f9 d1 	bl      fff84500 <spi_tpm_write_with_wait>
fff84b34:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84b38:	06 c3 00 10 	bwz     r3,fff84b58 <_Z20tpmWriteCommandReadyR16SpiControlHandle+0x50>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed while setting isCommandReady bit with rc 0x%08X", rc);
fff84b3c:	3c 60 8f c5 	lis     r3,-28731
fff84b40:	60 63 00 01 	ori     r3,r3,1
fff84b44:	7f e5 fb 78 	mr      r5,r31
fff84b48:	38 c0 00 00 	li      r6,0
fff84b4c:	38 e0 00 00 	li      r7,0
fff84b50:	39 00 00 00 	li      r8,0
fff84b54:	4b ff e5 11 	bl      fff83064 <pk_trace_big>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84b58:	80 01 00 24 	lwz     r0,36(r1)
fff84b5c:	7f e3 fb 78 	mr      r3,r31
fff84b60:	7c 08 03 a6 	mtlr    r0
fff84b64:	17 c1 00 18 	lvd     d30,24(r1)
fff84b68:	38 21 00 20 	addi    r1,r1,32
fff84b6c:	4e 80 00 20 	blr

fff84b70 <_Z22tpmPollForCommandReadyR16SpiControlHandle>:

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fff84b70:	94 21 ff d0 	stwu    r1,-48(r1)
fff84b74:	7c 08 02 a6 	mflr    r0
fff84b78:	1b c1 00 28 	stvd    d30,40(r1)
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fff84b7c:	39 20 00 00 	li      r9,0
fff84b80:	7c 3e 0b 78 	mr      r30,r1
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fff84b84:	1b 81 00 20 	stvd    d28,32(r1)
fff84b88:	90 01 00 34 	stw     r0,52(r1)
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fff84b8c:	3f 80 00 1e 	lis     r28,30
fff84b90:	9d 3e 00 08 	stbu    r9,8(r30)
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmPollForCommandReady(SpiControlHandle &handle)
{
fff84b94:	7c 7d 1b 78 	mr      r29,r3
   #define SBEM_FUNC " tpmPollForCommandReady "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
fff84b98:	63 9c 84 80 	ori     r28,r28,33920
    do
    {
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
        {
            rc = tpmIsCommandReady(handle, isCommandReady);
fff84b9c:	7f a3 eb 78 	mr      r3,r29
fff84ba0:	7f c4 f3 78 	mr      r4,r30
fff84ba4:	4b ff fe cd 	bl      fff84a70 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fff84ba8:	7c 69 1b 78 	mr      r9,r3
fff84bac:	7c 7f 1b 78 	mr      r31,r3
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
fff84bb0:	06 43 00 06 	bwnz    r3,fff84bbc <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x4c>
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (isCommandReady)) )
fff84bb4:	89 41 00 08 	lbz     r10,8(r1)
fff84bb8:	06 ca 00 56 	bwz     r10,fff84c64 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xf4>
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady either failed while reading TPM Status register with rc 0x%08X or cmdReady %d",
                                     rc, status.fields.isCommandReady);
fff84bbc:	3c 60 8f 9b 	lis     r3,-28773
fff84bc0:	7d 25 4b 78 	mr      r5,r9
fff84bc4:	60 63 00 02 	ori     r3,r3,2
fff84bc8:	38 c0 00 00 	li      r6,0
fff84bcc:	38 e0 00 00 	li      r7,0
fff84bd0:	39 00 00 00 	li      r8,0
fff84bd4:	91 21 00 18 	stw     r9,24(r1)
fff84bd8:	4b ff e4 8d 	bl      fff83064 <pk_trace_big>
                break;
            }
            fapi2::delay(1000, 1000);
        }

        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.isCommandReady))
fff84bdc:	81 21 00 18 	lwz     r9,24(r1)
fff84be0:	06 49 00 5e 	bwnz    r9,fff84c9c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
        {
            SBE_INFO(SBE_FUNC "isCommandReady Bit is not set. Set and poll");
fff84be4:	3c 60 f0 6e 	lis     r3,-3986
fff84be8:	4b ff b5 91 	bl      fff80178 <pk_trace_tiny>
            // The first write to command ready may have just aborted
            // an outstanding command, we will write it again and poll once
            // more
            rc = tpmWriteCommandReady(handle);
fff84bec:	7f a3 eb 78 	mr      r3,r29
fff84bf0:	4b ff ff 19 	bl      fff84b08 <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fff84bf4:	3f 80 00 1e 	lis     r28,30
fff84bf8:	7c 7f 1b 78 	mr      r31,r3
fff84bfc:	63 9c 84 80 	ori     r28,r28,33920
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84c00:	06 c3 00 26 	bwz     r3,fff84c4c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xdc>
            {
                SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
fff84c04:	3c 60 a7 16 	lis     r3,-22762
fff84c08:	60 63 00 01 	ori     r3,r3,1
fff84c0c:	7f e5 fb 78 	mr      r5,r31
fff84c10:	38 c0 00 00 	li      r6,0
fff84c14:	38 e0 00 00 	li      r7,0
fff84c18:	39 00 00 00 	li      r8,0
fff84c1c:	4b ff e4 49 	bl      fff83064 <pk_trace_big>
                break;
fff84c20:	48 00 00 7c 	b       fff84c9c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
                // Operation TIMEOUT_B defined by TCG spec for command ready
                for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
                {
                    rc = tpmIsCommandReady(handle, isCommandReady);
                    if((rc != fapi2::FAPI2_RC_SUCCESS) ||
                       ((rc == fapi2::FAPI2_RC_SUCCESS) && (isCommandReady)))
fff84c24:	89 21 00 08 	lbz     r9,8(r1)
fff84c28:	06 49 00 30 	bwnz    r9,fff84c88 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x118>
                    {
                        break;
                    }
                    fapi2::delay(1000, 1000);
fff84c2c:	38 60 00 00 	li      r3,0
fff84c30:	38 80 03 e8 	li      r4,1000
fff84c34:	38 a0 00 00 	li      r5,0
fff84c38:	38 c0 03 e8 	li      r6,1000
fff84c3c:	38 e0 00 00 	li      r7,0
fff84c40:	48 00 17 cd 	bl      fff8640c <_ZN5fapi25delayEyyb>
            }
            else
            {
                // Ok, poll again
                // Operation TIMEOUT_B defined by TCG spec for command ready
                for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fff84c44:	37 9c ff ff 	addic.  r28,r28,-1
fff84c48:	41 82 00 40 	beq     fff84c88 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x118>
                {
                    rc = tpmIsCommandReady(handle, isCommandReady);
fff84c4c:	7f a3 eb 78 	mr      r3,r29
fff84c50:	7f c4 f3 78 	mr      r4,r30
fff84c54:	4b ff fe 1d 	bl      fff84a70 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fff84c58:	7c 7f 1b 78 	mr      r31,r3
                    if((rc != fapi2::FAPI2_RC_SUCCESS) ||
fff84c5c:	06 c3 07 e4 	bwz     r3,fff84c24 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0xb4>
fff84c60:	48 00 00 3c 	b       fff84c9c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady either failed while reading TPM Status register with rc 0x%08X or cmdReady %d",
                                     rc, status.fields.isCommandReady);
                break;
            }
            fapi2::delay(1000, 1000);
fff84c64:	38 60 00 00 	li      r3,0
fff84c68:	38 80 03 e8 	li      r4,1000
fff84c6c:	38 a0 00 00 	li      r5,0
fff84c70:	38 c0 03 e8 	li      r6,1000
fff84c74:	38 e0 00 00 	li      r7,0
fff84c78:	48 00 17 95 	bl      fff8640c <_ZN5fapi25delayEyyb>
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t status;
    bool isCommandReady = false;
    do
    {
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fff84c7c:	37 9c ff ff 	addic.  r28,r28,-1
fff84c80:	40 82 ff 1c 	bne     fff84b9c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x2c>
fff84c84:	4b ff ff 60 	b       fff84be4 <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x74>
                    }
                    fapi2::delay(1000, 1000);
                }
            }
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!isCommandReady))
fff84c88:	89 21 00 08 	lbz     r9,8(r1)
fff84c8c:	3b e0 00 00 	li      r31,0
fff84c90:	06 49 00 06 	bwnz    r9,fff84c9c <_Z22tpmPollForCommandReadyR16SpiControlHandle+0x12c>
        {
            rc = fapi2::FAPI2_RC_FALSE;
fff84c94:	3f e0 04 00 	lis     r31,1024
fff84c98:	63 ff 00 06 	ori     r31,r31,6

    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84c9c:	80 01 00 34 	lwz     r0,52(r1)
fff84ca0:	7f e3 fb 78 	mr      r3,r31
fff84ca4:	7c 08 03 a6 	mtlr    r0
fff84ca8:	17 81 00 20 	lvd     d28,32(r1)
fff84cac:	17 c1 00 28 	lvd     d30,40(r1)
fff84cb0:	38 21 00 30 	addi    r1,r1,48
fff84cb4:	4e 80 00 20 	blr

fff84cb8 <_Z17tpmReadBurstCountR16SpiControlHandleRt>:

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fff84cb8:	94 21 ff e0 	stwu    r1,-32(r1)
fff84cbc:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
fff84cc0:	7c 27 0b 78 	mr      r7,r1
fff84cc4:	39 20 00 00 	li      r9,0
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fff84cc8:	1b c1 00 18 	stvd    d30,24(r1)
fff84ccc:	90 01 00 24 	stw     r0,36(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
fff84cd0:	b5 27 00 08 	sthu    r9,8(r7)
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmReadBurstCount(SpiControlHandle &handle,
                                    uint16_t & o_burstCount)
{
fff84cd4:	7c 9e 23 78 	mr      r30,r4
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_BURSTCOUNT_0;  // Relative address to read from TPM.
        uint16_t value = 0;
        uint32_t readBytes = 2;
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&value);
fff84cd8:	38 a0 00 19 	li      r5,25
fff84cdc:	38 80 00 00 	li      r4,0
fff84ce0:	38 c0 00 02 	li      r6,2
fff84ce4:	4b ff f4 89 	bl      fff8416c <spi_tpm_read_secure>
fff84ce8:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84cec:	06 c3 00 12 	bwz     r3,fff84d10 <_Z17tpmReadBurstCountR16SpiControlHandleRt+0x58>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading burst count with rc 0x%08X", rc);
fff84cf0:	3c 60 b1 f6 	lis     r3,-19978
fff84cf4:	60 63 00 01 	ori     r3,r3,1
fff84cf8:	7f e5 fb 78 	mr      r5,r31
fff84cfc:	38 c0 00 00 	li      r6,0
fff84d00:	38 e0 00 00 	li      r7,0
fff84d04:	39 00 00 00 	li      r8,0
fff84d08:	4b ff e3 5d 	bl      fff83064 <pk_trace_big>
fff84d0c:	48 00 00 18 	b       fff84d24 <_Z17tpmReadBurstCountR16SpiControlHandleRt+0x6c>
            break;
        }
        uint8_t lowByte = (value & 0x00FF);
fff84d10:	a1 21 00 08 	lhz     r9,8(r1)
        uint8_t highByte = (value & 0xFF00) >> 8;
        o_burstCount = (lowByte << 8) | highByte;
fff84d14:	55 2a 44 2e 	rlwinm  r10,r9,8,16,23
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading burst count with rc 0x%08X", rc);
            break;
        }
        uint8_t lowByte = (value & 0x00FF);
        uint8_t highByte = (value & 0xFF00) >> 8;
fff84d18:	55 29 c2 3e 	rlwinm  r9,r9,24,8,31
        o_burstCount = (lowByte << 8) | highByte;
fff84d1c:	7d 49 4b 78 	or      r9,r10,r9
fff84d20:	b1 3e 00 00 	sth     r9,0(r30)
    }while(0);
    SBEM_DEBUG(SBEM_FUNC "Burst count is 0x%04X", o_burstCount);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84d24:	80 01 00 24 	lwz     r0,36(r1)
fff84d28:	7f e3 fb 78 	mr      r3,r31
fff84d2c:	7c 08 03 a6 	mtlr    r0
fff84d30:	17 c1 00 18 	lvd     d30,24(r1)
fff84d34:	38 21 00 20 	addi    r1,r1,32
fff84d38:	4e 80 00 20 	blr

fff84d3c <_Z13tpmWriteTpmGoR16SpiControlHandle>:

fapi2::ReturnCode tpmWriteTpmGo(SpiControlHandle &handle)
{
fff84d3c:	94 21 ff e0 	stwu    r1,-32(r1)
fff84d40:	7c 08 02 a6 	mflr    r0
    #define SBEM_FUNC " tpmWriteTpmGo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.tpmGo = 1;
fff84d44:	7c 27 0b 78 	mr      r7,r1
fff84d48:	39 20 00 20 	li      r9,32
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmWriteTpmGo(SpiControlHandle &handle)
{
fff84d4c:	1b c1 00 18 	stvd    d30,24(r1)
fff84d50:	90 01 00 24 	stw     r0,36(r1)
    #define SBEM_FUNC " tpmWriteTpmGo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    tpm_sts_reg_t stsReg;
    stsReg.value = 0;
    stsReg.fields.tpmGo = 1;
fff84d54:	9d 27 00 08 	stbu    r9,8(r7)
    do
    {
        uint32_t tpmLocality = 0;      // TPM locality (0-4)
        uint32_t offsetAddr = TPM_INT_STATUS_0;  // Relative address to read from TPM.
        uint32_t readBytes = 1;
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, readBytes, (uint8_t *)&stsReg);
fff84d58:	38 80 00 00 	li      r4,0
fff84d5c:	38 a0 00 18 	li      r5,24
fff84d60:	38 c0 00 01 	li      r6,1
fff84d64:	4b ff f7 9d 	bl      fff84500 <spi_tpm_write_with_wait>
fff84d68:	7c 7f 1b 78 	mr      r31,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84d6c:	06 c3 00 10 	bwz     r3,fff84d8c <_Z13tpmWriteTpmGoR16SpiControlHandle+0x50>
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed while setting tpmGo bit with rc 0x%08X", rc);
fff84d70:	3c 60 b2 5f 	lis     r3,-19873
fff84d74:	60 63 00 01 	ori     r3,r3,1
fff84d78:	7f e5 fb 78 	mr      r5,r31
fff84d7c:	38 c0 00 00 	li      r6,0
fff84d80:	38 e0 00 00 	li      r7,0
fff84d84:	39 00 00 00 	li      r8,0
fff84d88:	4b ff e2 dd 	bl      fff83064 <pk_trace_big>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84d8c:	80 01 00 24 	lwz     r0,36(r1)
fff84d90:	7f e3 fb 78 	mr      r3,r31
fff84d94:	7c 08 03 a6 	mtlr    r0
fff84d98:	17 c1 00 18 	lvd     d30,24(r1)
fff84d9c:	38 21 00 20 	addi    r1,r1,32
fff84da0:	4e 80 00 20 	blr

fff84da4 <_Z19tpmPollForDataAvailR16SpiControlHandle>:

fapi2::ReturnCode tpmPollForDataAvail(SpiControlHandle &handle)
{
fff84da4:	94 21 ff d8 	stwu    r1,-40(r1)
fff84da8:	7c 08 02 a6 	mflr    r0
fff84dac:	1b 81 00 18 	stvd    d28,24(r1)
fff84db0:	90 01 00 2c 	stw     r0,44(r1)
fff84db4:	3f a0 00 1e 	lis     r29,30
fff84db8:	1b c1 00 20 	stvd    d30,32(r1)
fff84dbc:	7c 7c 1b 78 	mr      r28,r3
fff84dc0:	63 bd 84 80 	ori     r29,r29,33920
    {
        // Use the longer timeout B here since some of the TPM commands may take
        // more than timeout A to complete
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
        {
            rc = tpmReadSTSRegValid(handle, status);
fff84dc4:	7f 83 e3 78 	mr      r3,r28
fff84dc8:	38 81 00 08 	addi    r4,r1,8
fff84dcc:	4b ff fa 99 	bl      fff84864 <_Z18tpmReadSTSRegValidR16SpiControlHandleR13tpm_sts_reg_t>
fff84dd0:	7c 7f 1b 78 	mr      r31,r3
fff84dd4:	7c 7e 1b 78 	mr      r30,r3
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
fff84dd8:	06 43 00 26 	bwnz    r3,fff84e24 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x80>
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (status.fields.dataAvail)))
fff84ddc:	89 21 00 08 	lbz     r9,8(r1)
fff84de0:	07 09 d8 22 	bb1wi   r9,27,fff84e24 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x80>
            if((rc == fapi2::FAPI2_RC_FALSE))
            {
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
fff84de4:	38 60 00 00 	li      r3,0
fff84de8:	38 80 03 e8 	li      r4,1000
fff84dec:	38 a0 00 00 	li      r5,0
fff84df0:	38 c0 03 e8 	li      r6,1000
fff84df4:	38 e0 00 00 	li      r7,0
fff84df8:	48 00 16 15 	bl      fff8640c <_ZN5fapi25delayEyyb>
    tpm_sts_reg_t status;
    do
    {
        // Use the longer timeout B here since some of the TPM commands may take
        // more than timeout A to complete
        for (uint32_t delay = 0; delay < TPM_TIMEOUT_B; delay ++)
fff84dfc:	37 bd ff ff 	addic.  r29,r29,-1
fff84e00:	40 82 ff c4 	bne     fff84dc4 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x20>
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
fff84e04:	89 21 00 08 	lbz     r9,8(r1)
fff84e08:	3b c0 00 00 	li      r30,0
fff84e0c:	07 09 d8 1e 	bb1wi   r9,27,fff84e48 <_Z19tpmPollForDataAvailR16SpiControlHandle+0xa4>
        {
            SBEM_ERROR(SBEM_FUNC "Timeout polling for dataAvail!");
fff84e10:	3c 60 fd 9a 	lis     r3,-614
            rc = fapi2::FAPI2_RC_FALSE;
fff84e14:	3f c0 04 00 	lis     r30,1024
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
        {
            SBEM_ERROR(SBEM_FUNC "Timeout polling for dataAvail!");
fff84e18:	4b ff b3 61 	bl      fff80178 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fff84e1c:	63 de 00 06 	ori     r30,r30,6
fff84e20:	48 00 00 28 	b       fff84e48 <_Z19tpmPollForDataAvailR16SpiControlHandle+0xa4>
        {
            rc = tpmReadSTSRegValid(handle, status);
            if( (rc != fapi2::FAPI2_RC_SUCCESS) ||
                ((rc == fapi2::FAPI2_RC_SUCCESS) && (status.fields.dataAvail)))
            {
                SBEM_ERROR(SBEM_FUNC "Either tpmReadSTSRegValid failed while with rc 0x%08X or data is available %d", rc, status.fields.dataAvail);
fff84e24:	80 c1 00 08 	lwz     r6,8(r1)
fff84e28:	3c 60 ef b0 	lis     r3,-4176
fff84e2c:	60 63 00 02 	ori     r3,r3,2
fff84e30:	7f e5 fb 78 	mr      r5,r31
fff84e34:	54 c6 27 fe 	rlwinm  r6,r6,4,31,31
fff84e38:	38 e0 00 00 	li      r7,0
fff84e3c:	39 00 00 00 	li      r8,0
fff84e40:	4b ff e2 25 	bl      fff83064 <pk_trace_big>
                SBEM_ERROR(SBEM_FUNC "Polling loop within tpmReadSTSRegValid timed out");
                rc = fapi2::FAPI2_RC_SUCCESS;
            }
            fapi2::delay(1000, 1000);
        }
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (!status.fields.dataAvail))
fff84e44:	06 df 07 e0 	bwz     r31,fff84e04 <_Z19tpmPollForDataAvailR16SpiControlHandle+0x60>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff84e48:	80 01 00 2c 	lwz     r0,44(r1)
fff84e4c:	7f c3 f3 78 	mr      r3,r30
fff84e50:	7c 08 03 a6 	mtlr    r0
fff84e54:	17 81 00 18 	lvd     d28,24(r1)
fff84e58:	17 c1 00 20 	lvd     d30,32(r1)
fff84e5c:	38 21 00 28 	addi    r1,r1,40
fff84e60:	4e 80 00 20 	blr

fff84e64 <_Z11tpmReadFifoR16SpiControlHandlePvRm>:

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fff84e64:	94 21 ff c0 	stwu    r1,-64(r1)
fff84e68:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fff84e6c:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fff84e70:	1b 81 00 30 	stvd    d28,48(r1)
fff84e74:	90 01 00 44 	stw     r0,68(r1)
fff84e78:	1b c1 00 38 	stvd    d30,56(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fff84e7c:	b1 21 00 08 	sth     r9,8(r1)
    bool dataAvail = false;
fff84e80:	99 21 00 0a 	stb     r9,10(r1)
    bool firstRead = true;
fff84e84:	39 40 00 01 	li      r10,1
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
fff84e88:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fff84e8c:	90 61 00 1c 	stw     r3,28(r1)
fff84e90:	90 81 00 2c 	stw     r4,44(r1)
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
fff84e94:	83 a5 00 00 	lwz     r29,0(r5)
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
fff84e98:	91 21 00 18 	stw     r9,24(r1)
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)o_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    bool dataAvail = false;
    bool firstRead = true;
fff84e9c:	19 21 00 20 	stvd    d9,32(r1)
}

fapi2::ReturnCode tpmReadFifo(SpiControlHandle &handle,
                              void * o_buffer,
                              uint32_t & io_buflen)
{
fff84ea0:	7c bc 2b 78 	mr      r28,r5
    #define SBEM_FUNC " tpmReadFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
fff84ea4:	3b c0 00 00 	li      r30,0
        // all command responses are at least 10 bytes of data
        // 2 byte tag + 4 byte response size + 4 byte response code
        const uint32_t MIN_COMMAND_RESPONSE_SIZE = 10;

        // Verify the TPM has data waiting for us
        rc = tpmPollForDataAvail(handle);
fff84ea8:	80 61 00 1c 	lwz     r3,28(r1)
fff84eac:	4b ff fe f9 	bl      fff84da4 <_Z19tpmPollForDataAvailR16SpiControlHandle>
fff84eb0:	7c 7f 1b 78 	mr      r31,r3
        if(rc != fapi2::FAPI2_RC_SUCCESS)
fff84eb4:	06 c3 00 06 	bwz     r3,fff84ec0 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x5c>
        {
            SBEM_ERROR(SBEM_FUNC "tpmPollForDataAvail failed with rc 0x%08X", rc);
fff84eb8:	3c 60 be 2a 	lis     r3,-16854
fff84ebc:	48 00 00 d4 	b       fff84f90 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x12c>
            break;
        }

        // Read burst count.
        rc = tpmReadBurstCount(handle, burstCount);
fff84ec0:	80 61 00 1c 	lwz     r3,28(r1)
fff84ec4:	38 81 00 08 	addi    r4,r1,8
fff84ec8:	4b ff fd f1 	bl      fff84cb8 <_Z17tpmReadBurstCountR16SpiControlHandleRt>
        if(rc != fapi2::FAPI2_RC_SUCCESS )
fff84ecc:	06 c3 00 08 	bwz     r3,fff84edc <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x78>
fff84ed0:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
fff84ed4:	3c 60 06 7a 	lis     r3,1658
fff84ed8:	48 00 00 b8 	b       fff84f90 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x12c>
            break;
        }
        else if(burstCount == 0)
fff84edc:	a3 e1 00 08 	lhz     r31,8(r1)
fff84ee0:	06 5f 00 20 	bwnz    r31,fff84f20 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xbc>
        {
            fapi2::delay(1000, 1000);
fff84ee4:	38 60 00 00 	li      r3,0
fff84ee8:	38 80 03 e8 	li      r4,1000
fff84eec:	38 a0 00 00 	li      r5,0
fff84ef0:	38 c0 03 e8 	li      r6,1000
fff84ef4:	38 e0 00 00 	li      r7,0
fff84ef8:	48 00 15 15 	bl      fff8640c <_ZN5fapi25delayEyyb>
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
    do
fff84efc:	3d 20 00 0b 	lis     r9,11
            break;
        }
        else if(burstCount == 0)
        {
            fapi2::delay(1000, 1000);
            delay ++;
fff84f00:	3b de 00 01 	addi    r30,r30,1
    bool dataAvail = false;
    bool firstRead = true;
    uint16_t dataLen = 0;
    uint32_t responseSize = 0;
    uint32_t dataLeft = io_buflen;
    do
fff84f04:	61 29 71 af 	ori     r9,r9,29103
fff84f08:	05 3e 4f d0 	cmplwble r30,r9,fff84ea8 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x44>
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
        {
            SBEM_INFO(SBEM_FUNC "tpmReadFifo: timeout");
fff84f0c:	3c 60 14 b0 	lis     r3,5296
            rc = fapi2::FAPI2_RC_FALSE;
fff84f10:	3f e0 04 00 	lis     r31,1024
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
        {
            SBEM_INFO(SBEM_FUNC "tpmReadFifo: timeout");
fff84f14:	4b ff b2 65 	bl      fff80178 <pk_trace_tiny>
            rc = fapi2::FAPI2_RC_FALSE;
fff84f18:	63 ff 00 06 	ori     r31,r31,6
            break;
fff84f1c:	48 00 01 a8 	b       fff850c4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
            fapi2::delay(1000, 1000);
            delay ++;
            continue;
        }
        // Read some data.
        if (firstRead)
fff84f20:	81 41 00 24 	lwz     r10,36(r1)
fff84f24:	06 4a 00 08 	bwnz    r10,fff84f34 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd0>
        {
            dataLen = MIN_COMMAND_RESPONSE_SIZE;
        }
        else if (burstCount < dataLeft)
fff84f28:	05 9f e8 08 	cmplwblt r31,r29,fff84f38 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd4>
        {
            dataLen = burstCount;
        }
        else
        {
            dataLen = dataLeft;
fff84f2c:	57 bf 04 3e 	clrlwi  r31,r29,16
fff84f30:	48 00 00 08 	b       fff84f38 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xd4>
            continue;
        }
        // Read some data.
        if (firstRead)
        {
            dataLen = MIN_COMMAND_RESPONSE_SIZE;
fff84f34:	3b e0 00 0a 	li      r31,10
        else
        {
            dataLen = dataLeft;
        }
        // Check for a buffer overflow
        if (curByte + dataLen > io_buflen)
fff84f38:	81 21 00 20 	lwz     r9,32(r1)
fff84f3c:	81 5c 00 00 	lwz     r10,0(r28)
fff84f40:	7d 3f 4a 14 	add     r9,r31,r9
fff84f44:	91 21 00 28 	stw     r9,40(r1)
fff84f48:	05 29 50 08 	cmplwble r9,r10,fff84f58 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0xf4>
        {
            // TPM is expecting more data even though we think we are done
            SBEM_INFO(SBEM_FUNC "TPM is expecting more data even though we think we are done");
fff84f4c:	3c 60 68 9e 	lis     r3,26782
fff84f50:	4b ff b2 29 	bl      fff80178 <pk_trace_tiny>
fff84f54:	48 00 01 1c 	b       fff85070 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x20c>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }

        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fff84f58:	81 41 00 2c 	lwz     r10,44(r1)
fff84f5c:	81 21 00 20 	lwz     r9,32(r1)
        SBEM_INFO(SBEM_FUNC " Read %d byte from FIFO", dataLen);
fff84f60:	67 e3 74 49 	oris    r3,r31,29769
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }

        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fff84f64:	7f ca 4a 14 	add     r30,r10,r9
        SBEM_INFO(SBEM_FUNC " Read %d byte from FIFO", dataLen);
fff84f68:	4b ff b2 11 	bl      fff80178 <pk_trace_tiny>
        uint32_t tpmLocality = 0;               // TPM locality (0-4)
        uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
        rc = spi_tpm_read_secure(handle, tpmLocality, offsetAddr, dataLen, curBytePtr);
fff84f6c:	80 61 00 1c 	lwz     r3,28(r1)
fff84f70:	38 80 00 00 	li      r4,0
fff84f74:	38 a0 00 24 	li      r5,36
fff84f78:	57 e6 06 3e 	clrlwi  r6,r31,24
fff84f7c:	7f c7 f3 78 	mr      r7,r30
fff84f80:	4b ff f1 ed 	bl      fff8416c <spi_tpm_read_secure>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff84f84:	06 c3 00 14 	bwz     r3,fff84fac <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x148>
fff84f88:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_read_secure failed while reading data from FIFO with rc 0x%08X", rc);
fff84f8c:	3c 60 09 94 	lis     r3,2452
fff84f90:	60 63 00 01 	ori     r3,r3,1
fff84f94:	7f e5 fb 78 	mr      r5,r31
fff84f98:	38 c0 00 00 	li      r6,0
fff84f9c:	38 e0 00 00 	li      r7,0
fff84fa0:	39 00 00 00 	li      r8,0
fff84fa4:	4b ff e0 c1 	bl      fff83064 <pk_trace_big>
            break;
fff84fa8:	48 00 00 d0 	b       fff85078 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x214>
        }
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
fff84fac:	67 e3 90 17 	oris    r3,r31,36887
fff84fb0:	4b ff b1 c9 	bl      fff80178 <pk_trace_tiny>
        if (firstRead)
fff84fb4:	81 41 00 24 	lwz     r10,36(r1)
fff84fb8:	06 ca 00 3a 	bwz     r10,fff8502c <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x1c8>
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
fff84fbc:	3d 20 ff f8 	lis     r9,-8
fff84fc0:	80 a9 66 54 	lwz     r5,26196(r9)
fff84fc4:	3c 60 f2 c2 	lis     r3,-3390
fff84fc8:	60 63 00 01 	ori     r3,r3,1
fff84fcc:	38 c0 00 00 	li      r6,0
fff84fd0:	38 e0 00 00 	li      r7,0
fff84fd4:	39 00 00 00 	li      r8,0
fff84fd8:	4b ff e0 8d 	bl      fff83064 <pk_trace_big>
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fff84fdc:	89 5e 00 02 	lbz     r10,2(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fff84fe0:	3c 60 f2 c2 	lis     r3,-3390
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fff84fe4:	55 48 c0 0e 	rlwinm  r8,r10,24,0,7
fff84fe8:	89 5e 00 03 	lbz     r10,3(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fff84fec:	60 63 00 02 	ori     r3,r3,2
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fff84ff0:	55 4a 80 1e 	rlwinm  r10,r10,16,0,15
fff84ff4:	7d 0a 53 78 	or      r10,r8,r10
fff84ff8:	89 1e 00 05 	lbz     r8,5(r30)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fff84ffc:	38 e0 00 00 	li      r7,0
fff85000:	7d 4a 43 78 	or      r10,r10,r8
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fff85004:	89 1e 00 04 	lbz     r8,4(r30)
fff85008:	55 08 40 2e 	rlwinm  r8,r8,8,0,23
fff8500c:	7d 48 43 78 	or      r8,r10,r8
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fff85010:	3d 40 ff f8 	lis     r10,-8
fff85014:	80 aa 66 58 	lwz     r5,26200(r10)
        SBEM_INFO(SBEM_FUNC "Read %d byte", dataLen);
        if (firstRead)
        {
            SBEM_INFO(SBEM_FUNC, "Inside firstRead" );
            //responseSize = *(reinterpret_cast<uint32_t*>((curBytePtr + 2)));
            responseSize = curBytePtr[2] << 24 | curBytePtr[3] << 16 | curBytePtr[4] << 8 | curBytePtr[5];
fff85018:	91 01 00 18 	stw     r8,24(r1)
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
fff8501c:	7d 06 43 78 	mr      r6,r8
fff85020:	39 00 00 00 	li      r8,0
fff85024:	4b ff e0 41 	bl      fff83064 <pk_trace_big>
            dataLeft = responseSize;
fff85028:	83 a1 00 18 	lwz     r29,24(r1)
            firstRead = false;
        }
        curByte += dataLen;
        dataLeft -= dataLen;

        rc = tpmIsDataAvail(handle, dataAvail);
fff8502c:	80 61 00 1c 	lwz     r3,28(r1)
fff85030:	38 81 00 0a 	addi    r4,r1,10
fff85034:	4b ff f9 a1 	bl      fff849d4 <_Z14tpmIsDataAvailR16SpiControlHandleRb>
            SBEM_INFO(SBEM_FUNC, "tpmReadFifo: total size = 0x%08X", responseSize );
            dataLeft = responseSize;
            firstRead = false;
        }
        curByte += dataLen;
        dataLeft -= dataLen;
fff85038:	7f bf e8 50 	subf    r29,r31,r29
fff8503c:	88 c1 00 0a 	lbz     r6,10(r1)

        rc = tpmIsDataAvail(handle, dataAvail);
fff85040:	7c 7f 1b 78 	mr      r31,r3
        if((rc != fapi2::FAPI2_RC_SUCCESS) || ((rc == fapi2::FAPI2_RC_SUCCESS) && (!dataAvail)) )
fff85044:	06 43 00 20 	bwnz    r3,fff85084 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x220>
fff85048:	54 ca 06 3e 	clrlwi  r10,r6,24
fff8504c:	06 ca 00 1c 	bwz     r10,fff85084 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x220>
        {
            SBEM_ERROR(SBEM_FUNC "Either tpmIsDataAvail failed with rc 0x%08X or dataAvail is %d", rc, dataAvail);
            break;
        }
        if ((dataLeft == 0) && dataAvail)
fff85050:	06 5d 00 30 	bwnz    r29,fff850b0 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x24c>
        {
            // Either the available STS is wrong or
            // responseSize in firstRead response was wrong
            SBEM_INFO(SBEM_FUNC "data should not be available anymore"
fff85054:	3c 60 14 81 	lis     r3,5249
fff85058:	80 a1 00 18 	lwz     r5,24(r1)
fff8505c:	60 63 00 01 	ori     r3,r3,1
fff85060:	38 c0 00 00 	li      r6,0
fff85064:	38 e0 00 00 	li      r7,0
fff85068:	39 00 00 00 	li      r8,0
fff8506c:	4b ff df f9 	bl      fff83064 <pk_trace_big>
                                " (response size in response: 0x%04X)", responseSize);
            rc = fapi2::FAPI2_RC_FALSE;
fff85070:	3f e0 04 00 	lis     r31,1024
fff85074:	63 ff 00 06 	ori     r31,r31,6
            // We read it properly tell the caller the result length
            io_buflen = curByte;
        }
        else
        {
            io_buflen = 0;
fff85078:	39 40 00 00 	li      r10,0
fff8507c:	91 5c 00 00 	stw     r10,0(r28)
fff85080:	48 00 00 44 	b       fff850c4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
        dataLeft -= dataLen;

        rc = tpmIsDataAvail(handle, dataAvail);
        if((rc != fapi2::FAPI2_RC_SUCCESS) || ((rc == fapi2::FAPI2_RC_SUCCESS) && (!dataAvail)) )
        {
            SBEM_ERROR(SBEM_FUNC "Either tpmIsDataAvail failed with rc 0x%08X or dataAvail is %d", rc, dataAvail);
fff85084:	3c 60 9d 05 	lis     r3,-25339
fff85088:	60 63 00 02 	ori     r3,r3,2
fff8508c:	7f e5 fb 78 	mr      r5,r31
fff85090:	54 c6 06 3e 	clrlwi  r6,r6,24
fff85094:	38 e0 00 00 	li      r7,0
fff85098:	39 00 00 00 	li      r8,0
fff8509c:	4b ff df c9 	bl      fff83064 <pk_trace_big>
            break;
        }
    }while(delay < TPM_TIMEOUT_D);
    do
    {
        if (!rc && delay >= TPM_TIMEOUT_D)
fff850a0:	06 5f 07 ec 	bwnz    r31,fff85078 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x214>
            break;
        }
        if (rc == fapi2::FAPI2_RC_SUCCESS)
        {
            // We read it properly tell the caller the result length
            io_buflen = curByte;
fff850a4:	81 21 00 28 	lwz     r9,40(r1)
fff850a8:	91 3c 00 00 	stw     r9,0(r28)
fff850ac:	48 00 00 18 	b       fff850c4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x260>
fff850b0:	81 41 00 28 	lwz     r10,40(r1)
fff850b4:	39 20 00 00 	li      r9,0
fff850b8:	91 41 00 20 	stw     r10,32(r1)
fff850bc:	91 21 00 24 	stw     r9,36(r1)
fff850c0:	4b ff fd e4 	b       fff84ea4 <_Z11tpmReadFifoR16SpiControlHandlePvRm+0x40>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff850c4:	80 01 00 44 	lwz     r0,68(r1)
fff850c8:	7f e3 fb 78 	mr      r3,r31
fff850cc:	7c 08 03 a6 	mtlr    r0
fff850d0:	17 81 00 30 	lvd     d28,48(r1)
fff850d4:	17 c1 00 38 	lvd     d30,56(r1)
fff850d8:	38 21 00 40 	addi    r1,r1,64
fff850dc:	4e 80 00 20 	blr

fff850e0 <_Z12tpmWriteFifoR16SpiControlHandlePvm>:

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fff850e0:	94 21 ff d0 	stwu    r1,-48(r1)
fff850e4:	7c 08 02 a6 	mflr    r0
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fff850e8:	39 20 00 00 	li      r9,0
}

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fff850ec:	90 01 00 34 	stw     r0,52(r1)
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
fff850f0:	b1 21 00 08 	sth     r9,8(r1)
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
fff850f4:	99 21 00 0a 	stb     r9,10(r1)
}

fapi2::ReturnCode tpmWriteFifo(SpiControlHandle &handle,
                               void * i_buffer,
                               uint32_t i_buflen)
{
fff850f8:	1b 81 00 20 	stvd    d28,32(r1)
fff850fc:	1b c1 00 28 	stvd    d30,40(r1)
fff85100:	7c 7d 1b 78 	mr      r29,r3
fff85104:	7c 9f 23 78 	mr      r31,r4
    uint32_t delay = 0;
    uint32_t curByte = 0;
    uint8_t* bytePtr = (uint8_t*)i_buffer;
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
fff85108:	3b 85 ff ff 	addi    r28,r5,-1
{
    #define SBEM_FUNC " tpmWriteFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
    uint32_t curByte = 0;
fff8510c:	3b c0 00 00 	li      r30,0
                               uint32_t i_buflen)
{
    #define SBEM_FUNC " tpmWriteFifo "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    uint32_t delay = 0;
fff85110:	39 20 00 00 	li      r9,0
    uint32_t tx_len = 0;
    bool expect = false;
    do
    {
        // Read burst count.
        rc = tpmReadBurstCount(handle, burstCount);
fff85114:	7f a3 eb 78 	mr      r3,r29
fff85118:	38 81 00 08 	addi    r4,r1,8
fff8511c:	91 21 00 1c 	stw     r9,28(r1)
fff85120:	4b ff fb 99 	bl      fff84cb8 <_Z17tpmReadBurstCountR16SpiControlHandleRt>
        if(rc != fapi2::FAPI2_RC_SUCCESS )
fff85124:	81 21 00 1c 	lwz     r9,28(r1)
fff85128:	06 43 00 a6 	bwnz    r3,fff85274 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x194>
        {
            SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
            break;
        }
        else if(burstCount == 0)
fff8512c:	a1 41 00 08 	lhz     r10,8(r1)
fff85130:	06 4a 00 1c 	bwnz    r10,fff85168 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x88>
        {
            fapi2::delay(1000, 1000);
fff85134:	38 60 00 00 	li      r3,0
fff85138:	38 80 03 e8 	li      r4,1000
fff8513c:	38 a0 00 00 	li      r5,0
fff85140:	38 c0 03 e8 	li      r6,1000
fff85144:	38 e0 00 00 	li      r7,0
fff85148:	91 21 00 1c 	stw     r9,28(r1)
fff8514c:	48 00 12 c1 	bl      fff8640c <_ZN5fapi25delayEyyb>
            delay ++;
fff85150:	81 21 00 1c 	lwz     r9,28(r1)
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
    do
fff85154:	3d 40 00 0b 	lis     r10,11
            break;
        }
        else if(burstCount == 0)
        {
            fapi2::delay(1000, 1000);
            delay ++;
fff85158:	39 29 00 01 	addi    r9,r9,1
    uint8_t* curBytePtr = nullptr;
    uint16_t burstCount = 0;
    uint32_t length = i_buflen - 1;
    uint32_t tx_len = 0;
    bool expect = false;
    do
fff8515c:	61 4a 71 af 	ori     r10,r10,29103
fff85160:	05 29 57 da 	cmplwble r9,r10,fff85114 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x34>
fff85164:	48 00 01 bc 	b       fff85320 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x240>
            delay ++;
            continue;
        }

        // Single operations are limited to TPM SPI transmit size
        if (burstCount > TPM_MAX_SPI_TRANSMIT_SIZE)
fff85168:	28 0a 00 40 	cmplwi  r10,64
fff8516c:	40 81 00 0c 	ble     fff85178 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x98>
        {
            burstCount = TPM_MAX_SPI_TRANSMIT_SIZE;
fff85170:	39 20 00 40 	li      r9,64
fff85174:	b1 21 00 08 	sth     r9,8(r1)
        }

        // Limit TPM writes to 2 bytes and write information in chunks if
        // necessary
        if(burstCount > 2)
fff85178:	a1 21 00 08 	lhz     r9,8(r1)
fff8517c:	28 09 00 02 	cmplwi  r9,2
fff85180:	40 81 00 0c 	ble     fff8518c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0xac>
        {
            burstCount = 2;
fff85184:	39 20 00 02 	li      r9,2
fff85188:	b1 21 00 08 	sth     r9,8(r1)
        }

        //Send in some data
        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
        tx_len = (curByte + burstCount > length ?
fff8518c:	a1 21 00 08 	lhz     r9,8(r1)
            burstCount = 2;
        }

        //Send in some data
        delay = 0;
        curBytePtr = &(bytePtr[curByte]);
fff85190:	7d 5f f2 14 	add     r10,r31,r30
        tx_len = (curByte + burstCount > length ?
fff85194:	7d 1e 4a 14 	add     r8,r30,r9
                  (length - curByte) :
                  burstCount);
fff85198:	05 28 e0 04 	cmplwble r8,r28,fff851a0 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0xc0>
fff8519c:	7d 3e e0 50 	subf    r9,r30,r28
        SBEM_INFO(SBEM_FUNC "tpmWriteFifo: send some data %d tx_len", tx_len);
fff851a0:	3c 60 c4 95 	lis     r3,-15211
fff851a4:	7d 25 4b 78 	mr      r5,r9
fff851a8:	60 63 00 01 	ori     r3,r3,1
fff851ac:	38 c0 00 00 	li      r6,0
fff851b0:	38 e0 00 00 	li      r7,0
fff851b4:	39 00 00 00 	li      r8,0
fff851b8:	91 21 00 1c 	stw     r9,28(r1)
fff851bc:	91 41 00 18 	stw     r10,24(r1)
fff851c0:	4b ff de a5 	bl      fff83064 <pk_trace_big>
        uint32_t tpmLocality = 0;               // TPM locality (0-4)
        uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
        rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
fff851c4:	81 21 00 1c 	lwz     r9,28(r1)
fff851c8:	81 41 00 18 	lwz     r10,24(r1)
fff851cc:	55 26 06 3e 	clrlwi  r6,r9,24
fff851d0:	7f a3 eb 78 	mr      r3,r29
fff851d4:	38 80 00 00 	li      r4,0
fff851d8:	38 a0 00 24 	li      r5,36
fff851dc:	7d 47 53 78 	mr      r7,r10
fff851e0:	4b ff f3 21 	bl      fff84500 <spi_tpm_write_with_wait>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff851e4:	81 21 00 1c 	lwz     r9,28(r1)
fff851e8:	06 c3 00 14 	bwz     r3,fff85210 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x130>
fff851ec:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed with rc 0x%08X", rc);
fff851f0:	3c 60 4c bc 	lis     r3,19644
fff851f4:	60 63 00 01 	ori     r3,r3,1
fff851f8:	7f e5 fb 78 	mr      r5,r31
fff851fc:	38 c0 00 00 	li      r6,0
fff85200:	38 e0 00 00 	li      r7,0
fff85204:	39 00 00 00 	li      r8,0
fff85208:	4b ff de 5d 	bl      fff83064 <pk_trace_big>
            break;
fff8520c:	48 00 01 44 	b       fff85350 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x270>
        }
        curByte += tx_len;

        // TPM should be expecting more data from the command
        SBEM_INFO(SBEM_FUNC "TPM should be expecting more data from the command");
fff85210:	3c 60 bd ac 	lis     r3,-16980
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
            SBEM_ERROR(SBEM_FUNC "spi_tpm_write_with_wait failed with rc 0x%08X", rc);
            break;
        }
        curByte += tx_len;
fff85214:	7f de 4a 14 	add     r30,r30,r9

        // TPM should be expecting more data from the command
        SBEM_INFO(SBEM_FUNC "TPM should be expecting more data from the command");
fff85218:	4b ff af 61 	bl      fff80178 <pk_trace_tiny>
        rc = tpmIsExpecting(handle, expect);
fff8521c:	7f a3 eb 78 	mr      r3,r29
fff85220:	38 81 00 0a 	addi    r4,r1,10
fff85224:	4b ff f7 15 	bl      fff84938 <_Z14tpmIsExpectingR16SpiControlHandleRb>
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85228:	06 c3 00 08 	bwz     r3,fff85238 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x158>
fff8522c:	7c 7f 1b 78 	mr      r31,r3
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsExpecting failed with rc 0x%08X", rc);
fff85230:	3c 60 7f d2 	lis     r3,32722
fff85234:	4b ff ff c0 	b       fff851f4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x114>
            break;
        }
        if(( rc == fapi2::FAPI2_RC_SUCCESS) && (!expect))
fff85238:	89 21 00 0a 	lbz     r9,10(r1)
fff8523c:	06 49 00 06 	bwnz    r9,fff85248 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x168>
        {
            SBEM_ERROR(SBEM_FUNC "TPM is not expecting any further data, expect is %d", expect);
fff85240:	3c 60 53 9a 	lis     r3,21402
fff85244:	48 00 00 e0 	b       fff85324 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x244>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }
        // Everything but the last byte sent?
        SBEM_INFO(SBEM_FUNC "Everything but the last byte sent");
fff85248:	3c 60 11 8f 	lis     r3,4495
fff8524c:	4b ff af 2d 	bl      fff80178 <pk_trace_tiny>
        if (curByte >= length)
fff85250:	05 9e e7 60 	cmplwblt r30,r28,fff85110 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x30>

    if((rc ==fapi2::FAPI2_RC_SUCCESS) && (delay < TPM_TIMEOUT_D))
    {
        delay = 0;
        // Send the final byte.
        SBEM_INFO(SBEM_FUNC "Send the final byte");
fff85254:	3c 60 a2 2c 	lis     r3,-24020
fff85258:	3f 80 00 0b 	lis     r28,11
fff8525c:	4b ff af 1d 	bl      fff80178 <pk_trace_tiny>
fff85260:	63 9c 71 b0 	ori     r28,r28,29104
        do
        {
            // Read burst count.
            rc = tpmReadBurstCount(handle, burstCount);
fff85264:	7f a3 eb 78 	mr      r3,r29
fff85268:	38 81 00 08 	addi    r4,r1,8
fff8526c:	4b ff fa 4d 	bl      fff84cb8 <_Z17tpmReadBurstCountR16SpiControlHandleRt>
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85270:	06 c3 00 08 	bwz     r3,fff85280 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x1a0>
fff85274:	7c 7f 1b 78 	mr      r31,r3
            {
                SBEM_ERROR(SBEM_FUNC "tpmReadBurstCount failed with rc 0x%08X", rc);
fff85278:	3c 60 1c 87 	lis     r3,7303
fff8527c:	4b ff ff 78 	b       fff851f4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x114>
                break;
            }
            else if(burstCount == 0)
fff85280:	a1 21 00 08 	lhz     r9,8(r1)
fff85284:	06 49 00 18 	bwnz    r9,fff852b4 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x1d4>
            {
                fapi2::delay(1000, 1000);
fff85288:	38 60 00 00 	li      r3,0
fff8528c:	38 80 03 e8 	li      r4,1000
fff85290:	38 a0 00 00 	li      r5,0
fff85294:	38 c0 03 e8 	li      r6,1000
fff85298:	38 e0 00 00 	li      r7,0
fff8529c:	48 00 11 71 	bl      fff8640c <_ZN5fapi25delayEyyb>
    if((rc ==fapi2::FAPI2_RC_SUCCESS) && (delay < TPM_TIMEOUT_D))
    {
        delay = 0;
        // Send the final byte.
        SBEM_INFO(SBEM_FUNC "Send the final byte");
        do
fff852a0:	37 9c ff ff 	addic.  r28,r28,-1
fff852a4:	40 82 ff c0 	bne     fff85264 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x184>
fff852a8:	3d 20 00 0b 	lis     r9,11
fff852ac:	61 29 71 b0 	ori     r9,r9,29104
fff852b0:	48 00 00 38 	b       fff852e8 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x208>
                continue;
            }
            // Send in final byte
            delay = 0;
            curBytePtr = &(bytePtr[curByte]);
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
fff852b4:	7c 7f f0 ae 	lbzx    r3,r31,r30
                delay += 1;
                continue;
            }
            // Send in final byte
            delay = 0;
            curBytePtr = &(bytePtr[curByte]);
fff852b8:	7f 9f f2 14 	add     r28,r31,r30
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
fff852bc:	64 63 38 30 	oris    r3,r3,14384
fff852c0:	4b ff ae b9 	bl      fff80178 <pk_trace_tiny>
            uint32_t tpmLocality = 0;               // TPM locality (0-4)
            uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
            tx_len = 1;
            rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
fff852c4:	7f a3 eb 78 	mr      r3,r29
fff852c8:	38 80 00 00 	li      r4,0
fff852cc:	38 a0 00 24 	li      r5,36
fff852d0:	38 c0 00 01 	li      r6,1
fff852d4:	7f 87 e3 78 	mr      r7,r28
fff852d8:	4b ff f2 29 	bl      fff84500 <spi_tpm_write_with_wait>
fff852dc:	7c 7f 1b 78 	mr      r31,r3
                fapi2::delay(1000, 1000);
                delay += 1;
                continue;
            }
            // Send in final byte
            delay = 0;
fff852e0:	39 20 00 00 	li      r9,0
            SBEM_INFO(SBEM_FUNC "tpmWriteReg final byte, 0x%02X", *curBytePtr);
            uint32_t tpmLocality = 0;               // TPM locality (0-4)
            uint32_t offsetAddr = TPM_DATA_FIFO_0;  // Relative address to read from TPM.
            tx_len = 1;
            rc = spi_tpm_write_with_wait(handle, tpmLocality, offsetAddr, tx_len, curBytePtr);
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff852e4:	06 43 07 86 	bwnz    r3,fff851f0 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x110>
            break;
        }while(delay < TPM_TIMEOUT_D);
    }
    do
    {
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (delay >= TPM_TIMEOUT_D))
fff852e8:	3d 40 00 0b 	lis     r10,11
fff852ec:	61 4a 71 af 	ori     r10,r10,29103
fff852f0:	05 a9 50 18 	cmplwbgt r9,r10,fff85320 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x240>
            rc = fapi2::FAPI2_RC_FALSE;
            break;
        }
        if(rc == fapi2::FAPI2_RC_SUCCESS)
        {
            SBEM_INFO(SBEM_FUNC "Check if TPM is expecting more data.");
fff852f4:	3c 60 8c 4f 	lis     r3,-29617
fff852f8:	4b ff ae 81 	bl      fff80178 <pk_trace_tiny>
            rc = tpmIsExpecting(handle, expect);
fff852fc:	7f a3 eb 78 	mr      r3,r29
fff85300:	38 81 00 0a 	addi    r4,r1,10
fff85304:	4b ff f6 35 	bl      fff84938 <_Z14tpmIsExpectingR16SpiControlHandleRb>
fff85308:	7c 7f 1b 78 	mr      r31,r3
fff8530c:	88 c1 00 0a 	lbz     r6,10(r1)
            if(( rc != fapi2::FAPI2_RC_SUCCESS) || (expect))
fff85310:	06 43 00 0e 	bwnz    r3,fff8532c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x24c>
fff85314:	54 c9 06 3e 	clrlwi  r9,r6,24
fff85318:	06 49 00 0a 	bwnz    r9,fff8532c <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x24c>
fff8531c:	48 00 00 34 	b       fff85350 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x270>
    }
    do
    {
        if((rc == fapi2::FAPI2_RC_SUCCESS) && (delay >= TPM_TIMEOUT_D))
        {
            SBE_ERROR(SBE_FUNC "TPM has timed out");
fff85320:	3c 60 a9 3a 	lis     r3,-22214
fff85324:	4b ff ae 55 	bl      fff80178 <pk_trace_tiny>
fff85328:	48 00 00 20 	b       fff85348 <_Z12tpmWriteFifoR16SpiControlHandlePvm+0x268>
        {
            SBEM_INFO(SBEM_FUNC "Check if TPM is expecting more data.");
            rc = tpmIsExpecting(handle, expect);
            if(( rc != fapi2::FAPI2_RC_SUCCESS) || (expect))
            {
                SBEM_ERROR(SBEM_FUNC "tpmIsExpecting failed or expecting more data with rc 0x%08X %d", rc, expect);
fff8532c:	3c 60 e5 85 	lis     r3,-6779
fff85330:	60 63 00 02 	ori     r3,r3,2
fff85334:	7f e5 fb 78 	mr      r5,r31
fff85338:	54 c6 06 3e 	clrlwi  r6,r6,24
fff8533c:	38 e0 00 00 	li      r7,0
fff85340:	39 00 00 00 	li      r8,0
fff85344:	4b ff dd 21 	bl      fff83064 <pk_trace_big>
                rc = fapi2::FAPI2_RC_FALSE;
fff85348:	3f e0 04 00 	lis     r31,1024
fff8534c:	63 ff 00 06 	ori     r31,r31,6
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff85350:	80 01 00 34 	lwz     r0,52(r1)
fff85354:	7f e3 fb 78 	mr      r3,r31
fff85358:	7c 08 03 a6 	mtlr    r0
fff8535c:	17 81 00 20 	lvd     d28,32(r1)
fff85360:	17 c1 00 28 	lvd     d30,40(r1)
fff85364:	38 21 00 30 	addi    r1,r1,48
fff85368:	4e 80 00 20 	blr

fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>:

fapi2::ReturnCode tpmTransmit( SpiControlHandle &handle,
                         void * io_buffer,
                         uint32_t & io_buflen,
                         uint32_t i_commandlen)
{
fff8536c:	94 21 ff d0 	stwu    r1,-48(r1)
fff85370:	7c 08 02 a6 	mflr    r0
fff85374:	1b 81 00 20 	stvd    d28,32(r1)
fff85378:	1b c1 00 28 	stvd    d30,40(r1)
fff8537c:	90 01 00 34 	stw     r0,52(r1)
fff85380:	7c 7f 1b 78 	mr      r31,r3
fff85384:	7c be 2b 78 	mr      r30,r5
    #define SBEM_FUNC " tpmTransmit "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    SBEM_INFO(SBEM_FUNC "TPM TRANSMIT START buflen 0x%08X and cmdlen 0x%08X",
                         io_buflen, i_commandlen);
fff85388:	3c 60 09 23 	lis     r3,2339
fff8538c:	80 a5 00 00 	lwz     r5,0(r5)
fff85390:	60 63 00 02 	ori     r3,r3,2
fff85394:	38 e0 00 00 	li      r7,0
fff85398:	39 00 00 00 	li      r8,0

fapi2::ReturnCode tpmTransmit( SpiControlHandle &handle,
                         void * io_buffer,
                         uint32_t & io_buflen,
                         uint32_t i_commandlen)
{
fff8539c:	7c 9d 23 78 	mr      r29,r4
fff853a0:	90 c1 00 18 	stw     r6,24(r1)
    #define SBEM_FUNC " tpmTransmit "
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    SBEM_INFO(SBEM_FUNC "TPM TRANSMIT START buflen 0x%08X and cmdlen 0x%08X",
                         io_buflen, i_commandlen);
fff853a4:	4b ff dc c1 	bl      fff83064 <pk_trace_big>
    do
    {
        // Verify the TPM is ready to receive our command.
        bool isCmdReady = false;
fff853a8:	7c 24 0b 78 	mr      r4,r1
fff853ac:	39 20 00 00 	li      r9,0
fff853b0:	9d 24 00 08 	stbu    r9,8(r4)
        rc = tpmIsCommandReady(handle, isCmdReady );
fff853b4:	7f e3 fb 78 	mr      r3,r31
fff853b8:	4b ff f6 b9 	bl      fff84a70 <_Z17tpmIsCommandReadyR16SpiControlHandleRb>
fff853bc:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady failed with rc 0x%08X", rc);
fff853c0:	3c 60 f2 f1 	lis     r3,-3343
    do
    {
        // Verify the TPM is ready to receive our command.
        bool isCmdReady = false;
        rc = tpmIsCommandReady(handle, isCmdReady );
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff853c4:	06 5c 00 6c 	bwnz    r28,fff8549c <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
        {
            SBEM_ERROR(SBEM_FUNC "tpmIsCommandReady failed with rc 0x%08X", rc);
            break;
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is %d", isCmdReady);
fff853c8:	88 61 00 08 	lbz     r3,8(r1)
fff853cc:	64 63 d3 e5 	oris    r3,r3,54245
fff853d0:	4b ff ad a9 	bl      fff80178 <pk_trace_tiny>
        if(!isCmdReady)
fff853d4:	89 21 00 08 	lbz     r9,8(r1)
fff853d8:	06 49 00 14 	bwnz    r9,fff85400 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x94>
        {
            // set TPM into command ready state
            rc = tpmWriteCommandReady(handle);
fff853dc:	7f e3 fb 78 	mr      r3,r31
fff853e0:	4b ff f7 29 	bl      fff84b08 <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fff853e4:	7c 7c 1b 78 	mr      r28,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff853e8:	06 43 00 58 	bwnz    r3,fff85498 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x12c>
                SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
                break;
            }

            // Verify the TPM is now ready to receive our command
            rc = tpmPollForCommandReady(handle);
fff853ec:	7f e3 fb 78 	mr      r3,r31
fff853f0:	4b ff f7 81 	bl      fff84b70 <_Z22tpmPollForCommandReadyR16SpiControlHandle>
fff853f4:	7c 7c 1b 78 	mr      r28,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
            {
                SBEM_ERROR(SBEM_FUNC "tpmPollForCommandReady failed with rc 0x%08X", rc);
fff853f8:	3c 60 a7 4d 	lis     r3,-22707
                break;
            }

            // Verify the TPM is now ready to receive our command
            rc = tpmPollForCommandReady(handle);
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff853fc:	06 5c 00 50 	bwnz    r28,fff8549c <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
            {
                SBEM_ERROR(SBEM_FUNC "tpmPollForCommandReady failed with rc 0x%08X", rc);
                break;
            }
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is set. Go write the command to FIFO.");
fff85400:	3c 60 e5 ca 	lis     r3,-6710
fff85404:	4b ff ad 75 	bl      fff80178 <pk_trace_tiny>

        // Write the command into the TPM FIFO
        rc = tpmWriteFifo(handle, io_buffer, i_commandlen);
fff85408:	80 a1 00 18 	lwz     r5,24(r1)
fff8540c:	7f e3 fb 78 	mr      r3,r31
fff85410:	7f a4 eb 78 	mr      r4,r29
fff85414:	4b ff fc cd 	bl      fff850e0 <_Z12tpmWriteFifoR16SpiControlHandlePvm>
fff85418:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteFifo failed with rc 0x%08X", rc);
fff8541c:	3c 60 da a6 	lis     r3,-9562
        }
        SBEM_INFO(SBEM_FUNC "isCmdReady is set. Go write the command to FIFO.");

        // Write the command into the TPM FIFO
        rc = tpmWriteFifo(handle, io_buffer, i_commandlen);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85420:	06 5c 00 3e 	bwnz    r28,fff8549c <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
             SBEM_ERROR(SBEM_FUNC "tpmWriteFifo failed with rc 0x%08X", rc);
             break;
        }

        // Set the tpmGo bit
        SBEM_INFO(SBEM_FUNC "Set the tpmGo bit");
fff85424:	3c 60 fc e6 	lis     r3,-794
fff85428:	4b ff ad 51 	bl      fff80178 <pk_trace_tiny>
        rc = tpmWriteTpmGo(handle);
fff8542c:	7f e3 fb 78 	mr      r3,r31
fff85430:	4b ff f9 0d 	bl      fff84d3c <_Z13tpmWriteTpmGoR16SpiControlHandle>
fff85434:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteTpmGo failed with rc 0x%08X", rc);
fff85438:	3c 60 80 db 	lis     r3,-32549
        }

        // Set the tpmGo bit
        SBEM_INFO(SBEM_FUNC "Set the tpmGo bit");
        rc = tpmWriteTpmGo(handle);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff8543c:	06 5c 00 30 	bwnz    r28,fff8549c <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
             SBEM_ERROR(SBEM_FUNC "tpmWriteTpmGo failed with rc 0x%08X", rc);
             break;
        }

        // Read the response from the TPM FIFO
        SBEM_INFO(SBEM_FUNC "Read the response from TPM FIFO");
fff85440:	3c 60 cd 3d 	lis     r3,-12995
fff85444:	4b ff ad 35 	bl      fff80178 <pk_trace_tiny>
        rc = tpmReadFifo(handle, io_buffer, io_buflen);
fff85448:	7f e3 fb 78 	mr      r3,r31
fff8544c:	7f a4 eb 78 	mr      r4,r29
fff85450:	7f c5 f3 78 	mr      r5,r30
fff85454:	4b ff fa 11 	bl      fff84e64 <_Z11tpmReadFifoR16SpiControlHandlePvRm>
fff85458:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
        {
             SBEM_ERROR(SBEM_FUNC "tpmReadFifo failed with rc 0x%08X", rc);
fff8545c:	3c 60 3c 7a 	lis     r3,15482
        }

        // Read the response from the TPM FIFO
        SBEM_INFO(SBEM_FUNC "Read the response from TPM FIFO");
        rc = tpmReadFifo(handle, io_buffer, io_buflen);
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85460:	06 5c 00 1e 	bwnz    r28,fff8549c <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x130>
        {
             SBEM_ERROR(SBEM_FUNC "tpmReadFifo failed with rc 0x%08X", rc);
             break;
        }
        SBEM_INFO(SBEM_FUNC "Buffer length after response is 0x%08X", io_buflen);
fff85464:	80 be 00 00 	lwz     r5,0(r30)
fff85468:	3c 60 e0 2d 	lis     r3,-8147
fff8546c:	38 c0 00 00 	li      r6,0
fff85470:	38 e0 00 00 	li      r7,0
fff85474:	39 00 00 00 	li      r8,0
fff85478:	60 63 00 01 	ori     r3,r3,1
fff8547c:	4b ff db e9 	bl      fff83064 <pk_trace_big>

        // Set write command ready.
        SBEM_INFO(SBEM_FUNC "Set write command ready");
fff85480:	3c 60 60 c7 	lis     r3,24775
fff85484:	4b ff ac f5 	bl      fff80178 <pk_trace_tiny>
        rc = tpmWriteCommandReady(handle);
fff85488:	7f e3 fb 78 	mr      r3,r31
fff8548c:	4b ff f6 7d 	bl      fff84b08 <_Z20tpmWriteCommandReadyR16SpiControlHandle>
fff85490:	7c 7c 1b 78 	mr      r28,r3
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85494:	06 c3 00 10 	bwz     r3,fff854b4 <_Z11tpmTransmitR16SpiControlHandlePvRmm+0x148>
        {
             SBEM_ERROR(SBEM_FUNC "tpmWriteCommandReady failed with rc 0x%08X", rc);
fff85498:	3c 60 71 a0 	lis     r3,29088
fff8549c:	60 63 00 01 	ori     r3,r3,1
fff854a0:	7f 85 e3 78 	mr      r5,r28
fff854a4:	38 c0 00 00 	li      r6,0
fff854a8:	38 e0 00 00 	li      r7,0
fff854ac:	39 00 00 00 	li      r8,0
fff854b0:	4b ff db b5 	bl      fff83064 <pk_trace_big>
    }while(0);
    
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff854b4:	80 01 00 34 	lwz     r0,52(r1)
fff854b8:	7f 83 e3 78 	mr      r3,r28
fff854bc:	7c 08 03 a6 	mtlr    r0
fff854c0:	17 81 00 20 	lvd     d28,32(r1)
fff854c4:	17 c1 00 28 	lvd     d30,40(r1)
fff854c8:	38 21 00 30 	addi    r1,r1,48
fff854cc:	4e 80 00 20 	blr

fff854d0 <_Z12tpmExtendPCRmPhm>:
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode tpmExtendPCR(uint32_t pcrNum, uint8_t *hashKey, uint32_t size)
{
fff854d0:	94 21 ff 78 	stwu    r1,-136(r1)
fff854d4:	7c 08 02 a6 	mflr    r0
fff854d8:	1b 81 00 78 	stvd    d28,120(r1)
fff854dc:	1b c1 00 80 	stvd    d30,128(r1)
fff854e0:	90 01 00 8c 	stw     r0,140(r1)
fff854e4:	7c 9d 23 78 	mr      r29,r4
fff854e8:	7c be 2b 78 	mr      r30,r5
fff854ec:	7c 7c 1b 78 	mr      r28,r3
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        // PM2_PCR_Extend
        uint8_t tpmExtendPCR[72] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x01, 0x82, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
fff854f0:	3b e1 00 08 	addi    r31,r1,8
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff854f4:	48 00 0f c9 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff854f8:	39 20 00 04 	li      r9,4
fff854fc:	3d 40 00 0c 	lis     r10,12
fff85500:	61 4a 00 80 	ori     r10,r10,128
fff85504:	90 61 00 50 	stw     r3,80(r1)
fff85508:	99 21 00 54 	stb     r9,84(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        // PM2_PCR_Extend
        uint8_t tpmExtendPCR[72] = {0x80, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x01, 0x82, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
fff8550c:	7f e3 fb 78 	mr      r3,r31
fff85510:	39 20 00 01 	li      r9,1
fff85514:	38 80 00 00 	li      r4,0
fff85518:	38 a0 00 48 	li      r5,72
fff8551c:	b1 21 00 56 	sth     r9,86(r1)
fff85520:	91 41 00 58 	stw     r10,88(r1)
fff85524:	99 21 00 5c 	stb     r9,92(r1)
fff85528:	91 21 00 70 	stw     r9,112(r1)
fff8552c:	4b ff d4 f9 	bl      fff82a24 <memset>
fff85530:	39 40 ff 80 	li      r10,-128
fff85534:	99 41 00 08 	stb     r10,8(r1)
fff85538:	39 40 00 02 	li      r10,2
fff8553c:	81 21 00 70 	lwz     r9,112(r1)
fff85540:	99 41 00 09 	stb     r10,9(r1)
fff85544:	39 40 00 41 	li      r10,65
fff85548:	99 41 00 0d 	stb     r10,13(r1)
fff8554c:	39 00 00 40 	li      r8,64
fff85550:	39 40 ff 82 	li      r10,-126
fff85554:	99 21 00 10 	stb     r9,16(r1)
fff85558:	99 41 00 11 	stb     r10,17(r1)
fff8555c:	99 21 00 26 	stb     r9,38(r1)
fff85560:	39 40 00 09 	li      r10,9
fff85564:	39 20 00 0b 	li      r9,11
fff85568:	99 01 00 1a 	stb     r8,26(r1)
fff8556c:	99 41 00 19 	stb     r10,25(r1)
fff85570:	99 41 00 1d 	stb     r10,29(r1)
fff85574:	99 21 00 28 	stb     r9,40(r1)
        // Add 32 byte input hashKey to the tpmExtendPCR after offset 33. 33-64 ---> hashKey
        uint32_t offset = 33;
        uint32_t pcrOffset = 13;
        for(uint32_t i = 0; i < size; i ++)
fff85578:	39 40 00 00 	li      r10,0
fff8557c:	39 20 00 00 	li      r9,0
fff85580:	06 c9 00 28 	bwz     r9,fff855d0 <_Z12tpmExtendPCRmPhm+0x100>
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
fff85584:	7c dd 50 ae 	lbzx    r6,r29,r10
fff85588:	3c 60 c4 97 	lis     r3,-15209
fff8558c:	7d 45 53 78 	mr      r5,r10
fff85590:	38 e0 00 00 	li      r7,0
fff85594:	39 00 00 00 	li      r8,0
fff85598:	60 63 00 02 	ori     r3,r3,2
fff8559c:	91 41 00 6c 	stw     r10,108(r1)
fff855a0:	91 21 00 70 	stw     r9,112(r1)
fff855a4:	91 41 00 68 	stw     r10,104(r1)
fff855a8:	4b ff da bd 	bl      fff83064 <pk_trace_big>
            tpmExtendPCR[offset + i] = *(hashKey + i);
fff855ac:	80 81 00 6c 	lwz     r4,108(r1)
fff855b0:	81 41 00 68 	lwz     r10,104(r1)
fff855b4:	81 21 00 70 	lwz     r9,112(r1)
fff855b8:	7c fd 20 ae 	lbzx    r7,r29,r4
fff855bc:	7d 1f 52 14 	add     r8,r31,r10
fff855c0:	98 e8 00 21 	stb     r7,33(r8)
fff855c4:	31 4a 00 01 	addic   r10,r10,1
fff855c8:	7d 29 01 94 	addze   r9,r9
fff855cc:	4b ff ff b4 	b       fff85580 <_Z12tpmExtendPCRmPhm+0xb0>
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x09, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B};
        // Add 32 byte input hashKey to the tpmExtendPCR after offset 33. 33-64 ---> hashKey
        uint32_t offset = 33;
        uint32_t pcrOffset = 13;
        for(uint32_t i = 0; i < size; i ++)
fff855d0:	04 5e 57 da 	cmpwbne r30,r10,fff85584 <_Z12tpmExtendPCRmPhm+0xb4>
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fff855d4:	3c 60 51 d4 	lis     r3,20948
        for(uint32_t i = 0; i < size; i ++)
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
fff855d8:	39 20 00 48 	li      r9,72
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fff855dc:	60 63 00 01 	ori     r3,r3,1
fff855e0:	7f 85 e3 78 	mr      r5,r28
fff855e4:	38 c0 00 00 	li      r6,0
fff855e8:	38 e0 00 00 	li      r7,0
fff855ec:	39 00 00 00 	li      r8,0
        for(uint32_t i = 0; i < size; i ++)
        {
            SBEM_INFO(SBEM_FUNC "tpmExtendPCR at %d is 0x%02X", i , *(hashKey + i));
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
fff855f0:	91 21 00 60 	stw     r9,96(r1)
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
fff855f4:	4b ff da 71 	bl      fff83064 <pk_trace_big>
        tpmExtendPCR[pcrOffset] = pcrNum;
        uint8_t *seqBytes = tpmExtendPCR;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fff855f8:	38 61 00 50 	addi    r3,r1,80
fff855fc:	7f e4 fb 78 	mr      r4,r31
fff85600:	38 a1 00 60 	addi    r5,r1,96
fff85604:	38 c0 00 41 	li      r6,65
            tpmExtendPCR[offset + i] = *(hashKey + i);
        }
        uint32_t buflen = 72;
        uint32_t cmdLen = 65;
        SBEM_INFO(SBEM_FUNC "Extend PCR %d", pcrNum);
        tpmExtendPCR[pcrOffset] = pcrNum;
fff85608:	9b 81 00 15 	stb     r28,21(r1)
        uint8_t *seqBytes = tpmExtendPCR;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fff8560c:	4b ff fd 61 	bl      fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fff85610:	7c 7d 1b 78 	mr      r29,r3
fff85614:	3b c0 00 00 	li      r30,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff85618:	06 c3 00 1c 	bwz     r3,fff85650 <_Z12tpmExtendPCRmPhm+0x180>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fff8561c:	7c 7e 1b 78 	mr      r30,r3
fff85620:	3b e0 00 00 	li      r31,0
fff85624:	3c 60 0b 85 	lis     r3,2949
fff85628:	60 63 00 01 	ori     r3,r3,1
fff8562c:	7f a5 eb 78 	mr      r5,r29
fff85630:	7f e6 fb 78 	mr      r6,r31
fff85634:	38 e0 00 00 	li      r7,0
fff85638:	39 00 00 00 	li      r8,0
fff8563c:	4b ff da 29 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff85640:	3d 20 00 05 	lis     r9,5
fff85644:	61 29 01 85 	ori     r9,r9,389
fff85648:	1b c9 00 00 	stvd    d30,0(r9)
            break;
fff8564c:	48 00 00 b4 	b       fff85700 <_Z12tpmExtendPCRmPhm+0x230>
        }
        for(uint32_t i = 0; i < buflen; i++)
fff85650:	81 21 00 60 	lwz     r9,96(r1)
fff85654:	05 1e 48 0c 	cmplwbge r30,r9,fff8566c <_Z12tpmExtendPCRmPhm+0x19c>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fff85658:	7c 7f f0 ae 	lbzx    r3,r31,r30
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < buflen; i++)
fff8565c:	3b de 00 01 	addi    r30,r30,1
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fff85660:	64 63 73 a2 	oris    r3,r3,29602
fff85664:	4b ff ab 15 	bl      fff80178 <pk_trace_tiny>
fff85668:	4b ff ff e8 	b       fff85650 <_Z12tpmExtendPCRmPhm+0x180>
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fff8566c:	89 21 00 0e 	lbz     r9,14(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fff85670:	3b e0 00 00 	li      r31,0
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fff85674:	55 2a c0 0e 	rlwinm  r10,r9,24,0,7
fff85678:	89 21 00 0f 	lbz     r9,15(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fff8567c:	3c 60 ae 8f 	lis     r3,-20849
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fff85680:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fff85684:	7d 49 4b 78 	or      r9,r10,r9
fff85688:	89 41 00 11 	lbz     r10,17(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fff8568c:	60 63 00 01 	ori     r3,r3,1
fff85690:	7d 2a 53 78 	or      r10,r9,r10
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fff85694:	89 21 00 10 	lbz     r9,16(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fff85698:	7f e6 fb 78 	mr      r6,r31
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmExtendPCR[6] << 24) | (tpmExtendPCR[7] << 16) |  (tpmExtendPCR[8] << 8) | tpmExtendPCR[9];
fff8569c:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fff856a0:	7d 49 4b 78 	or      r9,r10,r9
        SBEM_INFO(SBEM_FUNC "TPM2_Extend PCR response code is 0x%08X", tpmRc);
fff856a4:	7d 25 4b 78 	mr      r5,r9
fff856a8:	38 e0 00 00 	li      r7,0
fff856ac:	39 00 00 00 	li      r8,0
fff856b0:	7d 3e 4b 78 	mr      r30,r9
fff856b4:	91 21 00 70 	stw     r9,112(r1)
fff856b8:	4b ff d9 ad 	bl      fff83064 <pk_trace_big>
        if(tpmRc || buflen < 10)
fff856bc:	81 21 00 70 	lwz     r9,112(r1)
fff856c0:	06 49 00 08 	bwnz    r9,fff856d0 <_Z12tpmExtendPCRmPhm+0x200>
fff856c4:	81 21 00 60 	lwz     r9,96(r1)
fff856c8:	28 09 00 09 	cmplwi  r9,9
fff856cc:	41 81 00 34 	bgt     fff85700 <_Z12tpmExtendPCRmPhm+0x230>
        {
            SBEM_ERROR(SBEM_FUNC "TPM2_Extend PCR response code is non zero for PCR %d.", pcrNum);
fff856d0:	3c 60 3d 85 	lis     r3,15749
fff856d4:	60 63 00 01 	ori     r3,r3,1
fff856d8:	7f 85 e3 78 	mr      r5,r28
fff856dc:	38 c0 00 00 	li      r6,0
fff856e0:	38 e0 00 00 	li      r7,0
fff856e4:	39 00 00 00 	li      r8,0
fff856e8:	4b ff d9 7d 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(tpmRc);
fff856ec:	3d 20 00 05 	lis     r9,5
fff856f0:	61 29 01 85 	ori     r9,r9,389
fff856f4:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fff856f8:	3f a0 02 00 	lis     r29,512
fff856fc:	63 bd 00 01 	ori     r29,r29,1

    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff85700:	80 01 00 8c 	lwz     r0,140(r1)
fff85704:	7f a3 eb 78 	mr      r3,r29
fff85708:	7c 08 03 a6 	mtlr    r0
fff8570c:	17 81 00 78 	lvd     d28,120(r1)
fff85710:	17 c1 00 80 	lvd     d30,128(r1)
fff85714:	38 21 00 88 	addi    r1,r1,136
fff85718:	4e 80 00 20 	blr

fff8571c <_Z12tpmPoisonPCRv>:
#include "p10_scom_pibms.H"

using namespace fapi2;

fapi2::ReturnCode tpmPoisonPCR()
{
fff8571c:	94 21 ff 88 	stwu    r1,-120(r1)
fff85720:	7c 08 02 a6 	mflr    r0
fff85724:	1b c1 00 70 	stvd    d30,112(r1)
fff85728:	90 01 00 7c 	stw     r0,124(r1)
fff8572c:	1b 81 00 68 	stvd    d28,104(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
fff85730:	48 00 0d 8d 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff85734:	39 20 00 04 	li      r9,4
fff85738:	99 21 00 4c 	stb     r9,76(r1)
fff8573c:	3d 20 00 0c 	lis     r9,12
fff85740:	3b e0 00 01 	li      r31,1
fff85744:	61 29 00 80 	ori     r9,r9,128
fff85748:	90 61 00 48 	stw     r3,72(r1)
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        SBEM_INFO(SBEM_FUNC "Call PM2_GetRandom ");
        uint8_t tpmGetRN[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C,
                                0x00, 0x00, 0x01, 0x7B, 0x00, 0x20};
fff8574c:	3b a1 00 08 	addi    r29,r1,8
    {
        uint8_t spi_engine  = 4;
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        SBEM_INFO(SBEM_FUNC "Call PM2_GetRandom ");
fff85750:	3c 60 c9 88 	lis     r3,-13944
fff85754:	91 21 00 50 	stw     r9,80(r1)
fff85758:	b3 e1 00 4e 	sth     r31,78(r1)
fff8575c:	9b e1 00 54 	stb     r31,84(r1)
fff85760:	4b ff aa 19 	bl      fff80178 <pk_trace_tiny>
        uint8_t tpmGetRN[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C,
                                0x00, 0x00, 0x01, 0x7B, 0x00, 0x20};
fff85764:	38 80 00 00 	li      r4,0
fff85768:	38 a0 00 40 	li      r5,64
fff8576c:	7f a3 eb 78 	mr      r3,r29
fff85770:	4b ff d2 b5 	bl      fff82a24 <memset>
fff85774:	39 20 ff 80 	li      r9,-128
fff85778:	99 21 00 08 	stb     r9,8(r1)
fff8577c:	39 20 00 0c 	li      r9,12
fff85780:	99 21 00 0d 	stb     r9,13(r1)
fff85784:	39 20 00 7b 	li      r9,123
fff85788:	99 21 00 11 	stb     r9,17(r1)
fff8578c:	39 20 00 20 	li      r9,32
fff85790:	99 21 00 13 	stb     r9,19(r1)
        uint8_t * seqBytes = tpmGetRN;
        uint32_t buflen = 64;
        uint32_t cmdLen = 12;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fff85794:	38 61 00 48 	addi    r3,r1,72

        SBEM_INFO(SBEM_FUNC "Call PM2_GetRandom ");
        uint8_t tpmGetRN[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C,
                                0x00, 0x00, 0x01, 0x7B, 0x00, 0x20};
        uint8_t * seqBytes = tpmGetRN;
        uint32_t buflen = 64;
fff85798:	39 20 00 40 	li      r9,64
        uint32_t cmdLen = 12;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fff8579c:	7f a4 eb 78 	mr      r4,r29
fff857a0:	38 a1 00 58 	addi    r5,r1,88
fff857a4:	38 c0 00 0c 	li      r6,12
        Target<TARGET_TYPE_PROC_CHIP> i_target_chip =  plat_getChipTarget();
        SpiControlHandle handle = SpiControlHandle(i_target_chip, spi_engine);

        SBEM_INFO(SBEM_FUNC "Call PM2_GetRandom ");
        uint8_t tpmGetRN[64] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x0C,
                                0x00, 0x00, 0x01, 0x7B, 0x00, 0x20};
fff857a8:	9b e1 00 09 	stb     r31,9(r1)
fff857ac:	9b e1 00 10 	stb     r31,16(r1)
        uint8_t * seqBytes = tpmGetRN;
        uint32_t buflen = 64;
fff857b0:	91 21 00 58 	stw     r9,88(r1)
        uint32_t cmdLen = 12;
        rc = tpmTransmit(handle, (void *)seqBytes, buflen, cmdLen);
fff857b4:	4b ff fb b9 	bl      fff8536c <_Z11tpmTransmitR16SpiControlHandlePvRmm>
fff857b8:	7c 7f 1b 78 	mr      r31,r3
fff857bc:	3b c0 00 00 	li      r30,0
        if( rc != fapi2::FAPI2_RC_SUCCESS )
fff857c0:	06 c3 00 1c 	bwz     r3,fff857f8 <_Z12tpmPoisonPCRv+0xdc>
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
fff857c4:	7c 7c 1b 78 	mr      r28,r3
fff857c8:	3b a0 00 00 	li      r29,0
fff857cc:	3c 60 ca 21 	lis     r3,-13791
fff857d0:	60 63 00 01 	ori     r3,r3,1
fff857d4:	7f e5 fb 78 	mr      r5,r31
fff857d8:	7f a6 eb 78 	mr      r6,r29
fff857dc:	38 e0 00 00 	li      r7,0
fff857e0:	39 00 00 00 	li      r8,0
fff857e4:	4b ff d8 81 	bl      fff83064 <pk_trace_big>
            SET_TPM_RC(rc);
fff857e8:	3d 20 00 05 	lis     r9,5
fff857ec:	61 29 01 85 	ori     r9,r9,389
fff857f0:	1b 89 00 00 	stvd    d28,0(r9)
            break;
fff857f4:	48 00 00 e0 	b       fff858d4 <_Z12tpmPoisonPCRv+0x1b8>
        }
        for(uint32_t i = 0; i < buflen; i++)
fff857f8:	81 21 00 58 	lwz     r9,88(r1)
fff857fc:	05 1e 48 0c 	cmplwbge r30,r9,fff85814 <_Z12tpmPoisonPCRv+0xf8>
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fff85800:	7c 7d f0 ae 	lbzx    r3,r29,r30
        {
            SBEM_ERROR(SBEM_FUNC "tpmTransmit failed with rc 08%08X", rc);
            SET_TPM_RC(rc);
            break;
        }
        for(uint32_t i = 0; i < buflen; i++)
fff85804:	3b de 00 01 	addi    r30,r30,1
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
fff85808:	64 63 34 51 	oris    r3,r3,13393
fff8580c:	4b ff a9 6d 	bl      fff80178 <pk_trace_tiny>
fff85810:	4b ff ff e8 	b       fff857f8 <_Z12tpmPoisonPCRv+0xdc>
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmGetRN[6] << 24) | (tpmGetRN[7] << 16) |  (tpmGetRN[8] << 8) | tpmGetRN[9];
fff85814:	89 21 00 0e 	lbz     r9,14(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_GetRandom response code is 0x%08X", tpmRc);
fff85818:	3b e0 00 00 	li      r31,0
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmGetRN[6] << 24) | (tpmGetRN[7] << 16) |  (tpmGetRN[8] << 8) | tpmGetRN[9];
fff8581c:	55 3d c0 0e 	rlwinm  r29,r9,24,0,7
fff85820:	89 21 00 0f 	lbz     r9,15(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_GetRandom response code is 0x%08X", tpmRc);
fff85824:	3c 60 55 27 	lis     r3,21799
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmGetRN[6] << 24) | (tpmGetRN[7] << 16) |  (tpmGetRN[8] << 8) | tpmGetRN[9];
fff85828:	55 29 80 1e 	rlwinm  r9,r9,16,0,15
fff8582c:	7f a9 4b 78 	or      r9,r29,r9
fff85830:	8b a1 00 11 	lbz     r29,17(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_GetRandom response code is 0x%08X", tpmRc);
fff85834:	60 63 00 01 	ori     r3,r3,1
fff85838:	7d 3d eb 78 	or      r29,r9,r29
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmGetRN[6] << 24) | (tpmGetRN[7] << 16) |  (tpmGetRN[8] << 8) | tpmGetRN[9];
fff8583c:	89 21 00 10 	lbz     r9,16(r1)
        SBEM_INFO(SBEM_FUNC "TPM2_GetRandom response code is 0x%08X", tpmRc);
fff85840:	7f e6 fb 78 	mr      r6,r31
        for(uint32_t i = 0; i < buflen; i++)
        {
            SBEM_INFO(SBEM_FUNC "TPM transmit data is 0x%02X", *(seqBytes + i));
        }
        // Get the command response code.
        uint32_t tpmRc = (tpmGetRN[6] << 24) | (tpmGetRN[7] << 16) |  (tpmGetRN[8] << 8) | tpmGetRN[9];
fff85844:	55 29 40 2e 	rlwinm  r9,r9,8,0,23
fff85848:	7f bd 4b 78 	or      r29,r29,r9
        SBEM_INFO(SBEM_FUNC "TPM2_GetRandom response code is 0x%08X", tpmRc);
fff8584c:	7f a5 eb 78 	mr      r5,r29
fff85850:	38 e0 00 00 	li      r7,0
fff85854:	39 00 00 00 	li      r8,0
fff85858:	7f be eb 78 	mr      r30,r29
fff8585c:	4b ff d8 09 	bl      fff83064 <pk_trace_big>
        if(tpmRc || buflen < 10)
fff85860:	06 5d 00 08 	bwnz    r29,fff85870 <_Z12tpmPoisonPCRv+0x154>
fff85864:	81 21 00 58 	lwz     r9,88(r1)
fff85868:	28 09 00 09 	cmplwi  r9,9
fff8586c:	41 81 00 24 	bgt     fff85890 <_Z12tpmPoisonPCRv+0x174>
        {
            SBEM_ERROR(SBEM_FUNC "TPM2_GetRandom response code is non zero.");
fff85870:	3c 60 f6 f4 	lis     r3,-2316
fff85874:	4b ff a9 05 	bl      fff80178 <pk_trace_tiny>
            SET_TPM_RC(tpmRc);
fff85878:	3d 20 00 05 	lis     r9,5
fff8587c:	61 29 01 85 	ori     r9,r9,389
fff85880:	1b c9 00 00 	stvd    d30,0(r9)
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
fff85884:	3f e0 02 00 	lis     r31,512
fff85888:	63 ff 00 01 	ori     r31,r31,1
            break;
fff8588c:	48 00 00 48 	b       fff858d4 <_Z12tpmPoisonPCRv+0x1b8>
fff85890:	3b c0 00 00 	li      r30,0
        }
        for(uint32_t i = 0; i < 8; i++)
        {
            uint8_t *hashKeys = (tpmGetRN + 12);
            uint8_t size = 32;
            rc = tpmExtendPCR(i, hashKeys, size);
fff85894:	7f c3 f3 78 	mr      r3,r30
fff85898:	38 81 00 14 	addi    r4,r1,20
fff8589c:	38 a0 00 20 	li      r5,32
fff858a0:	4b ff fc 31 	bl      fff854d0 <_Z12tpmExtendPCRmPhm>
fff858a4:	7c 7f 1b 78 	mr      r31,r3
            if( rc != fapi2::FAPI2_RC_SUCCESS )
fff858a8:	06 c3 00 12 	bwz     r3,fff858cc <_Z12tpmPoisonPCRv+0x1b0>
            {
                SBEM_ERROR(SBEM_FUNC "tpmExtendPCR failed with rc 08%08X", rc);
fff858ac:	3c 60 ef 68 	lis     r3,-4248
fff858b0:	60 63 00 01 	ori     r3,r3,1
fff858b4:	7f e5 fb 78 	mr      r5,r31
fff858b8:	38 c0 00 00 	li      r6,0
fff858bc:	38 e0 00 00 	li      r7,0
fff858c0:	39 00 00 00 	li      r8,0
fff858c4:	4b ff d7 a1 	bl      fff83064 <pk_trace_big>
                break;
fff858c8:	48 00 00 0c 	b       fff858d4 <_Z12tpmPoisonPCRv+0x1b8>
            SBEM_ERROR(SBEM_FUNC "TPM2_GetRandom response code is non zero.");
            SET_TPM_RC(tpmRc);
            rc = fapi2::FAPI2_RC_PLAT_ERR_SEE_DATA;
            break;
        }
        for(uint32_t i = 0; i < 8; i++)
fff858cc:	3b de 00 01 	addi    r30,r30,1
fff858d0:	06 5e 47 e2 	cmpwibne r30,8,fff85894 <_Z12tpmPoisonPCRv+0x178>

    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff858d4:	80 01 00 7c 	lwz     r0,124(r1)
fff858d8:	7f e3 fb 78 	mr      r3,r31
fff858dc:	7c 08 03 a6 	mtlr    r0
fff858e0:	17 81 00 68 	lvd     d28,104(r1)
fff858e4:	17 c1 00 70 	lvd     d30,112(r1)
fff858e8:	38 21 00 78 	addi    r1,r1,120
fff858ec:	4e 80 00 20 	blr

fff858f0 <_Z17setTPMDeconfigBitv>:
    return rc;
    #undef SBEM_FUNC
}

fapi2::ReturnCode setTPMDeconfigBit()
{
fff858f0:	94 21 ff e8 	stwu    r1,-24(r1)
fff858f4:	7c 08 02 a6 	mflr    r0
fff858f8:	90 01 00 1c 	stw     r0,28(r1)
    SBEM_ENTER(SBEM_FUNC);
    fapi2::ReturnCode rc = fapi2::FAPI2_RC_SUCCESS;
    do
    {
        // putscom 0x10005 0x00080000_00000000
        Target<TARGET_TYPE_PROC_CHIP> target =  plat_getChipTarget();
fff858fc:	48 00 0b c1 	bl      fff864bc <_ZN5fapi218plat_getChipTargetEv>
fff85900:	7c 29 0b 78 	mr      r9,r1
fff85904:	94 69 00 08 	stwu    r3,8(r9)
        constexpr uint64_t tpmDeconfigMask = 0x0008000000000000ULL;
        rc = putscom_abs_wrap (&target, OTP_SECURITY_SWITCH, tpmDeconfigMask);
fff85908:	3c 80 00 01 	lis     r4,1
fff8590c:	3c a0 00 08 	lis     r5,8
fff85910:	7d 23 4b 78 	mr      r3,r9
fff85914:	60 84 00 05 	ori     r4,r4,5
fff85918:	38 c0 00 00 	li      r6,0
fff8591c:	48 00 0a a1 	bl      fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>
fff85920:	7c 65 1b 78 	mr      r5,r3
        if(rc)
fff85924:	06 c3 00 10 	bwz     r3,fff85944 <_Z17setTPMDeconfigBitv+0x54>
        {
            SBEM_ERROR(SBEM_FUNC " putscom failed on OTP_SECURITY_SWITCH with rc 0x%08X", rc);
fff85928:	3c 60 be 95 	lis     r3,-16747
fff8592c:	60 63 00 01 	ori     r3,r3,1
fff85930:	38 c0 00 00 	li      r6,0
fff85934:	38 e0 00 00 	li      r7,0
fff85938:	39 00 00 00 	li      r8,0
fff8593c:	4b ff d7 29 	bl      fff83064 <pk_trace_big>
            // If we are unsuccessful in setting the deconfig bit we are in an
            // untrusted unsecure state, we must halt
            pk_halt();
fff85940:	4b ff a9 25 	bl      fff80264 <pk_halt>
        }
    }while(0);
    SBEM_EXIT(SBEM_FUNC);
    return rc;
    #undef SBEM_FUNC
}
fff85944:	80 01 00 1c 	lwz     r0,28(r1)
fff85948:	7c 08 03 a6 	mtlr    r0
fff8594c:	38 21 00 18 	addi    r1,r1,24
fff85950:	4e 80 00 20 	blr

fff85954 <_Z12getXipOffset20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return pSection->iv_offset;
fff85954:	1c 63 00 0c 	mulli   r3,r3,12
fff85958:	3c 63 ff 80 	addis   r3,r3,-128
}
fff8595c:	80 63 00 40 	lwz     r3,64(r3)
fff85960:	4e 80 00 20 	blr

fff85964 <_Z15getXipOffsetAbs20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return pSection->iv_offset;
fff85964:	1c 63 00 0c 	mulli   r3,r3,12
fff85968:	3c 63 ff 80 	addis   r3,r3,-128
    uint8_t *base = (uint8_t*)(SBE_BASE_ORIGIN);
#else
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif

    return ( (uint32_t)base + getXipOffset(xipSection));
fff8596c:	80 63 00 40 	lwz     r3,64(r3)
}
fff85970:	3c 63 ff 80 	addis   r3,r3,-128
fff85974:	4e 80 00 20 	blr

fff85978 <_Z10getXipSize20p9_xip_section_sbe_t>:
    uint8_t *base = (uint8_t*)(SBE_SEEPROM_BASE_ORIGIN);
#endif
    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return (pSection->iv_size);
fff85978:	1c 63 00 0c 	mulli   r3,r3,12
fff8597c:	3c 63 ff 80 	addis   r3,r3,-128
}
fff85980:	80 63 00 44 	lwz     r3,68(r3)
fff85984:	4e 80 00 20 	blr

fff85988 <_Z26getXipOffsetAbsMeasurement20p9_xip_section_sbe_t>:
#endif

    P9XipHeader* imgHdr = (P9XipHeader*)(base);
    p9_xip_section_sbe_t sectionName = xipSection;
    P9XipSection* pSection = &imgHdr->iv_section[sectionName];
    return ( (uint32_t)base + pSection->iv_offset);
fff85988:	1c 63 00 0c 	mulli   r3,r3,12
fff8598c:	3c 63 ff 88 	addis   r3,r3,-120
fff85990:	80 63 00 40 	lwz     r3,64(r3)
}
fff85994:	3c 63 ff 88 	addis   r3,r3,-120
fff85998:	4e 80 00 20 	blr

fff8599c <_ZL16SHA512_TransformP11_SHA512_CTXPKy>:
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fff8599c:	94 21 ff 38 	stwu    r1,-200(r1)
fff859a0:	7c 08 02 a6 	mflr    r0
fff859a4:	90 81 00 98 	stw     r4,152(r1)
                 "sub  %0,2,%0 \n\t" // because subi does not work
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
fff859a8:	14 83 00 00 	lvd     d4,0(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fff859ac:	1b c1 00 c0 	stvd    d30,192(r1)
                 "sub  %0,2,%0 \n\t" // because subi does not work
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
fff859b0:	18 81 00 10 	stvd    d4,16(r1)
    b = context->state[1];
fff859b4:	14 a3 00 08 	lvd     d5,8(r3)
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];
fff859b8:	17 c3 00 38 	lvd     d30,56(r3)
                 "addi %0,%0,(K512-0x8000)@l" : "=r" (K512_p) );
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
fff859bc:	18 a1 00 18 	stvd    d5,24(r1)
    c = context->state[2];
fff859c0:	14 c3 00 10 	lvd     d6,16(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fff859c4:	90 01 00 cc 	stw     r0,204(r1)
#endif

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
fff859c8:	18 c1 00 30 	stvd    d6,48(r1)
    d = context->state[3];
fff859cc:	14 e3 00 18 	lvd     d7,24(r3)


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
    uint64_t a, b, c, d, e, f, g, h, s0, s1;
    uint64_t T1, T2, *W512 = (uint64_t*)context->buffer;
fff859d0:	38 03 00 50 	addi    r0,r3,80

    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
fff859d4:	18 e1 00 20 	stvd    d7,32(r1)
    e = context->state[4];
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];
fff859d8:	1b c1 00 40 	stvd    d30,64(r1)
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
fff859dc:	15 03 00 28 	lvd     d8,40(r3)
fff859e0:	3b e0 00 10 	li      r31,16


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
    uint64_t a, b, c, d, e, f, g, h, s0, s1;
    uint64_t T1, T2, *W512 = (uint64_t*)context->buffer;
fff859e4:	7c 08 03 a6 	mtlr    r0
fff859e8:	7f e9 03 a6 	mtctr   r31
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
    f = context->state[5];
fff859ec:	19 01 00 28 	stvd    d8,40(r1)
    g = context->state[6];
fff859f0:	15 23 00 30 	lvd     d9,48(r3)
    context->bitcount[0] = context->bitcount[1] =  0;
}


static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data)
{
fff859f4:	1b 81 00 b8 	stvd    d28,184(r1)
    /* Initialize registers with the prev. intermediate value */
    a = context->state[0];
    b = context->state[1];
    c = context->state[2];
    d = context->state[3];
    e = context->state[4];
fff859f8:	17 83 00 20 	lvd     d28,32(r3)
    f = context->state[5];
    g = context->state[6];
fff859fc:	19 21 00 38 	stvd    d9,56(r1)
    h = context->state[7];
fff85a00:	39 40 00 00 	li      r10,0

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fff85a04:	57 9f 70 22 	rlwinm  r31,r28,14,0,17
fff85a08:	57 a4 74 be 	rlwinm  r4,r29,14,18,31
fff85a0c:	7f e4 23 78 	or      r4,r31,r4
fff85a10:	90 81 00 9c 	stw     r4,156(r1)
fff85a14:	57 80 74 be 	rlwinm  r0,r28,14,18,31
fff85a18:	57 a4 70 22 	rlwinm  r4,r29,14,0,17
fff85a1c:	7c 85 03 78 	or      r5,r4,r0
fff85a20:	57 9f 90 1a 	rlwinm  r31,r28,18,0,13
fff85a24:	57 a4 93 be 	rlwinm  r4,r29,18,14,31
fff85a28:	7f ff 23 78 	or      r31,r31,r4
fff85a2c:	57 a0 90 1a 	rlwinm  r0,r29,18,0,13
fff85a30:	57 84 93 be 	rlwinm  r4,r28,18,14,31
fff85a34:	7c 00 23 78 	or      r0,r0,r4
fff85a38:	81 01 00 98 	lwz     r8,152(r1)
fff85a3c:	7c a0 02 78 	xor     r0,r5,r0
fff85a40:	90 01 00 a0 	stw     r0,160(r1)
fff85a44:	3f c0 ff f8 	lis     r30,-8
fff85a48:	80 01 00 9c 	lwz     r0,156(r1)
fff85a4c:	7d 28 52 14 	add     r9,r8,r10
fff85a50:	3b de 66 90 	addi    r30,r30,26256
fff85a54:	14 c9 00 00 	lvd     d6,0(r9)
fff85a58:	7c 1f fa 78 	xor     r31,r0,r31
fff85a5c:	7d 3e 52 14 	add     r9,r30,r10
fff85a60:	57 80 b8 10 	rlwinm  r0,r28,23,0,8
fff85a64:	57 be ba 7e 	rlwinm  r30,r29,23,9,31
fff85a68:	80 81 00 a0 	lwz     r4,160(r1)
fff85a6c:	7f de 03 78 	or      r30,r30,r0
fff85a70:	57 a5 b8 10 	rlwinm  r5,r29,23,0,8
fff85a74:	57 80 ba 7e 	rlwinm  r0,r28,23,9,31
fff85a78:	7c 00 2b 78 	or      r0,r0,r5
fff85a7c:	7c 9e f2 78 	xor     r30,r4,r30
fff85a80:	7f e0 02 78 	xor     r0,r31,r0
fff85a84:	90 01 00 54 	stw     r0,84(r1)
fff85a88:	93 c1 00 50 	stw     r30,80(r1)
fff85a8c:	15 09 00 00 	lvd     d8,0(r9)
fff85a90:	17 c1 00 50 	lvd     d30,80(r1)
fff85a94:	7d 29 38 14 	addc    r9,r9,r7
fff85a98:	7d 08 31 14 	adde    r8,r8,r6
fff85a9c:	7d 29 f8 14 	addc    r9,r9,r31
fff85aa0:	7d 08 f1 14 	adde    r8,r8,r30
fff85aa4:	83 e1 00 38 	lwz     r31,56(r1)
fff85aa8:	83 c1 00 28 	lwz     r30,40(r1)
fff85aac:	7f e0 e0 78 	andc    r0,r31,r28
fff85ab0:	7f df e0 38 	and     r31,r30,r28
fff85ab4:	7c 1f fa 78 	xor     r31,r0,r31
fff85ab8:	80 a1 00 3c 	lwz     r5,60(r1)
fff85abc:	93 e1 00 48 	stw     r31,72(r1)
fff85ac0:	83 e1 00 2c 	lwz     r31,44(r1)
fff85ac4:	7c a4 e8 78 	andc    r4,r5,r29
fff85ac8:	7f e0 e8 38 	and     r0,r31,r29
fff85acc:	7c 80 02 78 	xor     r0,r4,r0
fff85ad0:	90 01 00 4c 	stw     r0,76(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85ad4:	80 01 00 10 	lwz     r0,16(r1)
fff85ad8:	17 c1 00 48 	lvd     d30,72(r1)
fff85adc:	7d 29 f8 14 	addc    r9,r9,r31
fff85ae0:	7d 08 f1 14 	adde    r8,r8,r30
fff85ae4:	7f e8 02 a6 	mflr    r31
fff85ae8:	83 c1 00 34 	lwz     r30,52(r1)
fff85aec:	7c 9f 52 14 	add     r4,r31,r10
    h = context->state[7];

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fff85af0:	18 c4 00 00 	stvd    d6,0(r4)
fff85af4:	14 81 00 40 	lvd     d4,64(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85af8:	80 e1 00 18 	lwz     r7,24(r1)
    h = context->state[7];

    j = 0;
    do {
        /* Apply the SHA-512 compression function to update a..h with copy */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
fff85afc:	7d 29 28 14 	addc    r9,r9,r5
fff85b00:	7d 08 21 14 	adde    r8,r8,r4
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85b04:	83 e1 00 1c 	lwz     r31,28(r1)
fff85b08:	80 a1 00 30 	lwz     r5,48(r1)
fff85b0c:	80 81 00 14 	lwz     r4,20(r1)
fff85b10:	7c a6 3a 78 	xor     r6,r5,r7
fff85b14:	7f c7 fa 78 	xor     r7,r30,r31
fff85b18:	83 c1 00 18 	lwz     r30,24(r1)
fff85b1c:	7c c6 00 38 	and     r6,r6,r0
fff85b20:	7c e7 20 38 	and     r7,r7,r4
fff85b24:	83 e1 00 34 	lwz     r31,52(r1)
fff85b28:	7c a4 f0 38 	and     r4,r5,r30
fff85b2c:	80 01 00 1c 	lwz     r0,28(r1)
fff85b30:	7c c4 22 78 	xor     r4,r6,r4
fff85b34:	80 a1 00 10 	lwz     r5,16(r1)
fff85b38:	7f e6 00 38 	and     r6,r31,r0
fff85b3c:	90 81 00 58 	stw     r4,88(r1)
fff85b40:	80 81 00 14 	lwz     r4,20(r1)
fff85b44:	7c e6 32 78 	xor     r6,r7,r6
fff85b48:	83 e1 00 14 	lwz     r31,20(r1)
fff85b4c:	90 c1 00 5c 	stw     r6,92(r1)
fff85b50:	54 be f0 02 	rlwinm  r30,r5,30,0,1
fff85b54:	54 86 f0 be 	rlwinm  r6,r4,30,2,31
fff85b58:	7c de f3 78 	or      r30,r6,r30
fff85b5c:	54 a7 f0 be 	rlwinm  r7,r5,30,2,31
fff85b60:	54 86 f0 02 	rlwinm  r6,r4,30,0,1
fff85b64:	7c e4 33 78 	or      r4,r7,r6
fff85b68:	57 e0 20 36 	rlwinm  r0,r31,4,0,27
fff85b6c:	57 e6 27 3e 	rlwinm  r6,r31,4,28,31
fff85b70:	54 bf 27 3e 	rlwinm  r31,r5,4,28,31
fff85b74:	7c 00 fb 78 	or      r0,r0,r31
fff85b78:	54 a7 20 36 	rlwinm  r7,r5,4,0,27
fff85b7c:	7c e7 33 78 	or      r7,r7,r6
fff85b80:	7f c6 02 78 	xor     r6,r30,r0
fff85b84:	80 01 00 14 	lwz     r0,20(r1)
fff85b88:	7c 87 3a 78 	xor     r7,r4,r7
fff85b8c:	54 1f c9 fe 	rlwinm  r31,r0,25,7,31
fff85b90:	54 a4 c8 0c 	rlwinm  r4,r5,25,0,6
fff85b94:	7f ff 23 78 	or      r31,r31,r4
fff85b98:	54 00 c8 0c 	rlwinm  r0,r0,25,0,6
fff85b9c:	54 a4 c9 fe 	rlwinm  r4,r5,25,7,31
fff85ba0:	7c 84 03 78 	or      r4,r4,r0
fff85ba4:	7c df fa 78 	xor     r31,r6,r31
fff85ba8:	7c e4 22 78 	xor     r4,r7,r4
fff85bac:	93 e1 00 60 	stw     r31,96(r1)
fff85bb0:	90 81 00 64 	stw     r4,100(r1)
fff85bb4:	17 c1 00 58 	lvd     d30,88(r1)
fff85bb8:	14 81 00 60 	lvd     d4,96(r1)
fff85bbc:	39 4a 00 08 	addi    r10,r10,8
fff85bc0:	7c ff 28 14 	addc    r7,r31,r5
fff85bc4:	7c de 21 14 	adde    r6,r30,r4
        h = g;
        g = f;
        f = e;
        e = d + T1;
fff85bc8:	14 81 00 20 	lvd     d4,32(r1)
fff85bcc:	7f e5 48 14 	addc    r31,r5,r9
fff85bd0:	7f c4 41 14 	adde    r30,r4,r8
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fff85bd4:	7c a7 48 14 	addc    r5,r7,r9
fff85bd8:	7c 86 41 14 	adde    r4,r6,r8
fff85bdc:	18 81 00 08 	stvd    d4,8(r1)
fff85be0:	14 a1 00 30 	lvd     d5,48(r1)
fff85be4:	18 a1 00 20 	stvd    d5,32(r1)
fff85be8:	14 c1 00 38 	lvd     d6,56(r1)
fff85bec:	18 c1 00 40 	stvd    d6,64(r1)
fff85bf0:	42 40 00 34 	bdz     fff85c24 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x288>
fff85bf4:	14 81 00 28 	lvd     d4,40(r1)
fff85bf8:	1b 81 00 28 	stvd    d28,40(r1)
fff85bfc:	18 81 00 38 	stvd    d4,56(r1)
fff85c00:	14 a1 00 18 	lvd     d5,24(r1)
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] + (W512[j] = *data++);
        T2 = Sigma0_512(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + T1;
fff85c04:	7f dc f3 78 	mr      r28,r30
fff85c08:	18 a1 00 30 	stvd    d5,48(r1)
fff85c0c:	14 c1 00 10 	lvd     d6,16(r1)
fff85c10:	7f fd fb 78 	mr      r29,r31
fff85c14:	18 c1 00 18 	stvd    d6,24(r1)
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fff85c18:	14 e1 00 08 	lvd     d7,8(r1)
fff85c1c:	18 e1 00 10 	stvd    d7,16(r1)
fff85c20:	4b ff fd e4 	b       fff85a04 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x68>
    f = context->state[5];
    g = context->state[6];
    h = context->state[7];

    j = 0;
    do {
fff85c24:	38 e0 00 40 	li      r7,64
fff85c28:	7c e9 03 a6 	mtctr   r7
fff85c2c:	39 40 00 10 	li      r10,16
fff85c30:	38 ca 00 01 	addi    r6,r10,1
        j++;
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
fff85c34:	7c e8 02 a6 	mflr    r7
fff85c38:	54 c9 1e 78 	rlwinm  r9,r6,3,25,28
fff85c3c:	7d 27 4a 14 	add     r9,r7,r9
fff85c40:	15 09 00 00 	lvd     d8,0(r9)
fff85c44:	90 c1 00 50 	stw     r6,80(r1)
        s0 = sigma0_512(s0);
fff85c48:	55 27 c2 3e 	rlwinm  r7,r9,24,8,31
fff85c4c:	55 06 c0 0e 	rlwinm  r6,r8,24,0,7
fff85c50:	7c c6 3b 78 	or      r6,r6,r7
fff85c54:	55 25 c0 0e 	rlwinm  r5,r9,24,0,7
fff85c58:	55 07 c2 3e 	rlwinm  r7,r8,24,8,31
fff85c5c:	7c a4 3b 78 	or      r4,r5,r7
fff85c60:	55 05 f8 00 	rlwinm  r5,r8,31,0,0
fff85c64:	55 27 f8 7e 	rlwinm  r7,r9,31,1,31
fff85c68:	55 20 f8 00 	rlwinm  r0,r9,31,0,0
fff85c6c:	7c a7 3b 78 	or      r7,r5,r7
fff85c70:	55 05 f8 7e 	rlwinm  r5,r8,31,1,31
fff85c74:	7c 05 2b 78 	or      r5,r0,r5
fff85c78:	7c 85 2a 78 	xor     r5,r4,r5
fff85c7c:	90 a1 00 48 	stw     r5,72(r1)
fff85c80:	79 04 c9 c2 	rldicl  d4,d8,57,7
fff85c84:	18 81 00 20 	stvd    d4,32(r1)
fff85c88:	39 2a 00 0e 	addi    r9,r10,14
        s1 = W512[(j+14)&0x0f];
fff85c8c:	7c a8 02 a6 	mflr    r5
fff85c90:	55 29 1e 78 	rlwinm  r9,r9,3,25,28
fff85c94:	7d 25 4a 14 	add     r9,r5,r9
fff85c98:	15 09 00 00 	lvd     d8,0(r9)
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
fff85c9c:	7c c7 3a 78 	xor     r7,r6,r7
fff85ca0:	90 e1 00 58 	stw     r7,88(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fff85ca4:	55 26 1f 7e 	rlwinm  r6,r9,3,29,31
fff85ca8:	55 07 18 38 	rlwinm  r7,r8,3,0,28
fff85cac:	7c c4 3b 78 	or      r4,r6,r7
fff85cb0:	55 00 1f 7e 	rlwinm  r0,r8,3,29,31
fff85cb4:	55 27 18 38 	rlwinm  r7,r9,3,0,28
fff85cb8:	7c 06 3b 78 	or      r6,r0,r7
fff85cbc:	55 00 68 24 	rlwinm  r0,r8,13,0,18
fff85cc0:	55 27 6c fe 	rlwinm  r7,r9,13,19,31
fff85cc4:	7c 07 3b 78 	or      r7,r0,r7
fff85cc8:	55 05 6c fe 	rlwinm  r5,r8,13,19,31
fff85ccc:	55 20 68 24 	rlwinm  r0,r9,13,0,18
fff85cd0:	7c 05 2b 78 	or      r5,r0,r5
fff85cd4:	7c c0 3a 78 	xor     r0,r6,r7
fff85cd8:	79 06 d1 82 	rldicl  d6,d8,58,6

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fff85cdc:	7d 08 02 a6 	mflr    r8
    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fff85ce0:	18 c1 00 b0 	stvd    d6,176(r1)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fff85ce4:	55 47 1e 78 	rlwinm  r7,r10,3,25,28
fff85ce8:	7d 08 3a 14 	add     r8,r8,r7
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fff85cec:	7d 28 02 a6 	mflr    r9
fff85cf0:	38 ea 00 09 	addi    r7,r10,9
fff85cf4:	54 e7 1e 78 	rlwinm  r7,r7,3,25,28
fff85cf8:	7c e9 3a 14 	add     r7,r9,r7
    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fff85cfc:	7c 85 2a 78 	xor     r5,r4,r5
fff85d00:	90 a1 00 60 	stw     r5,96(r1)
fff85d04:	14 87 00 00 	lvd     d4,0(r7)
fff85d08:	14 c8 00 00 	lvd     d6,0(r8)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fff85d0c:	91 01 00 40 	stw     r8,64(r1)
fff85d10:	7c e9 3b 78 	mr      r9,r7
fff85d14:	7c c8 33 78 	mr      r8,r6
fff85d18:	7c e9 28 14 	addc    r7,r9,r5
fff85d1c:	7c c8 21 14 	adde    r6,r8,r4
    } while (j < 16);

    do {
        /* Part of the message block expansion: */
        s0 = W512[(j+1)&0x0f];
        s0 = sigma0_512(s0);
fff85d20:	81 21 00 48 	lwz     r9,72(r1)
fff85d24:	80 81 00 20 	lwz     r4,32(r1)
fff85d28:	81 01 00 24 	lwz     r8,36(r1)
fff85d2c:	80 a1 00 58 	lwz     r5,88(r1)
fff85d30:	7d 29 22 78 	xor     r9,r9,r4
fff85d34:	7c a5 42 78 	xor     r5,r5,r8
fff85d38:	90 a1 00 6c 	stw     r5,108(r1)
fff85d3c:	91 21 00 68 	stw     r9,104(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);
fff85d40:	80 81 00 b0 	lwz     r4,176(r1)
fff85d44:	15 01 00 68 	lvd     d8,104(r1)
fff85d48:	80 a1 00 b4 	lwz     r5,180(r1)
fff85d4c:	7c e7 48 14 	addc    r7,r7,r9
fff85d50:	7c c6 41 14 	adde    r6,r6,r8
fff85d54:	81 21 00 60 	lwz     r9,96(r1)
fff85d58:	7c 00 2a 78 	xor     r0,r0,r5
fff85d5c:	7d 29 22 78 	xor     r9,r9,r4
fff85d60:	91 21 00 70 	stw     r9,112(r1)
fff85d64:	90 01 00 74 	stw     r0,116(r1)

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
fff85d68:	57 e0 90 1a 	rlwinm  r0,r31,18,0,13
fff85d6c:	14 81 00 70 	lvd     d4,112(r1)
fff85d70:	55 4a 18 38 	rlwinm  r10,r10,3,0,28
fff85d74:	7d 27 28 14 	addc    r9,r7,r5
fff85d78:	7d 06 21 14 	adde    r8,r6,r4
fff85d7c:	14 a1 00 28 	lvd     d5,40(r1)
fff85d80:	19 01 00 48 	stvd    d8,72(r1)
fff85d84:	7f 87 f0 38 	and     r7,r28,r30
fff85d88:	7c a8 f0 78 	andc    r8,r5,r30
fff85d8c:	7c c9 f8 78 	andc    r9,r6,r31
fff85d90:	7d 07 3a 78 	xor     r7,r8,r7
fff85d94:	7f a8 f8 38 	and     r8,r29,r31
fff85d98:	90 e1 00 78 	stw     r7,120(r1)
fff85d9c:	7d 28 42 78 	xor     r8,r9,r8
fff85da0:	57 e7 74 be 	rlwinm  r7,r31,14,18,31
fff85da4:	57 c9 70 22 	rlwinm  r9,r30,14,0,17
fff85da8:	91 01 00 7c 	stw     r8,124(r1)
fff85dac:	7d 27 3b 78 	or      r7,r9,r7
fff85db0:	57 e8 70 22 	rlwinm  r8,r31,14,0,17
fff85db4:	57 c9 74 be 	rlwinm  r9,r30,14,18,31
fff85db8:	7d 05 4b 78 	or      r5,r8,r9
fff85dbc:	57 c6 93 be 	rlwinm  r6,r30,18,14,31
fff85dc0:	57 e8 93 be 	rlwinm  r8,r31,18,14,31
fff85dc4:	57 c9 90 1a 	rlwinm  r9,r30,18,0,13
fff85dc8:	7c 00 33 78 	or      r0,r0,r6
fff85dcc:	7d 29 43 78 	or      r9,r9,r8
fff85dd0:	7c e9 4a 78 	xor     r9,r7,r9
fff85dd4:	7c a8 02 78 	xor     r8,r5,r0
fff85dd8:	57 c7 b8 10 	rlwinm  r7,r30,23,0,8
fff85ddc:	57 e0 ba 7e 	rlwinm  r0,r31,23,9,31
fff85de0:	7c 00 3b 78 	or      r0,r0,r7
fff85de4:	57 c6 ba 7e 	rlwinm  r6,r30,23,9,31
fff85de8:	57 e7 b8 10 	rlwinm  r7,r31,23,0,8
fff85dec:	7c c6 3b 78 	or      r6,r6,r7
fff85df0:	7d 00 02 78 	xor     r0,r8,r0
fff85df4:	7d 26 32 78 	xor     r6,r9,r6
fff85df8:	90 01 00 80 	stw     r0,128(r1)
fff85dfc:	90 c1 00 84 	stw     r6,132(r1)
fff85e00:	15 01 00 78 	lvd     d8,120(r1)
fff85e04:	14 81 00 80 	lvd     d4,128(r1)
fff85e08:	7c e9 28 14 	addc    r7,r9,r5
fff85e0c:	7c c8 21 14 	adde    r6,r8,r4
fff85e10:	3c a0 ff f8 	lis     r5,-8
fff85e14:	38 a5 66 90 	addi    r5,r5,26256
fff85e18:	7d 45 52 14 	add     r10,r5,r10
fff85e1c:	18 c1 00 20 	stvd    d6,32(r1)
fff85e20:	14 ca 00 00 	lvd     d6,0(r10)
fff85e24:	14 81 00 20 	lvd     d4,32(r1)
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85e28:	80 01 00 1c 	lwz     r0,28(r1)
fff85e2c:	7d 25 38 14 	addc    r9,r5,r7
fff85e30:	7d 04 31 14 	adde    r8,r4,r6
fff85e34:	14 a1 00 48 	lvd     d5,72(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fff85e38:	80 e1 00 40 	lwz     r7,64(r1)
fff85e3c:	7d 29 30 14 	addc    r9,r9,r6
fff85e40:	7d 08 29 14 	adde    r8,r8,r5
fff85e44:	18 a7 00 00 	stvd    d5,0(r7)
fff85e48:	14 c1 00 38 	lvd     d6,56(r1)
fff85e4c:	7c a9 38 14 	addc    r5,r9,r7
fff85e50:	7c 88 31 14 	adde    r4,r8,r6
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85e54:	80 e1 00 18 	lwz     r7,24(r1)
fff85e58:	81 01 00 10 	lwz     r8,16(r1)
        s1 = W512[(j+14)&0x0f];
        s1 =  sigma1_512(s1);

        /* Apply the SHA-512 compression function to update a..h */
        T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512_p[j] +
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
fff85e5c:	18 81 00 38 	stvd    d4,56(r1)
        T2 = Sigma0_512(a) + Maj(a, b, c);
fff85e60:	80 a1 00 08 	lwz     r5,8(r1)
fff85e64:	80 81 00 14 	lwz     r4,20(r1)
fff85e68:	80 c1 00 0c 	lwz     r6,12(r1)
fff85e6c:	7c ea 42 78 	xor     r10,r7,r8
fff85e70:	7c 09 22 78 	xor     r9,r0,r4
fff85e74:	7d 4a 28 38 	and     r10,r10,r5
fff85e78:	7c e8 40 38 	and     r8,r7,r8
fff85e7c:	7d 29 30 38 	and     r9,r9,r6
fff85e80:	7d 48 42 78 	xor     r8,r10,r8
fff85e84:	7c 0a 20 38 	and     r10,r0,r4
fff85e88:	7d 2a 52 78 	xor     r10,r9,r10
fff85e8c:	91 41 00 8c 	stw     r10,140(r1)
fff85e90:	54 a9 f0 02 	rlwinm  r9,r5,30,0,1
fff85e94:	54 ca f0 be 	rlwinm  r10,r6,30,2,31
fff85e98:	7d 40 4b 78 	or      r0,r10,r9
fff85e9c:	7c a4 2b 78 	mr      r4,r5
fff85ea0:	54 a9 f0 be 	rlwinm  r9,r5,30,2,31
fff85ea4:	54 ca f0 02 	rlwinm  r10,r6,30,0,1
fff85ea8:	91 01 00 88 	stw     r8,136(r1)
fff85eac:	7d 28 53 78 	or      r8,r9,r10
fff85eb0:	54 ca 27 3e 	rlwinm  r10,r6,4,28,31
fff85eb4:	54 89 20 36 	rlwinm  r9,r4,4,0,27
fff85eb8:	54 c4 20 36 	rlwinm  r4,r6,4,0,27
fff85ebc:	14 c1 00 08 	lvd     d6,8(r1)
fff85ec0:	54 c5 27 3e 	rlwinm  r5,r6,4,28,31
fff85ec4:	7c 84 2b 78 	or      r4,r4,r5
fff85ec8:	7d 29 53 78 	or      r9,r9,r10
fff85ecc:	7d 09 4a 78 	xor     r9,r8,r9
fff85ed0:	7c 0a 22 78 	xor     r10,r0,r4
fff85ed4:	54 c8 c8 0c 	rlwinm  r8,r6,25,0,6
fff85ed8:	54 e4 c9 fe 	rlwinm  r4,r7,25,7,31
fff85edc:	7c 84 43 78 	or      r4,r4,r8
fff85ee0:	54 c5 c9 fe 	rlwinm  r5,r6,25,7,31
fff85ee4:	54 e8 c8 0c 	rlwinm  r8,r7,25,0,6
fff85ee8:	7c a5 43 78 	or      r5,r5,r8
fff85eec:	7d 44 22 78 	xor     r4,r10,r4
fff85ef0:	7d 25 2a 78 	xor     r5,r9,r5
fff85ef4:	18 81 00 90 	stvd    d4,144(r1)
fff85ef8:	15 01 00 88 	lvd     d8,136(r1)
fff85efc:	14 81 00 90 	lvd     d4,144(r1)
fff85f00:	7c e9 28 14 	addc    r7,r9,r5
fff85f04:	7c c8 21 14 	adde    r6,r8,r4
fff85f08:	18 c1 00 20 	stvd    d6,32(r1)
        h = g;
        g = f;
        f = e;
        e = d + T1;
fff85f0c:	15 21 00 38 	lvd     d9,56(r1)
fff85f10:	14 e1 00 30 	lvd     d7,48(r1)
fff85f14:	7c c8 50 14 	addc    r6,r8,r10
fff85f18:	7c a7 49 14 	adde    r5,r7,r9
fff85f1c:	18 a1 00 40 	stvd    d5,64(r1)
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fff85f20:	14 c1 00 20 	lvd     d6,32(r1)
fff85f24:	7c a7 50 14 	addc    r5,r7,r10
fff85f28:	7c 86 49 14 	adde    r4,r6,r9
fff85f2c:	14 e1 00 18 	lvd     d7,24(r1)
fff85f30:	18 81 00 20 	stvd    d4,32(r1)
fff85f34:	18 e1 00 30 	stvd    d7,48(r1)
fff85f38:	15 01 00 28 	lvd     d8,40(r1)
fff85f3c:	81 41 00 50 	lwz     r10,80(r1)
fff85f40:	19 01 00 38 	stvd    d8,56(r1)
        a = T1 + T2;

        j++;
    } while (j < 16);

    do {
fff85f44:	42 40 00 30 	bdz     fff85f74 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x5d8>
fff85f48:	14 81 00 08 	lvd     d4,8(r1)
fff85f4c:	15 01 00 10 	lvd     d8,16(r1)
fff85f50:	18 81 00 10 	stvd    d4,16(r1)
        f = e;
        e = d + T1;
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
fff85f54:	14 a1 00 20 	lvd     d5,32(r1)
fff85f58:	1b 81 00 28 	stvd    d28,40(r1)
fff85f5c:	19 01 00 18 	stvd    d8,24(r1)
fff85f60:	7f dc f3 78 	mr      r28,r30
fff85f64:	7f fd fb 78 	mr      r29,r31
fff85f68:	18 a1 00 08 	stvd    d5,8(r1)
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
        T2 = Sigma0_512(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + T1;
fff85f6c:	17 c1 00 40 	lvd     d30,64(r1)
fff85f70:	4b ff fc c0 	b       fff85c30 <_ZL16SHA512_TransformP11_SHA512_CTXPKy+0x294>

        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
fff85f74:	14 c3 00 00 	lvd     d6,0(r3)
    context->state[6] += g;
    context->state[7] += h;

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fff85f78:	80 01 00 cc 	lwz     r0,204(r1)

        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
fff85f7c:	7d 25 38 14 	addc    r9,r5,r7
fff85f80:	7d 04 31 14 	adde    r8,r4,r6
fff85f84:	19 03 00 00 	stvd    d8,0(r3)
    context->state[1] += b;
fff85f88:	14 81 00 08 	lvd     d4,8(r1)
fff85f8c:	15 03 00 08 	lvd     d8,8(r3)
    context->state[6] += g;
    context->state[7] += h;

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fff85f90:	7c 08 03 a6 	mtlr    r0
        j++;
    } while (j < 80);

    /* Compute the current intermediate hash value */
    context->state[0] += a;
    context->state[1] += b;
fff85f94:	7d 29 28 14 	addc    r9,r9,r5
fff85f98:	7d 08 21 14 	adde    r8,r8,r4
fff85f9c:	19 03 00 08 	stvd    d8,8(r3)
    context->state[2] += c;
fff85fa0:	14 a1 00 10 	lvd     d5,16(r1)
fff85fa4:	15 03 00 10 	lvd     d8,16(r3)
fff85fa8:	7d 29 30 14 	addc    r9,r9,r6
fff85fac:	7d 08 29 14 	adde    r8,r8,r5
fff85fb0:	19 03 00 10 	stvd    d8,16(r3)
    context->state[3] += d;
fff85fb4:	14 c1 00 18 	lvd     d6,24(r1)
fff85fb8:	15 03 00 18 	lvd     d8,24(r3)
fff85fbc:	7d 29 38 14 	addc    r9,r9,r7
fff85fc0:	7d 08 31 14 	adde    r8,r8,r6
fff85fc4:	19 03 00 18 	stvd    d8,24(r3)
    context->state[4] += e;
fff85fc8:	14 c1 00 40 	lvd     d6,64(r1)
fff85fcc:	15 03 00 20 	lvd     d8,32(r3)
fff85fd0:	7c a7 48 14 	addc    r5,r7,r9
fff85fd4:	7c 86 41 14 	adde    r4,r6,r8
    context->state[5] += f;
fff85fd8:	15 03 00 28 	lvd     d8,40(r3)
    /* Compute the current intermediate hash value */
    context->state[0] += a;
    context->state[1] += b;
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
fff85fdc:	18 83 00 20 	stvd    d4,32(r3)
    context->state[5] += f;
fff85fe0:	7d 29 f8 14 	addc    r9,r9,r31
fff85fe4:	7d 08 f1 14 	adde    r8,r8,r30
fff85fe8:	19 03 00 28 	stvd    d8,40(r3)
    context->state[6] += g;
fff85fec:	15 03 00 30 	lvd     d8,48(r3)
    context->state[7] += h;
fff85ff0:	17 c1 00 28 	lvd     d30,40(r1)
    context->state[1] += b;
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
    context->state[5] += f;
    context->state[6] += g;
fff85ff4:	7d 29 e8 14 	addc    r9,r9,r29
fff85ff8:	7d 08 e1 14 	adde    r8,r8,r28
fff85ffc:	19 03 00 30 	stvd    d8,48(r3)
    context->state[7] += h;
fff86000:	15 03 00 38 	lvd     d8,56(r3)

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fff86004:	17 81 00 b8 	lvd     d28,184(r1)
    context->state[2] += c;
    context->state[3] += d;
    context->state[4] += e;
    context->state[5] += f;
    context->state[6] += g;
    context->state[7] += h;
fff86008:	7d 29 f8 14 	addc    r9,r9,r31
fff8600c:	7d 08 f1 14 	adde    r8,r8,r30
fff86010:	19 03 00 38 	stvd    d8,56(r3)

    /* Clean up */
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
fff86014:	17 c1 00 c0 	lvd     d30,192(r1)
fff86018:	38 21 00 c8 	addi    r1,r1,200
fff8601c:	4e 80 00 20 	blr

fff86020 <SHA512_Init>:
}

/*** SHA-512: *********************************************************/
asm(".globl .L.SHA512_Init");
void SHA512_Init(SHA512_CTX* context)
{
fff86020:	94 21 ff f0 	stwu    r1,-16(r1)
fff86024:	7c 08 02 a6 	mflr    r0
fff86028:	1b c1 00 08 	stvd    d30,8(r1)
fff8602c:	90 01 00 14 	stw     r0,20(r1)
fff86030:	7c 7f 1b 78 	mr      r31,r3
    if (context == (SHA512_CTX*)0)
fff86034:	06 c3 00 1a 	bwz     r3,fff86068 <SHA512_Init+0x48>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fff86038:	3c 80 ff f8 	lis     r4,-8
fff8603c:	38 84 69 10 	addi    r4,r4,26896
fff86040:	38 a0 00 40 	li      r5,64
fff86044:	4b ff ca b5 	bl      fff82af8 <memcpy>
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff86048:	38 7f 00 50 	addi    r3,r31,80
fff8604c:	38 80 00 00 	li      r4,0
fff86050:	38 a0 00 80 	li      r5,128
fff86054:	4b ff c9 d1 	bl      fff82a24 <memset>
                 "addi %0,%0,(sha512_initial_hash_value-0x8000)@l" : "=r" (sha512_initial_hash_value_p) );
#endif

    bcopy(sha512_initial_hash_value_p, context->state, SHA512_DIGEST_LENGTH);
    bzero(context->buffer, SHA512_BLOCK_LENGTH);
    context->bitcount[0] = context->bitcount[1] =  0;
fff86058:	39 00 00 00 	li      r8,0
fff8605c:	39 20 00 00 	li      r9,0
fff86060:	19 1f 00 48 	stvd    d8,72(r31)
fff86064:	19 1f 00 40 	stvd    d8,64(r31)
}
fff86068:	80 01 00 14 	lwz     r0,20(r1)
fff8606c:	17 c1 00 08 	lvd     d30,8(r1)
fff86070:	7c 08 03 a6 	mtlr    r0
fff86074:	38 21 00 10 	addi    r1,r1,16
fff86078:	4e 80 00 20 	blr

fff8607c <SHA512_Update>:
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

asm(".globl .L.SHA512_Update");
void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len)
{
fff8607c:	94 21 ff e8 	stwu    r1,-24(r1)
fff86080:	7c 08 02 a6 	mflr    r0
fff86084:	1b c1 00 10 	stvd    d30,16(r1)
fff86088:	90 01 00 1c 	stw     r0,28(r1)
fff8608c:	1b 81 00 08 	stvd    d28,8(r1)
fff86090:	7c be 2b 78 	mr      r30,r5
    unsigned int freespace, usedspace;

    if (len == 0)
fff86094:	06 c5 00 8a 	bwz     r5,fff861a8 <SHA512_Update+0x12c>
    {
        /* Calling with no data is valid - we do nothing */
        return;
    }

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fff86098:	15 03 00 40 	lvd     d8,64(r3)
fff8609c:	7c 7f 1b 78 	mr      r31,r3
fff860a0:	79 08 e8 c2 	rldicl  d8,d8,61,3
fff860a4:	55 23 06 7e 	clrlwi  r3,r9,25
fff860a8:	7c 9d 23 78 	mr      r29,r4
    if (usedspace > 0)
fff860ac:	06 c3 00 30 	bwz     r3,fff8610c <SHA512_Update+0x90>
    {
        /* Calculate how much free space is available in the buffer */
        freespace = SHA512_BLOCK_LENGTH - usedspace;
fff860b0:	23 83 00 80 	subfic  r28,r3,128
fff860b4:	38 63 00 50 	addi    r3,r3,80
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fff860b8:	7c 7f 1a 14 	add     r3,r31,r3
    if (usedspace > 0)
    {
        /* Calculate how much free space is available in the buffer */
        freespace = SHA512_BLOCK_LENGTH - usedspace;

        if (len >= freespace)
fff860bc:	05 85 e0 5c 	cmplwblt r5,r28,fff86174 <SHA512_Update+0xf8>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fff860c0:	7f 85 e3 78 	mr      r5,r28
fff860c4:	4b ff ca 35 	bl      fff82af8 <memcpy>

        if (len >= freespace)
        {
            /* Fill the buffer completely and process it */
            bcopy(data, &context->buffer[usedspace], freespace);
            ADDINC128(context->bitcount, freespace << 3);
fff860c8:	15 1f 00 40 	lvd     d8,64(r31)
fff860cc:	57 87 18 38 	rlwinm  r7,r28,3,0,28
fff860d0:	38 c0 00 00 	li      r6,0
fff860d4:	7d 29 38 14 	addc    r9,r9,r7
fff860d8:	7d 08 31 14 	adde    r8,r8,r6
fff860dc:	19 1f 00 40 	stvd    d8,64(r31)
fff860e0:	04 46 40 0c 	cmpwbne r6,r8,fff860f8 <SHA512_Update+0x7c>
fff860e4:	05 27 48 0a 	cmplwble r7,r9,fff860f8 <SHA512_Update+0x7c>
fff860e8:	15 1f 00 48 	lvd     d8,72(r31)
fff860ec:	31 29 00 01 	addic   r9,r9,1
fff860f0:	7d 08 01 94 	addze   r8,r8
fff860f4:	19 1f 00 48 	stvd    d8,72(r31)
            len -= freespace;
            data += freespace;
            SHA512_Transform(context, (uint64_t*)context->buffer);
fff860f8:	7f e3 fb 78 	mr      r3,r31
fff860fc:	38 9f 00 50 	addi    r4,r31,80
        if (len >= freespace)
        {
            /* Fill the buffer completely and process it */
            bcopy(data, &context->buffer[usedspace], freespace);
            ADDINC128(context->bitcount, freespace << 3);
            len -= freespace;
fff86100:	7f dc f0 50 	subf    r30,r28,r30
            data += freespace;
fff86104:	7f bd e2 14 	add     r29,r29,r28
            SHA512_Transform(context, (uint64_t*)context->buffer);
fff86108:	4b ff f8 95 	bl      fff8599c <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
    a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

asm(".globl .L.SHA512_Update");
void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len)
{
fff8610c:	7f dc f3 78 	mr      r28,r30
            /* Clean up: */
            usedspace = freespace = 0;
            return;
        }
    }
    while (len >= SHA512_BLOCK_LENGTH)
fff86110:	28 1c 00 7f 	cmplwi  r28,127
fff86114:	7c 9c f0 50 	subf    r4,r28,r30
fff86118:	7c 9d 22 14 	add     r4,r29,r4
fff8611c:	40 81 00 40 	ble     fff8615c <SHA512_Update+0xe0>
    {
        /* Process as many complete blocks as we can */
        SHA512_Transform(context, (const uint64_t*)data);
fff86120:	7f e3 fb 78 	mr      r3,r31
fff86124:	4b ff f8 79 	bl      fff8599c <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
fff86128:	15 1f 00 40 	lvd     d8,64(r31)
fff8612c:	31 29 04 00 	addic   r9,r9,1024
fff86130:	7d 08 01 94 	addze   r8,r8
fff86134:	19 1f 00 40 	stvd    d8,64(r31)
fff86138:	06 48 00 0e 	bwnz    r8,fff86154 <SHA512_Update+0xd8>
fff8613c:	28 09 03 ff 	cmplwi  r9,1023
fff86140:	41 81 00 14 	bgt     fff86154 <SHA512_Update+0xd8>
fff86144:	15 1f 00 48 	lvd     d8,72(r31)
fff86148:	31 29 00 01 	addic   r9,r9,1
fff8614c:	7d 08 01 94 	addze   r8,r8
fff86150:	19 1f 00 48 	stvd    d8,72(r31)
        len -= SHA512_BLOCK_LENGTH;
fff86154:	3b 9c ff 80 	addi    r28,r28,-128
fff86158:	4b ff ff b8 	b       fff86110 <SHA512_Update+0x94>
fff8615c:	57 c4 00 30 	rlwinm  r4,r30,0,0,24
fff86160:	57 de 06 7e 	clrlwi  r30,r30,25
fff86164:	7c 9d 22 14 	add     r4,r29,r4
        data += SHA512_BLOCK_LENGTH;
    }
    if (len > 0)
fff86168:	06 de 00 20 	bwz     r30,fff861a8 <SHA512_Update+0x12c>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fff8616c:	38 7f 00 50 	addi    r3,r31,80
fff86170:	7f c5 f3 78 	mr      r5,r30
fff86174:	4b ff c9 85 	bl      fff82af8 <memcpy>
    }
    if (len > 0)
    {
        /* There's left-overs, so save 'em */
        bcopy(data, context->buffer, len);
        ADDINC128(context->bitcount, len << 3);
fff86178:	15 1f 00 40 	lvd     d8,64(r31)
fff8617c:	57 c7 18 38 	rlwinm  r7,r30,3,0,28
fff86180:	38 c0 00 00 	li      r6,0
fff86184:	7d 29 38 14 	addc    r9,r9,r7
fff86188:	7d 08 31 14 	adde    r8,r8,r6
fff8618c:	19 1f 00 40 	stvd    d8,64(r31)
fff86190:	04 46 40 0c 	cmpwbne r6,r8,fff861a8 <SHA512_Update+0x12c>
fff86194:	05 27 48 0a 	cmplwble r7,r9,fff861a8 <SHA512_Update+0x12c>
fff86198:	15 1f 00 48 	lvd     d8,72(r31)
fff8619c:	31 29 00 01 	addic   r9,r9,1
fff861a0:	7d 08 01 94 	addze   r8,r8
fff861a4:	19 1f 00 48 	stvd    d8,72(r31)
    }
    /* Clean up: */
    usedspace = freespace = 0;
}
fff861a8:	80 01 00 1c 	lwz     r0,28(r1)
fff861ac:	17 81 00 08 	lvd     d28,8(r1)
fff861b0:	7c 08 03 a6 	mtlr    r0
fff861b4:	17 c1 00 10 	lvd     d30,16(r1)
fff861b8:	38 21 00 18 	addi    r1,r1,24
fff861bc:	4e 80 00 20 	blr

fff861c0 <SHA512_Final>:
    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
}

asm(".globl .L.SHA512_Final");
void SHA512_Final(SHA512_CTX* context, SHA512_t *result) {
fff861c0:	94 21 ff e8 	stwu    r1,-24(r1)
fff861c4:	7c 08 02 a6 	mflr    r0
fff861c8:	1b c1 00 10 	stvd    d30,16(r1)
fff861cc:	1b 81 00 08 	stvd    d28,8(r1)
fff861d0:	90 01 00 1c 	stw     r0,28(r1)
fff861d4:	7c 7f 1b 78 	mr      r31,r3

static void SHA512_Last(SHA512_CTX* context)
{
    unsigned int usedspace;

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fff861d8:	15 03 00 40 	lvd     d8,64(r3)
    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
}

asm(".globl .L.SHA512_Final");
void SHA512_Final(SHA512_CTX* context, SHA512_t *result) {
fff861dc:	7c 9d 23 78 	mr      r29,r4

static void SHA512_Last(SHA512_CTX* context)
{
    unsigned int usedspace;

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
fff861e0:	79 08 e8 c2 	rldicl  d8,d8,61,3
fff861e4:	55 25 06 7e 	clrlwi  r5,r9,25
fff861e8:	3b c3 00 50 	addi    r30,r3,80
    if (usedspace > 0)
fff861ec:	06 c5 00 36 	bwz     r5,fff86258 <SHA512_Final+0x98>
    {
        /* Begin padding with a 1 bit: */
        context->buffer[usedspace++] = 0x80;
fff861f0:	39 25 00 01 	addi    r9,r5,1

            /* And set-up for the last transform: */
            bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
        }
#else
        if (usedspace < SHA512_SHORT_BLOCK_LENGTH)
fff861f4:	28 09 00 6f 	cmplwi  r9,111

    usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
    if (usedspace > 0)
    {
        /* Begin padding with a 1 bit: */
        context->buffer[usedspace++] = 0x80;
fff861f8:	7d 43 2a 14 	add     r10,r3,r5
fff861fc:	39 00 ff 80 	li      r8,-128
fff86200:	99 0a 00 50 	stb     r8,80(r10)

            /* And set-up for the last transform: */
            bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
        }
#else
        if (usedspace < SHA512_SHORT_BLOCK_LENGTH)
fff86204:	41 a1 00 18 	bgt     fff8621c <SHA512_Final+0x5c>
        {
            /* Set-up for the last transform: */
            bzero(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH
                  - usedspace);
fff86208:	38 65 00 51 	addi    r3,r5,81
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff8620c:	7c 7f 1a 14 	add     r3,r31,r3
fff86210:	38 80 00 00 	li      r4,0
fff86214:	20 a5 00 6f 	subfic  r5,r5,111
fff86218:	48 00 00 38 	b       fff86250 <SHA512_Final+0x90>
            bzero(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH
                  - usedspace);
        }
        else
        {
            if (usedspace < SHA512_BLOCK_LENGTH)
fff8621c:	28 09 00 80 	cmplwi  r9,128
fff86220:	41 a2 00 18 	beq     fff86238 <SHA512_Final+0x78>
            {
                bzero(&context->buffer[usedspace], SHA512_BLOCK_LENGTH
                      - usedspace);
fff86224:	38 65 00 51 	addi    r3,r5,81
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff86228:	7c 7f 1a 14 	add     r3,r31,r3
fff8622c:	38 80 00 00 	li      r4,0
fff86230:	20 a5 00 7f 	subfic  r5,r5,127
fff86234:	4b ff c7 f1 	bl      fff82a24 <memset>
            {
                bzero(&context->buffer[usedspace], SHA512_BLOCK_LENGTH
                      - usedspace);
            }
            /* Do second-to-last transform: */
            SHA512_Transform(context, (uint64_t*)context->buffer);
fff86238:	7f e3 fb 78 	mr      r3,r31
fff8623c:	7f c4 f3 78 	mr      r4,r30
fff86240:	4b ff f7 5d 	bl      fff8599c <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff86244:	7f c3 f3 78 	mr      r3,r30
fff86248:	38 80 00 00 	li      r4,0
fff8624c:	38 a0 00 7e 	li      r5,126
fff86250:	4b ff c7 d5 	bl      fff82a24 <memset>
fff86254:	48 00 00 1c 	b       fff86270 <SHA512_Final+0xb0>
fff86258:	7f c3 f3 78 	mr      r3,r30
fff8625c:	38 80 00 00 	li      r4,0
fff86260:	38 a0 00 70 	li      r5,112
fff86264:	4b ff c7 c1 	bl      fff82a24 <memset>
    {
        /* Prepare for final transform: */
        bzero(context->buffer, SHA512_SHORT_BLOCK_LENGTH);

        /* Begin padding with a 1 bit: */
        *context->buffer = 0x80;
fff86268:	39 20 ff 80 	li      r9,-128
fff8626c:	99 3f 00 50 	stb     r9,80(r31)
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
fff86270:	15 1f 00 48 	lvd     d8,72(r31)
    *p2 = context->bitcount[0];

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fff86274:	7f e3 fb 78 	mr      r3,r31
        *context->buffer = 0x80;
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
fff86278:	19 1f 00 c0 	stvd    d8,192(r31)
    *p2 = context->bitcount[0];
fff8627c:	15 1f 00 40 	lvd     d8,64(r31)

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fff86280:	7f c4 f3 78 	mr      r4,r30
    }
    /* Store the length of input data (in bits): */
    uint64_t* p1 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH]);
    uint64_t* p2 = reinterpret_cast<uint64_t*>(&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8]);
    *p1 = context->bitcount[1];
    *p2 = context->bitcount[0];
fff86284:	19 1f 00 c8 	stvd    d8,200(r31)

    /* Final transform: */
    SHA512_Transform(context, (uint64_t*)context->buffer);
fff86288:	4b ff f7 15 	bl      fff8599c <_ZL16SHA512_TransformP11_SHA512_CTXPKy>
        *destination++ = *source++;
    }

#else
    
    memcpy(DST,SRC,length);
fff8628c:	7f e4 fb 78 	mr      r4,r31
fff86290:	7f a3 eb 78 	mr      r3,r29
fff86294:	38 a0 00 40 	li      r5,64
fff86298:	4b ff c8 61 	bl      fff82af8 <memcpy>
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fff8629c:	80 01 00 1c 	lwz     r0,28(r1)
fff862a0:	17 81 00 08 	lvd     d28,8(r1)
fff862a4:	7c 08 03 a6 	mtlr    r0
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff862a8:	7f e3 fb 78 	mr      r3,r31
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fff862ac:	17 c1 00 10 	lvd     d30,16(r1)
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff862b0:	38 80 00 00 	li      r4,0
fff862b4:	38 a0 00 04 	li      r5,4
    /* Save the hash data for output: */
    bcopy(context->state, result, SHA512_DIGEST_LENGTH);

    /* Zero out state data */
    bzero(context, sizeof(context));
}
fff862b8:	38 21 00 18 	addi    r1,r1,24
        *destination++=0x00;
    }

#else

    memset(DST,0x00,length);
fff862bc:	4b ff c7 68 	b       fff82a24 <memset>

fff862c0 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>:
    }
    FAPI_INF("Exiting recoverPibErr");
    return pibErr;
}
#endif
static fapi2::ReturnCode handle_scom_error(const uint32_t i_addr, uint64_t *io_data,
fff862c0:	94 21 ff f0 	stwu    r1,-16(r1)
    {

    }
    SBE_SCOM_FAILURE()
    {
        fapi2::current_err = RC_SBE_SCOM_FAILURE;
fff862c4:	3d 40 00 98 	lis     r10,152
fff862c8:	1b c1 00 08 	stvd    d30,8(r1)
fff862cc:	61 4a 3a b6 	ori     r10,r10,15030
fff862d0:	7c 08 02 a6 	mflr    r0
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("SBE encountered a SCOM failure");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SCOM_FAILURE;
fff862d4:	3f c0 ff f9 	lis     r30,-7
fff862d8:	39 3e a8 80 	addi    r9,r30,-22400
    {

    }
    SBE_SCOM_FAILURE()
    {
        fapi2::current_err = RC_SBE_SCOM_FAILURE;
fff862dc:	91 4d 40 4c 	stw     r10,16460(r13)
#if !defined(MINIMUM_FFDC)
        FAPI_ERR("SBE encountered a SCOM failure");
#endif
        fapi2::g_FfdcData.fapiRc = RC_SBE_SCOM_FAILURE;
fff862e0:	91 5e a8 80 	stw     r10,-22400(r30)
        fapi2::g_FfdcData.ffdcLength = 2 * sizeof(sbeFfdc_t);
fff862e4:	39 40 00 18 	li      r10,24
fff862e8:	90 01 00 14 	stw     r0,20(r1)
fff862ec:	91 49 00 04 	stw     r10,4(r9)
fff862f0:	39 40 00 00 	li      r10,0
    };

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff862f4:	91 49 00 0c 	stw     r10,12(r9)
{
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
fff862f8:	91 49 00 18 	stw     r10,24(r9)

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff862fc:	39 00 00 04 	li      r8,4
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff86300:	39 40 00 01 	li      r10,1
    };

    template< typename T >
    inline SBE_SCOM_FAILURE& set_address(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[0].data= convertType(i_value);
fff86304:	90 69 00 10 	stw     r3,16(r9)
        fapi2::g_FfdcData.ffdcData[0].size = fapi2::getErrorInfoFfdcSize(i_value);
fff86308:	91 09 00 08 	stw     r8,8(r9)
{
  public:
    template< typename T >
    inline SBE_SCOM_FAILURE& set_pcb_pib_rc(const T& i_value)
    {
        fapi2::g_FfdcData.ffdcData[1].data= convertType(i_value);
fff8630c:	90 a9 00 1c 	stw     r5,28(r9)
        fapi2::g_FfdcData.ffdcData[1].size = fapi2::getErrorInfoFfdcSize(i_value);
fff86310:	91 49 00 14 	stw     r10,20(r9)
fff86314:	7c 66 1b 78 	mr      r6,r3
fff86318:	7c bf 2b 78 	mr      r31,r5
    //if (PIB_NO_ERROR == i_pibRc)
    //{
    //    return FAPI2_RC_SUCCESS;
    //}

    PLAT_FAPI_ASSERT( false,
fff8631c:	3c 60 58 43 	lis     r3,22595
fff86320:	14 e4 00 00 	lvd     d7,0(r4)
fff86324:	60 63 00 04 	ori     r3,r3,4
fff86328:	3b ff ff ff 	addi    r31,r31,-1
fff8632c:	4b ff cd 39 	bl      fff83064 <pk_trace_big>
fff86330:	28 1f 00 06 	cmplwi  r31,6
                      "SCOM : pcb pib error, pibRc[0x%08X] Translated_ScomAddr[0x%08X]"
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
fff86334:	38 60 00 00 	li      r3,0
fff86338:	41 81 00 14 	bgt     fff8634c <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7+0x8c>
fff8633c:	3d 20 ff f8 	lis     r9,-8
fff86340:	57 ff 10 3a 	rlwinm  r31,r31,2,0,29
fff86344:	39 29 69 50 	addi    r9,r9,26960
fff86348:	7c 69 f8 2e 	lwzx    r3,r9,r31
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
    return fapi2::current_err;
}
fff8634c:	80 01 00 14 	lwz     r0,20(r1)
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
fff86350:	90 7e a8 80 	stw     r3,-22400(r30)
    return fapi2::current_err;
}
fff86354:	7c 08 03 a6 	mtlr    r0
fff86358:	17 c1 00 08 	lvd     d30,8(r1)
                      "SCOM : pcb pib error, pibRc[0x%08X] Translated_ScomAddr[0x%08X]"
                      "ScomData[0x%08X%08X]",
                      i_pibRc, i_addr, (*io_data >> 32), (*io_data & 0xFFFFFFFF));
fapi_try_exit:
    // Override FAPI RC based on PIB RC
    fapi2::current_err = pibRcToFapiRc(i_pibRc);
fff8635c:	90 6d 40 4c 	stw     r3,16460(r13)
    fapi2::g_FfdcData.fapiRc = fapi2::current_err;
    return fapi2::current_err;
}
fff86360:	38 21 00 10 	addi    r1,r1,16
fff86364:	4e 80 00 20 	blr

fff86368 <_ZN5fapi216getscom_abs_wrapEPKvmPy>:

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fff86368:	94 21 ff f0 	stwu    r1,-16(r1)
fff8636c:	7c 08 02 a6 	mflr    r0
fff86370:	1b c1 00 08 	stvd    d30,8(r1)
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fff86374:	7c 83 23 78 	mr      r3,r4
    return fapi2::current_err;
}

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fff86378:	7c 9e 23 78 	mr      r30,r4
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fff8637c:	7c a4 2b 78 	mr      r4,r5
    return fapi2::current_err;
}

fapi2::ReturnCode getscom_abs_wrap(const void *i_target,
                                   const uint32_t i_addr, uint64_t *o_data)
{
fff86380:	7c bf 2b 78 	mr      r31,r5
fff86384:	90 01 00 14 	stw     r0,20(r1)
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target, i_addr);
#endif
    l_pibRc = getscom_abs(l_addr, o_data);
fff86388:	4b ff c6 89 	bl      fff82a10 <getscom_abs>
fff8638c:	7c 65 1b 78 	mr      r5,r3
fff86390:	38 60 00 00 	li      r3,0
    FAPI_DBG("getScom: Address: 0x%08X returned pibRc: 0x%08X, data HI: 0x%08X, "
             "data LO: 0x%08X", l_addr, l_pibRc, (*o_data >> 32),
             static_cast<uint32_t>(*o_data & 0xFFFFFFFF));

    return (l_pibRc == PIB_NO_ERROR) ? fapi2::ReturnCode(FAPI2_RC_SUCCESS) :
            handle_scom_error(l_addr, o_data, l_pibRc, true);
fff86394:	06 c5 00 0a 	bwz     r5,fff863a8 <_ZN5fapi216getscom_abs_wrapEPKvmPy+0x40>
fff86398:	7f c3 f3 78 	mr      r3,r30
fff8639c:	7f e4 fb 78 	mr      r4,r31
fff863a0:	54 a5 06 3e 	clrlwi  r5,r5,24
fff863a4:	4b ff ff 1d 	bl      fff862c0 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>
}
fff863a8:	80 01 00 14 	lwz     r0,20(r1)
fff863ac:	17 c1 00 08 	lvd     d30,8(r1)
fff863b0:	7c 08 03 a6 	mtlr    r0
fff863b4:	38 21 00 10 	addi    r1,r1,16
fff863b8:	4e 80 00 20 	blr

fff863bc <_ZN5fapi216putscom_abs_wrapEPKvmy>:

fapi2::ReturnCode putscom_abs_wrap(const void *i_target,
                                    const uint32_t i_addr, uint64_t i_data)
{
fff863bc:	94 21 ff e8 	stwu    r1,-24(r1)
fff863c0:	7c 08 02 a6 	mflr    r0
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target,i_addr);
#endif
    l_pibRc = putscom_abs(l_addr, i_data);
fff863c4:	7c 83 23 78 	mr      r3,r4
            handle_scom_error(l_addr, o_data, l_pibRc, true);
}

fapi2::ReturnCode putscom_abs_wrap(const void *i_target,
                                    const uint32_t i_addr, uint64_t i_data)
{
fff863c8:	1b c1 00 10 	stvd    d30,16(r1)
fff863cc:	18 a1 00 08 	stvd    d5,8(r1)
fff863d0:	90 01 00 1c 	stw     r0,28(r1)
fff863d4:	7c 9f 23 78 	mr      r31,r4
    uint32_t l_pibRc = 0;
    uint32_t l_addr = i_addr;
#if !defined(__SBEMFW_MEASUREMENT__) && !defined(__SBEVFW_VERIFICATION__)
    l_addr = getEffectiveAddress(*(plat_target_handle_t*)i_target,i_addr);
#endif
    l_pibRc = putscom_abs(l_addr, i_data);
fff863d8:	4b ff c6 29 	bl      fff82a00 <putscom_abs>
fff863dc:	7c 65 1b 78 	mr      r5,r3
fff863e0:	38 60 00 00 	li      r3,0
    FAPI_DBG("putScom: address: 0x%08X, data HI: 0x%08X, data LO: 0x%08X : returned pibRc: 0x%08X", l_addr, (i_data >> 32),
             static_cast<uint32_t>(i_data & 0xFFFFFFFF), l_pibRc);

    return (l_pibRc == PIB_NO_ERROR) ? fapi2::ReturnCode(FAPI2_RC_SUCCESS) :
            handle_scom_error(l_addr, &i_data, l_pibRc, false);
fff863e4:	06 c5 00 0a 	bwz     r5,fff863f8 <_ZN5fapi216putscom_abs_wrapEPKvmy+0x3c>
fff863e8:	7f e3 fb 78 	mr      r3,r31
fff863ec:	38 81 00 08 	addi    r4,r1,8
fff863f0:	54 a5 06 3e 	clrlwi  r5,r5,24
fff863f4:	4b ff fe cd 	bl      fff862c0 <_ZN5fapi2L17handle_scom_errorEmPyhb.isra.7>
}
fff863f8:	80 01 00 1c 	lwz     r0,28(r1)
fff863fc:	17 c1 00 10 	lvd     d30,16(r1)
fff86400:	7c 08 03 a6 	mtlr    r0
fff86404:	38 21 00 18 	addi    r1,r1,24
fff86408:	4e 80 00 20 	blr

fff8640c <_ZN5fapi25delayEyyb>:
        PkTimebase  target_time;
        PkTimebase  current_time;


        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
fff8640c:	7c 69 23 78 	or      r9,r3,r4
fff86410:	06 c9 00 52 	bwz     r9,fff864b4 <_ZN5fapi25delayEyyb+0xa8>
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
    }
    /// @brief Delay this thread.
    ///
    ReturnCode delay(uint64_t i_nanoSeconds, uint64_t i_simCycles, bool i_fixed /* = false*/)
    {
fff86414:	94 21 ff e8 	stwu    r1,-24(r1)
fff86418:	7c 08 02 a6 	mflr    r0
fff8641c:	1b 81 00 08 	stvd    d28,8(r1)
fff86420:	90 01 00 1c 	stw     r0,28(r1)
fff86424:	1b c1 00 10 	stvd    d30,16(r1)
fff86428:	7c 9d 23 78 	mr      r29,r4
fff8642c:	7c 7c 1b 78 	mr      r28,r3

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fff86430:	4b ff a0 71 	bl      fff804a0 <pk_timebase_get>
fff86434:	7c 9f 23 78 	mr      r31,r4
#elif __SBEVFW_VERIFICATION__
        uint32_t sbeFrequency = g_sbevfreqency;
#else
        uint32_t sbeFrequency = SBE_GLOBAL->sbefreq;
#endif
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
fff86438:	38 a0 00 00 	li      r5,0
fff8643c:	38 c0 03 e8 	li      r6,1000

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fff86440:	7c 7e 1b 78 	mr      r30,r3
#elif __SBEVFW_VERIFICATION__
        uint32_t sbeFrequency = g_sbevfreqency;
#else
        uint32_t sbeFrequency = SBE_GLOBAL->sbefreq;
#endif
        return ( i_nanoSeconds/1000) * ( sbeFrequency /(1000*1000));
fff86444:	7f a4 eb 78 	mr      r4,r29
fff86448:	7f 83 e3 78 	mr      r3,r28
fff8644c:	48 00 00 91 	bl      fff864dc <__udivdi3>
fff86450:	7c 9d 23 78 	mr      r29,r4
fff86454:	7c 7c 1b 78 	mr      r28,r3
fff86458:	3c 80 00 0f 	lis     r4,15
fff8645c:	80 6d 13 70 	lwz     r3,4976(r13)
fff86460:	60 84 42 40 	ori     r4,r4,16960
fff86464:	4b ff c7 45 	bl      fff82ba8 <__udivsi3>
fff86468:	7c 66 1b 78 	mr      r6,r3
fff8646c:	7f a4 eb 78 	mr      r4,r29
fff86470:	7f 83 e3 78 	mr      r3,r28
fff86474:	38 a0 00 00 	li      r5,0
fff86478:	4b ff c5 51 	bl      fff829c8 <__muldi3>

        // Only execute if nanoSeconds is non-zero (eg a real wait)
        if (i_nanoSeconds)
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
fff8647c:	7f ff 20 14 	addc    r31,r31,r4
fff86480:	7f de 19 14 	adde    r30,r30,r3
            current_time = pk_timebase_get();
fff86484:	4b ff a0 1d 	bl      fff804a0 <pk_timebase_get>

            do
            {
                current_time = pk_timebase_get();
fff86488:	4b ff a0 19 	bl      fff804a0 <pk_timebase_get>
        {

            target_time = pk_timebase_get() + delayCycles( i_nanoSeconds);
            current_time = pk_timebase_get();

            do
fff8648c:	05 83 f7 fe 	cmplwblt r3,r30,fff86488 <_ZN5fapi25delayEyyb+0x7c>
fff86490:	04 43 f0 04 	cmpwbne r3,r30,fff86498 <_ZN5fapi25delayEyyb+0x8c>
fff86494:	05 84 ff fa 	cmplwblt r4,r31,fff86488 <_ZN5fapi25delayEyyb+0x7c>

#endif

        // replace with platform specific implementation
        return FAPI2_RC_SUCCESS;
    }
fff86498:	80 01 00 1c 	lwz     r0,28(r1)
fff8649c:	17 81 00 08 	lvd     d28,8(r1)
fff864a0:	7c 08 03 a6 	mtlr    r0
fff864a4:	17 c1 00 10 	lvd     d30,16(r1)
fff864a8:	38 60 00 00 	li      r3,0
fff864ac:	38 21 00 18 	addi    r1,r1,24
fff864b0:	4e 80 00 20 	blr
fff864b4:	38 60 00 00 	li      r3,0
fff864b8:	4e 80 00 20 	blr

fff864bc <_ZN5fapi218plat_getChipTargetEv>:
#if defined(__SBEMFW_MEASUREMENT__) || defined(__SBEVFW_VERIFICATION__)
    fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP> plat_getChipTarget()
    {
         // Get the chip default specific target
         return ((fapi2::plat_target_handle_t)0x0);
    }
fff864bc:	38 60 00 00 	li      r3,0
fff864c0:	4e 80 00 20 	blr

fff864c4 <_ZNK5fapi218plat_target_handle17getFapiTargetTypeEv>:
    TargetType plat_target_handle_t::getFapiTargetType() const
    {
         // Get the chip specific target
         return (TARGET_TYPE_PROC_CHIP);
    }
fff864c4:	38 60 00 00 	li      r3,0
fff864c8:	38 80 00 04 	li      r4,4
fff864cc:	4e 80 00 20 	blr

fff864d0 <_GLOBAL__sub_I__ZN5fapi211current_errE>:
fff864d0:	39 20 00 00 	li      r9,0
fff864d4:	91 2d 40 4c 	stw     r9,16460(r13)
fff864d8:	4e 80 00 20 	blr

fff864dc <__udivdi3>:
// quotient is 1 and the remainder is 0.
//

uint64_t
__udivdi3(uint64_t u, uint64_t v)
{
fff864dc:	94 21 ff e8 	stwu    r1,-24(r1)
fff864e0:	7c 08 02 a6 	mflr    r0
    uint64_t quotient, remainder;

    __ppe42_udiv64(u, v, &quotient, &remainder);
fff864e4:	38 e1 00 10 	addi    r7,r1,16
fff864e8:	39 01 00 08 	addi    r8,r1,8
// quotient is 1 and the remainder is 0.
//

uint64_t
__udivdi3(uint64_t u, uint64_t v)
{
fff864ec:	90 01 00 1c 	stw     r0,28(r1)
    uint64_t quotient, remainder;

    __ppe42_udiv64(u, v, &quotient, &remainder);
fff864f0:	48 00 00 19 	bl      fff86508 <__ppe42_udiv64>
    return quotient;
}
fff864f4:	80 01 00 1c 	lwz     r0,28(r1)
fff864f8:	14 61 00 10 	lvd     d3,16(r1)
fff864fc:	7c 08 03 a6 	mtlr    r0
fff86500:	38 21 00 18 	addi    r1,r1,24
fff86504:	4e 80 00 20 	blr

fff86508 <__ppe42_udiv64>:
fff86508:	94 21 ff f0 	stwu    r1,-16(r1)
fff8650c:	1b c1 00 08 	stvd    d30,8(r1)
fff86510:	61 1f 00 00 	ori     r31,r8,0
fff86514:	60 fe 00 00 	ori     r30,r7,0
fff86518:	2c 03 00 00 	cmpwi   r3,0
fff8651c:	7c 60 00 34 	cntlzw  r0,r3
fff86520:	7c 89 00 34 	cntlzw  r9,r4
fff86524:	40 82 00 08 	bne     fff8652c <lab1>
fff86528:	38 09 00 20 	addi    r0,r9,32

fff8652c <lab1>:
fff8652c:	2c 05 00 00 	cmpwi   r5,0
fff86530:	7c a9 00 34 	cntlzw  r9,r5
fff86534:	7c ca 00 34 	cntlzw  r10,r6
fff86538:	40 82 00 10 	bne     fff86548 <lab2>
fff8653c:	2c 06 00 00 	cmpwi   r6,0
fff86540:	41 82 00 e8 	beq     fff86628 <lab10>
fff86544:	39 2a 00 20 	addi    r9,r10,32

fff86548 <lab2>:
fff86548:	7c 00 48 00 	cmpw    r0,r9
fff8654c:	21 40 00 40 	subfic  r10,r0,64
fff86550:	41 81 00 c0 	bgt     fff86610 <lab9>
fff86554:	39 29 00 01 	addi    r9,r9,1
fff86558:	21 29 00 40 	subfic  r9,r9,64
fff8655c:	7c 00 4a 14 	add     r0,r0,r9
fff86560:	7d 29 50 50 	subf    r9,r9,r10
fff86564:	7d 29 03 a6 	mtctr   r9
fff86568:	2c 09 00 20 	cmpwi   r9,32
fff8656c:	38 e9 ff e0 	addi    r7,r9,-32
fff86570:	41 80 00 10 	blt     fff86580 <lab3>
fff86574:	7c 68 3c 30 	srw     r8,r3,r7
fff86578:	38 e0 00 00 	li      r7,0
fff8657c:	48 00 00 18 	b       fff86594 <lab4>

fff86580 <lab3>:
fff86580:	7c 88 4c 30 	srw     r8,r4,r9
fff86584:	20 e9 00 20 	subfic  r7,r9,32
fff86588:	7c 67 38 30 	slw     r7,r3,r7
fff8658c:	7d 08 3b 78 	or      r8,r8,r7
fff86590:	7c 67 4c 30 	srw     r7,r3,r9

fff86594 <lab4>:
fff86594:	2c 00 00 20 	cmpwi   r0,32
fff86598:	31 20 ff e0 	addic   r9,r0,-32
fff8659c:	41 80 00 10 	blt     fff865ac <lab5>
fff865a0:	7c 83 48 30 	slw     r3,r4,r9
fff865a4:	38 80 00 00 	li      r4,0
fff865a8:	48 00 00 18 	b       fff865c0 <lab6>

fff865ac <lab5>:
fff865ac:	7c 63 00 30 	slw     r3,r3,r0
fff865b0:	21 20 00 20 	subfic  r9,r0,32
fff865b4:	7c 89 4c 30 	srw     r9,r4,r9
fff865b8:	7c 63 4b 78 	or      r3,r3,r9
fff865bc:	7c 84 00 30 	slw     r4,r4,r0

fff865c0 <lab6>:
fff865c0:	39 40 ff ff 	li      r10,-1
fff865c4:	30 e7 00 00 	addic   r7,r7,0

fff865c8 <lab7>:
fff865c8:	7c 84 21 14 	adde    r4,r4,r4
fff865cc:	7c 63 19 14 	adde    r3,r3,r3
fff865d0:	7d 08 41 14 	adde    r8,r8,r8
fff865d4:	7c e7 39 14 	adde    r7,r7,r7
fff865d8:	7c 06 40 10 	subfc   r0,r6,r8
fff865dc:	7d 25 39 11 	subfe.  r9,r5,r7
fff865e0:	41 80 00 10 	blt     fff865f0 <lab8>
fff865e4:	7c 08 03 78 	mr      r8,r0
fff865e8:	7d 27 4b 78 	mr      r7,r9
fff865ec:	30 0a 00 01 	addic   r0,r10,1

fff865f0 <lab8>:
fff865f0:	42 00 ff d8 	bdnz    fff865c8 <lab7>
fff865f4:	7c 84 21 14 	adde    r4,r4,r4
fff865f8:	7c 63 19 14 	adde    r3,r3,r3
fff865fc:	90 9e 00 04 	stw     r4,4(r30)
fff86600:	90 7e 00 00 	stw     r3,0(r30)
fff86604:	91 1f 00 04 	stw     r8,4(r31)
fff86608:	90 ff 00 00 	stw     r7,0(r31)
fff8660c:	48 00 00 30 	b       fff8663c <lab11>

fff86610 <lab9>:
fff86610:	38 00 00 00 	li      r0,0
fff86614:	90 7f 00 00 	stw     r3,0(r31)
fff86618:	90 9f 00 04 	stw     r4,4(r31)
fff8661c:	90 1e 00 00 	stw     r0,0(r30)
fff86620:	90 1e 00 04 	stw     r0,4(r30)
fff86624:	48 00 00 18 	b       fff8663c <lab11>

fff86628 <lab10>:
fff86628:	38 00 ff ff 	li      r0,-1
fff8662c:	90 1f 00 00 	stw     r0,0(r31)
fff86630:	90 1f 00 04 	stw     r0,4(r31)
fff86634:	90 1e 00 00 	stw     r0,0(r30)
fff86638:	90 1e 00 04 	stw     r0,4(r30)

fff8663c <lab11>:
fff8663c:	17 c1 00 08 	lvd     d30,8(r1)
fff86640:	80 21 00 00 	lwz     r1,0(r1)
fff86644:	4e 80 00 20 	blr
